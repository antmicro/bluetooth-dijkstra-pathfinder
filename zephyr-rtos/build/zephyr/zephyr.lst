
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00001000 <_vector_table>:
    1000:	00 20 00 20 29 36 00 00 73 88 00 00 fd 35 00 00     . . )6..s....5..
    1010:	fd 35 00 00 fd 35 00 00 fd 35 00 00 00 00 00 00     .5...5...5......
	...
    102c:	11 33 00 00 fd 35 00 00 00 00 00 00 bd 32 00 00     .3...5.......2..
    103c:	fd 35 00 00                                         .5..

00001040 <_irq_vector_table>:
    1040:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    1050:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    1060:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    1070:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    1080:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    1090:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    10a0:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    10b0:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    10c0:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    10d0:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    10e0:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..
    10f0:	c1 33 00 00 c1 33 00 00 c1 33 00 00 c1 33 00 00     .3...3...3...3..

Disassembly of section text:

00001100 <__aeabi_uldivmod>:
    1100:	b953      	cbnz	r3, 1118 <__aeabi_uldivmod+0x18>
    1102:	b94a      	cbnz	r2, 1118 <__aeabi_uldivmod+0x18>
    1104:	2900      	cmp	r1, #0
    1106:	bf08      	it	eq
    1108:	2800      	cmpeq	r0, #0
    110a:	bf1c      	itt	ne
    110c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    1110:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    1114:	f000 b80c 	b.w	1130 <__aeabi_idiv0>
    1118:	f1ad 0c08 	sub.w	ip, sp, #8
    111c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    1120:	f000 f808 	bl	1134 <__udivmoddi4>
    1124:	f8dd e004 	ldr.w	lr, [sp, #4]
    1128:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    112c:	b004      	add	sp, #16
    112e:	4770      	bx	lr

00001130 <__aeabi_idiv0>:
    1130:	4770      	bx	lr
    1132:	bf00      	nop

00001134 <__udivmoddi4>:
    1134:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1138:	4607      	mov	r7, r0
    113a:	468c      	mov	ip, r1
    113c:	4608      	mov	r0, r1
    113e:	9e09      	ldr	r6, [sp, #36]	; 0x24
    1140:	4615      	mov	r5, r2
    1142:	463c      	mov	r4, r7
    1144:	4619      	mov	r1, r3
    1146:	2b00      	cmp	r3, #0
    1148:	f040 80c6 	bne.w	12d8 <__udivmoddi4+0x1a4>
    114c:	4282      	cmp	r2, r0
    114e:	fab2 f782 	clz	r7, r2
    1152:	d946      	bls.n	11e2 <__udivmoddi4+0xae>
    1154:	b14f      	cbz	r7, 116a <__udivmoddi4+0x36>
    1156:	f1c7 0e20 	rsb	lr, r7, #32
    115a:	fa24 fe0e 	lsr.w	lr, r4, lr
    115e:	fa00 f307 	lsl.w	r3, r0, r7
    1162:	40bd      	lsls	r5, r7
    1164:	ea4e 0c03 	orr.w	ip, lr, r3
    1168:	40bc      	lsls	r4, r7
    116a:	ea4f 4815 	mov.w	r8, r5, lsr #16
    116e:	fa1f fe85 	uxth.w	lr, r5
    1172:	fbbc f9f8 	udiv	r9, ip, r8
    1176:	0c22      	lsrs	r2, r4, #16
    1178:	fb08 c319 	mls	r3, r8, r9, ip
    117c:	fb09 fa0e 	mul.w	sl, r9, lr
    1180:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
    1184:	459a      	cmp	sl, r3
    1186:	d928      	bls.n	11da <__udivmoddi4+0xa6>
    1188:	18eb      	adds	r3, r5, r3
    118a:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    118e:	d204      	bcs.n	119a <__udivmoddi4+0x66>
    1190:	459a      	cmp	sl, r3
    1192:	d902      	bls.n	119a <__udivmoddi4+0x66>
    1194:	f1a9 0002 	sub.w	r0, r9, #2
    1198:	442b      	add	r3, r5
    119a:	eba3 030a 	sub.w	r3, r3, sl
    119e:	b2a4      	uxth	r4, r4
    11a0:	fbb3 f2f8 	udiv	r2, r3, r8
    11a4:	fb08 3312 	mls	r3, r8, r2, r3
    11a8:	fb02 fe0e 	mul.w	lr, r2, lr
    11ac:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    11b0:	45a6      	cmp	lr, r4
    11b2:	d914      	bls.n	11de <__udivmoddi4+0xaa>
    11b4:	192c      	adds	r4, r5, r4
    11b6:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
    11ba:	d203      	bcs.n	11c4 <__udivmoddi4+0x90>
    11bc:	45a6      	cmp	lr, r4
    11be:	d901      	bls.n	11c4 <__udivmoddi4+0x90>
    11c0:	1e93      	subs	r3, r2, #2
    11c2:	442c      	add	r4, r5
    11c4:	eba4 040e 	sub.w	r4, r4, lr
    11c8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    11cc:	b11e      	cbz	r6, 11d6 <__udivmoddi4+0xa2>
    11ce:	40fc      	lsrs	r4, r7
    11d0:	2300      	movs	r3, #0
    11d2:	6034      	str	r4, [r6, #0]
    11d4:	6073      	str	r3, [r6, #4]
    11d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    11da:	4648      	mov	r0, r9
    11dc:	e7dd      	b.n	119a <__udivmoddi4+0x66>
    11de:	4613      	mov	r3, r2
    11e0:	e7f0      	b.n	11c4 <__udivmoddi4+0x90>
    11e2:	b902      	cbnz	r2, 11e6 <__udivmoddi4+0xb2>
    11e4:	deff      	udf	#255	; 0xff
    11e6:	bb87      	cbnz	r7, 124a <__udivmoddi4+0x116>
    11e8:	1a83      	subs	r3, r0, r2
    11ea:	2101      	movs	r1, #1
    11ec:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    11f0:	b2aa      	uxth	r2, r5
    11f2:	fbb3 fcfe 	udiv	ip, r3, lr
    11f6:	0c20      	lsrs	r0, r4, #16
    11f8:	fb0e 331c 	mls	r3, lr, ip, r3
    11fc:	fb0c f802 	mul.w	r8, ip, r2
    1200:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
    1204:	4598      	cmp	r8, r3
    1206:	d963      	bls.n	12d0 <__udivmoddi4+0x19c>
    1208:	18eb      	adds	r3, r5, r3
    120a:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
    120e:	d204      	bcs.n	121a <__udivmoddi4+0xe6>
    1210:	4598      	cmp	r8, r3
    1212:	d902      	bls.n	121a <__udivmoddi4+0xe6>
    1214:	f1ac 0002 	sub.w	r0, ip, #2
    1218:	442b      	add	r3, r5
    121a:	eba3 0308 	sub.w	r3, r3, r8
    121e:	b2a4      	uxth	r4, r4
    1220:	fbb3 fcfe 	udiv	ip, r3, lr
    1224:	fb0e 331c 	mls	r3, lr, ip, r3
    1228:	fb0c f202 	mul.w	r2, ip, r2
    122c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    1230:	42a2      	cmp	r2, r4
    1232:	d94f      	bls.n	12d4 <__udivmoddi4+0x1a0>
    1234:	192c      	adds	r4, r5, r4
    1236:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
    123a:	d204      	bcs.n	1246 <__udivmoddi4+0x112>
    123c:	42a2      	cmp	r2, r4
    123e:	d902      	bls.n	1246 <__udivmoddi4+0x112>
    1240:	f1ac 0302 	sub.w	r3, ip, #2
    1244:	442c      	add	r4, r5
    1246:	1aa4      	subs	r4, r4, r2
    1248:	e7be      	b.n	11c8 <__udivmoddi4+0x94>
    124a:	f1c7 0c20 	rsb	ip, r7, #32
    124e:	fa20 f80c 	lsr.w	r8, r0, ip
    1252:	fa00 f307 	lsl.w	r3, r0, r7
    1256:	fa24 fc0c 	lsr.w	ip, r4, ip
    125a:	40bd      	lsls	r5, r7
    125c:	ea4c 0203 	orr.w	r2, ip, r3
    1260:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    1264:	b2ab      	uxth	r3, r5
    1266:	fbb8 fcfe 	udiv	ip, r8, lr
    126a:	0c11      	lsrs	r1, r2, #16
    126c:	fb0e 801c 	mls	r0, lr, ip, r8
    1270:	fb0c f903 	mul.w	r9, ip, r3
    1274:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
    1278:	4581      	cmp	r9, r0
    127a:	fa04 f407 	lsl.w	r4, r4, r7
    127e:	d923      	bls.n	12c8 <__udivmoddi4+0x194>
    1280:	1828      	adds	r0, r5, r0
    1282:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
    1286:	d204      	bcs.n	1292 <__udivmoddi4+0x15e>
    1288:	4581      	cmp	r9, r0
    128a:	d902      	bls.n	1292 <__udivmoddi4+0x15e>
    128c:	f1ac 0102 	sub.w	r1, ip, #2
    1290:	4428      	add	r0, r5
    1292:	eba0 0009 	sub.w	r0, r0, r9
    1296:	b292      	uxth	r2, r2
    1298:	fbb0 fcfe 	udiv	ip, r0, lr
    129c:	fb0e 001c 	mls	r0, lr, ip, r0
    12a0:	fb0c f803 	mul.w	r8, ip, r3
    12a4:	ea42 4300 	orr.w	r3, r2, r0, lsl #16
    12a8:	4598      	cmp	r8, r3
    12aa:	d90f      	bls.n	12cc <__udivmoddi4+0x198>
    12ac:	18eb      	adds	r3, r5, r3
    12ae:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
    12b2:	d204      	bcs.n	12be <__udivmoddi4+0x18a>
    12b4:	4598      	cmp	r8, r3
    12b6:	d902      	bls.n	12be <__udivmoddi4+0x18a>
    12b8:	f1ac 0202 	sub.w	r2, ip, #2
    12bc:	442b      	add	r3, r5
    12be:	eba3 0308 	sub.w	r3, r3, r8
    12c2:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
    12c6:	e791      	b.n	11ec <__udivmoddi4+0xb8>
    12c8:	4661      	mov	r1, ip
    12ca:	e7e2      	b.n	1292 <__udivmoddi4+0x15e>
    12cc:	4662      	mov	r2, ip
    12ce:	e7f6      	b.n	12be <__udivmoddi4+0x18a>
    12d0:	4660      	mov	r0, ip
    12d2:	e7a2      	b.n	121a <__udivmoddi4+0xe6>
    12d4:	4663      	mov	r3, ip
    12d6:	e7b6      	b.n	1246 <__udivmoddi4+0x112>
    12d8:	4283      	cmp	r3, r0
    12da:	d905      	bls.n	12e8 <__udivmoddi4+0x1b4>
    12dc:	b10e      	cbz	r6, 12e2 <__udivmoddi4+0x1ae>
    12de:	e9c6 7000 	strd	r7, r0, [r6]
    12e2:	2100      	movs	r1, #0
    12e4:	4608      	mov	r0, r1
    12e6:	e776      	b.n	11d6 <__udivmoddi4+0xa2>
    12e8:	fab3 f183 	clz	r1, r3
    12ec:	b981      	cbnz	r1, 1310 <__udivmoddi4+0x1dc>
    12ee:	4283      	cmp	r3, r0
    12f0:	d301      	bcc.n	12f6 <__udivmoddi4+0x1c2>
    12f2:	42ba      	cmp	r2, r7
    12f4:	d80a      	bhi.n	130c <__udivmoddi4+0x1d8>
    12f6:	1abc      	subs	r4, r7, r2
    12f8:	eb60 0303 	sbc.w	r3, r0, r3
    12fc:	2001      	movs	r0, #1
    12fe:	469c      	mov	ip, r3
    1300:	2e00      	cmp	r6, #0
    1302:	d068      	beq.n	13d6 <__udivmoddi4+0x2a2>
    1304:	e9c6 4c00 	strd	r4, ip, [r6]
    1308:	2100      	movs	r1, #0
    130a:	e764      	b.n	11d6 <__udivmoddi4+0xa2>
    130c:	4608      	mov	r0, r1
    130e:	e7f7      	b.n	1300 <__udivmoddi4+0x1cc>
    1310:	f1c1 0c20 	rsb	ip, r1, #32
    1314:	408b      	lsls	r3, r1
    1316:	fa22 f40c 	lsr.w	r4, r2, ip
    131a:	431c      	orrs	r4, r3
    131c:	fa02 f501 	lsl.w	r5, r2, r1
    1320:	fa00 f301 	lsl.w	r3, r0, r1
    1324:	fa27 f20c 	lsr.w	r2, r7, ip
    1328:	fa20 fb0c 	lsr.w	fp, r0, ip
    132c:	ea4f 4914 	mov.w	r9, r4, lsr #16
    1330:	4313      	orrs	r3, r2
    1332:	fbbb f8f9 	udiv	r8, fp, r9
    1336:	fa1f fe84 	uxth.w	lr, r4
    133a:	fb09 bb18 	mls	fp, r9, r8, fp
    133e:	0c1a      	lsrs	r2, r3, #16
    1340:	fb08 fa0e 	mul.w	sl, r8, lr
    1344:	ea42 420b 	orr.w	r2, r2, fp, lsl #16
    1348:	4592      	cmp	sl, r2
    134a:	fa07 f701 	lsl.w	r7, r7, r1
    134e:	d93e      	bls.n	13ce <__udivmoddi4+0x29a>
    1350:	18a2      	adds	r2, r4, r2
    1352:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
    1356:	d204      	bcs.n	1362 <__udivmoddi4+0x22e>
    1358:	4592      	cmp	sl, r2
    135a:	d902      	bls.n	1362 <__udivmoddi4+0x22e>
    135c:	f1a8 0002 	sub.w	r0, r8, #2
    1360:	4422      	add	r2, r4
    1362:	eba2 020a 	sub.w	r2, r2, sl
    1366:	b29b      	uxth	r3, r3
    1368:	fbb2 f8f9 	udiv	r8, r2, r9
    136c:	fb09 2218 	mls	r2, r9, r8, r2
    1370:	fb08 fe0e 	mul.w	lr, r8, lr
    1374:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
    1378:	4596      	cmp	lr, r2
    137a:	d92a      	bls.n	13d2 <__udivmoddi4+0x29e>
    137c:	18a2      	adds	r2, r4, r2
    137e:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    1382:	d204      	bcs.n	138e <__udivmoddi4+0x25a>
    1384:	4596      	cmp	lr, r2
    1386:	d902      	bls.n	138e <__udivmoddi4+0x25a>
    1388:	f1a8 0302 	sub.w	r3, r8, #2
    138c:	4422      	add	r2, r4
    138e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    1392:	fba0 9305 	umull	r9, r3, r0, r5
    1396:	eba2 020e 	sub.w	r2, r2, lr
    139a:	429a      	cmp	r2, r3
    139c:	46ce      	mov	lr, r9
    139e:	4698      	mov	r8, r3
    13a0:	d302      	bcc.n	13a8 <__udivmoddi4+0x274>
    13a2:	d106      	bne.n	13b2 <__udivmoddi4+0x27e>
    13a4:	454f      	cmp	r7, r9
    13a6:	d204      	bcs.n	13b2 <__udivmoddi4+0x27e>
    13a8:	ebb9 0e05 	subs.w	lr, r9, r5
    13ac:	eb63 0804 	sbc.w	r8, r3, r4
    13b0:	3801      	subs	r0, #1
    13b2:	b186      	cbz	r6, 13d6 <__udivmoddi4+0x2a2>
    13b4:	ebb7 030e 	subs.w	r3, r7, lr
    13b8:	eb62 0708 	sbc.w	r7, r2, r8
    13bc:	fa07 fc0c 	lsl.w	ip, r7, ip
    13c0:	40cb      	lsrs	r3, r1
    13c2:	ea4c 0303 	orr.w	r3, ip, r3
    13c6:	40cf      	lsrs	r7, r1
    13c8:	e9c6 3700 	strd	r3, r7, [r6]
    13cc:	e79c      	b.n	1308 <__udivmoddi4+0x1d4>
    13ce:	4640      	mov	r0, r8
    13d0:	e7c7      	b.n	1362 <__udivmoddi4+0x22e>
    13d2:	4643      	mov	r3, r8
    13d4:	e7db      	b.n	138e <__udivmoddi4+0x25a>
    13d6:	4631      	mov	r1, r6
    13d8:	e6fd      	b.n	11d6 <__udivmoddi4+0xa2>
	...

000013dc <main>:
BUILD_ASSERT(DT_NODE_HAS_COMPAT(DT_CHOSEN(zephyr_console), zephyr_cdc_acm_uart),
	     "Console device is not ACM CDC UART device");


void main(void)
{
    13dc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    13e0:	4820      	ldr	r0, [pc, #128]	; (1464 <main+0x88>)
    13e2:	f005 fb6b 	bl	6abc <z_impl_device_get_binding>
    const struct device *led;
	bool led_is_on = true;
	int ret;

	led = device_get_binding(LED0);
	if (led == NULL) {
    13e6:	4604      	mov	r4, r0
    13e8:	2800      	cmp	r0, #0
    13ea:	d038      	beq.n	145e <main+0x82>
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
    13ec:	6902      	ldr	r2, [r0, #16]
	const struct gpio_driver_api *api =
    13ee:	6881      	ldr	r1, [r0, #8]
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
    13f0:	6813      	ldr	r3, [r2, #0]
    13f2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    13f6:	6013      	str	r3, [r2, #0]
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
	}

	return api->pin_configure(port, pin, flags);
    13f8:	680b      	ldr	r3, [r1, #0]
    13fa:	f240 6201 	movw	r2, #1537	; 0x601
    13fe:	2106      	movs	r1, #6
    1400:	4798      	blx	r3
		//gpio_pin_set(led, PIN, true);
		return;
	}

	ret = gpio_pin_configure(led, PIN, GPIO_OUTPUT_ACTIVE | FLAGS);
	if (ret < 0) {
    1402:	2800      	cmp	r0, #0
    1404:	db2b      	blt.n	145e <main+0x82>
	}
    /* end led config */ 

    /* start usb cdc acm comm */
    const struct device *dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
	uint32_t dtr = 0;
    1406:	2000      	movs	r0, #0
    1408:	9001      	str	r0, [sp, #4]

    if (usb_enable(NULL)) {
    140a:	f001 f883 	bl	2514 <usb_enable>
    140e:	bb30      	cbnz	r0, 145e <main+0x82>

static inline int z_impl_uart_line_ctrl_get(const struct device *dev,
					    uint32_t ctrl, uint32_t *val)
{
#ifdef CONFIG_UART_LINE_CTRL
	const struct uart_driver_api *api =
    1410:	4815      	ldr	r0, [pc, #84]	; (1468 <main+0x8c>)
		(const struct uart_driver_api *)dev->api;

	if (api->line_ctrl_get == NULL) {
    1412:	6883      	ldr	r3, [r0, #8]
    1414:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    1416:	b113      	cbz	r3, 141e <main+0x42>
		return -ENOSYS;
	}
	return api->line_ctrl_get(dev, ctrl, val);
    1418:	aa01      	add	r2, sp, #4
    141a:	2104      	movs	r1, #4
    141c:	4798      	blx	r3
    }
    /* end usb cdc acm comm */

	while (1) {
		gpio_pin_set(led, PIN, (int)led_is_on);
        printk("Hello, world %s\n", CONFIG_BOARD);
    141e:	f8df 804c 	ldr.w	r8, [pc, #76]	; 146c <main+0x90>
    1422:	4f13      	ldr	r7, [pc, #76]	; (1470 <main+0x94>)
{
    1424:	2501      	movs	r5, #1

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    1426:	6923      	ldr	r3, [r4, #16]
    1428:	681b      	ldr	r3, [r3, #0]
    142a:	f085 0601 	eor.w	r6, r5, #1
    142e:	f013 0f40 	tst.w	r3, #64	; 0x40
		value = (value != 0) ? 0 : 1;
    1432:	bf18      	it	ne
    1434:	b2f5      	uxtbne	r5, r6
	if (value != 0)	{
    1436:	b17d      	cbz	r5, 1458 <main+0x7c>
	return api->port_set_bits_raw(port, pins);
    1438:	68a3      	ldr	r3, [r4, #8]
    143a:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
    143c:	2140      	movs	r1, #64	; 0x40
    143e:	4620      	mov	r0, r4
    1440:	4798      	blx	r3
        printk("Hello, world %s\n", CONFIG_BOARD);
    1442:	4641      	mov	r1, r8
    1444:	4638      	mov	r0, r7
    1446:	f006 fcd0 	bl	7dea <printk>
		led_is_on = !led_is_on;
    144a:	b2f5      	uxtb	r5, r6
		/* coverity[OVERRUN] */
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
    144c:	2100      	movs	r1, #0
    144e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    1452:	f006 fa69 	bl	7928 <z_impl_k_sleep>
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
    1456:	e7e6      	b.n	1426 <main+0x4a>
    1458:	68a3      	ldr	r3, [r4, #8]
    145a:	691b      	ldr	r3, [r3, #16]
    145c:	e7ee      	b.n	143c <main+0x60>
		k_msleep(SLEEP_TIME_MS);
	}
}
    145e:	b002      	add	sp, #8
    1460:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1464:	00009c50 	.word	0x00009c50
    1468:	00009860 	.word	0x00009860
    146c:	00009c57 	.word	0x00009c57
    1470:	00009c6f 	.word	0x00009c6f

00001474 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    1474:	680b      	ldr	r3, [r1, #0]
    1476:	3301      	adds	r3, #1
    1478:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    147a:	4b01      	ldr	r3, [pc, #4]	; (1480 <char_out+0xc>)
    147c:	681b      	ldr	r3, [r3, #0]
    147e:	4718      	bx	r3
    1480:	20000000 	.word	0x20000000

00001484 <__printk_hook_install>:
	_char_out = fn;
    1484:	4b01      	ldr	r3, [pc, #4]	; (148c <__printk_hook_install+0x8>)
    1486:	6018      	str	r0, [r3, #0]
}
    1488:	4770      	bx	lr
    148a:	bf00      	nop
    148c:	20000000 	.word	0x20000000

00001490 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
    1490:	b507      	push	{r0, r1, r2, lr}
    1492:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
    1494:	2100      	movs	r1, #0
{
    1496:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
    1498:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
    149a:	4803      	ldr	r0, [pc, #12]	; (14a8 <vprintk+0x18>)
    149c:	a901      	add	r1, sp, #4
    149e:	f000 f8e5 	bl	166c <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
    14a2:	b003      	add	sp, #12
    14a4:	f85d fb04 	ldr.w	pc, [sp], #4
    14a8:	00001475 	.word	0x00001475

000014ac <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
    14ac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    14b0:	f8b0 9018 	ldrh.w	r9, [r0, #24]
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
    14b4:	f019 0808 	ands.w	r8, r9, #8
{
    14b8:	4604      	mov	r4, r0
    14ba:	4693      	mov	fp, r2
	if (processing) {
    14bc:	d00d      	beq.n	14da <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
    14be:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
    14c0:	bf0c      	ite	eq
    14c2:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
    14c6:	f049 0920 	orrne.w	r9, r9, #32
    14ca:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    14ce:	f38b 8811 	msr	BASEPRI, fp
    14d2:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
    14d6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    14da:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
    14de:	2902      	cmp	r1, #2
    14e0:	d107      	bne.n	14f2 <process_event+0x46>
			evt = process_recheck(mgr);
    14e2:	4620      	mov	r0, r4
    14e4:	f006 fca8 	bl	7e38 <process_recheck>
		if (evt == EVT_NOP) {
    14e8:	2800      	cmp	r0, #0
    14ea:	d0f0      	beq.n	14ce <process_event+0x22>
		if (evt == EVT_COMPLETE) {
    14ec:	2801      	cmp	r0, #1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    14ee:	8b23      	ldrh	r3, [r4, #24]
		if (evt == EVT_COMPLETE) {
    14f0:	d14e      	bne.n	1590 <process_event+0xe4>
			res = mgr->last_res;
    14f2:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    14f4:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
    14f6:	2f00      	cmp	r7, #0
    14f8:	da15      	bge.n	1526 <process_event+0x7a>
		*clients = mgr->clients;
    14fa:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    14fc:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
    1500:	e9c4 8800 	strd	r8, r8, [r4]
    1504:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
    1508:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
    150a:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
    150c:	8b21      	ldrh	r1, [r4, #24]
    150e:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
    1512:	45ca      	cmp	sl, r9
    1514:	d002      	beq.n	151c <process_event+0x70>
		if (do_monitors
    1516:	68a3      	ldr	r3, [r4, #8]
    1518:	2b00      	cmp	r3, #0
    151a:	d15a      	bne.n	15d2 <process_event+0x126>
		    || !sys_slist_is_empty(&clients)
    151c:	b90d      	cbnz	r5, 1522 <process_event+0x76>
		    || (transit != NULL)) {
    151e:	2e00      	cmp	r6, #0
    1520:	d071      	beq.n	1606 <process_event+0x15a>
    1522:	2300      	movs	r3, #0
    1524:	e056      	b.n	15d4 <process_event+0x128>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    1526:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
    152a:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
    152c:	2a01      	cmp	r2, #1
    152e:	d81e      	bhi.n	156e <process_event+0xc2>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1530:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
    1534:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
    1536:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1538:	b289      	uxth	r1, r1
    153a:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
    153e:	d10a      	bne.n	1556 <process_event+0xaa>
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    1540:	b13d      	cbz	r5, 1552 <process_event+0xa6>
    1542:	8b63      	ldrh	r3, [r4, #26]
    1544:	462a      	mov	r2, r5

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
    1546:	6812      	ldr	r2, [r2, #0]
				mgr->refs += 1U;
    1548:	3301      	adds	r3, #1
    154a:	b29b      	uxth	r3, r3
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    154c:	2a00      	cmp	r2, #0
    154e:	d1fa      	bne.n	1546 <process_event+0x9a>
    1550:	8363      	strh	r3, [r4, #26]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1552:	f041 0102 	orr.w	r1, r1, #2
	mgr->flags = (state & ONOFF_STATE_MASK)
    1556:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
    1558:	4620      	mov	r0, r4
    155a:	f006 fc6d 	bl	7e38 <process_recheck>
    155e:	4606      	mov	r6, r0
    1560:	2800      	cmp	r0, #0
    1562:	d0d3      	beq.n	150c <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    1564:	8b23      	ldrh	r3, [r4, #24]
    1566:	f043 0320 	orr.w	r3, r3, #32
    156a:	8323      	strh	r3, [r4, #24]
    156c:	e7cd      	b.n	150a <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
    156e:	2b04      	cmp	r3, #4
    1570:	d10c      	bne.n	158c <process_event+0xe0>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1572:	f021 0107 	bic.w	r1, r1, #7
    1576:	b289      	uxth	r1, r1
	mgr->flags = (state & ONOFF_STATE_MASK)
    1578:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
    157a:	4620      	mov	r0, r4
    157c:	f006 fc5c 	bl	7e38 <process_recheck>
    1580:	4605      	mov	r5, r0
    1582:	2800      	cmp	r0, #0
    1584:	d0c1      	beq.n	150a <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    1586:	f041 0120 	orr.w	r1, r1, #32
    158a:	8321      	strh	r1, [r4, #24]
    158c:	2500      	movs	r5, #0
    158e:	e7bc      	b.n	150a <process_event+0x5e>
		} else if (evt == EVT_START) {
    1590:	2803      	cmp	r0, #3
    1592:	d109      	bne.n	15a8 <process_event+0xfc>
			transit = mgr->transitions->start;
    1594:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1596:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
    159a:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    159c:	f043 0306 	orr.w	r3, r3, #6
	mgr->flags = (state & ONOFF_STATE_MASK)
    15a0:	8323      	strh	r3, [r4, #24]
}
    15a2:	2500      	movs	r5, #0
		res = 0;
    15a4:	462f      	mov	r7, r5
    15a6:	e7b1      	b.n	150c <process_event+0x60>
		} else if (evt == EVT_STOP) {
    15a8:	2804      	cmp	r0, #4
    15aa:	d106      	bne.n	15ba <process_event+0x10e>
			transit = mgr->transitions->stop;
    15ac:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    15ae:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
    15b2:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    15b4:	f043 0304 	orr.w	r3, r3, #4
    15b8:	e7f2      	b.n	15a0 <process_event+0xf4>
		} else if (evt == EVT_RESET) {
    15ba:	2805      	cmp	r0, #5
    15bc:	d106      	bne.n	15cc <process_event+0x120>
			transit = mgr->transitions->reset;
    15be:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    15c0:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
    15c4:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    15c6:	f043 0305 	orr.w	r3, r3, #5
    15ca:	e7e9      	b.n	15a0 <process_event+0xf4>
    15cc:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
    15ce:	462e      	mov	r6, r5
    15d0:	e7e8      	b.n	15a4 <process_event+0xf8>
				   && !sys_slist_is_empty(&mgr->monitors);
    15d2:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
    15d4:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
    15d8:	8321      	strh	r1, [r4, #24]
    15da:	f38b 8811 	msr	BASEPRI, fp
    15de:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
    15e2:	b9fb      	cbnz	r3, 1624 <process_event+0x178>
	while (!sys_slist_is_empty(list)) {
    15e4:	bb85      	cbnz	r5, 1648 <process_event+0x19c>
			if (transit != NULL) {
    15e6:	b116      	cbz	r6, 15ee <process_event+0x142>
				transit(mgr, transition_complete);
    15e8:	491f      	ldr	r1, [pc, #124]	; (1668 <process_event+0x1bc>)
    15ea:	4620      	mov	r0, r4
    15ec:	47b0      	blx	r6
	__asm__ volatile(
    15ee:	f04f 0320 	mov.w	r3, #32
    15f2:	f3ef 8b11 	mrs	fp, BASEPRI
    15f6:	f383 8812 	msr	BASEPRI_MAX, r3
    15fa:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
    15fe:	8b23      	ldrh	r3, [r4, #24]
    1600:	f023 0308 	bic.w	r3, r3, #8
    1604:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
    1606:	8b23      	ldrh	r3, [r4, #24]
    1608:	06da      	lsls	r2, r3, #27
    160a:	d525      	bpl.n	1658 <process_event+0x1ac>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
    160c:	f023 0310 	bic.w	r3, r3, #16
    1610:	8323      	strh	r3, [r4, #24]
			evt = EVT_COMPLETE;
    1612:	2101      	movs	r1, #1
		state = mgr->flags & ONOFF_STATE_MASK;
    1614:	f8b4 9018 	ldrh.w	r9, [r4, #24]
    1618:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
    161c:	2900      	cmp	r1, #0
    161e:	f47f af5e 	bne.w	14de <process_event+0x32>
out:
    1622:	e754      	b.n	14ce <process_event+0x22>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
    1624:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    1626:	2900      	cmp	r1, #0
    1628:	d0dc      	beq.n	15e4 <process_event+0x138>
	return node->next;
    162a:	f8d1 9000 	ldr.w	r9, [r1]
		mon->callback(mgr, mon, state, res);
    162e:	f8d1 b004 	ldr.w	fp, [r1, #4]
    1632:	463b      	mov	r3, r7
    1634:	4652      	mov	r2, sl
    1636:	4620      	mov	r0, r4
    1638:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    163a:	f1b9 0f00 	cmp.w	r9, #0
    163e:	d0d1      	beq.n	15e4 <process_event+0x138>
    1640:	4649      	mov	r1, r9
    1642:	f8d9 9000 	ldr.w	r9, [r9]
    1646:	e7f2      	b.n	162e <process_event+0x182>
    1648:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
    164a:	463b      	mov	r3, r7
    164c:	4652      	mov	r2, sl
    164e:	4620      	mov	r0, r4
    1650:	682d      	ldr	r5, [r5, #0]
    1652:	f006 fc0d 	bl	7e70 <notify_one>
    1656:	e7c5      	b.n	15e4 <process_event+0x138>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
    1658:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
    165c:	bf1e      	ittt	ne
    165e:	f023 0320 	bicne.w	r3, r3, #32
    1662:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
    1664:	2102      	movne	r1, #2
    1666:	e7d5      	b.n	1614 <process_event+0x168>
    1668:	00007e9d 	.word	0x00007e9d

0000166c <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    166c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1670:	b091      	sub	sp, #68	; 0x44
    1672:	468b      	mov	fp, r1
    1674:	9002      	str	r0, [sp, #8]
    1676:	4692      	mov	sl, r2
    1678:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    167a:	2500      	movs	r5, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    167c:	f89a 0000 	ldrb.w	r0, [sl]
    1680:	b908      	cbnz	r0, 1686 <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
    1682:	4628      	mov	r0, r5
    1684:	e35f      	b.n	1d46 <cbvprintf+0x6da>
		if (*fp != '%') {
    1686:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
    1688:	f10a 0701 	add.w	r7, sl, #1
		if (*fp != '%') {
    168c:	d007      	beq.n	169e <cbvprintf+0x32>
			OUTC('%');
    168e:	9b02      	ldr	r3, [sp, #8]
    1690:	4659      	mov	r1, fp
    1692:	4798      	blx	r3
    1694:	2800      	cmp	r0, #0
    1696:	f2c0 8356 	blt.w	1d46 <cbvprintf+0x6da>
    169a:	3501      	adds	r5, #1
			break;
    169c:	e212      	b.n	1ac4 <cbvprintf+0x458>
		} state = {
    169e:	2218      	movs	r2, #24
    16a0:	2100      	movs	r1, #0
    16a2:	a80a      	add	r0, sp, #40	; 0x28
    16a4:	f007 f913 	bl	88ce <memset>
	if (*sp == '%') {
    16a8:	f89a 3001 	ldrb.w	r3, [sl, #1]
    16ac:	2b25      	cmp	r3, #37	; 0x25
    16ae:	d078      	beq.n	17a2 <cbvprintf+0x136>
    16b0:	2200      	movs	r2, #0
    16b2:	4610      	mov	r0, r2
    16b4:	4696      	mov	lr, r2
    16b6:	4694      	mov	ip, r2
    16b8:	4616      	mov	r6, r2
    16ba:	4639      	mov	r1, r7
		switch (*sp) {
    16bc:	f817 3b01 	ldrb.w	r3, [r7], #1
    16c0:	2b2b      	cmp	r3, #43	; 0x2b
    16c2:	f000 809d 	beq.w	1800 <cbvprintf+0x194>
    16c6:	f200 8094 	bhi.w	17f2 <cbvprintf+0x186>
    16ca:	2b20      	cmp	r3, #32
    16cc:	f000 809b 	beq.w	1806 <cbvprintf+0x19a>
    16d0:	2b23      	cmp	r3, #35	; 0x23
    16d2:	f000 809b 	beq.w	180c <cbvprintf+0x1a0>
    16d6:	b12e      	cbz	r6, 16e4 <cbvprintf+0x78>
    16d8:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    16dc:	f046 0604 	orr.w	r6, r6, #4
    16e0:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
    16e4:	f1bc 0f00 	cmp.w	ip, #0
    16e8:	d005      	beq.n	16f6 <cbvprintf+0x8a>
    16ea:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    16ee:	f046 0608 	orr.w	r6, r6, #8
    16f2:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
    16f6:	f1be 0f00 	cmp.w	lr, #0
    16fa:	d005      	beq.n	1708 <cbvprintf+0x9c>
    16fc:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    1700:	f046 0610 	orr.w	r6, r6, #16
    1704:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
    1708:	b128      	cbz	r0, 1716 <cbvprintf+0xaa>
    170a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
    170e:	f040 0020 	orr.w	r0, r0, #32
    1712:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
    1716:	b12a      	cbz	r2, 1724 <cbvprintf+0xb8>
    1718:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    171c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    1720:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
    1724:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    1728:	f002 0044 	and.w	r0, r2, #68	; 0x44
    172c:	2844      	cmp	r0, #68	; 0x44
    172e:	d103      	bne.n	1738 <cbvprintf+0xcc>
		conv->flag_zero = false;
    1730:	f36f 1286 	bfc	r2, #6, #1
    1734:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
    1738:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
    173c:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
    173e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    1742:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
    1746:	d17b      	bne.n	1840 <cbvprintf+0x1d4>
		conv->width_star = true;
    1748:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    174c:	f042 0201 	orr.w	r2, r2, #1
			++sp;
    1750:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
    1752:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
    1756:	781a      	ldrb	r2, [r3, #0]
    1758:	2a2e      	cmp	r2, #46	; 0x2e
    175a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    175e:	bf0c      	ite	eq
    1760:	2101      	moveq	r1, #1
    1762:	2100      	movne	r1, #0
    1764:	f361 0241 	bfi	r2, r1, #1, #1
    1768:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
    176c:	d174      	bne.n	1858 <cbvprintf+0x1ec>
	if (*sp == '*') {
    176e:	785a      	ldrb	r2, [r3, #1]
    1770:	2a2a      	cmp	r2, #42	; 0x2a
    1772:	d06a      	beq.n	184a <cbvprintf+0x1de>
	++sp;
    1774:	3301      	adds	r3, #1
	size_t val = 0;
    1776:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
    1778:	260a      	movs	r6, #10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    177a:	4618      	mov	r0, r3
    177c:	f810 2b01 	ldrb.w	r2, [r0], #1
    1780:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
    1784:	2f09      	cmp	r7, #9
    1786:	f240 808e 	bls.w	18a6 <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
    178a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
    178e:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
    1790:	f3c2 0040 	ubfx	r0, r2, #1, #1
    1794:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
    1798:	f361 0241 	bfi	r2, r1, #1, #1
    179c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
    17a0:	e05a      	b.n	1858 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
    17a2:	f10a 0702 	add.w	r7, sl, #2
    17a6:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
    17aa:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    17ae:	07d9      	lsls	r1, r3, #31
    17b0:	f140 8149 	bpl.w	1a46 <cbvprintf+0x3da>
			width = va_arg(ap, int);
    17b4:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
    17b8:	f1b9 0f00 	cmp.w	r9, #0
    17bc:	da07      	bge.n	17ce <cbvprintf+0x162>
				conv->flag_dash = true;
    17be:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    17c2:	f042 0204 	orr.w	r2, r2, #4
    17c6:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				width = -width;
    17ca:	f1c9 0900 	rsb	r9, r9, #0
		if (conv->prec_star) {
    17ce:	075a      	lsls	r2, r3, #29
    17d0:	f140 8142 	bpl.w	1a58 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
    17d4:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
    17d8:	f1b8 0f00 	cmp.w	r8, #0
    17dc:	f280 8141 	bge.w	1a62 <cbvprintf+0x3f6>
				conv->prec_present = false;
    17e0:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    17e4:	f36f 0341 	bfc	r3, #1, #1
    17e8:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
    17ec:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    17f0:	e137      	b.n	1a62 <cbvprintf+0x3f6>
		switch (*sp) {
    17f2:	2b2d      	cmp	r3, #45	; 0x2d
    17f4:	d00c      	beq.n	1810 <cbvprintf+0x1a4>
    17f6:	2b30      	cmp	r3, #48	; 0x30
    17f8:	f47f af6d 	bne.w	16d6 <cbvprintf+0x6a>
			conv->flag_zero = true;
    17fc:	2201      	movs	r2, #1
	} while (loop);
    17fe:	e75c      	b.n	16ba <cbvprintf+0x4e>
			conv->flag_plus = true;
    1800:	f04f 0c01 	mov.w	ip, #1
    1804:	e759      	b.n	16ba <cbvprintf+0x4e>
			conv->flag_space = true;
    1806:	f04f 0e01 	mov.w	lr, #1
    180a:	e756      	b.n	16ba <cbvprintf+0x4e>
			conv->flag_hash = true;
    180c:	2001      	movs	r0, #1
    180e:	e754      	b.n	16ba <cbvprintf+0x4e>
		switch (*sp) {
    1810:	2601      	movs	r6, #1
    1812:	e752      	b.n	16ba <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
    1814:	fb0c 0202 	mla	r2, ip, r2, r0
    1818:	3a30      	subs	r2, #48	; 0x30
    181a:	4633      	mov	r3, r6
    181c:	461e      	mov	r6, r3
    181e:	f816 0b01 	ldrb.w	r0, [r6], #1
    1822:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
    1826:	2f09      	cmp	r7, #9
    1828:	d9f4      	bls.n	1814 <cbvprintf+0x1a8>
	if (sp != wp) {
    182a:	4299      	cmp	r1, r3
    182c:	d093      	beq.n	1756 <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
    182e:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
    1832:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
    1834:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
    1836:	f362 0141 	bfi	r1, r2, #1, #1
    183a:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
    183e:	e78a      	b.n	1756 <cbvprintf+0xea>
    1840:	460b      	mov	r3, r1
	size_t val = 0;
    1842:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
    1844:	f04f 0c0a 	mov.w	ip, #10
    1848:	e7e8      	b.n	181c <cbvprintf+0x1b0>
		conv->prec_star = true;
    184a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    184e:	f042 0204 	orr.w	r2, r2, #4
    1852:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
		return ++sp;
    1856:	3302      	adds	r3, #2
	switch (*sp) {
    1858:	461f      	mov	r7, r3
    185a:	f817 2b01 	ldrb.w	r2, [r7], #1
    185e:	2a6c      	cmp	r2, #108	; 0x6c
    1860:	d041      	beq.n	18e6 <cbvprintf+0x27a>
    1862:	d825      	bhi.n	18b0 <cbvprintf+0x244>
    1864:	2a68      	cmp	r2, #104	; 0x68
    1866:	d02b      	beq.n	18c0 <cbvprintf+0x254>
    1868:	2a6a      	cmp	r2, #106	; 0x6a
    186a:	d046      	beq.n	18fa <cbvprintf+0x28e>
    186c:	2a4c      	cmp	r2, #76	; 0x4c
    186e:	d04c      	beq.n	190a <cbvprintf+0x29e>
    1870:	461f      	mov	r7, r3
	conv->specifier = *sp++;
    1872:	f817 2b01 	ldrb.w	r2, [r7], #1
		if (conv->length_mod == LENGTH_UPPER_L) {
    1876:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	conv->specifier = *sp++;
    187a:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
    187e:	2a78      	cmp	r2, #120	; 0x78
    1880:	f200 80d9 	bhi.w	1a36 <cbvprintf+0x3ca>
    1884:	2a57      	cmp	r2, #87	; 0x57
    1886:	d84d      	bhi.n	1924 <cbvprintf+0x2b8>
    1888:	2a41      	cmp	r2, #65	; 0x41
    188a:	d003      	beq.n	1894 <cbvprintf+0x228>
    188c:	3a45      	subs	r2, #69	; 0x45
    188e:	2a02      	cmp	r2, #2
    1890:	f200 80d1 	bhi.w	1a36 <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
    1894:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    1898:	2204      	movs	r2, #4
    189a:	f362 0302 	bfi	r3, r2, #0, #3
    189e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
    18a2:	2301      	movs	r3, #1
			break;
    18a4:	e09e      	b.n	19e4 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
    18a6:	fb06 2101 	mla	r1, r6, r1, r2
    18aa:	3930      	subs	r1, #48	; 0x30
    18ac:	4603      	mov	r3, r0
    18ae:	e764      	b.n	177a <cbvprintf+0x10e>
	switch (*sp) {
    18b0:	2a74      	cmp	r2, #116	; 0x74
    18b2:	d026      	beq.n	1902 <cbvprintf+0x296>
    18b4:	2a7a      	cmp	r2, #122	; 0x7a
    18b6:	d1db      	bne.n	1870 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
    18b8:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    18bc:	2206      	movs	r2, #6
    18be:	e00d      	b.n	18dc <cbvprintf+0x270>
		if (*++sp == 'h') {
    18c0:	785a      	ldrb	r2, [r3, #1]
    18c2:	2a68      	cmp	r2, #104	; 0x68
    18c4:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    18c8:	d106      	bne.n	18d8 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
    18ca:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
    18cc:	f361 02c6 	bfi	r2, r1, #3, #4
    18d0:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
    18d4:	1c9f      	adds	r7, r3, #2
    18d6:	e7cc      	b.n	1872 <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
    18d8:	4613      	mov	r3, r2
    18da:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
    18dc:	f362 03c6 	bfi	r3, r2, #3, #4
    18e0:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
    18e4:	e7c5      	b.n	1872 <cbvprintf+0x206>
		if (*++sp == 'l') {
    18e6:	785a      	ldrb	r2, [r3, #1]
    18e8:	2a6c      	cmp	r2, #108	; 0x6c
    18ea:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    18ee:	d101      	bne.n	18f4 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
    18f0:	2104      	movs	r1, #4
    18f2:	e7eb      	b.n	18cc <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
    18f4:	4613      	mov	r3, r2
    18f6:	2203      	movs	r2, #3
    18f8:	e7f0      	b.n	18dc <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
    18fa:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    18fe:	2205      	movs	r2, #5
    1900:	e7ec      	b.n	18dc <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
    1902:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    1906:	2207      	movs	r2, #7
    1908:	e7e8      	b.n	18dc <cbvprintf+0x270>
		conv->unsupported = true;
    190a:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    190e:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    1912:	f023 0302 	bic.w	r3, r3, #2
    1916:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    191a:	f043 0302 	orr.w	r3, r3, #2
    191e:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
    1922:	e7a6      	b.n	1872 <cbvprintf+0x206>
	switch (conv->specifier) {
    1924:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
    1928:	2920      	cmp	r1, #32
    192a:	f200 8084 	bhi.w	1a36 <cbvprintf+0x3ca>
    192e:	a001      	add	r0, pc, #4	; (adr r0, 1934 <cbvprintf+0x2c8>)
    1930:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
    1934:	000019f9 	.word	0x000019f9
    1938:	00001a37 	.word	0x00001a37
    193c:	00001a37 	.word	0x00001a37
    1940:	00001a37 	.word	0x00001a37
    1944:	00001a37 	.word	0x00001a37
    1948:	00001a37 	.word	0x00001a37
    194c:	00001a37 	.word	0x00001a37
    1950:	00001a37 	.word	0x00001a37
    1954:	00001a37 	.word	0x00001a37
    1958:	00001895 	.word	0x00001895
    195c:	00001a37 	.word	0x00001a37
    1960:	000019f9 	.word	0x000019f9
    1964:	000019b9 	.word	0x000019b9
    1968:	00001895 	.word	0x00001895
    196c:	00001895 	.word	0x00001895
    1970:	00001895 	.word	0x00001895
    1974:	00001a37 	.word	0x00001a37
    1978:	000019b9 	.word	0x000019b9
    197c:	00001a37 	.word	0x00001a37
    1980:	00001a37 	.word	0x00001a37
    1984:	00001a37 	.word	0x00001a37
    1988:	00001a37 	.word	0x00001a37
    198c:	00001a01 	.word	0x00001a01
    1990:	000019f9 	.word	0x000019f9
    1994:	00001a1d 	.word	0x00001a1d
    1998:	00001a37 	.word	0x00001a37
    199c:	00001a37 	.word	0x00001a37
    19a0:	00001a1d 	.word	0x00001a1d
    19a4:	00001a37 	.word	0x00001a37
    19a8:	000019f9 	.word	0x000019f9
    19ac:	00001a37 	.word	0x00001a37
    19b0:	00001a37 	.word	0x00001a37
    19b4:	000019f9 	.word	0x000019f9
		conv->specifier_cat = SPECIFIER_SINT;
    19b8:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
    19bc:	2001      	movs	r0, #1
		if (conv->length_mod == LENGTH_UPPER_L) {
    19be:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
    19c2:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    19c6:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
    19c8:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
    19cc:	bf02      	ittt	eq
    19ce:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
    19d2:	f041 0101 	orreq.w	r1, r1, #1
    19d6:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
    19da:	2a63      	cmp	r2, #99	; 0x63
    19dc:	d131      	bne.n	1a42 <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
    19de:	3b00      	subs	r3, #0
    19e0:	bf18      	it	ne
    19e2:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
    19e4:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    19e8:	f3c2 0140 	ubfx	r1, r2, #1, #1
    19ec:	430b      	orrs	r3, r1
    19ee:	f363 0241 	bfi	r2, r3, #1, #1
    19f2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
    19f6:	e6d8      	b.n	17aa <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
    19f8:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
    19fc:	2002      	movs	r0, #2
    19fe:	e7de      	b.n	19be <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
    1a00:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    1a04:	f003 0378 	and.w	r3, r3, #120	; 0x78
    1a08:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
    1a0c:	2103      	movs	r1, #3
    1a0e:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    1a12:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
    1a14:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    1a18:	4143      	adcs	r3, r0
    1a1a:	e7e3      	b.n	19e4 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
    1a1c:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
    1a20:	2103      	movs	r1, #3
		if (conv->length_mod != LENGTH_NONE) {
    1a22:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
    1a26:	f361 0202 	bfi	r2, r1, #0, #3
    1a2a:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
    1a2e:	bf14      	ite	ne
    1a30:	2301      	movne	r3, #1
    1a32:	2300      	moveq	r3, #0
    1a34:	e7d6      	b.n	19e4 <cbvprintf+0x378>
		conv->invalid = true;
    1a36:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    1a3a:	f043 0301 	orr.w	r3, r3, #1
    1a3e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
    1a42:	2300      	movs	r3, #0
    1a44:	e7ce      	b.n	19e4 <cbvprintf+0x378>
		} else if (conv->width_present) {
    1a46:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
    1a4a:	2a00      	cmp	r2, #0
			width = conv->width_value;
    1a4c:	bfb4      	ite	lt
    1a4e:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
		int width = -1;
    1a52:	f04f 39ff 	movge.w	r9, #4294967295	; 0xffffffff
    1a56:	e6ba      	b.n	17ce <cbvprintf+0x162>
		} else if (conv->prec_present) {
    1a58:	079b      	lsls	r3, r3, #30
    1a5a:	f57f aec7 	bpl.w	17ec <cbvprintf+0x180>
			precision = conv->prec_value;
    1a5e:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
			= (enum length_mod_enum)conv->length_mod;
    1a62:	f89d 1031 	ldrb.w	r1, [sp, #49]	; 0x31
		conv->pad0_value = 0;
    1a66:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
    1a68:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
    1a6c:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
		enum specifier_cat_enum specifier_cat
    1a70:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
    1a74:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
    1a76:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
    1a7a:	d138      	bne.n	1aee <cbvprintf+0x482>
			switch (length_mod) {
    1a7c:	1ecb      	subs	r3, r1, #3
    1a7e:	2b04      	cmp	r3, #4
    1a80:	d822      	bhi.n	1ac8 <cbvprintf+0x45c>
    1a82:	e8df f003 	tbb	[pc, r3]
    1a86:	0903      	.short	0x0903
    1a88:	2109      	.short	0x2109
    1a8a:	21          	.byte	0x21
    1a8b:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
    1a8c:	f854 3b04 	ldr.w	r3, [r4], #4
				value->sint = (short)value->sint;
    1a90:	17da      	asrs	r2, r3, #31
    1a92:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
    1a96:	e006      	b.n	1aa6 <cbvprintf+0x43a>
					(sint_value_type)va_arg(ap, intmax_t);
    1a98:	3407      	adds	r4, #7
    1a9a:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
    1a9e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
    1aa2:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
    1aa6:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    1aaa:	f013 0603 	ands.w	r6, r3, #3
    1aae:	d056      	beq.n	1b5e <cbvprintf+0x4f2>
			OUTS(sp, fp);
    1ab0:	9802      	ldr	r0, [sp, #8]
    1ab2:	463b      	mov	r3, r7
    1ab4:	4652      	mov	r2, sl
    1ab6:	4659      	mov	r1, fp
    1ab8:	f006 fcc0 	bl	843c <outs>
    1abc:	2800      	cmp	r0, #0
    1abe:	f2c0 8142 	blt.w	1d46 <cbvprintf+0x6da>
    1ac2:	4405      	add	r5, r0
			continue;
    1ac4:	46ba      	mov	sl, r7
    1ac6:	e5d9      	b.n	167c <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    1ac8:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
    1acc:	2901      	cmp	r1, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
    1ace:	ea4f 72e3 	mov.w	r2, r3, asr #31
    1ad2:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
    1ad6:	d105      	bne.n	1ae4 <cbvprintf+0x478>
				value->uint = (unsigned char)value->uint;
    1ad8:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
    1adc:	930a      	str	r3, [sp, #40]	; 0x28
    1ade:	2300      	movs	r3, #0
    1ae0:	930b      	str	r3, [sp, #44]	; 0x2c
    1ae2:	e7e0      	b.n	1aa6 <cbvprintf+0x43a>
			} else if (length_mod == LENGTH_H) {
    1ae4:	2902      	cmp	r1, #2
    1ae6:	d1de      	bne.n	1aa6 <cbvprintf+0x43a>
				value->sint = (short)value->sint;
    1ae8:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
    1aec:	e7d0      	b.n	1a90 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
    1aee:	2b02      	cmp	r3, #2
    1af0:	d123      	bne.n	1b3a <cbvprintf+0x4ce>
			switch (length_mod) {
    1af2:	1ecb      	subs	r3, r1, #3
    1af4:	2b04      	cmp	r3, #4
    1af6:	d813      	bhi.n	1b20 <cbvprintf+0x4b4>
    1af8:	e8df f003 	tbb	[pc, r3]
    1afc:	120a0a03 	.word	0x120a0a03
    1b00:	12          	.byte	0x12
    1b01:	00          	.byte	0x00
					value->uint = (wchar_t)va_arg(ap,
    1b02:	6822      	ldr	r2, [r4, #0]
    1b04:	920a      	str	r2, [sp, #40]	; 0x28
    1b06:	2300      	movs	r3, #0
				value->sint = va_arg(ap, int);
    1b08:	1d20      	adds	r0, r4, #4
					value->uint = (wchar_t)va_arg(ap,
    1b0a:	930b      	str	r3, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
    1b0c:	4604      	mov	r4, r0
    1b0e:	e7ca      	b.n	1aa6 <cbvprintf+0x43a>
					(uint_value_type)va_arg(ap,
    1b10:	1de0      	adds	r0, r4, #7
    1b12:	f020 0007 	bic.w	r0, r0, #7
				value->uint =
    1b16:	e8f0 2302 	ldrd	r2, r3, [r0], #8
    1b1a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				break;
    1b1e:	e7f5      	b.n	1b0c <cbvprintf+0x4a0>
					(uint_value_type)va_arg(ap, size_t);
    1b20:	f854 3b04 	ldr.w	r3, [r4], #4
    1b24:	930a      	str	r3, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
    1b26:	2901      	cmp	r1, #1
					(uint_value_type)va_arg(ap, size_t);
    1b28:	f04f 0300 	mov.w	r3, #0
    1b2c:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
    1b2e:	d0d3      	beq.n	1ad8 <cbvprintf+0x46c>
			} else if (length_mod == LENGTH_H) {
    1b30:	2902      	cmp	r1, #2
    1b32:	d1b8      	bne.n	1aa6 <cbvprintf+0x43a>
				value->uint = (unsigned short)value->uint;
    1b34:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
    1b38:	e7d0      	b.n	1adc <cbvprintf+0x470>
		} else if (specifier_cat == SPECIFIER_FP) {
    1b3a:	2b04      	cmp	r3, #4
    1b3c:	d109      	bne.n	1b52 <cbvprintf+0x4e6>
					(sint_value_type)va_arg(ap, long long);
    1b3e:	1de3      	adds	r3, r4, #7
    1b40:	f023 0307 	bic.w	r3, r3, #7
    1b44:	f103 0408 	add.w	r4, r3, #8
				value->ldbl = va_arg(ap, long double);
    1b48:	e9d3 2300 	ldrd	r2, r3, [r3]
    1b4c:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    1b50:	e7a9      	b.n	1aa6 <cbvprintf+0x43a>
		} else if (specifier_cat == SPECIFIER_PTR) {
    1b52:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
    1b54:	bf04      	itt	eq
    1b56:	f854 3b04 	ldreq.w	r3, [r4], #4
    1b5a:	930a      	streq	r3, [sp, #40]	; 0x28
    1b5c:	e7a3      	b.n	1aa6 <cbvprintf+0x43a>
		switch (conv->specifier) {
    1b5e:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    1b62:	2878      	cmp	r0, #120	; 0x78
    1b64:	d8ae      	bhi.n	1ac4 <cbvprintf+0x458>
    1b66:	2862      	cmp	r0, #98	; 0x62
    1b68:	d822      	bhi.n	1bb0 <cbvprintf+0x544>
    1b6a:	2825      	cmp	r0, #37	; 0x25
    1b6c:	f43f ad8f 	beq.w	168e <cbvprintf+0x22>
    1b70:	2858      	cmp	r0, #88	; 0x58
    1b72:	d1a7      	bne.n	1ac4 <cbvprintf+0x458>
			bps = encode_uint(value->uint, conv, buf, bpe);
    1b74:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    1b78:	9300      	str	r3, [sp, #0]
    1b7a:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    1b7e:	ab04      	add	r3, sp, #16
    1b80:	aa0c      	add	r2, sp, #48	; 0x30
    1b82:	f006 fc15 	bl	83b0 <encode_uint>
    1b86:	4682      	mov	sl, r0
			if (precision >= 0) {
    1b88:	f1b8 0f00 	cmp.w	r8, #0
    1b8c:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    1b90:	db0c      	blt.n	1bac <cbvprintf+0x540>
				conv->flag_zero = false;
    1b92:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
    1b96:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
    1b9a:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
    1b9e:	4598      	cmp	r8, r3
				conv->flag_zero = false;
    1ba0:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
    1ba4:	d902      	bls.n	1bac <cbvprintf+0x540>
					conv->pad0_value = precision - (int)len;
    1ba6:	eba8 0303 	sub.w	r3, r8, r3
    1baa:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
    1bac:	4680      	mov	r8, r0
    1bae:	e03d      	b.n	1c2c <cbvprintf+0x5c0>
		switch (conv->specifier) {
    1bb0:	3863      	subs	r0, #99	; 0x63
    1bb2:	2815      	cmp	r0, #21
    1bb4:	d886      	bhi.n	1ac4 <cbvprintf+0x458>
    1bb6:	a201      	add	r2, pc, #4	; (adr r2, 1bbc <cbvprintf+0x550>)
    1bb8:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
    1bbc:	00001c3d 	.word	0x00001c3d
    1bc0:	00001ca1 	.word	0x00001ca1
    1bc4:	00001ac5 	.word	0x00001ac5
    1bc8:	00001ac5 	.word	0x00001ac5
    1bcc:	00001ac5 	.word	0x00001ac5
    1bd0:	00001ac5 	.word	0x00001ac5
    1bd4:	00001ca1 	.word	0x00001ca1
    1bd8:	00001ac5 	.word	0x00001ac5
    1bdc:	00001ac5 	.word	0x00001ac5
    1be0:	00001ac5 	.word	0x00001ac5
    1be4:	00001ac5 	.word	0x00001ac5
    1be8:	00001cfb 	.word	0x00001cfb
    1bec:	00001cc9 	.word	0x00001cc9
    1bf0:	00001ccd 	.word	0x00001ccd
    1bf4:	00001ac5 	.word	0x00001ac5
    1bf8:	00001ac5 	.word	0x00001ac5
    1bfc:	00001c15 	.word	0x00001c15
    1c00:	00001ac5 	.word	0x00001ac5
    1c04:	00001cc9 	.word	0x00001cc9
    1c08:	00001ac5 	.word	0x00001ac5
    1c0c:	00001ac5 	.word	0x00001ac5
    1c10:	00001cc9 	.word	0x00001cc9
			if (precision >= 0) {
    1c14:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
    1c18:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
    1c1c:	db0a      	blt.n	1c34 <cbvprintf+0x5c8>
				len = strnlen(bps, precision);
    1c1e:	4641      	mov	r1, r8
    1c20:	4650      	mov	r0, sl
    1c22:	f006 fe34 	bl	888e <strnlen>
			bpe = bps + len;
    1c26:	eb0a 0800 	add.w	r8, sl, r0
		char sign = 0;
    1c2a:	2600      	movs	r6, #0
		if (bps == NULL) {
    1c2c:	f1ba 0f00 	cmp.w	sl, #0
    1c30:	d10c      	bne.n	1c4c <cbvprintf+0x5e0>
    1c32:	e747      	b.n	1ac4 <cbvprintf+0x458>
				len = strlen(bps);
    1c34:	4650      	mov	r0, sl
    1c36:	f006 fe23 	bl	8880 <strlen>
    1c3a:	e7f4      	b.n	1c26 <cbvprintf+0x5ba>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    1c3c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1c3e:	f88d 3010 	strb.w	r3, [sp, #16]
			break;
    1c42:	2600      	movs	r6, #0
			bps = buf;
    1c44:	f10d 0a10 	add.w	sl, sp, #16
			bpe = buf + 1;
    1c48:	f10d 0811 	add.w	r8, sp, #17
		size_t nj_len = (bpe - bps);
    1c4c:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
    1c50:	b106      	cbz	r6, 1c54 <cbvprintf+0x5e8>
			nj_len += 1U;
    1c52:	3301      	adds	r3, #1
		if (conv->altform_0c) {
    1c54:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
    1c58:	06d0      	lsls	r0, r2, #27
    1c5a:	d568      	bpl.n	1d2e <cbvprintf+0x6c2>
			nj_len += 2U;
    1c5c:	3302      	adds	r3, #2
		if (conv->pad_fp) {
    1c5e:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
    1c60:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
    1c62:	bf48      	it	mi
    1c64:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
    1c66:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
    1c68:	bf48      	it	mi
    1c6a:	189b      	addmi	r3, r3, r2
		if (width > 0) {
    1c6c:	f1b9 0f00 	cmp.w	r9, #0
    1c70:	dd76      	ble.n	1d60 <cbvprintf+0x6f4>
			if (!conv->flag_dash) {
    1c72:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
    1c76:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
    1c7a:	f3c2 0380 	ubfx	r3, r2, #2, #1
    1c7e:	9303      	str	r3, [sp, #12]
    1c80:	0753      	lsls	r3, r2, #29
    1c82:	d46d      	bmi.n	1d60 <cbvprintf+0x6f4>
				if (conv->flag_zero) {
    1c84:	0650      	lsls	r0, r2, #25
    1c86:	d561      	bpl.n	1d4c <cbvprintf+0x6e0>
					if (sign != 0) {
    1c88:	b146      	cbz	r6, 1c9c <cbvprintf+0x630>
						OUTC(sign);
    1c8a:	9b02      	ldr	r3, [sp, #8]
    1c8c:	4659      	mov	r1, fp
    1c8e:	4630      	mov	r0, r6
    1c90:	4798      	blx	r3
    1c92:	2800      	cmp	r0, #0
    1c94:	db57      	blt.n	1d46 <cbvprintf+0x6da>
						sign = 0;
    1c96:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
    1c98:	3501      	adds	r5, #1
						sign = 0;
    1c9a:	461e      	mov	r6, r3
					pad = '0';
    1c9c:	2330      	movs	r3, #48	; 0x30
    1c9e:	e056      	b.n	1d4e <cbvprintf+0x6e2>
			if (conv->flag_plus) {
    1ca0:	071e      	lsls	r6, r3, #28
    1ca2:	d40f      	bmi.n	1cc4 <cbvprintf+0x658>
				sign = ' ';
    1ca4:	f013 0610 	ands.w	r6, r3, #16
    1ca8:	bf18      	it	ne
    1caa:	2620      	movne	r6, #32
			sint = value->sint;
    1cac:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
    1cb0:	2b00      	cmp	r3, #0
    1cb2:	f6bf af5f 	bge.w	1b74 <cbvprintf+0x508>
				value->uint = (uint_value_type)-sint;
    1cb6:	4252      	negs	r2, r2
    1cb8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    1cbc:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				sign = '-';
    1cc0:	262d      	movs	r6, #45	; 0x2d
    1cc2:	e757      	b.n	1b74 <cbvprintf+0x508>
				sign = '+';
    1cc4:	262b      	movs	r6, #43	; 0x2b
    1cc6:	e7f1      	b.n	1cac <cbvprintf+0x640>
		switch (conv->specifier) {
    1cc8:	2600      	movs	r6, #0
    1cca:	e753      	b.n	1b74 <cbvprintf+0x508>
			if (value->ptr != NULL) {
    1ccc:	980a      	ldr	r0, [sp, #40]	; 0x28
    1cce:	b340      	cbz	r0, 1d22 <cbvprintf+0x6b6>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    1cd0:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    1cd4:	9300      	str	r3, [sp, #0]
    1cd6:	aa0c      	add	r2, sp, #48	; 0x30
    1cd8:	ab04      	add	r3, sp, #16
    1cda:	2100      	movs	r1, #0
    1cdc:	f006 fb68 	bl	83b0 <encode_uint>
				conv->altform_0c = true;
    1ce0:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
    1ce4:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    1ce8:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
    1cec:	f043 0310 	orr.w	r3, r3, #16
				bps = encode_uint((uintptr_t)value->ptr, conv,
    1cf0:	4682      	mov	sl, r0
				conv->altform_0c = true;
    1cf2:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
		char sign = 0;
    1cf6:	2600      	movs	r6, #0
				goto prec_int_pad0;
    1cf8:	e746      	b.n	1b88 <cbvprintf+0x51c>
				store_count(conv, value->ptr, count);
    1cfa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
    1cfc:	2907      	cmp	r1, #7
    1cfe:	f63f aee1 	bhi.w	1ac4 <cbvprintf+0x458>
    1d02:	e8df f001 	tbb	[pc, r1]
    1d06:	040c      	.short	0x040c
    1d08:	08080c06 	.word	0x08080c06
    1d0c:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
    1d0e:	701d      	strb	r5, [r3, #0]
		break;
    1d10:	e6d8      	b.n	1ac4 <cbvprintf+0x458>
		*(short *)dp = (short)count;
    1d12:	801d      	strh	r5, [r3, #0]
		break;
    1d14:	e6d6      	b.n	1ac4 <cbvprintf+0x458>
		*(intmax_t *)dp = (intmax_t)count;
    1d16:	17ea      	asrs	r2, r5, #31
    1d18:	e9c3 5200 	strd	r5, r2, [r3]
		break;
    1d1c:	e6d2      	b.n	1ac4 <cbvprintf+0x458>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    1d1e:	601d      	str	r5, [r3, #0]
		break;
    1d20:	e6d0      	b.n	1ac4 <cbvprintf+0x458>
			bps = "(nil)";
    1d22:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 1dec <cbvprintf+0x780>
    1d26:	4606      	mov	r6, r0
			bpe = bps + 5;
    1d28:	f10a 0805 	add.w	r8, sl, #5
    1d2c:	e78e      	b.n	1c4c <cbvprintf+0x5e0>
		} else if (conv->altform_0) {
    1d2e:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
    1d30:	bf48      	it	mi
    1d32:	3301      	addmi	r3, #1
    1d34:	e793      	b.n	1c5e <cbvprintf+0x5f2>
					OUTC(pad);
    1d36:	4618      	mov	r0, r3
    1d38:	9303      	str	r3, [sp, #12]
    1d3a:	4659      	mov	r1, fp
    1d3c:	9b02      	ldr	r3, [sp, #8]
    1d3e:	4798      	blx	r3
    1d40:	2800      	cmp	r0, #0
    1d42:	9b03      	ldr	r3, [sp, #12]
    1d44:	da04      	bge.n	1d50 <cbvprintf+0x6e4>
#undef OUTS
#undef OUTC
}
    1d46:	b011      	add	sp, #68	; 0x44
    1d48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
    1d4c:	2320      	movs	r3, #32
    1d4e:	444d      	add	r5, r9
    1d50:	464a      	mov	r2, r9
				while (width-- > 0) {
    1d52:	2a00      	cmp	r2, #0
    1d54:	eba5 0109 	sub.w	r1, r5, r9
    1d58:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    1d5c:	dceb      	bgt.n	1d36 <cbvprintf+0x6ca>
    1d5e:	460d      	mov	r5, r1
		if (sign != 0) {
    1d60:	b136      	cbz	r6, 1d70 <cbvprintf+0x704>
			OUTC(sign);
    1d62:	9b02      	ldr	r3, [sp, #8]
    1d64:	4659      	mov	r1, fp
    1d66:	4630      	mov	r0, r6
    1d68:	4798      	blx	r3
    1d6a:	2800      	cmp	r0, #0
    1d6c:	dbeb      	blt.n	1d46 <cbvprintf+0x6da>
    1d6e:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
    1d70:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    1d74:	06d9      	lsls	r1, r3, #27
    1d76:	d401      	bmi.n	1d7c <cbvprintf+0x710>
    1d78:	071a      	lsls	r2, r3, #28
    1d7a:	d506      	bpl.n	1d8a <cbvprintf+0x71e>
				OUTC('0');
    1d7c:	9b02      	ldr	r3, [sp, #8]
    1d7e:	4659      	mov	r1, fp
    1d80:	2030      	movs	r0, #48	; 0x30
    1d82:	4798      	blx	r3
    1d84:	2800      	cmp	r0, #0
    1d86:	dbde      	blt.n	1d46 <cbvprintf+0x6da>
    1d88:	3501      	adds	r5, #1
			if (conv->altform_0c) {
    1d8a:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    1d8e:	06db      	lsls	r3, r3, #27
    1d90:	d507      	bpl.n	1da2 <cbvprintf+0x736>
				OUTC(conv->specifier);
    1d92:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    1d96:	9b02      	ldr	r3, [sp, #8]
    1d98:	4659      	mov	r1, fp
    1d9a:	4798      	blx	r3
    1d9c:	2800      	cmp	r0, #0
    1d9e:	dbd2      	blt.n	1d46 <cbvprintf+0x6da>
    1da0:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
    1da2:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    1da4:	442e      	add	r6, r5
    1da6:	1b73      	subs	r3, r6, r5
    1da8:	2b00      	cmp	r3, #0
    1daa:	dc16      	bgt.n	1dda <cbvprintf+0x76e>
			OUTS(bps, bpe);
    1dac:	9802      	ldr	r0, [sp, #8]
    1dae:	4643      	mov	r3, r8
    1db0:	4652      	mov	r2, sl
    1db2:	4659      	mov	r1, fp
    1db4:	f006 fb42 	bl	843c <outs>
    1db8:	2800      	cmp	r0, #0
    1dba:	dbc4      	blt.n	1d46 <cbvprintf+0x6da>
    1dbc:	4405      	add	r5, r0
		while (width > 0) {
    1dbe:	44a9      	add	r9, r5
    1dc0:	eba9 0305 	sub.w	r3, r9, r5
    1dc4:	2b00      	cmp	r3, #0
    1dc6:	f77f ae7d 	ble.w	1ac4 <cbvprintf+0x458>
			OUTC(' ');
    1dca:	9b02      	ldr	r3, [sp, #8]
    1dcc:	4659      	mov	r1, fp
    1dce:	2020      	movs	r0, #32
    1dd0:	4798      	blx	r3
    1dd2:	2800      	cmp	r0, #0
    1dd4:	dbb7      	blt.n	1d46 <cbvprintf+0x6da>
    1dd6:	3501      	adds	r5, #1
			--width;
    1dd8:	e7f2      	b.n	1dc0 <cbvprintf+0x754>
				OUTC('0');
    1dda:	9b02      	ldr	r3, [sp, #8]
    1ddc:	4659      	mov	r1, fp
    1dde:	2030      	movs	r0, #48	; 0x30
    1de0:	4798      	blx	r3
    1de2:	2800      	cmp	r0, #0
    1de4:	dbaf      	blt.n	1d46 <cbvprintf+0x6da>
    1de6:	3501      	adds	r5, #1
    1de8:	e7dd      	b.n	1da6 <cbvprintf+0x73a>
    1dea:	bf00      	nop
    1dec:	00009c80 	.word	0x00009c80

00001df0 <class_handler>:
		if_descr = cfg_data->interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
    1df0:	4b0c      	ldr	r3, [pc, #48]	; (1e24 <class_handler+0x34>)
{
    1df2:	b4f0      	push	{r4, r5, r6, r7}
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
    1df4:	6a5f      	ldr	r7, [r3, #36]	; 0x24
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1df6:	4e0c      	ldr	r6, [pc, #48]	; (1e28 <class_handler+0x38>)
    1df8:	4b0c      	ldr	r3, [pc, #48]	; (1e2c <class_handler+0x3c>)
    1dfa:	42b3      	cmp	r3, r6
    1dfc:	d303      	bcc.n	1e06 <class_handler+0x16>
			return iface->class_handler(pSetup, len, data);
		}
	}

	return -ENOTSUP;
}
    1dfe:	f06f 0085 	mvn.w	r0, #133	; 0x85
    1e02:	bcf0      	pop	{r4, r5, r6, r7}
    1e04:	4770      	bx	lr
		if_descr = cfg_data->interface_descriptor;
    1e06:	685d      	ldr	r5, [r3, #4]
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
    1e08:	42bd      	cmp	r5, r7
    1e0a:	d309      	bcc.n	1e20 <class_handler+0x30>
		if (iface->class_handler &&
    1e0c:	691c      	ldr	r4, [r3, #16]
    1e0e:	b13c      	cbz	r4, 1e20 <class_handler+0x30>
		    if_descr->bInterfaceNumber == (pSetup->wIndex & 0xFF)) {
    1e10:	f895 c002 	ldrb.w	ip, [r5, #2]
    1e14:	7905      	ldrb	r5, [r0, #4]
		if (iface->class_handler &&
    1e16:	45ac      	cmp	ip, r5
    1e18:	d102      	bne.n	1e20 <class_handler+0x30>
			return iface->class_handler(pSetup, len, data);
    1e1a:	4623      	mov	r3, r4
}
    1e1c:	bcf0      	pop	{r4, r5, r6, r7}
			return iface->class_handler(pSetup, len, data);
    1e1e:	4718      	bx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1e20:	3324      	adds	r3, #36	; 0x24
    1e22:	e7ea      	b.n	1dfa <class_handler+0xa>
    1e24:	200005c0 	.word	0x200005c0
    1e28:	200002d8 	.word	0x200002d8
    1e2c:	200002b4 	.word	0x200002b4

00001e30 <custom_handler>:

static int custom_handler(struct usb_setup_packet *pSetup,
			  int32_t *len, uint8_t **data)
{
    1e30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct usb_interface_cfg_data *iface;

	LOG_DBG("bRequest 0x%02x, wIndex 0x%04x",
		pSetup->bRequest, pSetup->wIndex);

	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1e34:	4c13      	ldr	r4, [pc, #76]	; (1e84 <custom_handler+0x54>)
    1e36:	f8df 8050 	ldr.w	r8, [pc, #80]	; 1e88 <custom_handler+0x58>
		if_descr = cfg_data->interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
    1e3a:	f8df 9050 	ldr.w	r9, [pc, #80]	; 1e8c <custom_handler+0x5c>
{
    1e3e:	4605      	mov	r5, r0
    1e40:	460e      	mov	r6, r1
    1e42:	4617      	mov	r7, r2
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1e44:	4544      	cmp	r4, r8
    1e46:	d303      	bcc.n	1e50 <custom_handler+0x20>
			}
		}
	}

	return -ENOTSUP;
}
    1e48:	f06f 0085 	mvn.w	r0, #133	; 0x85
    1e4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if_descr = cfg_data->interface_descriptor;
    1e50:	6862      	ldr	r2, [r4, #4]
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
    1e52:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
    1e56:	429a      	cmp	r2, r3
    1e58:	d312      	bcc.n	1e80 <custom_handler+0x50>
		if (iface->custom_handler == NULL) {
    1e5a:	69a3      	ldr	r3, [r4, #24]
    1e5c:	b183      	cbz	r3, 1e80 <custom_handler+0x50>
		if (if_descr->bInterfaceNumber == (pSetup->wIndex & 0xFF)) {
    1e5e:	7890      	ldrb	r0, [r2, #2]
    1e60:	7929      	ldrb	r1, [r5, #4]
    1e62:	4288      	cmp	r0, r1
    1e64:	d105      	bne.n	1e72 <custom_handler+0x42>
			return iface->custom_handler(pSetup, len, data);
    1e66:	463a      	mov	r2, r7
    1e68:	4631      	mov	r1, r6
    1e6a:	4628      	mov	r0, r5
}
    1e6c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return iface->custom_handler(pSetup, len, data);
    1e70:	4718      	bx	r3
			if (if_descr->bInterfaceClass == USB_BCC_AUDIO) {
    1e72:	7952      	ldrb	r2, [r2, #5]
    1e74:	2a01      	cmp	r2, #1
    1e76:	d103      	bne.n	1e80 <custom_handler+0x50>
				(void)iface->custom_handler(pSetup, len, data);
    1e78:	463a      	mov	r2, r7
    1e7a:	4631      	mov	r1, r6
    1e7c:	4628      	mov	r0, r5
    1e7e:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1e80:	3424      	adds	r4, #36	; 0x24
    1e82:	e7df      	b.n	1e44 <custom_handler+0x14>
    1e84:	200002b4 	.word	0x200002b4
    1e88:	200002d8 	.word	0x200002d8
    1e8c:	200005c0 	.word	0x200005c0

00001e90 <vendor_handler>:

static int vendor_handler(struct usb_setup_packet *pSetup,
			  int32_t *len, uint8_t **data)
{
    1e90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (!usb_handle_os_desc_feature(pSetup, len, data)) {
			return 0;
		}
	}

	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1e94:	4c0b      	ldr	r4, [pc, #44]	; (1ec4 <vendor_handler+0x34>)
    1e96:	f8df 8030 	ldr.w	r8, [pc, #48]	; 1ec8 <vendor_handler+0x38>
{
    1e9a:	4605      	mov	r5, r0
    1e9c:	460e      	mov	r6, r1
    1e9e:	4617      	mov	r7, r2
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1ea0:	4544      	cmp	r4, r8
    1ea2:	d302      	bcc.n	1eaa <vendor_handler+0x1a>
				return 0;
			}
		}
	}

	return -ENOTSUP;
    1ea4:	f06f 0085 	mvn.w	r0, #133	; 0x85
    1ea8:	e009      	b.n	1ebe <vendor_handler+0x2e>
		if (iface->vendor_handler) {
    1eaa:	6963      	ldr	r3, [r4, #20]
    1eac:	b90b      	cbnz	r3, 1eb2 <vendor_handler+0x22>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1eae:	3424      	adds	r4, #36	; 0x24
    1eb0:	e7f6      	b.n	1ea0 <vendor_handler+0x10>
			if (!iface->vendor_handler(pSetup, len, data)) {
    1eb2:	463a      	mov	r2, r7
    1eb4:	4631      	mov	r1, r6
    1eb6:	4628      	mov	r0, r5
    1eb8:	4798      	blx	r3
    1eba:	2800      	cmp	r0, #0
    1ebc:	d1f7      	bne.n	1eae <vendor_handler+0x1e>
}
    1ebe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1ec2:	bf00      	nop
    1ec4:	200002b4 	.word	0x200002b4
    1ec8:	200002d8 	.word	0x200002d8

00001ecc <set_endpoint>:
{
    1ecc:	b507      	push	{r0, r1, r2, lr}
	ep_cfg.ep_addr = ep_desc->bEndpointAddress;
    1ece:	7883      	ldrb	r3, [r0, #2]
    1ed0:	f88d 3000 	strb.w	r3, [sp]
	ep_cfg.ep_mps = sys_le16_to_cpu(ep_desc->wMaxPacketSize);
    1ed4:	7903      	ldrb	r3, [r0, #4]
    1ed6:	7942      	ldrb	r2, [r0, #5]
    1ed8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    1edc:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
    1ee0:	78c3      	ldrb	r3, [r0, #3]
	ret = usb_dc_ep_configure(&ep_cfg);
    1ee2:	4668      	mov	r0, sp
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
    1ee4:	f003 0303 	and.w	r3, r3, #3
    1ee8:	f88d 3004 	strb.w	r3, [sp, #4]
	ret = usb_dc_ep_configure(&ep_cfg);
    1eec:	f002 f8b2 	bl	4054 <usb_dc_ep_configure>
	if (ret == -EALREADY) {
    1ef0:	f110 0f78 	cmn.w	r0, #120	; 0x78
    1ef4:	d004      	beq.n	1f00 <set_endpoint+0x34>
	} else if (ret) {
    1ef6:	b118      	cbz	r0, 1f00 <set_endpoint+0x34>
		return false;
    1ef8:	2000      	movs	r0, #0
}
    1efa:	b003      	add	sp, #12
    1efc:	f85d fb04 	ldr.w	pc, [sp], #4
	ret = usb_dc_ep_enable(ep_cfg.ep_addr);
    1f00:	f89d 0000 	ldrb.w	r0, [sp]
    1f04:	f002 f92c 	bl	4160 <usb_dc_ep_enable>
	if (ret == -EALREADY) {
    1f08:	f110 0f78 	cmn.w	r0, #120	; 0x78
    1f0c:	d001      	beq.n	1f12 <set_endpoint+0x46>
	} else if (ret) {
    1f0e:	2800      	cmp	r0, #0
    1f10:	d1f2      	bne.n	1ef8 <set_endpoint+0x2c>
	usb_dev.configured = true;
    1f12:	4b02      	ldr	r3, [pc, #8]	; (1f1c <set_endpoint+0x50>)
    1f14:	2001      	movs	r0, #1
    1f16:	f883 00b9 	strb.w	r0, [r3, #185]	; 0xb9
	return true;
    1f1a:	e7ee      	b.n	1efa <set_endpoint+0x2e>
    1f1c:	200005c0 	.word	0x200005c0

00001f20 <usb_reset_alt_setting>:
	memset(usb_dev.alt_setting, 0, ARRAY_SIZE(usb_dev.alt_setting));
    1f20:	4802      	ldr	r0, [pc, #8]	; (1f2c <usb_reset_alt_setting+0xc>)
    1f22:	2208      	movs	r2, #8
    1f24:	2100      	movs	r1, #0
    1f26:	f006 bcd2 	b.w	88ce <memset>
    1f2a:	bf00      	nop
    1f2c:	2000067b 	.word	0x2000067b

00001f30 <is_ep_valid.part.0>:
static bool is_ep_valid(uint8_t ep)
    1f30:	b570      	push	{r4, r5, r6, lr}
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1f32:	4b0b      	ldr	r3, [pc, #44]	; (1f60 <is_ep_valid.part.0+0x30>)
    1f34:	4c0b      	ldr	r4, [pc, #44]	; (1f64 <is_ep_valid.part.0+0x34>)
    1f36:	42a3      	cmp	r3, r4
    1f38:	d301      	bcc.n	1f3e <is_ep_valid.part.0+0xe>
	return false;
    1f3a:	2000      	movs	r0, #0
}
    1f3c:	bd70      	pop	{r4, r5, r6, pc}
		ep_data = cfg_data->endpoint;
    1f3e:	6a19      	ldr	r1, [r3, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
    1f40:	7f1e      	ldrb	r6, [r3, #28]
    1f42:	2200      	movs	r2, #0
			if (ep_data[n].ep_addr == ep) {
    1f44:	3904      	subs	r1, #4
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
    1f46:	b2d5      	uxtb	r5, r2
    1f48:	42ae      	cmp	r6, r5
    1f4a:	d801      	bhi.n	1f50 <is_ep_valid.part.0+0x20>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1f4c:	3324      	adds	r3, #36	; 0x24
    1f4e:	e7f2      	b.n	1f36 <is_ep_valid.part.0+0x6>
			if (ep_data[n].ep_addr == ep) {
    1f50:	3201      	adds	r2, #1
    1f52:	f811 5032 	ldrb.w	r5, [r1, r2, lsl #3]
    1f56:	4285      	cmp	r5, r0
    1f58:	d1f5      	bne.n	1f46 <is_ep_valid.part.0+0x16>
				return true;
    1f5a:	2001      	movs	r0, #1
    1f5c:	e7ee      	b.n	1f3c <is_ep_valid.part.0+0xc>
    1f5e:	bf00      	nop
    1f60:	200002b4 	.word	0x200002b4
    1f64:	200002d8 	.word	0x200002d8

00001f68 <usb_handle_request.constprop.0>:
	handler = usb_dev.req_handlers[type];
    1f68:	4809      	ldr	r0, [pc, #36]	; (1f90 <usb_handle_request.constprop.0+0x28>)
static bool usb_handle_request(struct usb_setup_packet *setup,
    1f6a:	b508      	push	{r3, lr}
	uint32_t type = setup->RequestType.type;
    1f6c:	7803      	ldrb	r3, [r0, #0]
    1f6e:	f3c3 1341 	ubfx	r3, r3, #5, #2
	handler = usb_dev.req_handlers[type];
    1f72:	330a      	adds	r3, #10
    1f74:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
	if (handler == NULL) {
    1f78:	b13b      	cbz	r3, 1f8a <usb_handle_request.constprop.0+0x22>
	if ((*handler)(setup, len, data) < 0) {
    1f7a:	f100 0208 	add.w	r2, r0, #8
    1f7e:	f100 0110 	add.w	r1, r0, #16
    1f82:	4798      	blx	r3
    1f84:	43c0      	mvns	r0, r0
    1f86:	0fc0      	lsrs	r0, r0, #31
}
    1f88:	bd08      	pop	{r3, pc}
		return false;
    1f8a:	4618      	mov	r0, r3
    1f8c:	e7fc      	b.n	1f88 <usb_handle_request.constprop.0+0x20>
    1f8e:	bf00      	nop
    1f90:	200005c0 	.word	0x200005c0

00001f94 <forward_status_cb>:
	if (status == USB_DC_DISCONNECTED) {
    1f94:	2804      	cmp	r0, #4
{
    1f96:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1f9a:	f8df 8080 	ldr.w	r8, [pc, #128]	; 201c <forward_status_cb+0x88>
    1f9e:	4604      	mov	r4, r0
    1fa0:	460e      	mov	r6, r1
	if (status == USB_DC_DISCONNECTED) {
    1fa2:	d10c      	bne.n	1fbe <forward_status_cb+0x2a>
		usb_reset_alt_setting();
    1fa4:	f7ff ffbc 	bl	1f20 <usb_reset_alt_setting>
		if (usb_dev.configured) {
    1fa8:	f8df 9074 	ldr.w	r9, [pc, #116]	; 2020 <forward_status_cb+0x8c>
    1fac:	f899 30b9 	ldrb.w	r3, [r9, #185]	; 0xb9
    1fb0:	b13b      	cbz	r3, 1fc2 <forward_status_cb+0x2e>
			usb_cancel_transfers();
    1fb2:	f000 fda9 	bl	2b08 <usb_cancel_transfers>
			if (status == USB_DC_DISCONNECTED) {
    1fb6:	2c04      	cmp	r4, #4
    1fb8:	d103      	bne.n	1fc2 <forward_status_cb+0x2e>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1fba:	4d1a      	ldr	r5, [pc, #104]	; (2024 <forward_status_cb+0x90>)
    1fbc:	e014      	b.n	1fe8 <forward_status_cb+0x54>
	if (status == USB_DC_DISCONNECTED || status == USB_DC_SUSPEND) {
    1fbe:	2805      	cmp	r0, #5
    1fc0:	d0f2      	beq.n	1fa8 <forward_status_cb+0x14>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1fc2:	4d18      	ldr	r5, [pc, #96]	; (2024 <forward_status_cb+0x90>)
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1fc4:	4545      	cmp	r5, r8
    1fc6:	d31e      	bcc.n	2006 <forward_status_cb+0x72>
	if (usb_dev.user_status_callback) {
    1fc8:	4b15      	ldr	r3, [pc, #84]	; (2020 <forward_status_cb+0x8c>)
    1fca:	6a1b      	ldr	r3, [r3, #32]
    1fcc:	b31b      	cbz	r3, 2016 <forward_status_cb+0x82>
		usb_dev.user_status_callback(status, param);
    1fce:	4631      	mov	r1, r6
    1fd0:	4620      	mov	r0, r4
}
    1fd2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		usb_dev.user_status_callback(status, param);
    1fd6:	4718      	bx	r3
		ep_data = cfg_data->endpoint;
    1fd8:	f8d5 a020 	ldr.w	sl, [r5, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
    1fdc:	2700      	movs	r7, #0
    1fde:	7f2a      	ldrb	r2, [r5, #28]
    1fe0:	b2fb      	uxtb	r3, r7
    1fe2:	429a      	cmp	r2, r3
    1fe4:	d803      	bhi.n	1fee <forward_status_cb+0x5a>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    1fe6:	3524      	adds	r5, #36	; 0x24
    1fe8:	4545      	cmp	r5, r8
    1fea:	d3f5      	bcc.n	1fd8 <forward_status_cb+0x44>
    1fec:	e007      	b.n	1ffe <forward_status_cb+0x6a>
	return usb_dc_ep_disable(ep_data->ep_addr);
    1fee:	eb0a 03c3 	add.w	r3, sl, r3, lsl #3
			if (ret < 0) {
    1ff2:	3701      	adds	r7, #1
	return usb_dc_ep_disable(ep_data->ep_addr);
    1ff4:	7918      	ldrb	r0, [r3, #4]
    1ff6:	f002 f8dd 	bl	41b4 <usb_dc_ep_disable>
			if (ret < 0) {
    1ffa:	2800      	cmp	r0, #0
    1ffc:	daef      	bge.n	1fde <forward_status_cb+0x4a>
				usb_dev.configured = false;
    1ffe:	2300      	movs	r3, #0
    2000:	f889 30b9 	strb.w	r3, [r9, #185]	; 0xb9
    2004:	e7dd      	b.n	1fc2 <forward_status_cb+0x2e>
		if (cfg_data->cb_usb_status) {
    2006:	68eb      	ldr	r3, [r5, #12]
    2008:	b11b      	cbz	r3, 2012 <forward_status_cb+0x7e>
			cfg_data->cb_usb_status(cfg_data, status, param);
    200a:	4632      	mov	r2, r6
    200c:	4621      	mov	r1, r4
    200e:	4628      	mov	r0, r5
    2010:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    2012:	3524      	adds	r5, #36	; 0x24
    2014:	e7d6      	b.n	1fc4 <forward_status_cb+0x30>
}
    2016:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    201a:	bf00      	nop
    201c:	200002d8 	.word	0x200002d8
    2020:	200005c0 	.word	0x200005c0
    2024:	200002b4 	.word	0x200002b4

00002028 <usb_halt_endpoint_req.isra.0>:
static bool usb_halt_endpoint_req(struct usb_setup_packet *setup, bool halt)
    2028:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t ep = setup->wIndex;
    202a:	b2c4      	uxtb	r4, r0
	if (USB_EP_GET_IDX(ep) == 0) {
    202c:	0663      	lsls	r3, r4, #25
static bool usb_halt_endpoint_req(struct usb_setup_packet *setup, bool halt)
    202e:	460d      	mov	r5, r1
	uint8_t ep = setup->wIndex;
    2030:	f88d 4007 	strb.w	r4, [sp, #7]
	if (USB_EP_GET_IDX(ep) == 0) {
    2034:	d007      	beq.n	2046 <usb_halt_endpoint_req.isra.0+0x1e>
    2036:	4620      	mov	r0, r4
    2038:	f7ff ff7a 	bl	1f30 <is_ep_valid.part.0>
	if (!is_ep_valid(ep)) {
    203c:	b188      	cbz	r0, 2062 <usb_halt_endpoint_req.isra.0+0x3a>
	return (usb_dev.configuration != 0);
    203e:	4b0f      	ldr	r3, [pc, #60]	; (207c <usb_halt_endpoint_req.isra.0+0x54>)
	if ((USB_EP_GET_IDX(ep) == 0) || is_device_configured()) {
    2040:	f893 00ba 	ldrb.w	r0, [r3, #186]	; 0xba
    2044:	b168      	cbz	r0, 2062 <usb_halt_endpoint_req.isra.0+0x3a>
		if (halt) {
    2046:	4e0d      	ldr	r6, [pc, #52]	; (207c <usb_halt_endpoint_req.isra.0+0x54>)
			usb_dc_ep_set_stall(ep);
    2048:	4620      	mov	r0, r4
		if (halt) {
    204a:	b165      	cbz	r5, 2066 <usb_halt_endpoint_req.isra.0+0x3e>
			usb_dc_ep_set_stall(ep);
    204c:	f002 f824 	bl	4098 <usb_dc_ep_set_stall>
			if (usb_dev.status_callback) {
    2050:	69f3      	ldr	r3, [r6, #28]
    2052:	b90b      	cbnz	r3, 2058 <usb_halt_endpoint_req.isra.0+0x30>
		return true;
    2054:	2001      	movs	r0, #1
    2056:	e004      	b.n	2062 <usb_halt_endpoint_req.isra.0+0x3a>
				usb_dev.status_callback(USB_DC_SET_HALT, &ep);
    2058:	2008      	movs	r0, #8
    205a:	f10d 0107 	add.w	r1, sp, #7
    205e:	4798      	blx	r3
		return true;
    2060:	4628      	mov	r0, r5
}
    2062:	b002      	add	sp, #8
    2064:	bd70      	pop	{r4, r5, r6, pc}
			usb_dc_ep_clear_stall(ep);
    2066:	f002 f83f 	bl	40e8 <usb_dc_ep_clear_stall>
			if (usb_dev.status_callback) {
    206a:	69f3      	ldr	r3, [r6, #28]
    206c:	2b00      	cmp	r3, #0
    206e:	d0f1      	beq.n	2054 <usb_halt_endpoint_req.isra.0+0x2c>
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
    2070:	f10d 0107 	add.w	r1, sp, #7
    2074:	2009      	movs	r0, #9
    2076:	4798      	blx	r3
    2078:	e7ec      	b.n	2054 <usb_halt_endpoint_req.isra.0+0x2c>
    207a:	bf00      	nop
    207c:	200005c0 	.word	0x200005c0

00002080 <usb_handle_standard_request>:
{
    2080:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (usb_dev.custom_req_handler &&
    2084:	4ea8      	ldr	r6, [pc, #672]	; (2328 <usb_handle_standard_request+0x2a8>)
    2086:	69b3      	ldr	r3, [r6, #24]
{
    2088:	4605      	mov	r5, r0
    208a:	460f      	mov	r7, r1
    208c:	4690      	mov	r8, r2
	if (usb_dev.custom_req_handler &&
    208e:	b963      	cbnz	r3, 20aa <usb_handle_standard_request+0x2a>
	switch (setup->RequestType.recipient) {
    2090:	7828      	ldrb	r0, [r5, #0]
    2092:	f000 001f 	and.w	r0, r0, #31
    2096:	2801      	cmp	r0, #1
    2098:	f000 80a6 	beq.w	21e8 <usb_handle_standard_request+0x168>
    209c:	2802      	cmp	r0, #2
    209e:	f000 810e 	beq.w	22be <usb_handle_standard_request+0x23e>
    20a2:	b138      	cbz	r0, 20b4 <usb_handle_standard_request+0x34>
		switch (setup->bRequest) {
    20a4:	f06f 0015 	mvn.w	r0, #21
    20a8:	e095      	b.n	21d6 <usb_handle_standard_request+0x156>
	    !usb_dev.custom_req_handler(setup, len, data_buf)) {
    20aa:	4798      	blx	r3
	if (usb_dev.custom_req_handler &&
    20ac:	2800      	cmp	r0, #0
    20ae:	d1ef      	bne.n	2090 <usb_handle_standard_request+0x10>
	int rc = 0;
    20b0:	2000      	movs	r0, #0
    20b2:	e090      	b.n	21d6 <usb_handle_standard_request+0x156>
	if (usb_reqtype_is_to_host(setup)) {
    20b4:	f995 2000 	ldrsb.w	r2, [r5]
		switch (setup->bRequest) {
    20b8:	786b      	ldrb	r3, [r5, #1]
	if (usb_reqtype_is_to_host(setup)) {
    20ba:	2a00      	cmp	r2, #0
    20bc:	da31      	bge.n	2122 <usb_handle_standard_request+0xa2>
		switch (setup->bRequest) {
    20be:	2b06      	cmp	r3, #6
	uint8_t *data = *data_buf;
    20c0:	f8d8 2000 	ldr.w	r2, [r8]
		switch (setup->bRequest) {
    20c4:	d010      	beq.n	20e8 <usb_handle_standard_request+0x68>
    20c6:	2b08      	cmp	r3, #8
    20c8:	d025      	beq.n	2116 <usb_handle_standard_request+0x96>
    20ca:	2b00      	cmp	r3, #0
    20cc:	d1ea      	bne.n	20a4 <usb_handle_standard_request+0x24>
		data[0] |= USB_GET_STATUS_SELF_POWERED;
    20ce:	2101      	movs	r1, #1
	data[1] = 0U;
    20d0:	7053      	strb	r3, [r2, #1]
		data[0] |= USB_GET_STATUS_SELF_POWERED;
    20d2:	7011      	strb	r1, [r2, #0]
		data[0] |= (usb_dev.remote_wakeup ?
    20d4:	f896 10c3 	ldrb.w	r1, [r6, #195]	; 0xc3
    20d8:	2900      	cmp	r1, #0
    20da:	bf18      	it	ne
    20dc:	2302      	movne	r3, #2
    20de:	f043 0301 	orr.w	r3, r3, #1
    20e2:	7013      	strb	r3, [r2, #0]
		*len = 2;
    20e4:	2302      	movs	r3, #2
    20e6:	e01a      	b.n	211e <usb_handle_standard_request+0x9e>
			return usb_get_descriptor(setup, len, data_buf);
    20e8:	886b      	ldrh	r3, [r5, #2]
	type = USB_GET_DESCRIPTOR_TYPE(setup->wValue);
    20ea:	0a1a      	lsrs	r2, r3, #8
	if ((type == USB_DESC_INTERFACE) || (type == USB_DESC_ENDPOINT) ||
    20ec:	1f11      	subs	r1, r2, #4
    20ee:	2901      	cmp	r1, #1
    20f0:	d9d8      	bls.n	20a4 <usb_handle_standard_request+0x24>
    20f2:	2a07      	cmp	r2, #7
    20f4:	d8d6      	bhi.n	20a4 <usb_handle_standard_request+0x24>
	index = USB_GET_DESCRIPTOR_INDEX(setup->wValue);
    20f6:	b2d9      	uxtb	r1, r3
	p = (uint8_t *)usb_dev.descriptors;
    20f8:	6a73      	ldr	r3, [r6, #36]	; 0x24
	while (p[DESC_bLength] != 0U) {
    20fa:	781c      	ldrb	r4, [r3, #0]
    20fc:	2c00      	cmp	r4, #0
    20fe:	d0d1      	beq.n	20a4 <usb_handle_standard_request+0x24>
		if (p[DESC_bDescriptorType] == type) {
    2100:	785d      	ldrb	r5, [r3, #1]
    2102:	4295      	cmp	r5, r2
    2104:	d103      	bne.n	210e <usb_handle_standard_request+0x8e>
			if (cur_index == index) {
    2106:	4281      	cmp	r1, r0
    2108:	f000 8112 	beq.w	2330 <usb_handle_standard_request+0x2b0>
			cur_index++;
    210c:	3001      	adds	r0, #1
		p += p[DESC_bLength];
    210e:	4423      	add	r3, r4
    2110:	e7f3      	b.n	20fa <usb_handle_standard_request+0x7a>
			*len = p[DESC_bLength];
    2112:	781b      	ldrb	r3, [r3, #0]
    2114:	e112      	b.n	233c <usb_handle_standard_request+0x2bc>
			data[0] = usb_dev.configuration;
    2116:	f896 30ba 	ldrb.w	r3, [r6, #186]	; 0xba
    211a:	7013      	strb	r3, [r2, #0]
			*len = 1;
    211c:	2301      	movs	r3, #1
		*len = 2;
    211e:	603b      	str	r3, [r7, #0]
		return true;
    2120:	e059      	b.n	21d6 <usb_handle_standard_request+0x156>
		switch (setup->bRequest) {
    2122:	3b01      	subs	r3, #1
    2124:	2b08      	cmp	r3, #8
    2126:	d8bd      	bhi.n	20a4 <usb_handle_standard_request+0x24>
    2128:	a201      	add	r2, pc, #4	; (adr r2, 2130 <usb_handle_standard_request+0xb0>)
    212a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    212e:	bf00      	nop
    2130:	000021c9 	.word	0x000021c9
    2134:	000020a5 	.word	0x000020a5
    2138:	000021db 	.word	0x000021db
    213c:	000020a5 	.word	0x000020a5
    2140:	00002155 	.word	0x00002155
    2144:	000020a5 	.word	0x000020a5
    2148:	000020a5 	.word	0x000020a5
    214c:	000020a5 	.word	0x000020a5
    2150:	00002161 	.word	0x00002161
			return !usb_dc_set_address(setup->wValue);
    2154:	78a8      	ldrb	r0, [r5, #2]
    2156:	f001 ff6b 	bl	4030 <usb_dc_set_address>
		if (usb_handle_std_device_req(setup, len, data_buf) == false) {
    215a:	2800      	cmp	r0, #0
    215c:	d0a8      	beq.n	20b0 <usb_handle_standard_request+0x30>
    215e:	e7a1      	b.n	20a4 <usb_handle_standard_request+0x24>
	if (setup->wValue == 0U) {
    2160:	886c      	ldrh	r4, [r5, #2]
    2162:	b144      	cbz	r4, 2176 <usb_handle_standard_request+0xf6>
	uint8_t cur_config = 0xFF;
    2164:	f04f 08ff 	mov.w	r8, #255	; 0xff
	uint8_t *p = (uint8_t *)usb_dev.descriptors;
    2168:	6a77      	ldr	r7, [r6, #36]	; 0x24
	bool found = false;
    216a:	2000      	movs	r0, #0
	uint8_t cur_alt_setting = 0xFF;
    216c:	46c1      	mov	r9, r8
	while (p[DESC_bLength] != 0U) {
    216e:	783c      	ldrb	r4, [r7, #0]
    2170:	b96c      	cbnz	r4, 218e <usb_handle_standard_request+0x10e>
	if (found) {
    2172:	2800      	cmp	r0, #0
    2174:	d096      	beq.n	20a4 <usb_handle_standard_request+0x24>
		usb_reset_alt_setting();
    2176:	f7ff fed3 	bl	1f20 <usb_reset_alt_setting>
		usb_dev.configuration = setup->wValue;
    217a:	886b      	ldrh	r3, [r5, #2]
    217c:	f886 30ba 	strb.w	r3, [r6, #186]	; 0xba
		if (usb_dev.status_callback) {
    2180:	69f3      	ldr	r3, [r6, #28]
    2182:	2b00      	cmp	r3, #0
    2184:	d094      	beq.n	20b0 <usb_handle_standard_request+0x30>
			usb_dev.status_callback(USB_DC_CONFIGURED,
    2186:	4969      	ldr	r1, [pc, #420]	; (232c <usb_handle_standard_request+0x2ac>)
    2188:	2003      	movs	r0, #3
    218a:	4798      	blx	r3
    218c:	e790      	b.n	20b0 <usb_handle_standard_request+0x30>
		switch (p[DESC_bDescriptorType]) {
    218e:	787b      	ldrb	r3, [r7, #1]
    2190:	2b04      	cmp	r3, #4
    2192:	d00c      	beq.n	21ae <usb_handle_standard_request+0x12e>
    2194:	2b05      	cmp	r3, #5
    2196:	d00d      	beq.n	21b4 <usb_handle_standard_request+0x134>
    2198:	2b02      	cmp	r3, #2
    219a:	d105      	bne.n	21a8 <usb_handle_standard_request+0x128>
			cur_config = p[CONF_DESC_bConfigurationValue];
    219c:	f897 8005 	ldrb.w	r8, [r7, #5]
			if (cur_config == setup->wValue) {
    21a0:	886a      	ldrh	r2, [r5, #2]
				found = true;
    21a2:	4542      	cmp	r2, r8
    21a4:	bf08      	it	eq
    21a6:	2001      	moveq	r0, #1
		p += p[DESC_bLength];
    21a8:	783b      	ldrb	r3, [r7, #0]
    21aa:	441f      	add	r7, r3
    21ac:	e7df      	b.n	216e <usb_handle_standard_request+0xee>
			cur_alt_setting =
    21ae:	f897 9003 	ldrb.w	r9, [r7, #3]
			break;
    21b2:	e7f9      	b.n	21a8 <usb_handle_standard_request+0x128>
			if ((cur_config != setup->wValue) ||
    21b4:	886b      	ldrh	r3, [r5, #2]
    21b6:	4543      	cmp	r3, r8
    21b8:	d1f6      	bne.n	21a8 <usb_handle_standard_request+0x128>
    21ba:	f1b9 0f00 	cmp.w	r9, #0
    21be:	d1f3      	bne.n	21a8 <usb_handle_standard_request+0x128>
			found = set_endpoint((struct usb_ep_descriptor *)p);
    21c0:	4638      	mov	r0, r7
    21c2:	f7ff fe83 	bl	1ecc <set_endpoint>
			break;
    21c6:	e7ef      	b.n	21a8 <usb_handle_standard_request+0x128>
				if (setup->wValue == USB_SFS_REMOTE_WAKEUP) {
    21c8:	886b      	ldrh	r3, [r5, #2]
    21ca:	2b01      	cmp	r3, #1
    21cc:	f47f af6a 	bne.w	20a4 <usb_handle_standard_request+0x24>
					usb_dev.remote_wakeup = false;
    21d0:	2000      	movs	r0, #0
    21d2:	f886 00c3 	strb.w	r0, [r6, #195]	; 0xc3
}
    21d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if (setup->wValue == USB_SFS_REMOTE_WAKEUP) {
    21da:	886b      	ldrh	r3, [r5, #2]
    21dc:	2b01      	cmp	r3, #1
    21de:	f47f af61 	bne.w	20a4 <usb_handle_standard_request+0x24>
					usb_dev.remote_wakeup = true;
    21e2:	f886 30c3 	strb.w	r3, [r6, #195]	; 0xc3
					return true;
    21e6:	e763      	b.n	20b0 <usb_handle_standard_request+0x30>
	if (!is_device_configured() ||
    21e8:	f896 30ba 	ldrb.w	r3, [r6, #186]	; 0xba
    21ec:	2b00      	cmp	r3, #0
    21ee:	f43f af59 	beq.w	20a4 <usb_handle_standard_request+0x24>
	const uint8_t *p = (uint8_t *)usb_dev.descriptors;
    21f2:	6a74      	ldr	r4, [r6, #36]	; 0x24
	   (!is_interface_valid((uint8_t)setup->wIndex))) {
    21f4:	f8b5 c004 	ldrh.w	ip, [r5, #4]
    21f8:	7928      	ldrb	r0, [r5, #4]
	const uint8_t *p = (uint8_t *)usb_dev.descriptors;
    21fa:	4623      	mov	r3, r4
	while (p[DESC_bLength] != 0U) {
    21fc:	781a      	ldrb	r2, [r3, #0]
    21fe:	2a00      	cmp	r2, #0
    2200:	f43f af50 	beq.w	20a4 <usb_handle_standard_request+0x24>
		if (p[DESC_bDescriptorType] == USB_DESC_CONFIGURATION) {
    2204:	7859      	ldrb	r1, [r3, #1]
    2206:	2902      	cmp	r1, #2
    2208:	d104      	bne.n	2214 <usb_handle_standard_request+0x194>
			if (interface < cfg_descr->bNumInterfaces) {
    220a:	f893 e004 	ldrb.w	lr, [r3, #4]
    220e:	4586      	cmp	lr, r0
    2210:	f200 8096 	bhi.w	2340 <usb_handle_standard_request+0x2c0>
		p += p[DESC_bLength];
    2214:	4413      	add	r3, r2
    2216:	e7f1      	b.n	21fc <usb_handle_standard_request+0x17c>
			data[0] = 0U;
    2218:	7010      	strb	r0, [r2, #0]
			data[1] = 0U;
    221a:	7050      	strb	r0, [r2, #1]
			*len = 2;
    221c:	6039      	str	r1, [r7, #0]
			return true;
    221e:	e7da      	b.n	21d6 <usb_handle_standard_request+0x156>
		p += p[DESC_bLength];
    2220:	440c      	add	r4, r1
    2222:	e09b      	b.n	235c <usb_handle_standard_request+0x2dc>
		if (setup->bRequest == USB_SREQ_SET_INTERFACE) {
    2224:	280b      	cmp	r0, #11
    2226:	f47f af3d 	bne.w	20a4 <usb_handle_standard_request+0x24>
	bool ret = false;
    222a:	2700      	movs	r7, #0
	uint8_t cur_iface = 0xFF;
    222c:	f04f 0aff 	mov.w	sl, #255	; 0xff
	uint8_t cur_alt_setting = 0xFF;
    2230:	46d0      	mov	r8, sl
	const uint8_t *if_desc = NULL;
    2232:	46b9      	mov	r9, r7
    2234:	e006      	b.n	2244 <usb_handle_standard_request+0x1c4>
		switch (p[DESC_bDescriptorType]) {
    2236:	7863      	ldrb	r3, [r4, #1]
    2238:	2b04      	cmp	r3, #4
    223a:	d00f      	beq.n	225c <usb_handle_standard_request+0x1dc>
    223c:	2b05      	cmp	r3, #5
    223e:	d022      	beq.n	2286 <usb_handle_standard_request+0x206>
		p += p[DESC_bLength];
    2240:	7823      	ldrb	r3, [r4, #0]
    2242:	441c      	add	r4, r3
	while (p[DESC_bLength] != 0U) {
    2244:	7823      	ldrb	r3, [r4, #0]
    2246:	2b00      	cmp	r3, #0
    2248:	d1f5      	bne.n	2236 <usb_handle_standard_request+0x1b6>
	if (usb_dev.status_callback) {
    224a:	69f3      	ldr	r3, [r6, #28]
    224c:	b113      	cbz	r3, 2254 <usb_handle_standard_request+0x1d4>
		usb_dev.status_callback(USB_DC_INTERFACE, if_desc);
    224e:	4649      	mov	r1, r9
    2250:	2007      	movs	r0, #7
    2252:	4798      	blx	r3
		if (usb_handle_std_interface_req(setup, len, data_buf) == false) {
    2254:	2f00      	cmp	r7, #0
    2256:	f47f af2b 	bne.w	20b0 <usb_handle_standard_request+0x30>
    225a:	e723      	b.n	20a4 <usb_handle_standard_request+0x24>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
    225c:	f894 a002 	ldrb.w	sl, [r4, #2]
			if (cur_iface == setup->wIndex &&
    2260:	88aa      	ldrh	r2, [r5, #4]
			cur_alt_setting = p[INTF_DESC_bAlternateSetting];
    2262:	f894 8003 	ldrb.w	r8, [r4, #3]
			if (cur_iface == setup->wIndex &&
    2266:	4592      	cmp	sl, r2
    2268:	4653      	mov	r3, sl
    226a:	d1e9      	bne.n	2240 <usb_handle_standard_request+0x1c0>
			    cur_alt_setting == setup->wValue) {
    226c:	8869      	ldrh	r1, [r5, #2]
			if (cur_iface == setup->wIndex &&
    226e:	4588      	cmp	r8, r1
    2270:	fa1f f288 	uxth.w	r2, r8
    2274:	d1e4      	bne.n	2240 <usb_handle_standard_request+0x1c0>
	if (iface < ARRAY_SIZE(usb_dev.alt_setting)) {
    2276:	2b07      	cmp	r3, #7
    2278:	d81e      	bhi.n	22b8 <usb_handle_standard_request+0x238>
		usb_dev.alt_setting[iface] = alt_setting;
    227a:	4433      	add	r3, r6
		return true;
    227c:	46a1      	mov	r9, r4
				ret = usb_set_alt_setting(setup->wIndex,
    227e:	f883 20bb 	strb.w	r2, [r3, #187]	; 0xbb
	return true;
    2282:	2701      	movs	r7, #1
    2284:	e7dc      	b.n	2240 <usb_handle_standard_request+0x1c0>
			if (cur_iface == setup->wIndex) {
    2286:	88ab      	ldrh	r3, [r5, #4]
    2288:	4553      	cmp	r3, sl
    228a:	d1d9      	bne.n	2240 <usb_handle_standard_request+0x1c0>
	if (cur_alt_setting != alt_setting) {
    228c:	78ab      	ldrb	r3, [r5, #2]
    228e:	4543      	cmp	r3, r8
    2290:	d00d      	beq.n	22ae <usb_handle_standard_request+0x22e>
		ret = reset_endpoint(ep_desc);
    2292:	78a7      	ldrb	r7, [r4, #2]
	usb_cancel_transfer(ep_cfg.ep_addr);
    2294:	4638      	mov	r0, r7
    2296:	f000 fc19 	bl	2acc <usb_cancel_transfer>
	ret = usb_dc_ep_disable(ep_cfg.ep_addr);
    229a:	4638      	mov	r0, r7
    229c:	f001 ff8a 	bl	41b4 <usb_dc_ep_disable>
	if (ret == -EALREADY) {
    22a0:	f110 0f78 	cmn.w	r0, #120	; 0x78
    22a4:	d0ed      	beq.n	2282 <usb_handle_standard_request+0x202>
	} else if (ret) {
    22a6:	fab0 f780 	clz	r7, r0
    22aa:	097f      	lsrs	r7, r7, #5
    22ac:	e7c8      	b.n	2240 <usb_handle_standard_request+0x1c0>
		ret = set_endpoint(ep_desc);
    22ae:	4620      	mov	r0, r4
    22b0:	f7ff fe0c 	bl	1ecc <set_endpoint>
    22b4:	4607      	mov	r7, r0
    22b6:	e7c3      	b.n	2240 <usb_handle_standard_request+0x1c0>
    22b8:	46a1      	mov	r9, r4
	return false;
    22ba:	2700      	movs	r7, #0
    22bc:	e7c0      	b.n	2240 <usb_handle_standard_request+0x1c0>
	if (usb_reqtype_is_to_host(setup)) {
    22be:	f995 2000 	ldrsb.w	r2, [r5]
		switch (setup->bRequest) {
    22c2:	786b      	ldrb	r3, [r5, #1]
	if (usb_reqtype_is_to_host(setup)) {
    22c4:	2a00      	cmp	r2, #0
    22c6:	da19      	bge.n	22fc <usb_handle_standard_request+0x27c>
		if (setup->bRequest == USB_SREQ_GET_STATUS) {
    22c8:	2b00      	cmp	r3, #0
    22ca:	f47f aeeb 	bne.w	20a4 <usb_handle_standard_request+0x24>
	uint8_t ep = setup->wIndex;
    22ce:	792c      	ldrb	r4, [r5, #4]
	if (USB_EP_GET_IDX(ep) == 0) {
    22d0:	0663      	lsls	r3, r4, #25
    22d2:	d00a      	beq.n	22ea <usb_handle_standard_request+0x26a>
    22d4:	4620      	mov	r0, r4
    22d6:	f7ff fe2b 	bl	1f30 <is_ep_valid.part.0>
	if (!is_ep_valid(ep)) {
    22da:	2800      	cmp	r0, #0
    22dc:	f43f aee2 	beq.w	20a4 <usb_handle_standard_request+0x24>
	if ((USB_EP_GET_IDX(ep) == 0) || is_device_configured()) {
    22e0:	f896 30ba 	ldrb.w	r3, [r6, #186]	; 0xba
    22e4:	2b00      	cmp	r3, #0
    22e6:	f43f aedd 	beq.w	20a4 <usb_handle_standard_request+0x24>
    22ea:	f8d8 5000 	ldr.w	r5, [r8]
		usb_dc_ep_is_stalled(ep, &data[0]);
    22ee:	4620      	mov	r0, r4
    22f0:	4629      	mov	r1, r5
    22f2:	f001 ff19 	bl	4128 <usb_dc_ep_is_stalled>
		data[1] = 0U;
    22f6:	2000      	movs	r0, #0
    22f8:	7068      	strb	r0, [r5, #1]
    22fa:	e6f3      	b.n	20e4 <usb_handle_standard_request+0x64>
		switch (setup->bRequest) {
    22fc:	2b01      	cmp	r3, #1
    22fe:	d008      	beq.n	2312 <usb_handle_standard_request+0x292>
    2300:	2b03      	cmp	r3, #3
    2302:	f47f aecf 	bne.w	20a4 <usb_handle_standard_request+0x24>
			if (setup->wValue == USB_SFS_ENDPOINT_HALT) {
    2306:	886b      	ldrh	r3, [r5, #2]
    2308:	2b00      	cmp	r3, #0
    230a:	f47f aecb 	bne.w	20a4 <usb_handle_standard_request+0x24>
				return usb_halt_endpoint_req(setup, true);
    230e:	2101      	movs	r1, #1
    2310:	e003      	b.n	231a <usb_handle_standard_request+0x29a>
			if (setup->wValue == USB_SFS_ENDPOINT_HALT) {
    2312:	8869      	ldrh	r1, [r5, #2]
    2314:	2900      	cmp	r1, #0
    2316:	f47f aec5 	bne.w	20a4 <usb_handle_standard_request+0x24>
				return usb_halt_endpoint_req(setup, true);
    231a:	88a8      	ldrh	r0, [r5, #4]
    231c:	f7ff fe84 	bl	2028 <usb_halt_endpoint_req.isra.0>
		if (usb_handle_std_endpoint_req(setup, len, data_buf) == false) {
    2320:	2800      	cmp	r0, #0
    2322:	f47f aec5 	bne.w	20b0 <usb_handle_standard_request+0x30>
    2326:	e6bd      	b.n	20a4 <usb_handle_standard_request+0x24>
    2328:	200005c0 	.word	0x200005c0
    232c:	2000067a 	.word	0x2000067a
		if (type == USB_DESC_CONFIGURATION) {
    2330:	2a02      	cmp	r2, #2
		*data = p;
    2332:	f8c8 3000 	str.w	r3, [r8]
		if (type == USB_DESC_CONFIGURATION) {
    2336:	f47f aeec 	bne.w	2112 <usb_handle_standard_request+0x92>
			*len = (p[CONF_DESC_wTotalLength]) |
    233a:	885b      	ldrh	r3, [r3, #2]
				*len = 1;
    233c:	603b      	str	r3, [r7, #0]
    233e:	e6b7      	b.n	20b0 <usb_handle_standard_request+0x30>
	if (usb_reqtype_is_to_host(setup)) {
    2340:	f995 3000 	ldrsb.w	r3, [r5]
		switch (setup->bRequest) {
    2344:	7868      	ldrb	r0, [r5, #1]
	if (usb_reqtype_is_to_host(setup)) {
    2346:	2b00      	cmp	r3, #0
    2348:	f6bf af6c 	bge.w	2224 <usb_handle_standard_request+0x1a4>
    234c:	f8d8 2000 	ldr.w	r2, [r8]
		switch (setup->bRequest) {
    2350:	2800      	cmp	r0, #0
    2352:	f43f af61 	beq.w	2218 <usb_handle_standard_request+0x198>
    2356:	280a      	cmp	r0, #10
    2358:	f47f aea4 	bne.w	20a4 <usb_handle_standard_request+0x24>
	while (p[DESC_bLength] != 0U) {
    235c:	7821      	ldrb	r1, [r4, #0]
    235e:	2900      	cmp	r1, #0
    2360:	f43f aea0 	beq.w	20a4 <usb_handle_standard_request+0x24>
		if (p[DESC_bDescriptorType] == USB_DESC_INTERFACE) {
    2364:	7863      	ldrb	r3, [r4, #1]
    2366:	2b04      	cmp	r3, #4
    2368:	f47f af5a 	bne.w	2220 <usb_handle_standard_request+0x1a0>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
    236c:	78a3      	ldrb	r3, [r4, #2]
			if (cur_iface == setup->wIndex) {
    236e:	459c      	cmp	ip, r3
    2370:	f47f af56 	bne.w	2220 <usb_handle_standard_request+0x1a0>
	if (iface < ARRAY_SIZE(usb_dev.alt_setting)) {
    2374:	2b07      	cmp	r3, #7
		return usb_dev.alt_setting[iface];
    2376:	bf96      	itet	ls
    2378:	199b      	addls	r3, r3, r6
	return 0;
    237a:	2300      	movhi	r3, #0
		return usb_dev.alt_setting[iface];
    237c:	f893 30bb 	ldrbls.w	r3, [r3, #187]	; 0xbb
				data[0] = usb_get_alt_setting(cur_iface);
    2380:	7013      	strb	r3, [r2, #0]
				*len = 1;
    2382:	2301      	movs	r3, #1
    2384:	e7da      	b.n	233c <usb_handle_standard_request+0x2bc>
    2386:	bf00      	nop

00002388 <usb_data_to_host>:
{
    2388:	b513      	push	{r0, r1, r4, lr}
	if (usb_dev.zlp_flag == false) {
    238a:	4c13      	ldr	r4, [pc, #76]	; (23d8 <usb_data_to_host+0x50>)
    238c:	7d23      	ldrb	r3, [r4, #20]
    238e:	b9c3      	cbnz	r3, 23c2 <usb_data_to_host+0x3a>
		uint32_t chunk = usb_dev.data_buf_residue;
    2390:	68e2      	ldr	r2, [r4, #12]
		usb_write(USB_CONTROL_EP_IN, usb_dev.data_buf,
    2392:	68a1      	ldr	r1, [r4, #8]
		uint32_t chunk = usb_dev.data_buf_residue;
    2394:	9201      	str	r2, [sp, #4]
		usb_write(USB_CONTROL_EP_IN, usb_dev.data_buf,
    2396:	ab01      	add	r3, sp, #4
    2398:	2080      	movs	r0, #128	; 0x80
    239a:	f006 f934 	bl	8606 <usb_write>
		usb_dev.data_buf += chunk;
    239e:	9901      	ldr	r1, [sp, #4]
    23a0:	68a2      	ldr	r2, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
    23a2:	68e3      	ldr	r3, [r4, #12]
		usb_dev.data_buf += chunk;
    23a4:	440a      	add	r2, r1
		usb_dev.data_buf_residue -= chunk;
    23a6:	1a5b      	subs	r3, r3, r1
		usb_dev.data_buf += chunk;
    23a8:	60a2      	str	r2, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
    23aa:	60e3      	str	r3, [r4, #12]
		if (!usb_dev.data_buf_residue &&
    23ac:	b93b      	cbnz	r3, 23be <usb_data_to_host+0x36>
		    usb_dev.setup.wLength > usb_dev.data_buf_len) {
    23ae:	6923      	ldr	r3, [r4, #16]
    23b0:	88e2      	ldrh	r2, [r4, #6]
		if (!usb_dev.data_buf_residue &&
    23b2:	429a      	cmp	r2, r3
    23b4:	dd03      	ble.n	23be <usb_data_to_host+0x36>
			if (!(usb_dev.data_buf_len % USB_MAX_CTRL_MPS)) {
    23b6:	069b      	lsls	r3, r3, #26
    23b8:	d101      	bne.n	23be <usb_data_to_host+0x36>
				usb_dev.zlp_flag = true;
    23ba:	2301      	movs	r3, #1
    23bc:	7523      	strb	r3, [r4, #20]
}
    23be:	b002      	add	sp, #8
    23c0:	bd10      	pop	{r4, pc}
		usb_dev.zlp_flag = false;
    23c2:	2300      	movs	r3, #0
		usb_dc_ep_write(USB_CONTROL_EP_IN, NULL, 0, NULL);
    23c4:	461a      	mov	r2, r3
    23c6:	4619      	mov	r1, r3
    23c8:	2080      	movs	r0, #128	; 0x80
		usb_dev.zlp_flag = false;
    23ca:	7523      	strb	r3, [r4, #20]
}
    23cc:	b002      	add	sp, #8
    23ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usb_dc_ep_write(USB_CONTROL_EP_IN, NULL, 0, NULL);
    23d2:	f001 bf15 	b.w	4200 <usb_dc_ep_write>
    23d6:	bf00      	nop
    23d8:	200005c0 	.word	0x200005c0

000023dc <usb_handle_control_transfer>:
{
    23dc:	b530      	push	{r4, r5, lr}
    23de:	b085      	sub	sp, #20
	uint32_t chunk = 0U;
    23e0:	2300      	movs	r3, #0
{
    23e2:	4602      	mov	r2, r0
    23e4:	460d      	mov	r5, r1
	uint32_t chunk = 0U;
    23e6:	9301      	str	r3, [sp, #4]
	if (ep == USB_CONTROL_EP_OUT && ep_status == USB_DC_EP_SETUP) {
    23e8:	2800      	cmp	r0, #0
    23ea:	d15f      	bne.n	24ac <usb_handle_control_transfer+0xd0>
    23ec:	2900      	cmp	r1, #0
    23ee:	d13c      	bne.n	246a <usb_handle_control_transfer+0x8e>
		if (usb_dc_ep_read(ep, (uint8_t *)&setup_raw,
    23f0:	2208      	movs	r2, #8
    23f2:	460b      	mov	r3, r1
    23f4:	eb0d 0102 	add.w	r1, sp, r2
    23f8:	f006 fac2 	bl	8980 <usb_dc_ep_read>
    23fc:	2800      	cmp	r0, #0
    23fe:	da04      	bge.n	240a <usb_handle_control_transfer+0x2e>
			usb_dc_ep_set_stall(USB_CONTROL_EP_IN);
    2400:	2080      	movs	r0, #128	; 0x80
				usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);
    2402:	f001 fe49 	bl	4098 <usb_dc_ep_set_stall>
}
    2406:	b005      	add	sp, #20
    2408:	bd30      	pop	{r4, r5, pc}
		setup->bmRequestType = setup_raw.bmRequestType;
    240a:	4c2d      	ldr	r4, [pc, #180]	; (24c0 <usb_handle_control_transfer+0xe4>)
		setup->bRequest = setup_raw.bRequest;
    240c:	f89d 3009 	ldrb.w	r3, [sp, #9]
		setup->bmRequestType = setup_raw.bmRequestType;
    2410:	f89d 2008 	ldrb.w	r2, [sp, #8]
		setup->bRequest = setup_raw.bRequest;
    2414:	7063      	strb	r3, [r4, #1]
		setup->wValue = sys_le16_to_cpu(setup_raw.wValue);
    2416:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    241a:	8063      	strh	r3, [r4, #2]
		setup->wIndex = sys_le16_to_cpu(setup_raw.wIndex);
    241c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
		setup->bmRequestType = setup_raw.bmRequestType;
    2420:	7022      	strb	r2, [r4, #0]
		setup->wIndex = sys_le16_to_cpu(setup_raw.wIndex);
    2422:	80a3      	strh	r3, [r4, #4]
		usb_dev.data_buf = usb_dev.req_data;
    2424:	f104 0138 	add.w	r1, r4, #56	; 0x38
		setup->wLength = sys_le16_to_cpu(setup_raw.wLength);
    2428:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    242c:	80e3      	strh	r3, [r4, #6]
		if (usb_reqtype_is_to_device(setup)) {
    242e:	0612      	lsls	r2, r2, #24
		usb_dev.data_buf_residue = 0;
    2430:	e9c4 5503 	strd	r5, r5, [r4, #12]
		usb_dev.data_buf = usb_dev.req_data;
    2434:	60a1      	str	r1, [r4, #8]
		usb_dev.zlp_flag = false;
    2436:	7525      	strb	r5, [r4, #20]
		if (usb_reqtype_is_to_device(setup)) {
    2438:	d40a      	bmi.n	2450 <usb_handle_control_transfer+0x74>
			if (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {
    243a:	2b80      	cmp	r3, #128	; 0x80
    243c:	d904      	bls.n	2448 <usb_handle_control_transfer+0x6c>
				usb_dc_ep_set_stall(USB_CONTROL_EP_IN);
    243e:	2080      	movs	r0, #128	; 0x80
    2440:	f001 fe2a 	bl	4098 <usb_dc_ep_set_stall>
				usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);
    2444:	2000      	movs	r0, #0
    2446:	e7dc      	b.n	2402 <usb_handle_control_transfer+0x26>
			if (setup->wLength) {
    2448:	b113      	cbz	r3, 2450 <usb_handle_control_transfer+0x74>
				usb_dev.data_buf_residue = setup->wLength;
    244a:	e9c4 3303 	strd	r3, r3, [r4, #12]
				return;
    244e:	e7da      	b.n	2406 <usb_handle_control_transfer+0x2a>
		if (!usb_handle_request(setup,
    2450:	f7ff fd8a 	bl	1f68 <usb_handle_request.constprop.0>
    2454:	2800      	cmp	r0, #0
    2456:	d0d3      	beq.n	2400 <usb_handle_control_transfer+0x24>
		usb_dev.data_buf_residue = MIN(usb_dev.data_buf_len,
    2458:	88e2      	ldrh	r2, [r4, #6]
    245a:	6923      	ldr	r3, [r4, #16]
    245c:	429a      	cmp	r2, r3
    245e:	bfd4      	ite	le
    2460:	60e2      	strle	r2, [r4, #12]
    2462:	60e3      	strgt	r3, [r4, #12]
			usb_data_to_host();
    2464:	f7ff ff90 	bl	2388 <usb_data_to_host>
    2468:	e7cd      	b.n	2406 <usb_handle_control_transfer+0x2a>
		if (usb_dev.data_buf_residue <= 0) {
    246a:	4c15      	ldr	r4, [pc, #84]	; (24c0 <usb_handle_control_transfer+0xe4>)
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
    246c:	e9d4 1502 	ldrd	r1, r5, [r4, #8]
		if (usb_dev.data_buf_residue <= 0) {
    2470:	2d00      	cmp	r5, #0
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
    2472:	ab01      	add	r3, sp, #4
		if (usb_dev.data_buf_residue <= 0) {
    2474:	dc04      	bgt.n	2480 <usb_handle_control_transfer+0xa4>
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
    2476:	f006 fa83 	bl	8980 <usb_dc_ep_read>
    247a:	2800      	cmp	r0, #0
    247c:	dac3      	bge.n	2406 <usb_handle_control_transfer+0x2a>
    247e:	e7bf      	b.n	2400 <usb_handle_control_transfer+0x24>
		if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
    2480:	462a      	mov	r2, r5
    2482:	f006 fa7d 	bl	8980 <usb_dc_ep_read>
    2486:	2800      	cmp	r0, #0
    2488:	dbd9      	blt.n	243e <usb_handle_control_transfer+0x62>
		usb_dev.data_buf += chunk;
    248a:	9901      	ldr	r1, [sp, #4]
    248c:	68a2      	ldr	r2, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
    248e:	68e3      	ldr	r3, [r4, #12]
		usb_dev.data_buf += chunk;
    2490:	440a      	add	r2, r1
		usb_dev.data_buf_residue -= chunk;
    2492:	1a5b      	subs	r3, r3, r1
		usb_dev.data_buf += chunk;
    2494:	60a2      	str	r2, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
    2496:	60e3      	str	r3, [r4, #12]
		if (usb_dev.data_buf_residue == 0) {
    2498:	2b00      	cmp	r3, #0
    249a:	d1b4      	bne.n	2406 <usb_handle_control_transfer+0x2a>
			usb_dev.data_buf = usb_dev.req_data;
    249c:	f104 0338 	add.w	r3, r4, #56	; 0x38
    24a0:	60a3      	str	r3, [r4, #8]
			if (!usb_handle_request(setup,
    24a2:	f7ff fd61 	bl	1f68 <usb_handle_request.constprop.0>
    24a6:	2800      	cmp	r0, #0
    24a8:	d1dc      	bne.n	2464 <usb_handle_control_transfer+0x88>
    24aa:	e7a9      	b.n	2400 <usb_handle_control_transfer+0x24>
	} else if (ep == USB_CONTROL_EP_IN) {
    24ac:	2880      	cmp	r0, #128	; 0x80
    24ae:	d1aa      	bne.n	2406 <usb_handle_control_transfer+0x2a>
		if (usb_dev.data_buf_residue != 0 || usb_dev.zlp_flag == true) {
    24b0:	4b03      	ldr	r3, [pc, #12]	; (24c0 <usb_handle_control_transfer+0xe4>)
    24b2:	68da      	ldr	r2, [r3, #12]
    24b4:	2a00      	cmp	r2, #0
    24b6:	d1d5      	bne.n	2464 <usb_handle_control_transfer+0x88>
    24b8:	7d1b      	ldrb	r3, [r3, #20]
    24ba:	2b00      	cmp	r3, #0
    24bc:	d1d2      	bne.n	2464 <usb_handle_control_transfer+0x88>
    24be:	e7a2      	b.n	2406 <usb_handle_control_transfer+0x2a>
    24c0:	200005c0 	.word	0x200005c0

000024c4 <usb_set_config>:
	usb_dev.descriptors = usb_descriptors;
    24c4:	4b05      	ldr	r3, [pc, #20]	; (24dc <usb_set_config+0x18>)
	usb_dev.req_handlers[type] = handler;
    24c6:	4a06      	ldr	r2, [pc, #24]	; (24e0 <usb_set_config+0x1c>)
    24c8:	629a      	str	r2, [r3, #40]	; 0x28
    24ca:	4a06      	ldr	r2, [pc, #24]	; (24e4 <usb_set_config+0x20>)
    24cc:	62da      	str	r2, [r3, #44]	; 0x2c
    24ce:	4a06      	ldr	r2, [pc, #24]	; (24e8 <usb_set_config+0x24>)
    24d0:	631a      	str	r2, [r3, #48]	; 0x30
	usb_dev.custom_req_handler = handler;
    24d2:	4a06      	ldr	r2, [pc, #24]	; (24ec <usb_set_config+0x28>)
	usb_dev.descriptors = usb_descriptors;
    24d4:	6258      	str	r0, [r3, #36]	; 0x24
	usb_dev.custom_req_handler = handler;
    24d6:	619a      	str	r2, [r3, #24]

	/* register class request handlers for each interface*/
	usb_register_custom_req_handler(custom_handler);

	return 0;
}
    24d8:	2000      	movs	r0, #0
    24da:	4770      	bx	lr
    24dc:	200005c0 	.word	0x200005c0
    24e0:	00002081 	.word	0x00002081
    24e4:	00001df1 	.word	0x00001df1
    24e8:	00001e91 	.word	0x00001e91
    24ec:	00001e31 	.word	0x00001e31

000024f0 <usb_device_init>:
 */
static int usb_device_init(const struct device *dev)
{
	uint8_t *device_descriptor;

	if (usb_dev.enabled == true) {
    24f0:	4b07      	ldr	r3, [pc, #28]	; (2510 <usb_device_init+0x20>)
{
    24f2:	b510      	push	{r4, lr}
	if (usb_dev.enabled == true) {
    24f4:	f893 40b8 	ldrb.w	r4, [r3, #184]	; 0xb8
    24f8:	b924      	cbnz	r4, 2504 <usb_device_init+0x14>
		return 0;
	}

	/* register device descriptor */
	device_descriptor = usb_get_device_descriptor();
    24fa:	f000 f99d 	bl	2838 <usb_get_device_descriptor>
	if (!device_descriptor) {
    24fe:	b118      	cbz	r0, 2508 <usb_device_init+0x18>
		LOG_ERR("Failed to configure USB device stack");
		return -1;
	}

	usb_set_config(device_descriptor);
    2500:	f7ff ffe0 	bl	24c4 <usb_set_config>
		return 0;
    2504:	2000      	movs	r0, #0

	return 0;
}
    2506:	bd10      	pop	{r4, pc}
		return -1;
    2508:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    250c:	e7fb      	b.n	2506 <usb_device_init+0x16>
    250e:	bf00      	nop
    2510:	200005c0 	.word	0x200005c0

00002514 <usb_enable>:
{
    2514:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    2518:	4604      	mov	r4, r0
	if (usb_dev.enabled == true) {
    251a:	4d34      	ldr	r5, [pc, #208]	; (25ec <usb_enable+0xd8>)
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&mutex, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
    251c:	4834      	ldr	r0, [pc, #208]	; (25f0 <usb_enable+0xdc>)
    251e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2522:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2526:	f004 fcd5 	bl	6ed4 <z_impl_k_mutex_lock>
    252a:	f895 60b8 	ldrb.w	r6, [r5, #184]	; 0xb8
    252e:	2e00      	cmp	r6, #0
    2530:	d13e      	bne.n	25b0 <usb_enable+0x9c>
	usb_dev.status_callback = cb;
    2532:	4830      	ldr	r0, [pc, #192]	; (25f4 <usb_enable+0xe0>)
	usb_dev.user_status_callback = status_cb;
    2534:	622c      	str	r4, [r5, #32]
	usb_dev.status_callback = cb;
    2536:	61e8      	str	r0, [r5, #28]
	usb_dc_set_status_callback(forward_status_cb);
    2538:	f001 ff78 	bl	442c <usb_dc_set_status_callback>
	ret = usb_dc_attach();
    253c:	f001 fd3a 	bl	3fb4 <usb_dc_attach>
	if (ret < 0) {
    2540:	1e04      	subs	r4, r0, #0
    2542:	db36      	blt.n	25b2 <usb_enable+0x9e>
	ret = usb_transfer_init();
    2544:	f000 fb08 	bl	2b58 <usb_transfer_init>
	if (ret < 0) {
    2548:	1e04      	subs	r4, r0, #0
    254a:	db32      	blt.n	25b2 <usb_enable+0x9e>
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
    254c:	2340      	movs	r3, #64	; 0x40
	ret = usb_dc_ep_configure(&ep0_cfg);
    254e:	4668      	mov	r0, sp
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
    2550:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;
    2554:	f88d 6004 	strb.w	r6, [sp, #4]
	ep0_cfg.ep_addr = USB_CONTROL_EP_OUT;
    2558:	f88d 6000 	strb.w	r6, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
    255c:	f001 fd7a 	bl	4054 <usb_dc_ep_configure>
	if (ret < 0) {
    2560:	1e04      	subs	r4, r0, #0
    2562:	db26      	blt.n	25b2 <usb_enable+0x9e>
	ep0_cfg.ep_addr = USB_CONTROL_EP_IN;
    2564:	2780      	movs	r7, #128	; 0x80
	ret = usb_dc_ep_configure(&ep0_cfg);
    2566:	4668      	mov	r0, sp
	ep0_cfg.ep_addr = USB_CONTROL_EP_IN;
    2568:	f88d 7000 	strb.w	r7, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
    256c:	f001 fd72 	bl	4054 <usb_dc_ep_configure>
	if (ret < 0) {
    2570:	1e04      	subs	r4, r0, #0
    2572:	db1e      	blt.n	25b2 <usb_enable+0x9e>
	ret = usb_dc_ep_set_callback(USB_CONTROL_EP_OUT,
    2574:	4920      	ldr	r1, [pc, #128]	; (25f8 <usb_enable+0xe4>)
    2576:	4630      	mov	r0, r6
    2578:	f001 ff44 	bl	4404 <usb_dc_ep_set_callback>
	if (ret < 0) {
    257c:	1e04      	subs	r4, r0, #0
    257e:	db18      	blt.n	25b2 <usb_enable+0x9e>
	ret = usb_dc_ep_set_callback(USB_CONTROL_EP_IN,
    2580:	491d      	ldr	r1, [pc, #116]	; (25f8 <usb_enable+0xe4>)
    2582:	4638      	mov	r0, r7
    2584:	f001 ff3e 	bl	4404 <usb_dc_ep_set_callback>
	if (ret < 0) {
    2588:	1e04      	subs	r4, r0, #0
    258a:	db12      	blt.n	25b2 <usb_enable+0x9e>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    258c:	4c1b      	ldr	r4, [pc, #108]	; (25fc <usb_enable+0xe8>)
    258e:	f8df 8070 	ldr.w	r8, [pc, #112]	; 2600 <usb_enable+0xec>
    2592:	4544      	cmp	r4, r8
    2594:	d314      	bcc.n	25c0 <usb_enable+0xac>
	ret = usb_dc_ep_enable(USB_CONTROL_EP_OUT);
    2596:	2000      	movs	r0, #0
    2598:	f001 fde2 	bl	4160 <usb_dc_ep_enable>
	if (ret < 0) {
    259c:	1e04      	subs	r4, r0, #0
    259e:	db08      	blt.n	25b2 <usb_enable+0x9e>
	ret = usb_dc_ep_enable(USB_CONTROL_EP_IN);
    25a0:	2080      	movs	r0, #128	; 0x80
    25a2:	f001 fddd 	bl	4160 <usb_dc_ep_enable>
	if (ret < 0) {
    25a6:	1e04      	subs	r4, r0, #0
    25a8:	db03      	blt.n	25b2 <usb_enable+0x9e>
	usb_dev.enabled = true;
    25aa:	2301      	movs	r3, #1
    25ac:	f885 30b8 	strb.w	r3, [r5, #184]	; 0xb8
		ret = 0;
    25b0:	2400      	movs	r4, #0
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
    25b2:	480f      	ldr	r0, [pc, #60]	; (25f0 <usb_enable+0xdc>)
    25b4:	f004 fd06 	bl	6fc4 <z_impl_k_mutex_unlock>
}
    25b8:	4620      	mov	r0, r4
    25ba:	b002      	add	sp, #8
    25bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ep_data = cfg_data->endpoint;
    25c0:	6a27      	ldr	r7, [r4, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
    25c2:	2600      	movs	r6, #0
    25c4:	7f22      	ldrb	r2, [r4, #28]
    25c6:	b2f3      	uxtb	r3, r6
    25c8:	429a      	cmp	r2, r3
    25ca:	d801      	bhi.n	25d0 <usb_enable+0xbc>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    25cc:	3424      	adds	r4, #36	; 0x24
    25ce:	e7e0      	b.n	2592 <usb_enable+0x7e>
			if (usb_dc_ep_set_callback(ep_data[n].ep_addr,
    25d0:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
    25d4:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
    25d8:	7910      	ldrb	r0, [r2, #4]
    25da:	f001 ff13 	bl	4404 <usb_dc_ep_set_callback>
    25de:	3601      	adds	r6, #1
    25e0:	2800      	cmp	r0, #0
    25e2:	d0ef      	beq.n	25c4 <usb_enable+0xb0>
    25e4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    25e8:	e7e3      	b.n	25b2 <usb_enable+0x9e>
    25ea:	bf00      	nop
    25ec:	200005c0 	.word	0x200005c0
    25f0:	200001c8 	.word	0x200001c8
    25f4:	00001f95 	.word	0x00001f95
    25f8:	000023dd 	.word	0x000023dd
    25fc:	200002b4 	.word	0x200002b4
    2600:	200002d8 	.word	0x200002d8

00002604 <usb_update_sn_string_descriptor>:
 * case the device ID returned by the HWINFO driver is bigger, the lower
 * part is used for the USB Serial Number, as that part is usually having
 * more entropy.
 */
__weak uint8_t *usb_update_sn_string_descriptor(void)
{
    2604:	b530      	push	{r4, r5, lr}
	 * unless the user requested a longer serial number.
	 */
	const int usblen = sizeof(CONFIG_USB_DEVICE_SN) / 2;
	uint8_t hwid[MAX(16, sizeof(CONFIG_USB_DEVICE_SN) / 2)];
	static uint8_t sn[sizeof(CONFIG_USB_DEVICE_SN) + 1];
	const char hex[] = "0123456789ABCDEF";
    2606:	4b1e      	ldr	r3, [pc, #120]	; (2680 <usb_update_sn_string_descriptor+0x7c>)
{
    2608:	b08b      	sub	sp, #44	; 0x2c
	const char hex[] = "0123456789ABCDEF";
    260a:	aa05      	add	r2, sp, #20
    260c:	f103 0510 	add.w	r5, r3, #16
    2610:	6818      	ldr	r0, [r3, #0]
    2612:	6859      	ldr	r1, [r3, #4]
    2614:	4614      	mov	r4, r2
    2616:	c403      	stmia	r4!, {r0, r1}
    2618:	3308      	adds	r3, #8
    261a:	42ab      	cmp	r3, r5
    261c:	4622      	mov	r2, r4
    261e:	d1f7      	bne.n	2610 <usb_update_sn_string_descriptor+0xc>
    2620:	781b      	ldrb	r3, [r3, #0]
    2622:	7023      	strb	r3, [r4, #0]
	int hwlen, skip;

	memset(hwid, 0, sizeof(hwid));
    2624:	2210      	movs	r2, #16
    2626:	2100      	movs	r1, #0
    2628:	a801      	add	r0, sp, #4
    262a:	f006 f950 	bl	88ce <memset>
	memset(sn, 0, sizeof(sn));
    262e:	2212      	movs	r2, #18
    2630:	2100      	movs	r1, #0
    2632:	4814      	ldr	r0, [pc, #80]	; (2684 <usb_update_sn_string_descriptor+0x80>)
    2634:	f006 f94b 	bl	88ce <memset>
		/* coverity[OVERRUN] */
		return (ssize_t) arch_syscall_invoke2(*(uintptr_t *)&buffer, *(uintptr_t *)&length, K_SYSCALL_HWINFO_GET_DEVICE_ID);
	}
#endif
	compiler_barrier();
	return z_impl_hwinfo_get_device_id(buffer, length);
    2638:	2110      	movs	r1, #16
    263a:	a801      	add	r0, sp, #4
    263c:	f006 fa92 	bl	8b64 <z_impl_hwinfo_get_device_id>

	hwlen = hwinfo_get_device_id(hwid, sizeof(hwid));
	if (hwlen > 0) {
    2640:	2800      	cmp	r0, #0
    2642:	dd1a      	ble.n	267a <usb_update_sn_string_descriptor+0x76>
		skip = MAX(0, hwlen - usblen);
    2644:	3808      	subs	r0, #8
    2646:	aa01      	add	r2, sp, #4
    2648:	490e      	ldr	r1, [pc, #56]	; (2684 <usb_update_sn_string_descriptor+0x80>)
    264a:	2800      	cmp	r0, #0
    264c:	bfa8      	it	ge
    264e:	1812      	addge	r2, r2, r0
		LOG_HEXDUMP_DBG(&hwid[skip], usblen, "Serial Number");
		for (int i = 0; i < usblen; i++) {
    2650:	2000      	movs	r0, #0
			sn[i * 2] = hex[hwid[i + skip] >> 4];
    2652:	f812 3b01 	ldrb.w	r3, [r2], #1
    2656:	ac0a      	add	r4, sp, #40	; 0x28
    2658:	eb04 1413 	add.w	r4, r4, r3, lsr #4
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
    265c:	f003 030f 	and.w	r3, r3, #15
			sn[i * 2] = hex[hwid[i + skip] >> 4];
    2660:	f814 4c14 	ldrb.w	r4, [r4, #-20]
    2664:	700c      	strb	r4, [r1, #0]
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
    2666:	ac0a      	add	r4, sp, #40	; 0x28
    2668:	4423      	add	r3, r4
		for (int i = 0; i < usblen; i++) {
    266a:	3001      	adds	r0, #1
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
    266c:	f813 3c14 	ldrb.w	r3, [r3, #-20]
    2670:	704b      	strb	r3, [r1, #1]
		for (int i = 0; i < usblen; i++) {
    2672:	2808      	cmp	r0, #8
    2674:	f101 0102 	add.w	r1, r1, #2
    2678:	d1eb      	bne.n	2652 <usb_update_sn_string_descriptor+0x4e>
		}
	}

	return sn;
}
    267a:	4802      	ldr	r0, [pc, #8]	; (2684 <usb_update_sn_string_descriptor+0x80>)
    267c:	b00b      	add	sp, #44	; 0x2c
    267e:	bd30      	pop	{r4, r5, pc}
    2680:	00009c86 	.word	0x00009c86
    2684:	20001370 	.word	0x20001370

00002688 <usb_fix_descriptor>:
 * Restrictions:
 * - just one device configuration (there is only one)
 * - string descriptor must be present
 */
static int usb_fix_descriptor(struct usb_desc_header *head)
{
    2688:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    268c:	4604      	mov	r4, r0
    268e:	b085      	sub	sp, #20
	struct usb_cfg_descriptor *cfg_descr = NULL;
	struct usb_if_descriptor *if_descr = NULL;
	struct usb_cfg_data *cfg_data = NULL;
	struct usb_ep_descriptor *ep_descr = NULL;
	uint8_t numof_ifaces = 0U;
	uint8_t str_descr_idx = 0U;
    2690:	2500      	movs	r5, #0
	uint32_t requested_ep = BIT(16) | BIT(0);
    2692:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
	uint8_t numof_ifaces = 0U;
    2696:	46a9      	mov	r9, r5
	struct usb_cfg_data *cfg_data = NULL;
    2698:	462e      	mov	r6, r5
	struct usb_cfg_descriptor *cfg_descr = NULL;
    269a:	46aa      	mov	sl, r5

	while (head->bLength != 0U) {
    269c:	7820      	ldrb	r0, [r4, #0]
    269e:	b920      	cbnz	r0, 26aa <usb_fix_descriptor+0x22>

		/* Move to next descriptor */
		head = (struct usb_desc_header *)((uint8_t *)head + head->bLength);
	}

	if ((head + 1) != __usb_descriptor_end) {
    26a0:	4b61      	ldr	r3, [pc, #388]	; (2828 <usb_fix_descriptor+0x1a0>)
    26a2:	3402      	adds	r4, #2
    26a4:	429c      	cmp	r4, r3
    26a6:	d01f      	beq.n	26e8 <usb_fix_descriptor+0x60>
    26a8:	e7f2      	b.n	2690 <usb_fix_descriptor+0x8>
		switch (head->bDescriptorType) {
    26aa:	7863      	ldrb	r3, [r4, #1]
    26ac:	2b05      	cmp	r3, #5
    26ae:	d805      	bhi.n	26bc <usb_fix_descriptor+0x34>
    26b0:	e8df f003 	tbb	[pc, r3]
    26b4:	78030478 	.word	0x78030478
    26b8:	2007      	.short	0x2007
    26ba:	46a2      	mov	sl, r4
		head = (struct usb_desc_header *)((uint8_t *)head + head->bLength);
    26bc:	7823      	ldrb	r3, [r4, #0]
    26be:	441c      	add	r4, r3
    26c0:	e7ec      	b.n	269c <usb_fix_descriptor+0x14>
			if (if_descr->bAlternateSetting) {
    26c2:	78e3      	ldrb	r3, [r4, #3]
    26c4:	2b00      	cmp	r3, #0
    26c6:	d1f9      	bne.n	26bc <usb_fix_descriptor+0x34>
			if (if_descr->bInterfaceNumber == 0U) {
    26c8:	78a3      	ldrb	r3, [r4, #2]
    26ca:	b183      	cbz	r3, 26ee <usb_fix_descriptor+0x66>
			numof_ifaces++;
    26cc:	f109 0901 	add.w	r9, r9, #1
    26d0:	fa5f f989 	uxtb.w	r9, r9
			break;
    26d4:	e7f2      	b.n	26bc <usb_fix_descriptor+0x34>
		if (cfg_data->interface_descriptor == iface) {
    26d6:	6872      	ldr	r2, [r6, #4]
    26d8:	4294      	cmp	r4, r2
    26da:	f000 809d 	beq.w	2818 <usb_fix_descriptor+0x190>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    26de:	3624      	adds	r6, #36	; 0x24
    26e0:	429e      	cmp	r6, r3
    26e2:	d3f8      	bcc.n	26d6 <usb_fix_descriptor+0x4e>
					return -1;
    26e4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		LOG_DBG("try to fix next descriptor at %p", head + 1);
		return usb_fix_descriptor(head + 1);
	}

	return 0;
}
    26e8:	b005      	add	sp, #20
    26ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
    26ee:	4e4f      	ldr	r6, [pc, #316]	; (282c <usb_fix_descriptor+0x1a4>)
    26f0:	4b4f      	ldr	r3, [pc, #316]	; (2830 <usb_fix_descriptor+0x1a8>)
    26f2:	e7f5      	b.n	26e0 <usb_fix_descriptor+0x58>
			if (!cfg_data) {
    26f4:	2e00      	cmp	r6, #0
    26f6:	d0f5      	beq.n	26e4 <usb_fix_descriptor+0x5c>
	for (unsigned int i = 0; i < cfg_data->num_endpoints; i++) {
    26f8:	2300      	movs	r3, #0
    26fa:	2101      	movs	r1, #1
    26fc:	7f32      	ldrb	r2, [r6, #28]
    26fe:	4293      	cmp	r3, r2
    2700:	d2f0      	bcs.n	26e4 <usb_fix_descriptor+0x5c>
		if (ep_descr->bEndpointAddress != ep_data[i].ep_addr) {
    2702:	6a32      	ldr	r2, [r6, #32]
    2704:	78a7      	ldrb	r7, [r4, #2]
    2706:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    270a:	7910      	ldrb	r0, [r2, #4]
    270c:	4287      	cmp	r7, r0
    270e:	d001      	beq.n	2714 <usb_fix_descriptor+0x8c>
	for (unsigned int i = 0; i < cfg_data->num_endpoints; i++) {
    2710:	3301      	adds	r3, #1
    2712:	e7f3      	b.n	26fc <usb_fix_descriptor+0x74>
    2714:	2701      	movs	r7, #1
			ep_cfg.ep_type = (ep_descr->bmAttributes &
    2716:	78e0      	ldrb	r0, [r4, #3]
			ep_cfg.ep_mps = ep_descr->wMaxPacketSize;
    2718:	f894 c005 	ldrb.w	ip, [r4, #5]
			ep_cfg.ep_type = (ep_descr->bmAttributes &
    271c:	f000 0003 	and.w	r0, r0, #3
    2720:	f88d 000c 	strb.w	r0, [sp, #12]
			ep_cfg.ep_mps = ep_descr->wMaxPacketSize;
    2724:	7920      	ldrb	r0, [r4, #4]
    2726:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
    272a:	f8ad 000a 	strh.w	r0, [sp, #10]
			if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
    272e:	f994 0002 	ldrsb.w	r0, [r4, #2]
    2732:	2800      	cmp	r0, #0
    2734:	fa5f f887 	uxtb.w	r8, r7
    2738:	da28      	bge.n	278c <usb_fix_descriptor+0x104>
				if ((*requested_ep & (1U << (idx + 16U)))) {
    273a:	f107 0010 	add.w	r0, r7, #16
    273e:	fa01 f000 	lsl.w	r0, r1, r0
    2742:	ea10 0f0b 	tst.w	r0, fp
    2746:	d129      	bne.n	279c <usb_fix_descriptor+0x114>
				ep_cfg.ep_addr = (USB_EP_DIR_IN | idx);
    2748:	f068 007f 	orn	r0, r8, #127	; 0x7f
    274c:	f88d 0008 	strb.w	r0, [sp, #8]
			if (!usb_dc_ep_check_cap(&ep_cfg)) {
    2750:	a802      	add	r0, sp, #8
    2752:	e9cd 3200 	strd	r3, r2, [sp]
    2756:	f006 f8fb 	bl	8950 <usb_dc_ep_check_cap>
    275a:	e9dd 3200 	ldrd	r3, r2, [sp]
    275e:	2101      	movs	r1, #1
    2760:	b9e0      	cbnz	r0, 279c <usb_fix_descriptor+0x114>
				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
    2762:	f89d 3008 	ldrb.w	r3, [sp, #8]
    2766:	70a3      	strb	r3, [r4, #2]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
    2768:	f013 0f80 	tst.w	r3, #128	; 0x80
					*requested_ep |= (1U << (idx + 16U));
    276c:	bf1c      	itt	ne
    276e:	f108 0810 	addne.w	r8, r8, #16
    2772:	fa5f f888 	uxtbne.w	r8, r8
				ep_data[i].ep_addr = ep_cfg.ep_addr;
    2776:	7113      	strb	r3, [r2, #4]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
    2778:	460b      	mov	r3, r1
					*requested_ep |= (1U << (idx + 16U));
    277a:	bf15      	itete	ne
    277c:	fa01 f808 	lslne.w	r8, r1, r8
					*requested_ep |= (1U << idx);
    2780:	40bb      	lsleq	r3, r7
					*requested_ep |= (1U << (idx + 16U));
    2782:	ea4b 0b08 	orrne.w	fp, fp, r8
					*requested_ep |= (1U << idx);
    2786:	ea4b 0b03 	orreq.w	fp, fp, r3
				return 0;
    278a:	e797      	b.n	26bc <usb_fix_descriptor+0x34>
				if ((*requested_ep & (1U << (idx)))) {
    278c:	fa01 f007 	lsl.w	r0, r1, r7
    2790:	ea10 0f0b 	tst.w	r0, fp
    2794:	d102      	bne.n	279c <usb_fix_descriptor+0x114>
				ep_cfg.ep_addr = idx;
    2796:	f88d 8008 	strb.w	r8, [sp, #8]
    279a:	e7d9      	b.n	2750 <usb_fix_descriptor+0xc8>
		for (uint8_t idx = 1; idx < 16U; idx++) {
    279c:	3701      	adds	r7, #1
    279e:	2f10      	cmp	r7, #16
    27a0:	d1b9      	bne.n	2716 <usb_fix_descriptor+0x8e>
    27a2:	e7b5      	b.n	2710 <usb_fix_descriptor+0x88>
			if (str_descr_idx == USB_DESC_SERIAL_NUMBER_IDX) {
    27a4:	2d03      	cmp	r5, #3
    27a6:	d11d      	bne.n	27e4 <usb_fix_descriptor+0x15c>
	uint8_t *runtime_sn =  usb_update_sn_string_descriptor();
    27a8:	f7ff ff2c 	bl	2604 <usb_update_sn_string_descriptor>
	if (!runtime_sn) {
    27ac:	4607      	mov	r7, r0
    27ae:	b168      	cbz	r0, 27cc <usb_fix_descriptor+0x144>
	runtime_sn_len = strlen(runtime_sn);
    27b0:	f006 f866 	bl	8880 <strlen>
	if (!runtime_sn_len) {
    27b4:	4680      	mov	r8, r0
    27b6:	b148      	cbz	r0, 27cc <usb_fix_descriptor+0x144>
	default_sn_len = strlen(CONFIG_USB_DEVICE_SN);
    27b8:	481e      	ldr	r0, [pc, #120]	; (2834 <usb_fix_descriptor+0x1ac>)
    27ba:	f006 f861 	bl	8880 <strlen>
	if (runtime_sn_len != default_sn_len) {
    27be:	4580      	cmp	r8, r0
    27c0:	d104      	bne.n	27cc <usb_fix_descriptor+0x144>
	memcpy(sn->bString, runtime_sn, runtime_sn_len);
    27c2:	4642      	mov	r2, r8
    27c4:	4639      	mov	r1, r7
    27c6:	1ca0      	adds	r0, r4, #2
    27c8:	f006 f876 	bl	88b8 <memcpy>
	int idx_max = USB_BSTRING_UTF16LE_IDX_MAX(str_descr->bLength);
    27cc:	7823      	ldrb	r3, [r4, #0]
	for (int i = idx_max; i >= 0; i -= 2) {
    27ce:	f06f 0102 	mvn.w	r1, #2
    27d2:	18e2      	adds	r2, r4, r3
    27d4:	1b09      	subs	r1, r1, r4
    27d6:	eb04 0353 	add.w	r3, r4, r3, lsr #1
    27da:	42d1      	cmn	r1, r2
    27dc:	d513      	bpl.n	2806 <usb_fix_descriptor+0x17e>
			str_descr_idx += 1U;
    27de:	3501      	adds	r5, #1
    27e0:	b2ed      	uxtb	r5, r5
			break;
    27e2:	e76b      	b.n	26bc <usb_fix_descriptor+0x34>
			if (str_descr_idx) {
    27e4:	2d00      	cmp	r5, #0
    27e6:	d1f1      	bne.n	27cc <usb_fix_descriptor+0x144>
				if (!cfg_descr) {
    27e8:	f1ba 0f00 	cmp.w	sl, #0
    27ec:	f43f af7a 	beq.w	26e4 <usb_fix_descriptor+0x5c>
				sys_put_le16((uint8_t *)head - (uint8_t *)cfg_descr,
    27f0:	eba4 030a 	sub.w	r3, r4, sl
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
    27f4:	f88a 3002 	strb.w	r3, [sl, #2]
	dst[1] = val >> 8;
    27f8:	f3c3 2307 	ubfx	r3, r3, #8, #8
    27fc:	f88a 3003 	strb.w	r3, [sl, #3]
				cfg_descr->bNumInterfaces = numof_ifaces;
    2800:	f88a 9004 	strb.w	r9, [sl, #4]
    2804:	e7eb      	b.n	27de <usb_fix_descriptor+0x156>
		buf[i] = 0U;
    2806:	f04f 0000 	mov.w	r0, #0
    280a:	f802 0c01 	strb.w	r0, [r2, #-1]
		buf[i - 1] = buf[ascii_idx_max--];
    280e:	f813 0901 	ldrb.w	r0, [r3], #-1
    2812:	f802 0d02 	strb.w	r0, [r2, #-2]!
	for (int i = idx_max; i >= 0; i -= 2) {
    2816:	e7e0      	b.n	27da <usb_fix_descriptor+0x152>
				if (cfg_data->interface_config) {
    2818:	68b3      	ldr	r3, [r6, #8]
    281a:	2b00      	cmp	r3, #0
    281c:	f43f af56 	beq.w	26cc <usb_fix_descriptor+0x44>
					cfg_data->interface_config(head,
    2820:	4649      	mov	r1, r9
    2822:	4620      	mov	r0, r4
    2824:	4798      	blx	r3
    2826:	e751      	b.n	26cc <usb_fix_descriptor+0x44>
    2828:	200002b3 	.word	0x200002b3
    282c:	200002b4 	.word	0x200002b4
    2830:	200002d8 	.word	0x200002d8
    2834:	00009c86 	.word	0x00009c86

00002838 <usb_get_device_descriptor>:


uint8_t *usb_get_device_descriptor(void)
{
    2838:	b508      	push	{r3, lr}
	LOG_DBG("__usb_descriptor_start %p", __usb_descriptor_start);
	LOG_DBG("__usb_descriptor_end %p", __usb_descriptor_end);

	if (usb_fix_descriptor(__usb_descriptor_start)) {
    283a:	4804      	ldr	r0, [pc, #16]	; (284c <usb_get_device_descriptor+0x14>)
    283c:	f7ff ff24 	bl	2688 <usb_fix_descriptor>
		LOG_ERR("Failed to fixup USB descriptor");
		return NULL;
    2840:	2800      	cmp	r0, #0
	}

	return (uint8_t *) __usb_descriptor_start;
}
    2842:	4802      	ldr	r0, [pc, #8]	; (284c <usb_get_device_descriptor+0x14>)
    2844:	bf18      	it	ne
    2846:	2000      	movne	r0, #0
    2848:	bd08      	pop	{r3, pc}
    284a:	bf00      	nop
    284c:	200001ec 	.word	0x200001ec

00002850 <usb_ep_get_transfer>:
/** Max number of parallel transfers */
static struct usb_transfer_data ut_data[CONFIG_USB_MAX_NUM_TRANSFERS];

/* Transfer management */
static struct usb_transfer_data *usb_ep_get_transfer(uint8_t ep)
{
    2850:	b510      	push	{r4, lr}
    2852:	4b09      	ldr	r3, [pc, #36]	; (2878 <usb_ep_get_transfer+0x28>)
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    2854:	2100      	movs	r1, #0
    2856:	461a      	mov	r2, r3
		if (ut_data[i].ep == ep && ut_data[i].status != 0) {
    2858:	781c      	ldrb	r4, [r3, #0]
    285a:	4284      	cmp	r4, r0
    285c:	d104      	bne.n	2868 <usb_ep_get_transfer+0x18>
    285e:	685c      	ldr	r4, [r3, #4]
    2860:	b114      	cbz	r4, 2868 <usb_ep_get_transfer+0x18>
			return &ut_data[i];
    2862:	eb02 1081 	add.w	r0, r2, r1, lsl #6
		}
	}

	return NULL;
}
    2866:	bd10      	pop	{r4, pc}
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    2868:	3101      	adds	r1, #1
    286a:	2904      	cmp	r1, #4
    286c:	f103 0340 	add.w	r3, r3, #64	; 0x40
    2870:	d1f2      	bne.n	2858 <usb_ep_get_transfer+0x8>
	return NULL;
    2872:	2000      	movs	r0, #0
    2874:	e7f7      	b.n	2866 <usb_ep_get_transfer+0x16>
    2876:	bf00      	nop
    2878:	20000684 	.word	0x20000684

0000287c <usb_transfer_work>:

	return false;
}

static void usb_transfer_work(struct k_work *item)
{
    287c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	uint8_t ep;

	trans = CONTAINER_OF(item, struct usb_transfer_data, work);
	ep = trans->ep;

	if (trans->status != -EBUSY) {
    2880:	f850 3c28 	ldr.w	r3, [r0, #-40]
	ep = trans->ep;
    2884:	f810 6c2c 	ldrb.w	r6, [r0, #-44]
	if (trans->status != -EBUSY) {
    2888:	3310      	adds	r3, #16
{
    288a:	4604      	mov	r4, r0
	if (trans->status != -EBUSY) {
    288c:	d110      	bne.n	28b0 <usb_transfer_work+0x34>
		/* transfer cancelled or already completed */
		LOG_DBG("Transfer cancelled or completed, ep 0x%02x", ep);
		goto done;
	}

	if (trans->flags & USB_TRANS_WRITE) {
    288e:	6903      	ldr	r3, [r0, #16]
		if (!trans->bsize) {
    2890:	f850 2c20 	ldr.w	r2, [r0, #-32]
	if (trans->flags & USB_TRANS_WRITE) {
    2894:	0799      	lsls	r1, r3, #30
    2896:	d53c      	bpl.n	2912 <usb_transfer_work+0x96>
		if (!trans->bsize) {
    2898:	bb02      	cbnz	r2, 28dc <usb_transfer_work+0x60>
			if (!(trans->flags & USB_TRANS_NO_ZLP)) {
    289a:	f013 0304 	ands.w	r3, r3, #4
    289e:	d104      	bne.n	28aa <usb_transfer_work+0x2e>
				LOG_DBG("Transfer ZLP");
				usb_write(ep, NULL, 0, NULL);
    28a0:	461a      	mov	r2, r3
    28a2:	4619      	mov	r1, r3
    28a4:	4630      	mov	r0, r6
    28a6:	f005 feae 	bl	8606 <usb_write>
			}
			trans->status = 0;
    28aa:	2300      	movs	r3, #0

		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
		if (ret) {
			LOG_ERR("Transfer error %d, ep 0x%02x", ret, ep);
			/* transfer error */
			trans->status = -EINVAL;
    28ac:	f844 3c28 	str.w	r3, [r4, #-40]
		/* we expect mote data, clear NAK */
		usb_dc_ep_read_continue(ep);
	}

done:
	if (trans->status != -EBUSY && trans->cb) { /* Transfer complete */
    28b0:	f854 3c28 	ldr.w	r3, [r4, #-40]
    28b4:	3310      	adds	r3, #16
    28b6:	d00e      	beq.n	28d6 <usb_transfer_work+0x5a>
    28b8:	f854 5c18 	ldr.w	r5, [r4, #-24]
    28bc:	b15d      	cbz	r5, 28d6 <usb_transfer_work+0x5a>
		usb_transfer_callback cb = trans->cb;
		int tsize = trans->tsize;
    28be:	f854 7c1c 	ldr.w	r7, [r4, #-28]
		void *priv = trans->priv;
    28c2:	f854 8c14 	ldr.w	r8, [r4, #-20]

		if (k_is_in_isr()) {
    28c6:	f006 fcc6 	bl	9256 <k_is_in_isr>
    28ca:	2800      	cmp	r0, #0
    28cc:	d04c      	beq.n	2968 <usb_transfer_work+0xec>
			/* reschedule completion in thread context */
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
    28ce:	482e      	ldr	r0, [pc, #184]	; (2988 <usb_transfer_work+0x10c>)
    28d0:	4621      	mov	r1, r4
    28d2:	f006 fd7f 	bl	93d4 <k_work_submit_to_queue>
		/* Transfer completion callback */
		if (trans->status != -ECANCELED) {
			cb(ep, tsize, priv);
		}
	}
}
    28d6:	b002      	add	sp, #8
    28d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
    28dc:	f850 1c24 	ldr.w	r1, [r0, #-36]
    28e0:	ab01      	add	r3, sp, #4
    28e2:	4630      	mov	r0, r6
    28e4:	f005 fe8f 	bl	8606 <usb_write>
		if (ret) {
    28e8:	b110      	cbz	r0, 28f0 <usb_transfer_work+0x74>
			trans->status = -EINVAL;
    28ea:	f06f 0315 	mvn.w	r3, #21
    28ee:	e7dd      	b.n	28ac <usb_transfer_work+0x30>
		trans->buffer += bytes;
    28f0:	9a01      	ldr	r2, [sp, #4]
    28f2:	f854 3c24 	ldr.w	r3, [r4, #-36]
    28f6:	4413      	add	r3, r2
    28f8:	f844 3c24 	str.w	r3, [r4, #-36]
		trans->bsize -= bytes;
    28fc:	f854 3c20 	ldr.w	r3, [r4, #-32]
    2900:	1a9b      	subs	r3, r3, r2
    2902:	f844 3c20 	str.w	r3, [r4, #-32]
		trans->tsize += bytes;
    2906:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    290a:	4413      	add	r3, r2
    290c:	f844 3c1c 	str.w	r3, [r4, #-28]
    2910:	e7ce      	b.n	28b0 <usb_transfer_work+0x34>
		ret = usb_dc_ep_read_wait(ep, trans->buffer, trans->bsize,
    2912:	f850 1c24 	ldr.w	r1, [r0, #-36]
    2916:	ab01      	add	r3, sp, #4
    2918:	4630      	mov	r0, r6
    291a:	f001 fce9 	bl	42f0 <usb_dc_ep_read_wait>
		if (ret) {
    291e:	2800      	cmp	r0, #0
    2920:	d1e3      	bne.n	28ea <usb_transfer_work+0x6e>
		trans->buffer += bytes;
    2922:	9d01      	ldr	r5, [sp, #4]
    2924:	f854 3c24 	ldr.w	r3, [r4, #-36]
    2928:	442b      	add	r3, r5
    292a:	f844 3c24 	str.w	r3, [r4, #-36]
		trans->bsize -= bytes;
    292e:	f854 3c20 	ldr.w	r3, [r4, #-32]
    2932:	1b5b      	subs	r3, r3, r5
    2934:	f844 3c20 	str.w	r3, [r4, #-32]
		trans->tsize += bytes;
    2938:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    293c:	442b      	add	r3, r5
    293e:	f844 3c1c 	str.w	r3, [r4, #-28]
		if (!bytes || (bytes % usb_dc_ep_mps(ep)) || !trans->bsize) {
    2942:	2d00      	cmp	r5, #0
    2944:	d0b1      	beq.n	28aa <usb_transfer_work+0x2e>
    2946:	4630      	mov	r0, r6
    2948:	f001 fd76 	bl	4438 <usb_dc_ep_mps>
    294c:	fbb5 f3f0 	udiv	r3, r5, r0
    2950:	fb03 5510 	mls	r5, r3, r0, r5
    2954:	2d00      	cmp	r5, #0
    2956:	d1a8      	bne.n	28aa <usb_transfer_work+0x2e>
    2958:	f854 3c20 	ldr.w	r3, [r4, #-32]
    295c:	2b00      	cmp	r3, #0
    295e:	d0a4      	beq.n	28aa <usb_transfer_work+0x2e>
		usb_dc_ep_read_continue(ep);
    2960:	4630      	mov	r0, r6
    2962:	f001 fd0d 	bl	4380 <usb_dc_ep_read_continue>
    2966:	e7a3      	b.n	28b0 <usb_transfer_work+0x34>
		trans->cb = NULL;
    2968:	f844 0c18 	str.w	r0, [r4, #-24]
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    296c:	f1a4 0010 	sub.w	r0, r4, #16
    2970:	f004 fb9e 	bl	70b0 <z_impl_k_sem_give>
		if (trans->status != -ECANCELED) {
    2974:	f854 3c28 	ldr.w	r3, [r4, #-40]
    2978:	338c      	adds	r3, #140	; 0x8c
    297a:	d0ac      	beq.n	28d6 <usb_transfer_work+0x5a>
			cb(ep, tsize, priv);
    297c:	4642      	mov	r2, r8
    297e:	4639      	mov	r1, r7
    2980:	4630      	mov	r0, r6
    2982:	47a8      	blx	r5
    2984:	e7a7      	b.n	28d6 <usb_transfer_work+0x5a>
    2986:	bf00      	nop
    2988:	200002d8 	.word	0x200002d8

0000298c <usb_transfer_ep_callback>:

void usb_transfer_ep_callback(uint8_t ep, enum usb_dc_ep_cb_status_code status)
{
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);

	if (status != USB_DC_EP_DATA_IN && status != USB_DC_EP_DATA_OUT) {
    298c:	1e4b      	subs	r3, r1, #1
    298e:	2b01      	cmp	r3, #1
{
    2990:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2992:	4606      	mov	r6, r0
    2994:	460d      	mov	r5, r1
	if (status != USB_DC_EP_DATA_IN && status != USB_DC_EP_DATA_OUT) {
    2996:	d80f      	bhi.n	29b8 <usb_transfer_ep_callback+0x2c>
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);
    2998:	f7ff ff5a 	bl	2850 <usb_ep_get_transfer>
		return;
	}

	if (!trans) {
    299c:	4604      	mov	r4, r0
    299e:	b968      	cbnz	r0, 29bc <usb_transfer_ep_callback+0x30>
		if (status == USB_DC_EP_DATA_OUT) {
    29a0:	2d01      	cmp	r5, #1
    29a2:	d109      	bne.n	29b8 <usb_transfer_ep_callback+0x2c>
			 * so drain it).
			 */
			do {
				uint8_t data;

				usb_dc_ep_read_wait(ep, &data, 1, &bytes);
    29a4:	ab01      	add	r3, sp, #4
    29a6:	2201      	movs	r2, #1
    29a8:	f10d 0103 	add.w	r1, sp, #3
    29ac:	4630      	mov	r0, r6
    29ae:	f001 fc9f 	bl	42f0 <usb_dc_ep_read_wait>
			} while (bytes);
    29b2:	9b01      	ldr	r3, [sp, #4]
    29b4:	2b00      	cmp	r3, #0
    29b6:	d1f5      	bne.n	29a4 <usb_transfer_ep_callback+0x18>
		/* Read (out) needs to be done from ep_callback */
		usb_transfer_work(&trans->work);
	} else {
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
	}
}
    29b8:	b002      	add	sp, #8
    29ba:	bd70      	pop	{r4, r5, r6, pc}
	if (!k_is_in_isr() || (status == USB_DC_EP_DATA_OUT)) {
    29bc:	f006 fc4b 	bl	9256 <k_is_in_isr>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
    29c0:	f104 012c 	add.w	r1, r4, #44	; 0x2c
	if (!k_is_in_isr() || (status == USB_DC_EP_DATA_OUT)) {
    29c4:	b108      	cbz	r0, 29ca <usb_transfer_ep_callback+0x3e>
    29c6:	2d01      	cmp	r5, #1
    29c8:	d105      	bne.n	29d6 <usb_transfer_ep_callback+0x4a>
		usb_transfer_work(&trans->work);
    29ca:	4608      	mov	r0, r1
}
    29cc:	b002      	add	sp, #8
    29ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		usb_transfer_work(&trans->work);
    29d2:	f7ff bf53 	b.w	287c <usb_transfer_work>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
    29d6:	4803      	ldr	r0, [pc, #12]	; (29e4 <usb_transfer_ep_callback+0x58>)
}
    29d8:	b002      	add	sp, #8
    29da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
    29de:	f006 bcf9 	b.w	93d4 <k_work_submit_to_queue>
    29e2:	bf00      	nop
    29e4:	200002d8 	.word	0x200002d8

000029e8 <usb_transfer>:

int usb_transfer(uint8_t ep, uint8_t *data, size_t dlen, unsigned int flags,
		 usb_transfer_callback cb, void *cb_data)
{
    29e8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    29ec:	4606      	mov	r6, r0
    29ee:	9101      	str	r1, [sp, #4]
    29f0:	4615      	mov	r5, r2
    29f2:	4698      	mov	r8, r3
	struct usb_transfer_data *trans = NULL;
	int i, key, ret = 0;

	/* Parallel transfer to same endpoint is not supported. */
	if (usb_transfer_is_busy(ep)) {
    29f4:	f005 fe59 	bl	86aa <usb_transfer_is_busy>
    29f8:	4604      	mov	r4, r0
    29fa:	2800      	cmp	r0, #0
    29fc:	d15c      	bne.n	2ab8 <usb_transfer+0xd0>
    29fe:	f04f 0320 	mov.w	r3, #32
    2a02:	f3ef 8a11 	mrs	sl, BASEPRI
    2a06:	f383 8812 	msr	BASEPRI_MAX, r3
    2a0a:	f3bf 8f6f 	isb	sy
	LOG_DBG("Transfer start, ep 0x%02x, data %p, dlen %zd",
		ep, data, dlen);

	key = irq_lock();

	for (i = 0; i < ARRAY_SIZE(ut_data); i++) {
    2a0e:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 2ac0 <usb_transfer+0xd8>
		if (!k_sem_take(&ut_data[i].sem, K_NO_WAIT)) {
    2a12:	01a7      	lsls	r7, r4, #6
	return z_impl_k_sem_take(sem, timeout);
    2a14:	2200      	movs	r2, #0
    2a16:	2300      	movs	r3, #0
    2a18:	4658      	mov	r0, fp
    2a1a:	f004 fb69 	bl	70f0 <z_impl_k_sem_take>
    2a1e:	b968      	cbnz	r0, 2a3c <usb_transfer+0x54>
		LOG_ERR("No transfer slot available");
		ret = -ENOMEM;
		goto done;
	}

	if (trans->status == -EBUSY) {
    2a20:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 2ac4 <usb_transfer+0xdc>
    2a24:	eb09 0407 	add.w	r4, r9, r7
    2a28:	6863      	ldr	r3, [r4, #4]
    2a2a:	f113 0f10 	cmn.w	r3, #16
    2a2e:	d114      	bne.n	2a5a <usb_transfer+0x72>
    2a30:	9301      	str	r3, [sp, #4]
	z_impl_k_sem_give(sem);
    2a32:	4658      	mov	r0, fp
    2a34:	f004 fb3c 	bl	70b0 <z_impl_k_sem_give>
		/* A transfer is already ongoing and not completed */
		LOG_ERR("A transfer is already ongoing, ep 0x%02x", ep);
		k_sem_give(&trans->sem);
		ret = -EBUSY;
		goto done;
    2a38:	9b01      	ldr	r3, [sp, #4]
    2a3a:	e006      	b.n	2a4a <usb_transfer+0x62>
	for (i = 0; i < ARRAY_SIZE(ut_data); i++) {
    2a3c:	3401      	adds	r4, #1
    2a3e:	2c04      	cmp	r4, #4
    2a40:	f10b 0b40 	add.w	fp, fp, #64	; 0x40
    2a44:	d1e5      	bne.n	2a12 <usb_transfer+0x2a>
		ret = -ENOMEM;
    2a46:	f06f 030b 	mvn.w	r3, #11
	__asm__ volatile(
    2a4a:	f38a 8811 	msr	BASEPRI, sl
    2a4e:	f3bf 8f6f 	isb	sy
	}

done:
	irq_unlock(key);
	return ret;
}
    2a52:	4618      	mov	r0, r3
    2a54:	b003      	add	sp, #12
    2a56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	trans->buffer = data;
    2a5a:	9b01      	ldr	r3, [sp, #4]
	trans->tsize = 0;
    2a5c:	6120      	str	r0, [r4, #16]
	trans->bsize = dlen;
    2a5e:	e9c4 3502 	strd	r3, r5, [r4, #8]
	trans->cb = cb;
    2a62:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    2a64:	6163      	str	r3, [r4, #20]
	trans->priv = cb_data;
    2a66:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    2a68:	61a3      	str	r3, [r4, #24]
	trans->status = -EBUSY;
    2a6a:	f06f 030f 	mvn.w	r3, #15
	trans->flags = flags;
    2a6e:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
	trans->status = -EBUSY;
    2a72:	6063      	str	r3, [r4, #4]
	if (usb_dc_ep_mps(ep) && (dlen % usb_dc_ep_mps(ep))) {
    2a74:	4630      	mov	r0, r6
	trans->ep = ep;
    2a76:	f809 6007 	strb.w	r6, [r9, r7]
	if (usb_dc_ep_mps(ep) && (dlen % usb_dc_ep_mps(ep))) {
    2a7a:	f001 fcdd 	bl	4438 <usb_dc_ep_mps>
    2a7e:	b158      	cbz	r0, 2a98 <usb_transfer+0xb0>
    2a80:	4630      	mov	r0, r6
    2a82:	f001 fcd9 	bl	4438 <usb_dc_ep_mps>
    2a86:	fbb5 f2f0 	udiv	r2, r5, r0
    2a8a:	fb02 5510 	mls	r5, r2, r0, r5
    2a8e:	b11d      	cbz	r5, 2a98 <usb_transfer+0xb0>
		trans->flags |= USB_TRANS_NO_ZLP;
    2a90:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    2a92:	f043 0304 	orr.w	r3, r3, #4
    2a96:	63e3      	str	r3, [r4, #60]	; 0x3c
	if (flags & USB_TRANS_WRITE) {
    2a98:	f018 0f02 	tst.w	r8, #2
    2a9c:	d007      	beq.n	2aae <usb_transfer+0xc6>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
    2a9e:	372c      	adds	r7, #44	; 0x2c
    2aa0:	4809      	ldr	r0, [pc, #36]	; (2ac8 <usb_transfer+0xe0>)
    2aa2:	eb09 0107 	add.w	r1, r9, r7
    2aa6:	f006 fc95 	bl	93d4 <k_work_submit_to_queue>
	int i, key, ret = 0;
    2aaa:	2300      	movs	r3, #0
    2aac:	e7cd      	b.n	2a4a <usb_transfer+0x62>
		ret = usb_dc_ep_read_continue(ep);
    2aae:	4630      	mov	r0, r6
    2ab0:	f001 fc66 	bl	4380 <usb_dc_ep_read_continue>
    2ab4:	4603      	mov	r3, r0
    2ab6:	e7c8      	b.n	2a4a <usb_transfer+0x62>
		return -EBUSY;
    2ab8:	f06f 030f 	mvn.w	r3, #15
    2abc:	e7c9      	b.n	2a52 <usb_transfer+0x6a>
    2abe:	bf00      	nop
    2ac0:	200006a0 	.word	0x200006a0
    2ac4:	20000684 	.word	0x20000684
    2ac8:	200002d8 	.word	0x200002d8

00002acc <usb_cancel_transfer>:

void usb_cancel_transfer(uint8_t ep)
{
    2acc:	b510      	push	{r4, lr}
	__asm__ volatile(
    2ace:	f04f 0320 	mov.w	r3, #32
    2ad2:	f3ef 8411 	mrs	r4, BASEPRI
    2ad6:	f383 8812 	msr	BASEPRI_MAX, r3
    2ada:	f3bf 8f6f 	isb	sy
	struct usb_transfer_data *trans;
	unsigned int key;

	key = irq_lock();

	trans = usb_ep_get_transfer(ep);
    2ade:	f7ff feb7 	bl	2850 <usb_ep_get_transfer>
	if (!trans) {
    2ae2:	b150      	cbz	r0, 2afa <usb_cancel_transfer+0x2e>
		goto done;
	}

	if (trans->status != -EBUSY) {
    2ae4:	6843      	ldr	r3, [r0, #4]
    2ae6:	3310      	adds	r3, #16
    2ae8:	d107      	bne.n	2afa <usb_cancel_transfer+0x2e>
		goto done;
	}

	trans->status = -ECANCELED;
    2aea:	f06f 038b 	mvn.w	r3, #139	; 0x8b
    2aee:	6043      	str	r3, [r0, #4]
	k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
    2af0:	f100 012c 	add.w	r1, r0, #44	; 0x2c
    2af4:	4803      	ldr	r0, [pc, #12]	; (2b04 <usb_cancel_transfer+0x38>)
    2af6:	f006 fc6d 	bl	93d4 <k_work_submit_to_queue>
	__asm__ volatile(
    2afa:	f384 8811 	msr	BASEPRI, r4
    2afe:	f3bf 8f6f 	isb	sy

done:
	irq_unlock(key);
}
    2b02:	bd10      	pop	{r4, pc}
    2b04:	200002d8 	.word	0x200002d8

00002b08 <usb_cancel_transfers>:

void usb_cancel_transfers(void)
{
    2b08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2b0c:	4c10      	ldr	r4, [pc, #64]	; (2b50 <usb_cancel_transfers+0x48>)

		key = irq_lock();

		if (trans->status == -EBUSY) {
			trans->status = -ECANCELED;
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
    2b0e:	f8df 8044 	ldr.w	r8, [pc, #68]	; 2b54 <usb_cancel_transfers+0x4c>
{
    2b12:	2504      	movs	r5, #4
			trans->status = -ECANCELED;
    2b14:	f06f 078b 	mvn.w	r7, #139	; 0x8b
	__asm__ volatile(
    2b18:	f04f 0320 	mov.w	r3, #32
    2b1c:	f3ef 8611 	mrs	r6, BASEPRI
    2b20:	f383 8812 	msr	BASEPRI_MAX, r3
    2b24:	f3bf 8f6f 	isb	sy
		if (trans->status == -EBUSY) {
    2b28:	6863      	ldr	r3, [r4, #4]
    2b2a:	3310      	adds	r3, #16
    2b2c:	d105      	bne.n	2b3a <usb_cancel_transfers+0x32>
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
    2b2e:	f104 012c 	add.w	r1, r4, #44	; 0x2c
    2b32:	4640      	mov	r0, r8
			trans->status = -ECANCELED;
    2b34:	6067      	str	r7, [r4, #4]
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
    2b36:	f006 fc4d 	bl	93d4 <k_work_submit_to_queue>
	__asm__ volatile(
    2b3a:	f386 8811 	msr	BASEPRI, r6
    2b3e:	f3bf 8f6f 	isb	sy
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    2b42:	3d01      	subs	r5, #1
    2b44:	f104 0440 	add.w	r4, r4, #64	; 0x40
    2b48:	d1e6      	bne.n	2b18 <usb_cancel_transfers+0x10>
			LOG_DBG("Cancel transfer for ep: 0x%02x", trans->ep);
		}

		irq_unlock(key);
	}
}
    2b4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2b4e:	bf00      	nop
    2b50:	20000684 	.word	0x20000684
    2b54:	200002d8 	.word	0x200002d8

00002b58 <usb_transfer_init>:
	return pdata.tsize;
}

/* Init transfer slots */
int usb_transfer_init(void)
{
    2b58:	b570      	push	{r4, r5, r6, lr}
    2b5a:	4c0a      	ldr	r4, [pc, #40]	; (2b84 <usb_transfer_init+0x2c>)
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
		k_work_init(&ut_data[i].work, usb_transfer_work);
    2b5c:	4e0a      	ldr	r6, [pc, #40]	; (2b88 <usb_transfer_init+0x30>)
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    2b5e:	2500      	movs	r5, #0
		k_work_init(&ut_data[i].work, usb_transfer_work);
    2b60:	4631      	mov	r1, r6
    2b62:	4620      	mov	r0, r4
    2b64:	f006 fc2d 	bl	93c2 <k_work_init>
	return z_impl_k_sem_init(sem, initial_count, limit);
    2b68:	2201      	movs	r2, #1
    2b6a:	f1a4 0010 	sub.w	r0, r4, #16
    2b6e:	4611      	mov	r1, r2
	for (int i = 0; i < ARRAY_SIZE(ut_data); i++) {
    2b70:	3501      	adds	r5, #1
    2b72:	f006 fc08 	bl	9386 <z_impl_k_sem_init>
    2b76:	2d04      	cmp	r5, #4
    2b78:	f104 0440 	add.w	r4, r4, #64	; 0x40
    2b7c:	d1f0      	bne.n	2b60 <usb_transfer_init+0x8>
		k_sem_init(&ut_data[i].sem, 1, 1);
	}

	return 0;
}
    2b7e:	2000      	movs	r0, #0
    2b80:	bd70      	pop	{r4, r5, r6, pc}
    2b82:	bf00      	nop
    2b84:	200006b0 	.word	0x200006b0
    2b88:	0000287d 	.word	0x0000287d

00002b8c <cdc_acm_class_handle_req>:
 *
 * @return  0 on success, negative errno code on fail.
 */
int cdc_acm_class_handle_req(struct usb_setup_packet *setup,
			     int32_t *len, uint8_t **data)
{
    2b8c:	b570      	push	{r4, r5, r6, lr}
    2b8e:	4604      	mov	r4, r0
    2b90:	460e      	mov	r6, r1
	struct cdc_acm_dev_data_t *dev_data;
	struct usb_dev_data *common;
	uint32_t rate;
	uint32_t new_rate;

	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
    2b92:	7901      	ldrb	r1, [r0, #4]
    2b94:	4812      	ldr	r0, [pc, #72]	; (2be0 <cdc_acm_class_handle_req+0x54>)
{
    2b96:	4615      	mov	r5, r2
	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
    2b98:	f005 fd5c 	bl	8654 <usb_get_dev_data_by_iface>
					   (uint8_t)setup->wIndex);
	if (common == NULL) {
    2b9c:	b1e8      	cbz	r0, 2bda <cdc_acm_class_handle_req+0x4e>
		return -ENODEV;
	}

	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);

	if (usb_reqtype_is_to_device(setup)) {
    2b9e:	f994 2000 	ldrsb.w	r2, [r4]
		switch (setup->bRequest) {
    2ba2:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_device(setup)) {
    2ba4:	2a00      	cmp	r2, #0
    2ba6:	db11      	blt.n	2bcc <cdc_acm_class_handle_req+0x40>
		switch (setup->bRequest) {
    2ba8:	2b20      	cmp	r3, #32
    2baa:	d004      	beq.n	2bb6 <cdc_acm_class_handle_req+0x2a>
    2bac:	2b22      	cmp	r3, #34	; 0x22
    2bae:	d009      	beq.n	2bc4 <cdc_acm_class_handle_req+0x38>
		}
	}

	LOG_DBG("CDC ACM bmRequestType 0x%02x bRequest 0x%02x unsupported",
		setup->bmRequestType, setup->bRequest);
	return -ENOTSUP;
    2bb0:	f06f 0085 	mvn.w	r0, #133	; 0x85
    2bb4:	e005      	b.n	2bc2 <cdc_acm_class_handle_req+0x36>
			memcpy(&dev_data->line_coding, *data,
    2bb6:	6829      	ldr	r1, [r5, #0]
    2bb8:	2207      	movs	r2, #7
    2bba:	380c      	subs	r0, #12
    2bbc:	f005 fe7c 	bl	88b8 <memcpy>
			return 0;
    2bc0:	2000      	movs	r0, #0
}
    2bc2:	bd70      	pop	{r4, r5, r6, pc}
			dev_data->line_state = (uint8_t)setup->wValue;
    2bc4:	8863      	ldrh	r3, [r4, #2]
    2bc6:	f800 3c05 	strb.w	r3, [r0, #-5]
			return 0;
    2bca:	e7f9      	b.n	2bc0 <cdc_acm_class_handle_req+0x34>
		if (setup->bRequest == GET_LINE_CODING) {
    2bcc:	2b21      	cmp	r3, #33	; 0x21
    2bce:	d1ef      	bne.n	2bb0 <cdc_acm_class_handle_req+0x24>
			*data = (uint8_t *)(&dev_data->line_coding);
    2bd0:	380c      	subs	r0, #12
			*len = sizeof(dev_data->line_coding);
    2bd2:	2307      	movs	r3, #7
			*data = (uint8_t *)(&dev_data->line_coding);
    2bd4:	6028      	str	r0, [r5, #0]
			*len = sizeof(dev_data->line_coding);
    2bd6:	6033      	str	r3, [r6, #0]
    2bd8:	e7f2      	b.n	2bc0 <cdc_acm_class_handle_req+0x34>
		return -ENODEV;
    2bda:	f06f 0012 	mvn.w	r0, #18
    2bde:	e7f0      	b.n	2bc2 <cdc_acm_class_handle_req+0x36>
    2be0:	20000784 	.word	0x20000784

00002be4 <cdc_acm_int_in>:
 * @param ep_status Endpoint status code.
 *
 * @return  N/A.
 */
static void cdc_acm_int_in(uint8_t ep, enum usb_dc_ep_cb_status_code ep_status)
{
    2be4:	b508      	push	{r3, lr}
    2be6:	4601      	mov	r1, r0
	struct cdc_acm_dev_data_t *dev_data;
	struct usb_dev_data *common;

	ARG_UNUSED(ep_status);

	common = usb_get_dev_data_by_ep(&cdc_acm_data_devlist, ep);
    2be8:	4803      	ldr	r0, [pc, #12]	; (2bf8 <cdc_acm_int_in+0x14>)
    2bea:	f005 fd44 	bl	8676 <usb_get_dev_data_by_ep>
	if (common == NULL) {
    2bee:	b110      	cbz	r0, 2bf6 <cdc_acm_int_in+0x12>
		return;
	}

	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);

	dev_data->notification_sent = 1U;
    2bf0:	2301      	movs	r3, #1
    2bf2:	f800 3c03 	strb.w	r3, [r0, #-3]
	LOG_DBG("CDC_IntIN EP[%x]\r", ep);
}
    2bf6:	bd08      	pop	{r3, pc}
    2bf8:	20000784 	.word	0x20000784

00002bfc <cdc_acm_irq_rx_enable>:
 *
 * @return N/A
 */
static void cdc_acm_irq_rx_enable(const struct device *dev)
{
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    2bfc:	6901      	ldr	r1, [r0, #16]

	dev_data->rx_irq_ena = true;
    2bfe:	2301      	movs	r3, #1
    2c00:	f881 302b 	strb.w	r3, [r1, #43]	; 0x2b

	if (dev_data->cb && dev_data->rx_ready) {
    2c04:	680b      	ldr	r3, [r1, #0]
    2c06:	b133      	cbz	r3, 2c16 <cdc_acm_irq_rx_enable+0x1a>
    2c08:	f891 3029 	ldrb.w	r3, [r1, #41]	; 0x29
    2c0c:	b11b      	cbz	r3, 2c16 <cdc_acm_irq_rx_enable+0x1a>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
    2c0e:	4802      	ldr	r0, [pc, #8]	; (2c18 <cdc_acm_irq_rx_enable+0x1c>)
    2c10:	3108      	adds	r1, #8
    2c12:	f006 bbdf 	b.w	93d4 <k_work_submit_to_queue>
	}
}
    2c16:	4770      	bx	lr
    2c18:	200002d8 	.word	0x200002d8

00002c1c <cdc_acm_irq_tx_enable>:
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    2c1c:	6901      	ldr	r1, [r0, #16]
	dev_data->tx_irq_ena = true;
    2c1e:	2301      	movs	r3, #1
    2c20:	f881 302a 	strb.w	r3, [r1, #42]	; 0x2a
	if (dev_data->cb && dev_data->tx_ready) {
    2c24:	680b      	ldr	r3, [r1, #0]
    2c26:	b133      	cbz	r3, 2c36 <cdc_acm_irq_tx_enable+0x1a>
    2c28:	f891 3028 	ldrb.w	r3, [r1, #40]	; 0x28
    2c2c:	b11b      	cbz	r3, 2c36 <cdc_acm_irq_tx_enable+0x1a>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
    2c2e:	4802      	ldr	r0, [pc, #8]	; (2c38 <cdc_acm_irq_tx_enable+0x1c>)
    2c30:	3108      	adds	r1, #8
    2c32:	f006 bbcf 	b.w	93d4 <k_work_submit_to_queue>
}
    2c36:	4770      	bx	lr
    2c38:	200002d8 	.word	0x200002d8

00002c3c <cdc_acm_reset_port>:
	dev_data->line_coding = (struct cdc_acm_line_coding)
    2c3c:	4a0b      	ldr	r2, [pc, #44]	; (2c6c <cdc_acm_reset_port+0x30>)
{
    2c3e:	4603      	mov	r3, r0
	dev_data->configured = false;
    2c40:	2100      	movs	r1, #0
    2c42:	f8a0 107e 	strh.w	r1, [r0, #126]	; 0x7e
	dev_data->tx_ready = false;
    2c46:	8501      	strh	r1, [r0, #40]	; 0x28
	dev_data->line_coding = (struct cdc_acm_line_coding)
    2c48:	6810      	ldr	r0, [r2, #0]
    2c4a:	6758      	str	r0, [r3, #116]	; 0x74
    2c4c:	8890      	ldrh	r0, [r2, #4]
    2c4e:	7992      	ldrb	r2, [r2, #6]
    2c50:	f8a3 0078 	strh.w	r0, [r3, #120]	; 0x78
    2c54:	f883 207a 	strb.w	r2, [r3, #122]	; 0x7a
	dev_data->serial_state = 0;
    2c58:	f883 107c 	strb.w	r1, [r3, #124]	; 0x7c
	dev_data->line_state = 0;
    2c5c:	f883 107b 	strb.w	r1, [r3, #123]	; 0x7b
	memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
    2c60:	2240      	movs	r2, #64	; 0x40
    2c62:	f103 002c 	add.w	r0, r3, #44	; 0x2c
    2c66:	f005 be32 	b.w	88ce <memset>
    2c6a:	bf00      	nop
    2c6c:	00009a30 	.word	0x00009a30

00002c70 <cdc_acm_fifo_fill>:
{
    2c70:	b538      	push	{r3, r4, r5, lr}
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    2c72:	6905      	ldr	r5, [r0, #16]
	if (!dev_data->configured || dev_data->suspended) {
    2c74:	f895 007e 	ldrb.w	r0, [r5, #126]	; 0x7e
    2c78:	b170      	cbz	r0, 2c98 <cdc_acm_fifo_fill+0x28>
    2c7a:	f895 307f 	ldrb.w	r3, [r5, #127]	; 0x7f
    2c7e:	b963      	cbnz	r3, 2c9a <cdc_acm_fifo_fill+0x2a>
	dev_data->tx_ready = false;
    2c80:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
	wrote = ring_buf_put(dev_data->tx_ringbuf, tx_data, len);
    2c84:	6f28      	ldr	r0, [r5, #112]	; 0x70
    2c86:	f005 fc38 	bl	84fa <ring_buf_put>
	k_work_submit_to_queue(&USB_WORK_Q, &dev_data->tx_work);
    2c8a:	f105 0118 	add.w	r1, r5, #24
	wrote = ring_buf_put(dev_data->tx_ringbuf, tx_data, len);
    2c8e:	4604      	mov	r4, r0
	k_work_submit_to_queue(&USB_WORK_Q, &dev_data->tx_work);
    2c90:	4803      	ldr	r0, [pc, #12]	; (2ca0 <cdc_acm_fifo_fill+0x30>)
    2c92:	f006 fb9f 	bl	93d4 <k_work_submit_to_queue>
	return wrote;
    2c96:	4620      	mov	r0, r4
}
    2c98:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
    2c9a:	2000      	movs	r0, #0
    2c9c:	e7fc      	b.n	2c98 <cdc_acm_fifo_fill+0x28>
    2c9e:	bf00      	nop
    2ca0:	200002d8 	.word	0x200002d8

00002ca4 <cdc_acm_read_cb>:
{
    2ca4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2ca6:	4614      	mov	r4, r2
	wrote = ring_buf_put(dev_data->rx_ringbuf, dev_data->rx_buf, size);
    2ca8:	f102 062c 	add.w	r6, r2, #44	; 0x2c
	if (size <= 0) {
    2cac:	1e0a      	subs	r2, r1, #0
{
    2cae:	4605      	mov	r5, r0
	if (size <= 0) {
    2cb0:	dd10      	ble.n	2cd4 <cdc_acm_read_cb+0x30>
	wrote = ring_buf_put(dev_data->rx_ringbuf, dev_data->rx_buf, size);
    2cb2:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    2cb4:	4631      	mov	r1, r6
    2cb6:	f005 fc20 	bl	84fa <ring_buf_put>
	dev_data->rx_ready = true;
    2cba:	2301      	movs	r3, #1
    2cbc:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
	if (dev_data->cb && dev_data->rx_irq_ena) {
    2cc0:	6823      	ldr	r3, [r4, #0]
    2cc2:	b13b      	cbz	r3, 2cd4 <cdc_acm_read_cb+0x30>
    2cc4:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
    2cc8:	b123      	cbz	r3, 2cd4 <cdc_acm_read_cb+0x30>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
    2cca:	4808      	ldr	r0, [pc, #32]	; (2cec <cdc_acm_read_cb+0x48>)
    2ccc:	f104 0108 	add.w	r1, r4, #8
    2cd0:	f006 fb80 	bl	93d4 <k_work_submit_to_queue>
	usb_transfer(ep, dev_data->rx_buf, sizeof(dev_data->rx_buf),
    2cd4:	4b06      	ldr	r3, [pc, #24]	; (2cf0 <cdc_acm_read_cb+0x4c>)
    2cd6:	9300      	str	r3, [sp, #0]
    2cd8:	9401      	str	r4, [sp, #4]
    2cda:	2301      	movs	r3, #1
    2cdc:	2240      	movs	r2, #64	; 0x40
    2cde:	4631      	mov	r1, r6
    2ce0:	4628      	mov	r0, r5
    2ce2:	f7ff fe81 	bl	29e8 <usb_transfer>
}
    2ce6:	b002      	add	sp, #8
    2ce8:	bd70      	pop	{r4, r5, r6, pc}
    2cea:	bf00      	nop
    2cec:	200002d8 	.word	0x200002d8
    2cf0:	00002ca5 	.word	0x00002ca5

00002cf4 <cdc_acm_poll_out>:
 * is not ready, no data is transferred to the buffer, that is, c is dropped.
 * If the USB subsystem is ready and the buffer is full, the first character
 * from the tx_ringbuf is removed to make room for the new character.
 */
static void cdc_acm_poll_out(const struct device *dev, unsigned char c)
{
    2cf4:	b513      	push	{r0, r1, r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
    2cf6:	6904      	ldr	r4, [r0, #16]
{
    2cf8:	f88d 1007 	strb.w	r1, [sp, #7]

	if (!dev_data->configured || dev_data->suspended) {
    2cfc:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
    2d00:	b18b      	cbz	r3, 2d26 <cdc_acm_poll_out+0x32>
    2d02:	f894 307f 	ldrb.w	r3, [r4, #127]	; 0x7f
    2d06:	b973      	cbnz	r3, 2d26 <cdc_acm_poll_out+0x32>
		return;
	}

	dev_data->tx_ready = false;

	if (!ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
    2d08:	f10d 0107 	add.w	r1, sp, #7
    2d0c:	6f20      	ldr	r0, [r4, #112]	; 0x70
	dev_data->tx_ready = false;
    2d0e:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	if (!ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
    2d12:	2201      	movs	r2, #1
    2d14:	f005 fbf1 	bl	84fa <ring_buf_put>
    2d18:	4601      	mov	r1, r0
    2d1a:	b130      	cbz	r0, 2d2a <cdc_acm_poll_out+0x36>
			LOG_ERR("Failed to drain buffer");
			return;
		}
	}

	k_work_submit_to_queue(&USB_WORK_Q, &dev_data->tx_work);
    2d1c:	480a      	ldr	r0, [pc, #40]	; (2d48 <cdc_acm_poll_out+0x54>)
    2d1e:	f104 0118 	add.w	r1, r4, #24
    2d22:	f006 fb57 	bl	93d4 <k_work_submit_to_queue>
}
    2d26:	b002      	add	sp, #8
    2d28:	bd10      	pop	{r4, pc}
		if (!ring_buf_get(dev_data->tx_ringbuf, NULL, 1) ||
    2d2a:	6f20      	ldr	r0, [r4, #112]	; 0x70
    2d2c:	2201      	movs	r2, #1
    2d2e:	f005 fc49 	bl	85c4 <ring_buf_get>
    2d32:	2800      	cmp	r0, #0
    2d34:	d0f7      	beq.n	2d26 <cdc_acm_poll_out+0x32>
		    !ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
    2d36:	6f20      	ldr	r0, [r4, #112]	; 0x70
    2d38:	2201      	movs	r2, #1
    2d3a:	f10d 0107 	add.w	r1, sp, #7
    2d3e:	f005 fbdc 	bl	84fa <ring_buf_put>
		if (!ring_buf_get(dev_data->tx_ringbuf, NULL, 1) ||
    2d42:	2800      	cmp	r0, #0
    2d44:	d1ea      	bne.n	2d1c <cdc_acm_poll_out+0x28>
    2d46:	e7ee      	b.n	2d26 <cdc_acm_poll_out+0x32>
    2d48:	200002d8 	.word	0x200002d8

00002d4c <cdc_acm_write_cb>:
	dev_data->tx_ready = true;
    2d4c:	2301      	movs	r3, #1
    2d4e:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
	if (dev_data->cb && dev_data->tx_irq_ena) {
    2d52:	6813      	ldr	r3, [r2, #0]
{
    2d54:	b510      	push	{r4, lr}
    2d56:	4614      	mov	r4, r2
	if (dev_data->cb && dev_data->tx_irq_ena) {
    2d58:	b13b      	cbz	r3, 2d6a <cdc_acm_write_cb+0x1e>
    2d5a:	f892 302a 	ldrb.w	r3, [r2, #42]	; 0x2a
    2d5e:	b123      	cbz	r3, 2d6a <cdc_acm_write_cb+0x1e>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
    2d60:	4808      	ldr	r0, [pc, #32]	; (2d84 <cdc_acm_write_cb+0x38>)
    2d62:	f102 0108 	add.w	r1, r2, #8
    2d66:	f006 fb35 	bl	93d4 <k_work_submit_to_queue>
	if (ring_buf_is_empty(dev_data->tx_ringbuf)) {
    2d6a:	6f20      	ldr	r0, [r4, #112]	; 0x70
    2d6c:	f005 fb7f 	bl	846e <ring_buf_is_empty>
    2d70:	b930      	cbnz	r0, 2d80 <cdc_acm_write_cb+0x34>
	k_work_submit_to_queue(&USB_WORK_Q, &dev_data->tx_work);
    2d72:	f104 0118 	add.w	r1, r4, #24
    2d76:	4803      	ldr	r0, [pc, #12]	; (2d84 <cdc_acm_write_cb+0x38>)
}
    2d78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_work_submit_to_queue(&USB_WORK_Q, &dev_data->tx_work);
    2d7c:	f006 bb2a 	b.w	93d4 <k_work_submit_to_queue>
}
    2d80:	bd10      	pop	{r4, pc}
    2d82:	bf00      	nop
    2d84:	200002d8 	.word	0x200002d8

00002d88 <tx_work_handler>:
{
    2d88:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct usb_cfg_data *cfg = (void *)dev->config;
    2d8a:	6e83      	ldr	r3, [r0, #104]	; 0x68
	uint8_t ep = cfg->endpoint[ACM_IN_EP_IDX].ep_addr;
    2d8c:	685b      	ldr	r3, [r3, #4]
    2d8e:	6a1b      	ldr	r3, [r3, #32]
    2d90:	7d1e      	ldrb	r6, [r3, #20]
{
    2d92:	4605      	mov	r5, r0
	if (usb_transfer_is_busy(ep)) {
    2d94:	4630      	mov	r0, r6
    2d96:	f005 fc88 	bl	86aa <usb_transfer_is_busy>
    2d9a:	b9d0      	cbnz	r0, 2dd2 <tx_work_handler+0x4a>
	len = ring_buf_get_claim(dev_data->tx_ringbuf, &data,
    2d9c:	6da8      	ldr	r0, [r5, #88]	; 0x58
    2d9e:	f44f 6280 	mov.w	r2, #1024	; 0x400
    2da2:	a903      	add	r1, sp, #12
    2da4:	f005 fbc8 	bl	8538 <ring_buf_get_claim>
	if (!len) {
    2da8:	4604      	mov	r4, r0
    2daa:	b190      	cbz	r0, 2dd2 <tx_work_handler+0x4a>
	if (!(len % CONFIG_CDC_ACM_BULK_EP_MPS)) {
    2dac:	0683      	lsls	r3, r0, #26
	struct cdc_acm_dev_data_t *dev_data =
    2dae:	f1a5 0318 	sub.w	r3, r5, #24
		len -= 1;
    2db2:	bf08      	it	eq
    2db4:	f100 34ff 	addeq.w	r4, r0, #4294967295	; 0xffffffff
	usb_transfer(ep, data, len, USB_TRANS_WRITE,
    2db8:	9301      	str	r3, [sp, #4]
    2dba:	4b07      	ldr	r3, [pc, #28]	; (2dd8 <tx_work_handler+0x50>)
    2dbc:	9903      	ldr	r1, [sp, #12]
    2dbe:	9300      	str	r3, [sp, #0]
    2dc0:	4622      	mov	r2, r4
    2dc2:	2302      	movs	r3, #2
    2dc4:	4630      	mov	r0, r6
    2dc6:	f7ff fe0f 	bl	29e8 <usb_transfer>
	ring_buf_get_finish(dev_data->tx_ringbuf, len);
    2dca:	6da8      	ldr	r0, [r5, #88]	; 0x58
    2dcc:	4621      	mov	r1, r4
    2dce:	f005 fbdd 	bl	858c <ring_buf_get_finish>
}
    2dd2:	b004      	add	sp, #16
    2dd4:	bd70      	pop	{r4, r5, r6, pc}
    2dd6:	bf00      	nop
    2dd8:	00002d4d 	.word	0x00002d4d

00002ddc <cdc_acm_dev_status_cb>:
{
    2ddc:	b538      	push	{r3, r4, r5, lr}
    2dde:	460d      	mov	r5, r1
	common = usb_get_dev_data_by_cfg(&cdc_acm_data_devlist, cfg);
    2de0:	4601      	mov	r1, r0
    2de2:	4824      	ldr	r0, [pc, #144]	; (2e74 <cdc_acm_dev_status_cb+0x98>)
    2de4:	f005 fc27 	bl	8636 <usb_get_dev_data_by_cfg>
	if (common == NULL) {
    2de8:	4604      	mov	r4, r0
    2dea:	b380      	cbz	r0, 2e4e <cdc_acm_dev_status_cb+0x72>
	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);
    2dec:	4602      	mov	r2, r0
	switch (status) {
    2dee:	1e69      	subs	r1, r5, #1
	struct usb_cfg_data *cfg = (void *)dev->config;
    2df0:	f852 3980 	ldr.w	r3, [r2], #-128
    2df4:	685b      	ldr	r3, [r3, #4]
	switch (status) {
    2df6:	2905      	cmp	r1, #5
    2df8:	d829      	bhi.n	2e4e <cdc_acm_dev_status_cb+0x72>
    2dfa:	e8df f001 	tbb	[pc, r1]
    2dfe:	2820      	.short	0x2820
    2e00:	29252003 	.word	0x29252003
		if (!dev_data->configured) {
    2e04:	f814 1c02 	ldrb.w	r1, [r4, #-2]
    2e08:	b931      	cbnz	r1, 2e18 <cdc_acm_dev_status_cb+0x3c>
			cdc_acm_read_cb(cfg->endpoint[ACM_OUT_EP_IDX].ep_addr, 0,
    2e0a:	6a1b      	ldr	r3, [r3, #32]
    2e0c:	7b18      	ldrb	r0, [r3, #12]
    2e0e:	f7ff ff49 	bl	2ca4 <cdc_acm_read_cb>
			dev_data->configured = true;
    2e12:	2301      	movs	r3, #1
    2e14:	f804 3c02 	strb.w	r3, [r4, #-2]
		if (!dev_data->tx_ready) {
    2e18:	f814 3c58 	ldrb.w	r3, [r4, #-88]
    2e1c:	b9bb      	cbnz	r3, 2e4e <cdc_acm_dev_status_cb+0x72>
			dev_data->tx_ready = true;
    2e1e:	2301      	movs	r3, #1
    2e20:	f804 3c58 	strb.w	r3, [r4, #-88]
			if (dev_data->cb != NULL && dev_data->tx_irq_ena) {
    2e24:	f854 3c80 	ldr.w	r3, [r4, #-128]
    2e28:	b18b      	cbz	r3, 2e4e <cdc_acm_dev_status_cb+0x72>
    2e2a:	f814 3c56 	ldrb.w	r3, [r4, #-86]
    2e2e:	b173      	cbz	r3, 2e4e <cdc_acm_dev_status_cb+0x72>
				k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
    2e30:	f1a4 0178 	sub.w	r1, r4, #120	; 0x78
    2e34:	4810      	ldr	r0, [pc, #64]	; (2e78 <cdc_acm_dev_status_cb+0x9c>)
}
    2e36:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
    2e3a:	f006 bacb 	b.w	93d4 <k_work_submit_to_queue>
}
    2e3e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		cdc_acm_reset_port(dev_data);
    2e42:	4610      	mov	r0, r2
    2e44:	f7ff befa 	b.w	2c3c <cdc_acm_reset_port>
		dev_data->suspended = true;
    2e48:	2301      	movs	r3, #1
    2e4a:	f804 3c01 	strb.w	r3, [r4, #-1]
}
    2e4e:	bd38      	pop	{r3, r4, r5, pc}
		if (dev_data->suspended) {
    2e50:	f814 1c01 	ldrb.w	r1, [r4, #-1]
    2e54:	2900      	cmp	r1, #0
    2e56:	d0fa      	beq.n	2e4e <cdc_acm_dev_status_cb+0x72>
			if (dev_data->configured) {
    2e58:	f814 0c02 	ldrb.w	r0, [r4, #-2]
			dev_data->suspended = false;
    2e5c:	2100      	movs	r1, #0
    2e5e:	f804 1c01 	strb.w	r1, [r4, #-1]
			if (dev_data->configured) {
    2e62:	2800      	cmp	r0, #0
    2e64:	d0f3      	beq.n	2e4e <cdc_acm_dev_status_cb+0x72>
				cdc_acm_read_cb(cfg->endpoint[ACM_OUT_EP_IDX].ep_addr,
    2e66:	6a1b      	ldr	r3, [r3, #32]
    2e68:	7b18      	ldrb	r0, [r3, #12]
}
    2e6a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				cdc_acm_read_cb(cfg->endpoint[ACM_OUT_EP_IDX].ep_addr,
    2e6e:	f7ff bf19 	b.w	2ca4 <cdc_acm_read_cb>
    2e72:	bf00      	nop
    2e74:	20000784 	.word	0x20000784
    2e78:	200002d8 	.word	0x200002d8

00002e7c <cdc_acm_init>:
{
    2e7c:	b510      	push	{r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    2e7e:	6904      	ldr	r4, [r0, #16]
	parent->next = child;
    2e80:	2300      	movs	r3, #0
    2e82:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
    2e86:	4b0c      	ldr	r3, [pc, #48]	; (2eb8 <cdc_acm_init+0x3c>)
	dev_data->common.dev = dev;
    2e88:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
    2e8c:	6859      	ldr	r1, [r3, #4]
	sys_slist_append(&cdc_acm_data_devlist, &dev_data->common.node);
    2e8e:	f104 0284 	add.w	r2, r4, #132	; 0x84
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    2e92:	b969      	cbnz	r1, 2eb0 <cdc_acm_init+0x34>
	list->head = node;
    2e94:	e9c3 2200 	strd	r2, r2, [r3]
	k_work_init(&dev_data->cb_work, cdc_acm_irq_callback_work_handler);
    2e98:	f104 0008 	add.w	r0, r4, #8
    2e9c:	4907      	ldr	r1, [pc, #28]	; (2ebc <cdc_acm_init+0x40>)
    2e9e:	f006 fa90 	bl	93c2 <k_work_init>
	k_work_init(&dev_data->tx_work, tx_work_handler);
    2ea2:	f104 0018 	add.w	r0, r4, #24
    2ea6:	4906      	ldr	r1, [pc, #24]	; (2ec0 <cdc_acm_init+0x44>)
    2ea8:	f006 fa8b 	bl	93c2 <k_work_init>
}
    2eac:	2000      	movs	r0, #0
    2eae:	bd10      	pop	{r4, pc}
	parent->next = child;
    2eb0:	600a      	str	r2, [r1, #0]
	list->tail = node;
    2eb2:	605a      	str	r2, [r3, #4]
}
    2eb4:	e7f0      	b.n	2e98 <cdc_acm_init+0x1c>
    2eb6:	bf00      	nop
    2eb8:	20000784 	.word	0x20000784
    2ebc:	000086d5 	.word	0x000086d5
    2ec0:	00002d89 	.word	0x00002d89

00002ec4 <cdc_acm_send_notification.isra.0>:
static int cdc_acm_send_notification(const struct device *dev,
    2ec4:	b530      	push	{r4, r5, lr}
    2ec6:	b085      	sub	sp, #20
	notification.bmRequestType = 0xA1;
    2ec8:	23a1      	movs	r3, #161	; 0xa1
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    2eca:	6905      	ldr	r5, [r0, #16]
	notification.bmRequestType = 0xA1;
    2ecc:	f88d 3004 	strb.w	r3, [sp, #4]
	notification.bNotificationType = 0x20;
    2ed0:	2320      	movs	r3, #32
	struct usb_cfg_data * const cfg = (void *)dev->config;
    2ed2:	6842      	ldr	r2, [r0, #4]
	notification.bNotificationType = 0x20;
    2ed4:	f88d 3005 	strb.w	r3, [sp, #5]
	notification.wValue = 0U;
    2ed8:	2300      	movs	r3, #0
	dev_data->notification_sent = 0U;
    2eda:	f885 307d 	strb.w	r3, [r5, #125]	; 0x7d
	notification.wLength = sys_cpu_to_le16(sizeof(serial_state));
    2ede:	2002      	movs	r0, #2
    2ee0:	f8ad 000a 	strh.w	r0, [sp, #10]
	usb_write(cfg->endpoint[ACM_INT_EP_IDX].ep_addr,
    2ee4:	6a10      	ldr	r0, [r2, #32]
	notification.data = sys_cpu_to_le16(serial_state);
    2ee6:	f8ad 100c 	strh.w	r1, [sp, #12]
	notification.wIndex = 0U;
    2eea:	f8ad 3008 	strh.w	r3, [sp, #8]
	usb_write(cfg->endpoint[ACM_INT_EP_IDX].ep_addr,
    2eee:	7900      	ldrb	r0, [r0, #4]
	notification.wValue = 0U;
    2ef0:	f8ad 3006 	strh.w	r3, [sp, #6]
	usb_write(cfg->endpoint[ACM_INT_EP_IDX].ep_addr,
    2ef4:	220a      	movs	r2, #10
    2ef6:	a901      	add	r1, sp, #4
    2ef8:	f005 fb85 	bl	8606 <usb_write>
	while (!((volatile uint8_t)dev_data->notification_sent)) {
    2efc:	4c05      	ldr	r4, [pc, #20]	; (2f14 <cdc_acm_send_notification.isra.0+0x50>)
    2efe:	f895 307d 	ldrb.w	r3, [r5, #125]	; 0x7d
    2f02:	b923      	cbnz	r3, 2f0e <cdc_acm_send_notification.isra.0+0x4a>
	z_impl_k_busy_wait(usec_to_wait);
    2f04:	2001      	movs	r0, #1
    2f06:	f006 fba9 	bl	965c <z_impl_k_busy_wait>
		if (++cnt > CDC_CONTROL_SERIAL_STATE_TIMEOUT_US) {
    2f0a:	3c01      	subs	r4, #1
    2f0c:	d1f7      	bne.n	2efe <cdc_acm_send_notification.isra.0+0x3a>
}
    2f0e:	b005      	add	sp, #20
    2f10:	bd30      	pop	{r4, r5, pc}
    2f12:	bf00      	nop
    2f14:	000186a1 	.word	0x000186a1

00002f18 <z_usb_work_q_init>:
K_KERNEL_STACK_DEFINE(z_usb_work_q_stack, CONFIG_USB_WORKQUEUE_STACK_SIZE);

struct k_work_q z_usb_work_q;

static int z_usb_work_q_init(const struct device *dev)
{
    2f18:	b537      	push	{r0, r1, r2, r4, r5, lr}
	ARG_UNUSED(dev);

	k_work_queue_start(&z_usb_work_q,
    2f1a:	4d09      	ldr	r5, [pc, #36]	; (2f40 <z_usb_work_q_init+0x28>)
    2f1c:	4909      	ldr	r1, [pc, #36]	; (2f44 <z_usb_work_q_init+0x2c>)
    2f1e:	2400      	movs	r4, #0
    2f20:	9400      	str	r4, [sp, #0]
    2f22:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2f26:	f44f 6280 	mov.w	r2, #1024	; 0x400
    2f2a:	4628      	mov	r0, r5
    2f2c:	f004 f9ee 	bl	730c <k_work_queue_start>
	return z_impl_k_thread_name_set(thread, str);
    2f30:	4905      	ldr	r1, [pc, #20]	; (2f48 <z_usb_work_q_init+0x30>)
    2f32:	4628      	mov	r0, r5
    2f34:	f006 f995 	bl	9262 <z_impl_k_thread_name_set>
			   K_KERNEL_STACK_SIZEOF(z_usb_work_q_stack),
			   CONFIG_USB_WORKQUEUE_PRIORITY, NULL);
	k_thread_name_set(&z_usb_work_q.thread, "usbworkq");

	return 0;
}
    2f38:	4620      	mov	r0, r4
    2f3a:	b003      	add	sp, #12
    2f3c:	bd30      	pop	{r4, r5, pc}
    2f3e:	bf00      	nop
    2f40:	200002d8 	.word	0x200002d8
    2f44:	200013c0 	.word	0x200013c0
    2f48:	00009ca1 	.word	0x00009ca1

00002f4c <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
    2f4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2f50:	4605      	mov	r5, r0
	__asm__ volatile(
    2f52:	f04f 0320 	mov.w	r3, #32
    2f56:	f3ef 8611 	mrs	r6, BASEPRI
    2f5a:	f383 8812 	msr	BASEPRI_MAX, r3
    2f5e:	f3bf 8f6f 	isb	sy
	return list->head;
    2f62:	4b0e      	ldr	r3, [pc, #56]	; (2f9c <pm_state_notify+0x50>)
    2f64:	681c      	ldr	r4, [r3, #0]
	struct pm_notifier *notifier;
	k_spinlock_key_t pm_notifier_key;
	void (*callback)(enum pm_state state);

	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    2f66:	b19c      	cbz	r4, 2f90 <pm_state_notify+0x44>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_power_states[_current_cpu->id].state);
    2f68:	4f0d      	ldr	r7, [pc, #52]	; (2fa0 <pm_state_notify+0x54>)
    2f6a:	f8df 8038 	ldr.w	r8, [pc, #56]	; 2fa4 <pm_state_notify+0x58>
    2f6e:	f04f 090c 	mov.w	r9, #12
			callback = notifier->state_exit;
    2f72:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
    2f76:	2d00      	cmp	r5, #0
    2f78:	bf08      	it	eq
    2f7a:	4613      	moveq	r3, r2
		if (callback) {
    2f7c:	b12b      	cbz	r3, 2f8a <pm_state_notify+0x3e>
			callback(z_power_states[_current_cpu->id].state);
    2f7e:	f898 2014 	ldrb.w	r2, [r8, #20]
    2f82:	fb09 f202 	mul.w	r2, r9, r2
    2f86:	5cb8      	ldrb	r0, [r7, r2]
    2f88:	4798      	blx	r3
	return node->next;
    2f8a:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    2f8c:	2c00      	cmp	r4, #0
    2f8e:	d1f0      	bne.n	2f72 <pm_state_notify+0x26>
	__asm__ volatile(
    2f90:	f386 8811 	msr	BASEPRI, r6
    2f94:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
    2f98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2f9c:	2000078c 	.word	0x2000078c
    2fa0:	20000798 	.word	0x20000798
    2fa4:	20001330 	.word	0x20001330

00002fa8 <atomic_test_and_set_bit.constprop.0>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    2fa8:	f000 031f 	and.w	r3, r0, #31
    2fac:	2201      	movs	r2, #1
    2fae:	409a      	lsls	r2, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    2fb0:	4b0a      	ldr	r3, [pc, #40]	; (2fdc <atomic_test_and_set_bit.constprop.0+0x34>)
    2fb2:	f3bf 8f5b 	dmb	ish
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    2fb6:	0940      	lsrs	r0, r0, #5
    2fb8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    2fbc:	e850 3f00 	ldrex	r3, [r0]
    2fc0:	ea43 0102 	orr.w	r1, r3, r2
    2fc4:	e840 1c00 	strex	ip, r1, [r0]
    2fc8:	f1bc 0f00 	cmp.w	ip, #0
    2fcc:	d1f6      	bne.n	2fbc <atomic_test_and_set_bit.constprop.0+0x14>
    2fce:	f3bf 8f5b 	dmb	ish

	return (old & mask) != 0;
    2fd2:	421a      	tst	r2, r3
}
    2fd4:	bf14      	ite	ne
    2fd6:	2001      	movne	r0, #1
    2fd8:	2000      	moveq	r0, #0
    2fda:	4770      	bx	lr
    2fdc:	200007a4 	.word	0x200007a4

00002fe0 <pm_system_resume>:

void pm_system_resume(void)
{
    2fe0:	b530      	push	{r4, r5, lr}
	uint8_t id = _current_cpu->id;
    2fe2:	4b1d      	ldr	r3, [pc, #116]	; (3058 <CONFIG_USB_DEVICE_VID+0x75>)
    2fe4:	7d1c      	ldrb	r4, [r3, #20]
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    2fe6:	f3bf 8f5b 	dmb	ish
	atomic_val_t mask = ATOMIC_MASK(bit);
    2fea:	f004 031f 	and.w	r3, r4, #31
    2fee:	2201      	movs	r2, #1
    2ff0:	409a      	lsls	r2, r3
    2ff2:	4b1a      	ldr	r3, [pc, #104]	; (305c <CONFIG_USB_DEVICE_VID+0x79>)
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    2ff4:	0961      	lsrs	r1, r4, #5
{
    2ff6:	b085      	sub	sp, #20
    2ff8:	43d0      	mvns	r0, r2
    2ffa:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    2ffe:	e853 1f00 	ldrex	r1, [r3]
    3002:	ea01 0500 	and.w	r5, r1, r0
    3006:	e843 5c00 	strex	ip, r5, [r3]
    300a:	f1bc 0f00 	cmp.w	ip, #0
    300e:	d1f6      	bne.n	2ffe <CONFIG_USB_DEVICE_VID+0x1b>
    3010:	f3bf 8f5b 	dmb	ish
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
    3014:	4211      	tst	r1, r2
    3016:	d017      	beq.n	3048 <CONFIG_USB_DEVICE_VID+0x65>
		exit_pos_ops(z_power_states[id]);
    3018:	4d11      	ldr	r5, [pc, #68]	; (3060 <CONFIG_USB_DEVICE_VID+0x7d>)
    301a:	220c      	movs	r2, #12
    301c:	fb02 5204 	mla	r2, r2, r4, r5
    3020:	ca07      	ldmia	r2, {r0, r1, r2}
    3022:	ab01      	add	r3, sp, #4
    3024:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
    3028:	4a0e      	ldr	r2, [pc, #56]	; (3064 <CONFIG_USB_DEVICE_VID+0x81>)
    302a:	b17a      	cbz	r2, 304c <CONFIG_USB_DEVICE_VID+0x69>
		pm_power_state_exit_post_ops(info);
    302c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    3030:	f005 fc6c 	bl	890c <pm_power_state_exit_post_ops>
		pm_state_notify(false);
    3034:	2000      	movs	r0, #0
    3036:	f7ff ff89 	bl	2f4c <pm_state_notify>
		z_power_states[id] = (struct pm_state_info){PM_STATE_ACTIVE,
    303a:	230c      	movs	r3, #12
    303c:	435c      	muls	r4, r3
    303e:	192a      	adds	r2, r5, r4
    3040:	2300      	movs	r3, #0
    3042:	512b      	str	r3, [r5, r4]
    3044:	e9c2 3301 	strd	r3, r3, [r2, #4]
			0, 0};
	}
}
    3048:	b005      	add	sp, #20
    304a:	bd30      	pop	{r4, r5, pc}
    304c:	f382 8811 	msr	BASEPRI, r2
    3050:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    3054:	e7ee      	b.n	3034 <CONFIG_USB_DEVICE_VID+0x51>
    3056:	bf00      	nop
    3058:	20001330 	.word	0x20001330
    305c:	20000794 	.word	0x20000794
    3060:	20000798 	.word	0x20000798
    3064:	0000890d 	.word	0x0000890d

00003068 <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
    3068:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool ret = true;
	uint8_t id = _current_cpu->id;
    306c:	4b37      	ldr	r3, [pc, #220]	; (314c <pm_system_suspend+0xe4>)
    306e:	4c38      	ldr	r4, [pc, #224]	; (3150 <pm_system_suspend+0xe8>)
    3070:	7d1d      	ldrb	r5, [r3, #20]
{
    3072:	b088      	sub	sp, #32
    3074:	4680      	mov	r8, r0

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_and_set_bit(z_power_states_forced, id)) {
    3076:	4628      	mov	r0, r5
    3078:	f7ff ff96 	bl	2fa8 <atomic_test_and_set_bit.constprop.0>
    307c:	b960      	cbnz	r0, 3098 <pm_system_suspend+0x30>
		z_power_states[id] = pm_policy_next_state(id, ticks);
    307e:	466f      	mov	r7, sp
    3080:	4642      	mov	r2, r8
    3082:	4629      	mov	r1, r5
    3084:	4638      	mov	r0, r7
    3086:	f005 fbe5 	bl	8854 <pm_policy_next_state>
    308a:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    308e:	260c      	movs	r6, #12
    3090:	fb06 4605 	mla	r6, r6, r5, r4
    3094:	e886 0007 	stmia.w	r6, {r0, r1, r2}
	}

	if (z_power_states[id].state == PM_STATE_ACTIVE) {
    3098:	230c      	movs	r3, #12
    309a:	436b      	muls	r3, r5
    309c:	18e2      	adds	r2, r4, r3
    309e:	5ce0      	ldrb	r0, [r4, r3]
    30a0:	096e      	lsrs	r6, r5, #5
    30a2:	f005 071f 	and.w	r7, r5, #31
    30a6:	2800      	cmp	r0, #0
    30a8:	d03b      	beq.n	3122 <pm_system_suspend+0xba>
				   z_power_states[id].state);
		ret = false;
		goto end;
	}

	if (ticks != K_TICKS_FOREVER) {
    30aa:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    30ae:	d010      	beq.n	30d2 <pm_system_suspend+0x6a>
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
    30b0:	f8d2 e008 	ldr.w	lr, [r2, #8]
    30b4:	4827      	ldr	r0, [pc, #156]	; (3154 <pm_system_suspend+0xec>)
    30b6:	4a28      	ldr	r2, [pc, #160]	; (3158 <pm_system_suspend+0xf0>)
    30b8:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
    30bc:	2100      	movs	r1, #0
    30be:	2300      	movs	r3, #0
    30c0:	fbee 010c 	umlal	r0, r1, lr, ip
    30c4:	f7fe f81c 	bl	1100 <__aeabi_uldivmod>

		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		z_set_timeout_expiry(ticks -
    30c8:	2101      	movs	r1, #1
    30ca:	eba8 0000 	sub.w	r0, r8, r0
    30ce:	f006 faa7 	bl	9620 <z_set_timeout_expiry>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
    30d2:	f004 f9ab 	bl	742c <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
    30d6:	2001      	movs	r0, #1
    30d8:	f7ff ff38 	bl	2f4c <pm_state_notify>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    30dc:	f3bf 8f5b 	dmb	ish
    30e0:	4b1e      	ldr	r3, [pc, #120]	; (315c <pm_system_suspend+0xf4>)
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    30e2:	2201      	movs	r2, #1
    30e4:	40ba      	lsls	r2, r7
    30e6:	eb03 0386 	add.w	r3, r3, r6, lsl #2
    30ea:	e853 1f00 	ldrex	r1, [r3]
    30ee:	4311      	orrs	r1, r2
    30f0:	e843 1000 	strex	r0, r1, [r3]
    30f4:	2800      	cmp	r0, #0
    30f6:	d1f8      	bne.n	30ea <pm_system_suspend+0x82>
    30f8:	f3bf 8f5b 	dmb	ish
	atomic_set_bit(z_post_ops_required, id);
	pm_state_set(z_power_states[id]);
    30fc:	230c      	movs	r3, #12
    30fe:	fb03 4405 	mla	r4, r3, r5, r4
    3102:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    3106:	ab05      	add	r3, sp, #20
    3108:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
    310c:	4a14      	ldr	r2, [pc, #80]	; (3160 <pm_system_suspend+0xf8>)
    310e:	b11a      	cbz	r2, 3118 <pm_system_suspend+0xb0>
		pm_power_state_set(info);
    3110:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    3114:	f005 fbe7 	bl	88e6 <pm_power_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_power_states[id].state);
	pm_system_resume();
    3118:	f7ff ff62 	bl	2fe0 <pm_system_resume>
	k_sched_unlock();
    311c:	f004 fb54 	bl	77c8 <k_sched_unlock>
	bool ret = true;
    3120:	2001      	movs	r0, #1
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    3122:	4a10      	ldr	r2, [pc, #64]	; (3164 <pm_system_suspend+0xfc>)
    3124:	f3bf 8f5b 	dmb	ish
	atomic_val_t mask = ATOMIC_MASK(bit);
    3128:	2301      	movs	r3, #1
    312a:	40bb      	lsls	r3, r7
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    312c:	43db      	mvns	r3, r3
    312e:	eb02 0686 	add.w	r6, r2, r6, lsl #2
    3132:	e856 2f00 	ldrex	r2, [r6]
    3136:	401a      	ands	r2, r3
    3138:	e846 2100 	strex	r1, r2, [r6]
    313c:	2900      	cmp	r1, #0
    313e:	d1f8      	bne.n	3132 <pm_system_suspend+0xca>
    3140:	f3bf 8f5b 	dmb	ish
				   z_power_states[id].state);

end:
	atomic_clear_bit(z_power_states_forced, id);
	return ret;
}
    3144:	b008      	add	sp, #32
    3146:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    314a:	bf00      	nop
    314c:	20001330 	.word	0x20001330
    3150:	20000798 	.word	0x20000798
    3154:	000f423f 	.word	0x000f423f
    3158:	000f4240 	.word	0x000f4240
    315c:	20000794 	.word	0x20000794
    3160:	000088e7 	.word	0x000088e7
    3164:	200007a4 	.word	0x200007a4

00003168 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    3168:	4901      	ldr	r1, [pc, #4]	; (3170 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    316a:	2210      	movs	r2, #16
	str	r2, [r1]
    316c:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    316e:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    3170:	e000ed10 	.word	0xe000ed10

00003174 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    3174:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    3176:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    3178:	f380 8811 	msr	BASEPRI, r0
	isb
    317c:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    3180:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    3184:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    3186:	b662      	cpsie	i
	isb
    3188:	f3bf 8f6f 	isb	sy

	bx	lr
    318c:	4770      	bx	lr
    318e:	bf00      	nop

00003190 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    3190:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    3192:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    3194:	f381 8811 	msr	BASEPRI, r1

	wfe
    3198:	bf20      	wfe

	msr	BASEPRI, r0
    319a:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    319e:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    31a0:	4770      	bx	lr
    31a2:	bf00      	nop

000031a4 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    31a4:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    31a6:	2b00      	cmp	r3, #0
    31a8:	db08      	blt.n	31bc <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    31aa:	2201      	movs	r2, #1
    31ac:	f000 001f 	and.w	r0, r0, #31
    31b0:	fa02 f000 	lsl.w	r0, r2, r0
    31b4:	095b      	lsrs	r3, r3, #5
    31b6:	4a02      	ldr	r2, [pc, #8]	; (31c0 <arch_irq_enable+0x1c>)
    31b8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    31bc:	4770      	bx	lr
    31be:	bf00      	nop
    31c0:	e000e100 	.word	0xe000e100

000031c4 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    31c4:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    31c6:	2b00      	cmp	r3, #0
    31c8:	db0d      	blt.n	31e6 <arch_irq_disable+0x22>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    31ca:	2201      	movs	r2, #1
    31cc:	095b      	lsrs	r3, r3, #5
    31ce:	f000 001f 	and.w	r0, r0, #31
    31d2:	fa02 f000 	lsl.w	r0, r2, r0
    31d6:	3320      	adds	r3, #32
    31d8:	4a03      	ldr	r2, [pc, #12]	; (31e8 <arch_irq_disable+0x24>)
    31da:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    31de:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    31e2:	f3bf 8f6f 	isb	sy
}
    31e6:	4770      	bx	lr
    31e8:	e000e100 	.word	0xe000e100

000031ec <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    31ec:	4b05      	ldr	r3, [pc, #20]	; (3204 <arch_irq_is_enabled+0x18>)
    31ee:	0942      	lsrs	r2, r0, #5
    31f0:	f000 001f 	and.w	r0, r0, #31
    31f4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    31f8:	2301      	movs	r3, #1
    31fa:	fa03 f000 	lsl.w	r0, r3, r0
}
    31fe:	4010      	ands	r0, r2
    3200:	4770      	bx	lr
    3202:	bf00      	nop
    3204:	e000e100 	.word	0xe000e100

00003208 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    3208:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    320a:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    320c:	bfa8      	it	ge
    320e:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
		prio += _IRQ_PRIO_OFFSET;
    3212:	f101 0101 	add.w	r1, r1, #1
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    3216:	bfb8      	it	lt
    3218:	4b06      	ldrlt	r3, [pc, #24]	; (3234 <z_arm_irq_priority_set+0x2c>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    321a:	ea4f 1141 	mov.w	r1, r1, lsl #5
    321e:	bfac      	ite	ge
    3220:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    3224:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    3228:	b2c9      	uxtb	r1, r1
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    322a:	bfb4      	ite	lt
    322c:	5419      	strblt	r1, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    322e:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
}
    3232:	4770      	bx	lr
    3234:	e000ed14 	.word	0xe000ed14

00003238 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    3238:	bf30      	wfi
    b z_SysNmiOnReset
    323a:	f7ff bffd 	b.w	3238 <z_SysNmiOnReset>
    323e:	bf00      	nop

00003240 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    3240:	4a0f      	ldr	r2, [pc, #60]	; (3280 <z_arm_prep_c+0x40>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    3242:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    3244:	4b0f      	ldr	r3, [pc, #60]	; (3284 <z_arm_prep_c+0x44>)
    3246:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    324a:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    324c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    3250:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    3254:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    3258:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    325c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    3260:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    3264:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    3268:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
    326c:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    3270:	f003 fc94 	bl	6b9c <z_bss_zero>
	z_data_copy();
    3274:	f004 fbec 	bl	7a50 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    3278:	f000 f9ca 	bl	3610 <z_arm_interrupt_init>
	z_cstart();
    327c:	f003 fc98 	bl	6bb0 <z_cstart>
    3280:	00001000 	.word	0x00001000
    3284:	e000ed00 	.word	0xe000ed00

00003288 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    3288:	4a09      	ldr	r2, [pc, #36]	; (32b0 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    328a:	490a      	ldr	r1, [pc, #40]	; (32b4 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    328c:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    328e:	6809      	ldr	r1, [r1, #0]
    3290:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    3292:	4909      	ldr	r1, [pc, #36]	; (32b8 <arch_swap+0x30>)
	_current->arch.basepri = key;
    3294:	6758      	str	r0, [r3, #116]	; 0x74
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    3296:	684b      	ldr	r3, [r1, #4]
    3298:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    329c:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
    329e:	2300      	movs	r3, #0
    32a0:	f383 8811 	msr	BASEPRI, r3
    32a4:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    32a8:	6893      	ldr	r3, [r2, #8]
}
    32aa:	6f98      	ldr	r0, [r3, #120]	; 0x78
    32ac:	4770      	bx	lr
    32ae:	bf00      	nop
    32b0:	20001330 	.word	0x20001330
    32b4:	00009c28 	.word	0x00009c28
    32b8:	e000ed00 	.word	0xe000ed00

000032bc <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    32bc:	4912      	ldr	r1, [pc, #72]	; (3308 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    32be:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    32c0:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    32c4:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    32c6:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    32ca:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    32ce:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
    32d0:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    32d4:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    32d8:	4f0c      	ldr	r7, [pc, #48]	; (330c <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    32da:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    32de:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
    32e0:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    32e2:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    32e4:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
    32e6:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    32e8:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    32ea:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
    32ee:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    32f0:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    32f2:	f000 f9cf 	bl	3694 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    32f6:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    32fa:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    32fe:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    3302:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
    3306:	4770      	bx	lr
    ldr r1, =_kernel
    3308:	20001330 	.word	0x20001330
    ldr v4, =_SCS_ICSR
    330c:	e000ed04 	.word	0xe000ed04

00003310 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
    3310:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    3314:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    3316:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    331a:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    331e:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    3320:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    3324:	2902      	cmp	r1, #2
    beq _oops
    3326:	d0ff      	beq.n	3328 <_oops>

00003328 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    3328:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    332a:	f005 fa9a 	bl	8862 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    332e:	bd01      	pop	{r0, pc}

00003330 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
    3330:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
    3334:	9b00      	ldr	r3, [sp, #0]
    3336:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->pc &= 0xfffffffe;
    333a:	490a      	ldr	r1, [pc, #40]	; (3364 <arch_new_thread+0x34>)
	iframe->a3 = (uint32_t)p2;
    333c:	9b01      	ldr	r3, [sp, #4]
    333e:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
    3342:	9b02      	ldr	r3, [sp, #8]
    3344:	f842 3c14 	str.w	r3, [r2, #-20]
	iframe->pc &= 0xfffffffe;
    3348:	f021 0101 	bic.w	r1, r1, #1

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    334c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    3350:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->pc &= 0xfffffffe;
    3354:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
    3358:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    335a:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
    335c:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    335e:	6743      	str	r3, [r0, #116]	; 0x74
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    3360:	4770      	bx	lr
    3362:	bf00      	nop
    3364:	00008011 	.word	0x00008011

00003368 <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
    3368:	4a09      	ldr	r2, [pc, #36]	; (3390 <z_check_thread_stack_fail+0x28>)
{
    336a:	4603      	mov	r3, r0
	const struct k_thread *thread = _current;
    336c:	6890      	ldr	r0, [r2, #8]

	if (thread == NULL) {
    336e:	b170      	cbz	r0, 338e <z_check_thread_stack_fail+0x26>
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    3370:	f113 0f16 	cmn.w	r3, #22
    3374:	6e40      	ldr	r0, [r0, #100]	; 0x64
    3376:	d005      	beq.n	3384 <z_check_thread_stack_fail+0x1c>
    3378:	f1a0 0220 	sub.w	r2, r0, #32
    337c:	429a      	cmp	r2, r3
    337e:	d805      	bhi.n	338c <z_check_thread_stack_fail+0x24>
    3380:	4283      	cmp	r3, r0
    3382:	d203      	bcs.n	338c <z_check_thread_stack_fail+0x24>
		return (uint32_t)Z_THREAD_STACK_BUFFER(z_main_stack);
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
    3384:	4281      	cmp	r1, r0
    3386:	bf28      	it	cs
    3388:	2000      	movcs	r0, #0
    338a:	4770      	bx	lr
    338c:	2000      	movs	r0, #0
}
    338e:	4770      	bx	lr
    3390:	20001330 	.word	0x20001330

00003394 <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    3394:	b508      	push	{r3, lr}
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    3396:	4b09      	ldr	r3, [pc, #36]	; (33bc <arch_switch_to_main_thread+0x28>)
    3398:	6098      	str	r0, [r3, #8]
{
    339a:	460d      	mov	r5, r1
    339c:	4614      	mov	r4, r2
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    339e:	f000 f979 	bl	3694 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    33a2:	4620      	mov	r0, r4
    33a4:	f385 8809 	msr	PSP, r5
    33a8:	2100      	movs	r1, #0
    33aa:	b663      	cpsie	if
    33ac:	f381 8811 	msr	BASEPRI, r1
    33b0:	f3bf 8f6f 	isb	sy
    33b4:	2200      	movs	r2, #0
    33b6:	2300      	movs	r3, #0
    33b8:	f004 fe2a 	bl	8010 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    33bc:	20001330 	.word	0x20001330

000033c0 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    33c0:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    33c2:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    33c4:	4a0b      	ldr	r2, [pc, #44]	; (33f4 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    33c6:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
    33c8:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    33ca:	bf1e      	ittt	ne
	movne	r1, #0
    33cc:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    33ce:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
    33d0:	f005 ff4c 	blne	926c <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    33d4:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    33d6:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    33da:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    33de:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    33e2:	4905      	ldr	r1, [pc, #20]	; (33f8 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    33e4:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    33e6:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    33e8:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    33ea:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    33ee:	4903      	ldr	r1, [pc, #12]	; (33fc <_isr_wrapper+0x3c>)
	bx r1
    33f0:	4708      	bx	r1
    33f2:	0000      	.short	0x0000
	ldr r2, =_kernel
    33f4:	20001330 	.word	0x20001330
	ldr r1, =_sw_isr_table
    33f8:	00009890 	.word	0x00009890
	ldr r1, =z_arm_int_exit
    33fc:	00003401 	.word	0x00003401

00003400 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    3400:	4b04      	ldr	r3, [pc, #16]	; (3414 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    3402:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    3404:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
    3406:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    3408:	d003      	beq.n	3412 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    340a:	4903      	ldr	r1, [pc, #12]	; (3418 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    340c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    3410:	600a      	str	r2, [r1, #0]

00003412 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    3412:	4770      	bx	lr
	ldr r3, =_kernel
    3414:	20001330 	.word	0x20001330
	ldr r1, =_SCS_ICSR
    3418:	e000ed04 	.word	0xe000ed04

0000341c <mem_manage_fault>:
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
			      bool *recoverable)
{
    341c:	b538      	push	{r3, r4, r5, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    341e:	4b19      	ldr	r3, [pc, #100]	; (3484 <mem_manage_fault+0x68>)
{
    3420:	4614      	mov	r4, r2
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    3422:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    3424:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    3426:	6a9a      	ldr	r2, [r3, #40]	; 0x28
{
    3428:	4605      	mov	r5, r0
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    342a:	0790      	lsls	r0, r2, #30
    342c:	d519      	bpl.n	3462 <mem_manage_fault+0x46>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		uint32_t temp = SCB->MMFAR;
    342e:	6b58      	ldr	r0, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    3430:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    3432:	0612      	lsls	r2, r2, #24
    3434:	d515      	bpl.n	3462 <mem_manage_fault+0x46>
			mmfar = temp;
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault != 0) {
    3436:	b119      	cbz	r1, 3440 <mem_manage_fault+0x24>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    3438:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    343a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    343e:	629a      	str	r2, [r3, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    3440:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Instruction Access Violation");
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    3442:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	 * crossed into an area beyond the thread stack.]
	 *
	 * Data Access Violation errors may or may not be caused by
	 * thread stack overflows.
	 */
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    3444:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    3446:	06d1      	lsls	r1, r2, #27
    3448:	d40e      	bmi.n	3468 <mem_manage_fault+0x4c>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    344a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    344c:	079a      	lsls	r2, r3, #30
    344e:	d40b      	bmi.n	3468 <mem_manage_fault+0x4c>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    3450:	2000      	movs	r0, #0
		"without stack guard, user-mode or null-pointer detection\n");
#endif /* CONFIG_MPU_STACK_GUARD || CONFIG_USERSPACE */
	}

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    3452:	4a0c      	ldr	r2, [pc, #48]	; (3484 <mem_manage_fault+0x68>)
    3454:	6a93      	ldr	r3, [r2, #40]	; 0x28
    3456:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
    345a:	6293      	str	r3, [r2, #40]	; 0x28

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf, true);
    345c:	2300      	movs	r3, #0
    345e:	7023      	strb	r3, [r4, #0]

	return reason;
}
    3460:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t mmfar = -EINVAL;
    3462:	f06f 0015 	mvn.w	r0, #21
    3466:	e7eb      	b.n	3440 <mem_manage_fault+0x24>
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
    3468:	4b06      	ldr	r3, [pc, #24]	; (3484 <mem_manage_fault+0x68>)
    346a:	685b      	ldr	r3, [r3, #4]
    346c:	051b      	lsls	r3, r3, #20
    346e:	d5ef      	bpl.n	3450 <mem_manage_fault+0x34>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
    3470:	4629      	mov	r1, r5
    3472:	f7ff ff79 	bl	3368 <z_check_thread_stack_fail>
			if (min_stack_ptr) {
    3476:	2800      	cmp	r0, #0
    3478:	d0ea      	beq.n	3450 <mem_manage_fault+0x34>
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
    347a:	f380 8809 	msr	PSP, r0
				reason = K_ERR_STACK_CHK_FAIL;
    347e:	2002      	movs	r0, #2
    3480:	e7e7      	b.n	3452 <mem_manage_fault+0x36>
    3482:	bf00      	nop
    3484:	e000ed00 	.word	0xe000ed00

00003488 <bus_fault.constprop.0>:
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    3488:	4b0d      	ldr	r3, [pc, #52]	; (34c0 <bus_fault.constprop.0+0x38>)
    348a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    348c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    348e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    3490:	0592      	lsls	r2, r2, #22
    3492:	d508      	bpl.n	34a6 <bus_fault.constprop.0+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    3494:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    3496:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    3498:	0412      	lsls	r2, r2, #16
    349a:	d504      	bpl.n	34a6 <bus_fault.constprop.0+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault != 0) {
    349c:	b118      	cbz	r0, 34a6 <bus_fault.constprop.0+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    349e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    34a0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    34a4:	629a      	str	r2, [r3, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    34a6:	4b06      	ldr	r3, [pc, #24]	; (34c0 <bus_fault.constprop.0+0x38>)
    34a8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Imprecise data bus error");
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    34aa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    34ac:	05d2      	lsls	r2, r2, #23
		PR_FAULT_INFO("  Instruction bus error");
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    34ae:	bf58      	it	pl
    34b0:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    34b2:	6a9a      	ldr	r2, [r3, #40]	; 0x28

	*recoverable = memory_fault_recoverable(esf, true);
    34b4:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    34b6:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
    34ba:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    34bc:	7008      	strb	r0, [r1, #0]

	return reason;
}
    34be:	4770      	bx	lr
    34c0:	e000ed00 	.word	0xe000ed00

000034c4 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    34c4:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    34c6:	4b48      	ldr	r3, [pc, #288]	; (35e8 <z_arm_fault+0x124>)
    34c8:	685b      	ldr	r3, [r3, #4]
{
    34ca:	b08a      	sub	sp, #40	; 0x28
    34cc:	460d      	mov	r5, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    34ce:	f3c3 0308 	ubfx	r3, r3, #0, #9
    34d2:	2600      	movs	r6, #0
    34d4:	f386 8811 	msr	BASEPRI, r6
    34d8:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    34dc:	f002 417f 	and.w	r1, r2, #4278190080	; 0xff000000
    34e0:	f1b1 4f7f 	cmp.w	r1, #4278190080	; 0xff000000
    34e4:	d111      	bne.n	350a <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    34e6:	f002 010c 	and.w	r1, r2, #12
    34ea:	2908      	cmp	r1, #8
    34ec:	d00d      	beq.n	350a <z_arm_fault+0x46>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    34ee:	0711      	lsls	r1, r2, #28
    34f0:	d401      	bmi.n	34f6 <z_arm_fault+0x32>
			ptr_esf = (z_arch_esf_t *)msp;
    34f2:	4605      	mov	r5, r0
			*nested_exc = true;
    34f4:	2601      	movs	r6, #1
	*recoverable = false;
    34f6:	2200      	movs	r2, #0
	switch (fault) {
    34f8:	3b03      	subs	r3, #3
	*recoverable = false;
    34fa:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
    34fe:	2b03      	cmp	r3, #3
    3500:	d86b      	bhi.n	35da <z_arm_fault+0x116>
    3502:	e8df f003 	tbb	[pc, r3]
    3506:	5504      	.short	0x5504
    3508:	5d59      	.short	0x5d59
		return NULL;
    350a:	4635      	mov	r5, r6
    350c:	e7f3      	b.n	34f6 <z_arm_fault+0x32>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    350e:	4b36      	ldr	r3, [pc, #216]	; (35e8 <z_arm_fault+0x124>)
    3510:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    3512:	f014 0402 	ands.w	r4, r4, #2
    3516:	d160      	bne.n	35da <z_arm_fault+0x116>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
    3518:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    351a:	2a00      	cmp	r2, #0
    351c:	db15      	blt.n	354a <z_arm_fault+0x86>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    351e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    3520:	0052      	lsls	r2, r2, #1
    3522:	d512      	bpl.n	354a <z_arm_fault+0x86>
	uint16_t fault_insn = *(ret_addr - 1);
    3524:	69aa      	ldr	r2, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
    3526:	f832 1c02 	ldrh.w	r1, [r2, #-2]
    352a:	f64d 7202 	movw	r2, #57090	; 0xdf02
    352e:	4291      	cmp	r1, r2
    3530:	d00a      	beq.n	3548 <z_arm_fault+0x84>
		} else if (SCB_MMFSR != 0) {
    3532:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    3536:	b30a      	cbz	r2, 357c <z_arm_fault+0xb8>
			reason = mem_manage_fault(esf, 1, recoverable);
    3538:	f10d 0207 	add.w	r2, sp, #7
    353c:	2101      	movs	r1, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    353e:	4628      	mov	r0, r5
    3540:	f7ff ff6c 	bl	341c <mem_manage_fault>
		reason = bus_fault(esf, 0, recoverable);
    3544:	4604      	mov	r4, r0
		break;
    3546:	e000      	b.n	354a <z_arm_fault+0x86>
			reason = esf->basic.r0;
    3548:	682c      	ldr	r4, [r5, #0]
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    354a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    354e:	b99b      	cbnz	r3, 3578 <z_arm_fault+0xb4>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    3550:	2220      	movs	r2, #32
    3552:	4629      	mov	r1, r5
    3554:	a802      	add	r0, sp, #8
    3556:	f005 f9af 	bl	88b8 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    355a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    355c:	2e00      	cmp	r6, #0
    355e:	d03e      	beq.n	35de <z_arm_fault+0x11a>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    3560:	f3c3 0208 	ubfx	r2, r3, #0, #9
    3564:	b922      	cbnz	r2, 3570 <z_arm_fault+0xac>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    3566:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    356a:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    356e:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    3570:	a902      	add	r1, sp, #8
    3572:	4620      	mov	r0, r4
    3574:	f005 f973 	bl	885e <z_arm_fatal_error>
}
    3578:	b00a      	add	sp, #40	; 0x28
    357a:	bd70      	pop	{r4, r5, r6, pc}
		} else if (SCB_BFSR != 0) {
    357c:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
    3580:	b12a      	cbz	r2, 358e <z_arm_fault+0xca>
			reason = bus_fault(esf, 1, recoverable);
    3582:	f10d 0107 	add.w	r1, sp, #7
    3586:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    3588:	f7ff ff7e 	bl	3488 <bus_fault.constprop.0>
    358c:	e7da      	b.n	3544 <z_arm_fault+0x80>
		} else if (SCB_UFSR != 0) {
    358e:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
    3590:	b292      	uxth	r2, r2
    3592:	2a00      	cmp	r2, #0
    3594:	d0d9      	beq.n	354a <z_arm_fault+0x86>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    3596:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    3598:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    359a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    359c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    359e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    35a0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    35a2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    35a4:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    35a8:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    35ac:	629a      	str	r2, [r3, #40]	; 0x28
	return reason;
    35ae:	e7cc      	b.n	354a <z_arm_fault+0x86>
		reason = mem_manage_fault(esf, 0, recoverable);
    35b0:	f10d 0207 	add.w	r2, sp, #7
    35b4:	2100      	movs	r1, #0
    35b6:	e7c2      	b.n	353e <z_arm_fault+0x7a>
		reason = bus_fault(esf, 0, recoverable);
    35b8:	f10d 0107 	add.w	r1, sp, #7
    35bc:	2000      	movs	r0, #0
    35be:	e7e3      	b.n	3588 <z_arm_fault+0xc4>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    35c0:	4b09      	ldr	r3, [pc, #36]	; (35e8 <z_arm_fault+0x124>)
    35c2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    35c4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    35c6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    35c8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    35ca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    35cc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    35ce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    35d0:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    35d4:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    35d8:	629a      	str	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    35da:	2400      	movs	r4, #0
    35dc:	e7b5      	b.n	354a <z_arm_fault+0x86>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    35de:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    35e2:	f023 0301 	bic.w	r3, r3, #1
    35e6:	e7c2      	b.n	356e <z_arm_fault+0xaa>
    35e8:	e000ed00 	.word	0xe000ed00

000035ec <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    35ec:	4a02      	ldr	r2, [pc, #8]	; (35f8 <z_arm_fault_init+0xc>)
    35ee:	6953      	ldr	r3, [r2, #20]
    35f0:	f043 0310 	orr.w	r3, r3, #16
    35f4:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    35f6:	4770      	bx	lr
    35f8:	e000ed00 	.word	0xe000ed00

000035fc <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    35fc:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    3600:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    3604:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    3606:	4672      	mov	r2, lr
	bl z_arm_fault
    3608:	f7ff ff5c 	bl	34c4 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    360c:	bd01      	pop	{r0, pc}
    360e:	bf00      	nop

00003610 <z_arm_interrupt_init>:
    3610:	4804      	ldr	r0, [pc, #16]	; (3624 <z_arm_interrupt_init+0x14>)
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    3612:	2300      	movs	r3, #0
    3614:	2120      	movs	r1, #32
    3616:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    3618:	3301      	adds	r3, #1
    361a:	2b30      	cmp	r3, #48	; 0x30
    361c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    3620:	d1f9      	bne.n	3616 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    3622:	4770      	bx	lr
    3624:	e000e100 	.word	0xe000e100

00003628 <__start>:
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
    3628:	f006 f8b4 	bl	9794 <z_arm_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    362c:	2020      	movs	r0, #32
    msr BASEPRI, r0
    362e:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    3632:	4808      	ldr	r0, [pc, #32]	; (3654 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    3634:	f44f 6102 	mov.w	r1, #2080	; 0x820
    adds r0, r0, r1
    3638:	1840      	adds	r0, r0, r1
    msr PSP, r0
    363a:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    363e:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    3642:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    3644:	4308      	orrs	r0, r1
    msr CONTROL, r0
    3646:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    364a:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    364e:	f7ff fdf7 	bl	3240 <z_arm_prep_c>
    3652:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
    3654:	20002180 	.word	0x20002180

00003658 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
    3658:	4b06      	ldr	r3, [pc, #24]	; (3674 <z_impl_k_thread_abort+0x1c>)
    365a:	689b      	ldr	r3, [r3, #8]
    365c:	4283      	cmp	r3, r0
    365e:	d107      	bne.n	3670 <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    3660:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    3664:	b123      	cbz	r3, 3670 <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    3666:	4a04      	ldr	r2, [pc, #16]	; (3678 <z_impl_k_thread_abort+0x20>)
    3668:	6853      	ldr	r3, [r2, #4]
    366a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    366e:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
    3670:	f004 b98a 	b.w	7988 <z_thread_abort>
    3674:	20001330 	.word	0x20001330
    3678:	e000ed00 	.word	0xe000ed00

0000367c <z_arm_configure_static_mpu_regions>:
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    367c:	4b02      	ldr	r3, [pc, #8]	; (3688 <z_arm_configure_static_mpu_regions+0xc>)
    367e:	4a03      	ldr	r2, [pc, #12]	; (368c <z_arm_configure_static_mpu_regions+0x10>)
    3680:	4803      	ldr	r0, [pc, #12]	; (3690 <z_arm_configure_static_mpu_regions+0x14>)
    3682:	2101      	movs	r1, #1
    3684:	f000 b86e 	b.w	3764 <arm_core_mpu_configure_static_mpu_regions>
    3688:	20040000 	.word	0x20040000
    368c:	20000000 	.word	0x20000000
    3690:	00009a9c 	.word	0x00009a9c

00003694 <z_arm_configure_dynamic_mpu_regions>:
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
    3694:	6e42      	ldr	r2, [r0, #100]	; 0x64
	}

	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
    3696:	4b05      	ldr	r3, [pc, #20]	; (36ac <z_arm_configure_dynamic_mpu_regions+0x18>)
		guard_start = thread->stack_info.start - guard_size;
    3698:	3a20      	subs	r2, #32
	dynamic_regions[region_num].start = guard_start;
    369a:	601a      	str	r2, [r3, #0]
	dynamic_regions[region_num].size = guard_size;
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
    369c:	4a04      	ldr	r2, [pc, #16]	; (36b0 <z_arm_configure_dynamic_mpu_regions+0x1c>)
    369e:	2120      	movs	r1, #32
    36a0:	e9c3 1201 	strd	r1, r2, [r3, #4]

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
    36a4:	4618      	mov	r0, r3
    36a6:	2101      	movs	r1, #1
    36a8:	f000 b866 	b.w	3778 <arm_core_mpu_configure_dynamic_mpu_regions>
    36ac:	200007a8 	.word	0x200007a8
    36b0:	150b0000 	.word	0x150b0000

000036b4 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
    36b4:	b5f0      	push	{r4, r5, r6, r7, lr}
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
    36b6:	4f1f      	ldr	r7, [pc, #124]	; (3734 <mpu_configure_regions+0x80>)
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    36b8:	2600      	movs	r6, #0
    36ba:	428e      	cmp	r6, r1
    36bc:	db01      	blt.n	36c2 <mpu_configure_regions+0xe>
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    36be:	4610      	mov	r0, r2
    36c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (regions[i].size == 0U) {
    36c2:	6844      	ldr	r4, [r0, #4]
    36c4:	b39c      	cbz	r4, 372e <mpu_configure_regions+0x7a>
		if (do_sanity_check &&
    36c6:	b153      	cbz	r3, 36de <mpu_configure_regions+0x2a>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1U)) == 0U)
    36c8:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    36cc:	ea14 0f0c 	tst.w	r4, ip
    36d0:	d118      	bne.n	3704 <mpu_configure_regions+0x50>
		&&
    36d2:	2c1f      	cmp	r4, #31
    36d4:	d916      	bls.n	3704 <mpu_configure_regions+0x50>
		((part->start & (part->size - 1U)) == 0U);
    36d6:	6805      	ldr	r5, [r0, #0]
		&&
    36d8:	ea1c 0f05 	tst.w	ip, r5
    36dc:	d112      	bne.n	3704 <mpu_configure_regions+0x50>
 * to that power-of-two value.
 */
static inline uint32_t size_to_mpu_rasr_size(uint32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    36de:	2c20      	cmp	r4, #32
	region_conf.base = new_region->start;
    36e0:	6805      	ldr	r5, [r0, #0]
#if defined(CONFIG_CPU_CORTEX_R)
	(void) size;

	p_attr->rasr = attr->rasr_attr;
#else
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    36e2:	f8d0 c008 	ldr.w	ip, [r0, #8]
		reg_index = mpu_configure_region(reg_index, &regions[i]);
    36e6:	b2d2      	uxtb	r2, r2
	if (size <= 32U) {
    36e8:	d90f      	bls.n	370a <mpu_configure_regions+0x56>
	if (size > (1UL << 31)) {
    36ea:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    36ee:	d80e      	bhi.n	370e <mpu_configure_regions+0x5a>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    36f0:	3c01      	subs	r4, #1
    36f2:	fab4 f484 	clz	r4, r4
    36f6:	f1c4 041f 	rsb	r4, r4, #31
    36fa:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1U)) {
    36fc:	2a07      	cmp	r2, #7
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    36fe:	ea4c 0404 	orr.w	r4, ip, r4
    3702:	d906      	bls.n	3712 <mpu_configure_regions+0x5e>
			return -EINVAL;
    3704:	f06f 0215 	mvn.w	r2, #21
    3708:	e7d9      	b.n	36be <mpu_configure_regions+0xa>
		return REGION_32B;
    370a:	2408      	movs	r4, #8
    370c:	e7f6      	b.n	36fc <mpu_configure_regions+0x48>
		return REGION_4G;
    370e:	243e      	movs	r4, #62	; 0x3e
    3710:	e7f4      	b.n	36fc <mpu_configure_regions+0x48>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    3712:	f025 051f 	bic.w	r5, r5, #31
				| MPU_RBAR_VALID_Msk | index;
    3716:	4315      	orrs	r5, r2
    3718:	f045 0510 	orr.w	r5, r5, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    371c:	f044 0401 	orr.w	r4, r4, #1
    3720:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    3724:	f8c7 509c 	str.w	r5, [r7, #156]	; 0x9c
		reg_index++;
    3728:	3201      	adds	r2, #1
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    372a:	f8c7 40a0 	str.w	r4, [r7, #160]	; 0xa0
	for (i = 0; i < regions_num; i++) {
    372e:	3601      	adds	r6, #1
    3730:	300c      	adds	r0, #12
    3732:	e7c2      	b.n	36ba <mpu_configure_regions+0x6>
    3734:	e000ed00 	.word	0xe000ed00

00003738 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    3738:	4b04      	ldr	r3, [pc, #16]	; (374c <arm_core_mpu_enable+0x14>)
    373a:	2205      	movs	r2, #5
    373c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
    3740:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    3744:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    3748:	4770      	bx	lr
    374a:	bf00      	nop
    374c:	e000ed00 	.word	0xe000ed00

00003750 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    3750:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    3754:	4b02      	ldr	r3, [pc, #8]	; (3760 <arm_core_mpu_disable+0x10>)
    3756:	2200      	movs	r2, #0
    3758:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    375c:	4770      	bx	lr
    375e:	bf00      	nop
    3760:	e000ed00 	.word	0xe000ed00

00003764 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
    3764:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    3766:	4c03      	ldr	r4, [pc, #12]	; (3774 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    3768:	2301      	movs	r3, #1
    376a:	7822      	ldrb	r2, [r4, #0]
    376c:	f7ff ffa2 	bl	36b4 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    3770:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
    3772:	bd10      	pop	{r4, pc}
    3774:	20001382 	.word	0x20001382

00003778 <arm_core_mpu_configure_dynamic_mpu_regions>:
/**
 * @brief configure dynamic MPU regions.
 */
void arm_core_mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	dynamic_regions[], uint8_t regions_num)
{
    3778:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    377a:	4a09      	ldr	r2, [pc, #36]	; (37a0 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
    377c:	2300      	movs	r3, #0
    377e:	7812      	ldrb	r2, [r2, #0]
    3780:	f7ff ff98 	bl	36b4 <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    3784:	f110 0f16 	cmn.w	r0, #22
    3788:	d002      	beq.n	3790 <arm_core_mpu_configure_dynamic_mpu_regions+0x18>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    378a:	4a06      	ldr	r2, [pc, #24]	; (37a4 <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>)

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    378c:	2807      	cmp	r0, #7
    378e:	dd00      	ble.n	3792 <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
		== -EINVAL) {

		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
			regions_num);
	}
}
    3790:	bd08      	pop	{r3, pc}
    3792:	f8c2 0098 	str.w	r0, [r2, #152]	; 0x98
  MPU->RASR = 0U;
    3796:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
    379a:	3001      	adds	r0, #1
    379c:	e7f6      	b.n	378c <arm_core_mpu_configure_dynamic_mpu_regions+0x14>
    379e:	bf00      	nop
    37a0:	20001382 	.word	0x20001382
    37a4:	e000ed00 	.word	0xe000ed00

000037a8 <z_arm_mpu_init>:
 */
int z_arm_mpu_init(void)
{
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    37a8:	4914      	ldr	r1, [pc, #80]	; (37fc <z_arm_mpu_init+0x54>)
    37aa:	6808      	ldr	r0, [r1, #0]
    37ac:	2808      	cmp	r0, #8
{
    37ae:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    37b0:	d821      	bhi.n	37f6 <z_arm_mpu_init+0x4e>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    37b2:	f7ff ffcd 	bl	3750 <arm_core_mpu_disable>
    37b6:	4c12      	ldr	r4, [pc, #72]	; (3800 <z_arm_mpu_init+0x58>)
    37b8:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    37ba:	2200      	movs	r2, #0
    37bc:	4290      	cmp	r0, r2
    37be:	f101 010c 	add.w	r1, r1, #12
    37c2:	d105      	bne.n	37d0 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    37c4:	4b0f      	ldr	r3, [pc, #60]	; (3804 <z_arm_mpu_init+0x5c>)
    37c6:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    37c8:	f7ff ffb6 	bl	3738 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
    37cc:	2000      	movs	r0, #0
}
    37ce:	bd10      	pop	{r4, pc}
    37d0:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    37d4:	f851 3c0c 	ldr.w	r3, [r1, #-12]
    37d8:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    37dc:	4313      	orrs	r3, r2
    37de:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    37e2:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    37e6:	f851 3c04 	ldr.w	r3, [r1, #-4]
    37ea:	f043 0301 	orr.w	r3, r3, #1
    37ee:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    37f2:	3201      	adds	r2, #1
    37f4:	e7e2      	b.n	37bc <z_arm_mpu_init+0x14>
		return -1;
    37f6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    37fa:	e7e8      	b.n	37ce <z_arm_mpu_init+0x26>
    37fc:	00009aa8 	.word	0x00009aa8
    3800:	e000ed00 	.word	0xe000ed00
    3804:	20001382 	.word	0x20001382

00003808 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    3808:	4b01      	ldr	r3, [pc, #4]	; (3810 <__stdout_hook_install+0x8>)
    380a:	6018      	str	r0, [r3, #0]
}
    380c:	4770      	bx	lr
    380e:	bf00      	nop
    3810:	200000dc 	.word	0x200000dc

00003814 <nordicsemi_nrf52_init>:
	nrf_power_gpregret_set(NRF_POWER, (uint8_t)type);
	NVIC_SystemReset();
}

static int nordicsemi_nrf52_init(const struct device *arg)
{
    3814:	b510      	push	{r4, lr}
	__asm__ volatile(
    3816:	f04f 0320 	mov.w	r3, #32
    381a:	f3ef 8011 	mrs	r0, BASEPRI
    381e:	f383 8812 	msr	BASEPRI_MAX, r3
    3822:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    3826:	4a11      	ldr	r2, [pc, #68]	; (386c <nordicsemi_nrf52_init+0x58>)
    3828:	2301      	movs	r3, #1
    382a:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    382e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
{
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    3832:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    3836:	f8c2 3578 	str.w	r3, [r2, #1400]	; 0x578
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
    383a:	f8d1 4130 	ldr.w	r4, [r1, #304]	; 0x130
    383e:	2c08      	cmp	r4, #8
    3840:	d108      	bne.n	3854 <nordicsemi_nrf52_init+0x40>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    3842:	f8d1 1134 	ldr.w	r1, [r1, #308]	; 0x134
            {
                switch(var2)
    3846:	2905      	cmp	r1, #5
    3848:	d804      	bhi.n	3854 <nordicsemi_nrf52_init+0x40>
#endif // defined(POWER_RAM_POWER_S0POWER_Msk)

#if NRF_POWER_HAS_DCDCEN_VDDH
NRF_STATIC_INLINE void nrf_power_dcdcen_vddh_set(NRF_POWER_Type * p_reg, bool enable)
{
    if (enable && nrf52_errata_197())
    384a:	4c09      	ldr	r4, [pc, #36]	; (3870 <nordicsemi_nrf52_init+0x5c>)
    384c:	5c61      	ldrb	r1, [r4, r1]
    384e:	b109      	cbz	r1, 3854 <nordicsemi_nrf52_init+0x40>
    {
        // Workaround for anomaly 197 "POWER: DCDC of REG0 not functional".
        *(volatile uint32_t *)0x40000638ul = 1ul;
    3850:	f8c2 3638 	str.w	r3, [r2, #1592]	; 0x638
    }
    p_reg->DCDCEN0 = (enable ? POWER_DCDCEN0_DCDCEN_Enabled : POWER_DCDCEN0_DCDCEN_Disabled) <<
    3854:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3858:	2201      	movs	r2, #1
    385a:	f8c3 2580 	str.w	r2, [r3, #1408]	; 0x580
	__asm__ volatile(
    385e:	f380 8811 	msr	BASEPRI, r0
    3862:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    3866:	2000      	movs	r0, #0
    3868:	bd10      	pop	{r4, pc}
    386a:	bf00      	nop
    386c:	4001e000 	.word	0x4001e000
    3870:	00009cb9 	.word	0x00009cb9

00003874 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    3874:	b120      	cbz	r0, 3880 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    3876:	4b03      	ldr	r3, [pc, #12]	; (3884 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    3878:	0180      	lsls	r0, r0, #6
    387a:	f043 0301 	orr.w	r3, r3, #1
    387e:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    3880:	4770      	bx	lr
    3882:	bf00      	nop
    3884:	00009a40 	.word	0x00009a40

00003888 <board_nrf52840dongle_nrf52840_init>:

#if NRF_POWER_HAS_MAINREGSTATUS
NRF_STATIC_INLINE
nrf_power_mainregstatus_t nrf_power_mainregstatus_get(NRF_POWER_Type const * p_reg)
{
    return (nrf_power_mainregstatus_t)(((p_reg->MAINREGSTATUS) &
    3888:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    388c:	f8d3 3640 	ldr.w	r3, [r3, #1600]	; 0x640
	/* if the nrf52840dongle_nrf52840 board is powered from USB
	 * (high voltage mode), GPIO output voltage is set to 1.8 volts by
	 * default and that is not enough to turn the green and blue LEDs on.
	 * Increase GPIO voltage to 3.0 volts.
	 */
	if ((nrf_power_mainregstatus_get(NRF_POWER) ==
    3890:	07db      	lsls	r3, r3, #31
    3892:	d52e      	bpl.n	38f2 <board_nrf52840dongle_nrf52840_init+0x6a>
	     NRF_POWER_MAINREGSTATUS_HIGH) &&
	    ((NRF_UICR->REGOUT0 & UICR_REGOUT0_VOUT_Msk) ==
    3894:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    3898:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
    389c:	f003 0307 	and.w	r3, r3, #7
	     NRF_POWER_MAINREGSTATUS_HIGH) &&
    38a0:	2b07      	cmp	r3, #7
    38a2:	d126      	bne.n	38f2 <board_nrf52840dongle_nrf52840_init+0x6a>
	     (UICR_REGOUT0_VOUT_DEFAULT << UICR_REGOUT0_VOUT_Pos))) {

		NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
    38a4:	4a14      	ldr	r2, [pc, #80]	; (38f8 <board_nrf52840dongle_nrf52840_init+0x70>)
    38a6:	2301      	movs	r3, #1
    38a8:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
		while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
    38ac:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    38b0:	2b00      	cmp	r3, #0
    38b2:	d0fb      	beq.n	38ac <board_nrf52840dongle_nrf52840_init+0x24>
			;
		}

		NRF_UICR->REGOUT0 =
		    (NRF_UICR->REGOUT0 & ~((uint32_t)UICR_REGOUT0_VOUT_Msk)) |
    38b4:	f04f 2110 	mov.w	r1, #268439552	; 0x10001000
    38b8:	f8d1 3304 	ldr.w	r3, [r1, #772]	; 0x304
    38bc:	f023 0307 	bic.w	r3, r3, #7
    38c0:	f043 0304 	orr.w	r3, r3, #4
		NRF_UICR->REGOUT0 =
    38c4:	f8c1 3304 	str.w	r3, [r1, #772]	; 0x304
		    (UICR_REGOUT0_VOUT_3V0 << UICR_REGOUT0_VOUT_Pos);

		NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
    38c8:	2300      	movs	r3, #0
    38ca:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
		while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
    38ce:	4a0a      	ldr	r2, [pc, #40]	; (38f8 <board_nrf52840dongle_nrf52840_init+0x70>)
    38d0:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    38d4:	2b00      	cmp	r3, #0
    38d6:	d0fb      	beq.n	38d0 <board_nrf52840dongle_nrf52840_init+0x48>
  __ASM volatile ("dsb 0xF":::"memory");
    38d8:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    38dc:	4907      	ldr	r1, [pc, #28]	; (38fc <board_nrf52840dongle_nrf52840_init+0x74>)
    38de:	4b08      	ldr	r3, [pc, #32]	; (3900 <board_nrf52840dongle_nrf52840_init+0x78>)
    38e0:	68ca      	ldr	r2, [r1, #12]
    38e2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    38e6:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    38e8:	60cb      	str	r3, [r1, #12]
    38ea:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    38ee:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    38f0:	e7fd      	b.n	38ee <board_nrf52840dongle_nrf52840_init+0x66>
		/* a reset is required for changes to take effect */
		NVIC_SystemReset();
	}

	return 0;
}
    38f2:	2000      	movs	r0, #0
    38f4:	4770      	bx	lr
    38f6:	bf00      	nop
    38f8:	4001e000 	.word	0x4001e000
    38fc:	e000ed00 	.word	0xe000ed00
    3900:	05fa0004 	.word	0x05fa0004

00003904 <endpoint_ctx>:
	return (uint8_t)ep;
}

static inline bool ep_is_valid(const uint8_t ep)
{
	uint8_t ep_num = USB_EP_GET_IDX(ep);
    3904:	f000 037f 	and.w	r3, r0, #127	; 0x7f

	if (NRF_USBD_EPIN_CHECK(ep)) {
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
    3908:	2b08      	cmp	r3, #8
	if (NRF_USBD_EPIN_CHECK(ep)) {
    390a:	b242      	sxtb	r2, r0
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
    390c:	d004      	beq.n	3918 <endpoint_ctx+0x14>
			if (CFG_EP_ISOIN_CNT == 0) {
				return false;
			}
		} else {
			if (ep_num >= CFG_EPIN_CNT) {
    390e:	f010 0f78 	tst.w	r0, #120	; 0x78
    3912:	d001      	beq.n	3918 <endpoint_ctx+0x14>
{
	struct nrf_usbd_ctx *ctx;
	uint8_t ep_num;

	if (!ep_is_valid(ep)) {
		return NULL;
    3914:	2000      	movs	r0, #0
    3916:	4770      	bx	lr
	}

	ctx = get_usbd_ctx();
	ep_num = NRF_USBD_EP_NR_GET(ep);

	if (NRF_USBD_EPIN_CHECK(ep)) {
    3918:	2a00      	cmp	r2, #0
	ep_num = NRF_USBD_EP_NR_GET(ep);
    391a:	f000 030f 	and.w	r3, r0, #15
	if (NRF_USBD_EPIN_CHECK(ep)) {
    391e:	f000 0008 	and.w	r0, r0, #8
    3922:	da05      	bge.n	3930 <endpoint_ctx+0x2c>
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
    3924:	b958      	cbnz	r0, 393e <endpoint_ctx+0x3a>
			return &ctx->ep_ctx[EP_ISOIN_INDEX];
		} else {
			return &ctx->ep_ctx[ep_num];
    3926:	4808      	ldr	r0, [pc, #32]	; (3948 <endpoint_ctx+0x44>)
    3928:	eb00 1043 	add.w	r0, r0, r3, lsl #5
    392c:	304c      	adds	r0, #76	; 0x4c
    392e:	4770      	bx	lr
		}
	} else {
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
    3930:	b938      	cbnz	r0, 3942 <endpoint_ctx+0x3e>
			return &ctx->ep_ctx[EP_ISOOUT_INDEX];
		} else {
			return &ctx->ep_ctx[CFG_EPIN_CNT +
    3932:	4805      	ldr	r0, [pc, #20]	; (3948 <endpoint_ctx+0x44>)
    3934:	eb00 1043 	add.w	r0, r0, r3, lsl #5
    3938:	f500 70b6 	add.w	r0, r0, #364	; 0x16c
    393c:	4770      	bx	lr
			return &ctx->ep_ctx[EP_ISOIN_INDEX];
    393e:	4803      	ldr	r0, [pc, #12]	; (394c <endpoint_ctx+0x48>)
    3940:	4770      	bx	lr
			return &ctx->ep_ctx[EP_ISOOUT_INDEX];
    3942:	4803      	ldr	r0, [pc, #12]	; (3950 <endpoint_ctx+0x4c>)
					    ep_num];
		}
	}

	return NULL;
}
    3944:	4770      	bx	lr
    3946:	bf00      	nop
    3948:	20000db4 	.word	0x20000db4
    394c:	20000f00 	.word	0x20000f00
    3950:	20001020 	.word	0x20001020

00003954 <usbd_evt_put>:
 * @brief Enqueue USBD event.
 *
 * @param Pointer to the previously allocated and filled event structure.
 */
static inline void usbd_evt_put(struct usbd_event *ev)
{
    3954:	4601      	mov	r1, r0
	k_fifo_put(&usbd_evt_fifo, ev);
    3956:	4801      	ldr	r0, [pc, #4]	; (395c <usbd_evt_put+0x8>)
    3958:	f005 bd0a 	b.w	9370 <k_queue_append>
    395c:	200001dc 	.word	0x200001dc

00003960 <usbd_work_schedule>:
	k_work_submit_to_queue(&usbd_work_queue, &get_usbd_ctx()->usb_work);
    3960:	4901      	ldr	r1, [pc, #4]	; (3968 <usbd_work_schedule+0x8>)
    3962:	4802      	ldr	r0, [pc, #8]	; (396c <usbd_work_schedule+0xc>)
    3964:	f005 bd36 	b.w	93d4 <k_work_submit_to_queue>
    3968:	20000ddc 	.word	0x20000ddc
    396c:	20000378 	.word	0x20000378

00003970 <usb_init>:
	}
	return 0;
}

static int usb_init(const struct device *arg)
{
    3970:	b513      	push	{r0, r1, r4, lr}
	};

	/* Ignore the return value, as NRFX_ERROR_ALREADY_INITIALIZED is not
	 * a problem here.
	 */
	(void)nrfx_power_init(&power_config);
    3972:	480b      	ldr	r0, [pc, #44]	; (39a0 <usb_init+0x30>)
    3974:	f002 f860 	bl	5a38 <nrfx_power_init>
	nrfx_power_usbevt_init(&usbevt_config);

	k_work_queue_start(&usbd_work_queue,
    3978:	2400      	movs	r4, #0
	nrfx_power_usbevt_init(&usbevt_config);
    397a:	480a      	ldr	r0, [pc, #40]	; (39a4 <usb_init+0x34>)
    397c:	f002 f8a2 	bl	5ac4 <nrfx_power_usbevt_init>
	k_work_queue_start(&usbd_work_queue,
    3980:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3984:	f44f 6280 	mov.w	r2, #1024	; 0x400
    3988:	4907      	ldr	r1, [pc, #28]	; (39a8 <usb_init+0x38>)
    398a:	4808      	ldr	r0, [pc, #32]	; (39ac <usb_init+0x3c>)
    398c:	9400      	str	r4, [sp, #0]
    398e:	f003 fcbd 	bl	730c <k_work_queue_start>
			   usbd_work_queue_stack,
			   K_KERNEL_STACK_SIZEOF(usbd_work_queue_stack),
			   CONFIG_SYSTEM_WORKQUEUE_PRIORITY, NULL);

	k_work_init(&ctx->usb_work, usbd_work_handler);
    3992:	4907      	ldr	r1, [pc, #28]	; (39b0 <usb_init+0x40>)
    3994:	4807      	ldr	r0, [pc, #28]	; (39b4 <usb_init+0x44>)
    3996:	f005 fd14 	bl	93c2 <k_work_init>

	return 0;
}
    399a:	4620      	mov	r0, r4
    399c:	b002      	add	sp, #8
    399e:	bd10      	pop	{r4, pc}
    39a0:	00009cc2 	.word	0x00009cc2
    39a4:	00009ac8 	.word	0x00009ac8
    39a8:	200017e0 	.word	0x200017e0
    39ac:	20000378 	.word	0x20000378
    39b0:	00003ccd 	.word	0x00003ccd
    39b4:	20000ddc 	.word	0x20000ddc

000039b8 <usbd_evt_get>:
	return z_impl_k_queue_get(queue, timeout);
    39b8:	4802      	ldr	r0, [pc, #8]	; (39c4 <usbd_evt_get+0xc>)
    39ba:	2200      	movs	r2, #0
    39bc:	2300      	movs	r3, #0
    39be:	f003 bb43 	b.w	7048 <z_impl_k_queue_get>
    39c2:	bf00      	nop
    39c4:	200001dc 	.word	0x200001dc

000039c8 <usbd_evt_flush>:
{
    39c8:	b510      	push	{r4, lr}
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
    39ca:	4c05      	ldr	r4, [pc, #20]	; (39e0 <usbd_evt_flush+0x18>)
		ev = usbd_evt_get();
    39cc:	f7ff fff4 	bl	39b8 <usbd_evt_get>
		if (ev) {
    39d0:	b120      	cbz	r0, 39dc <usbd_evt_flush+0x14>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
    39d2:	1d01      	adds	r1, r0, #4
    39d4:	4620      	mov	r0, r4
    39d6:	f005 fc15 	bl	9204 <k_mem_slab_free>
	} while (ev != NULL);
    39da:	e7f7      	b.n	39cc <usbd_evt_flush+0x4>
}
    39dc:	bd10      	pop	{r4, pc}
    39de:	bf00      	nop
    39e0:	200001ac 	.word	0x200001ac

000039e4 <usbd_evt_alloc>:
{
    39e4:	b507      	push	{r0, r1, r2, lr}
	if (k_mem_slab_alloc(&fifo_elem_slab,
    39e6:	2300      	movs	r3, #0
    39e8:	480e      	ldr	r0, [pc, #56]	; (3a24 <usbd_evt_alloc+0x40>)
    39ea:	2200      	movs	r2, #0
    39ec:	a901      	add	r1, sp, #4
    39ee:	f003 f973 	bl	6cd8 <k_mem_slab_alloc>
    39f2:	b190      	cbz	r0, 3a1a <usbd_evt_alloc+0x36>
		usbd_evt_flush();
    39f4:	f7ff ffe8 	bl	39c8 <usbd_evt_flush>
		if (k_mem_slab_alloc(&fifo_elem_slab, (void **)&block.data, K_NO_WAIT)) {
    39f8:	480a      	ldr	r0, [pc, #40]	; (3a24 <usbd_evt_alloc+0x40>)
    39fa:	2200      	movs	r2, #0
    39fc:	2300      	movs	r3, #0
    39fe:	a901      	add	r1, sp, #4
    3a00:	f003 f96a 	bl	6cd8 <k_mem_slab_alloc>
    3a04:	b938      	cbnz	r0, 3a16 <usbd_evt_alloc+0x32>
		ev = (struct usbd_event *)block.data;
    3a06:	9801      	ldr	r0, [sp, #4]
		ev->evt_type = USBD_EVT_REINIT;
    3a08:	2304      	movs	r3, #4
		ev->block = block;
    3a0a:	6040      	str	r0, [r0, #4]
		ev->evt_type = USBD_EVT_REINIT;
    3a0c:	7403      	strb	r3, [r0, #16]
		usbd_evt_put(ev);
    3a0e:	f7ff ffa1 	bl	3954 <usbd_evt_put>
		usbd_work_schedule();
    3a12:	f7ff ffa5 	bl	3960 <usbd_work_schedule>
		return NULL;
    3a16:	2000      	movs	r0, #0
    3a18:	e001      	b.n	3a1e <usbd_evt_alloc+0x3a>
	ev = (struct usbd_event *)block.data;
    3a1a:	9801      	ldr	r0, [sp, #4]
	ev->block = block;
    3a1c:	6040      	str	r0, [r0, #4]
}
    3a1e:	b003      	add	sp, #12
    3a20:	f85d fb04 	ldr.w	pc, [sp], #4
    3a24:	200001ac 	.word	0x200001ac

00003a28 <usbd_event_transfer_data>:
		endpoint_ctx(p_event->data.eptransfer.ep);
    3a28:	7881      	ldrb	r1, [r0, #2]
{
    3a2a:	b570      	push	{r4, r5, r6, lr}
    3a2c:	4606      	mov	r6, r0
		endpoint_ctx(p_event->data.eptransfer.ep);
    3a2e:	4608      	mov	r0, r1
    3a30:	f7ff ff68 	bl	3904 <endpoint_ctx>
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
    3a34:	060b      	lsls	r3, r1, #24
		switch (p_event->data.eptransfer.status) {
    3a36:	78f5      	ldrb	r5, [r6, #3]
		endpoint_ctx(p_event->data.eptransfer.ep);
    3a38:	4604      	mov	r4, r0
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
    3a3a:	d512      	bpl.n	3a62 <usbd_event_transfer_data+0x3a>
		switch (p_event->data.eptransfer.status) {
    3a3c:	2d00      	cmp	r5, #0
    3a3e:	d143      	bne.n	3ac8 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x30>
			struct usbd_event *ev = usbd_evt_alloc();
    3a40:	f7ff ffd0 	bl	39e4 <usbd_evt_alloc>
			if (!ev) {
    3a44:	4603      	mov	r3, r0
    3a46:	2800      	cmp	r0, #0
    3a48:	d03e      	beq.n	3ac8 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x30>
			ev->evt_type = USBD_EVT_EP;
    3a4a:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
    3a4c:	77a5      	strb	r5, [r4, #30]
			ev->evt_type = USBD_EVT_EP;
    3a4e:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
    3a50:	2203      	movs	r2, #3
    3a52:	7302      	strb	r2, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
    3a54:	609c      	str	r4, [r3, #8]
			usbd_evt_put(ev);
    3a56:	f7ff ff7d 	bl	3954 <usbd_evt_put>
}
    3a5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			usbd_work_schedule();
    3a5e:	f7ff bf7f 	b.w	3960 <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
    3a62:	b14d      	cbz	r5, 3a78 <usbd_event_transfer_data+0x50>
    3a64:	2d01      	cmp	r5, #1
    3a66:	d12f      	bne.n	3ac8 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x30>
			struct usbd_event *ev = usbd_evt_alloc();
    3a68:	f7ff ffbc 	bl	39e4 <usbd_evt_alloc>
			if (!ev) {
    3a6c:	4603      	mov	r3, r0
    3a6e:	b358      	cbz	r0, 3ac8 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x30>
			ep_ctx->read_pending = true;
    3a70:	7765      	strb	r5, [r4, #29]
			ev->evt_type = USBD_EVT_EP;
    3a72:	7405      	strb	r5, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
    3a74:	7305      	strb	r5, [r0, #12]
    3a76:	e7ed      	b.n	3a54 <usbd_event_transfer_data+0x2c>
			struct usbd_event *ev = usbd_evt_alloc();
    3a78:	f7ff ffb4 	bl	39e4 <usbd_evt_alloc>
			if (!ev) {
    3a7c:	b320      	cbz	r0, 3ac8 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x30>
				p_event->data.eptransfer.ep);
    3a7e:	78b2      	ldrb	r2, [r6, #2]

NRF_STATIC_INLINE uint32_t nrf_usbd_ep_amount_get(NRF_USBD_Type const * p_reg, uint8_t ep)
{
    uint32_t ret;

    if (NRF_USBD_EPIN_CHECK(ep))
    3a80:	4b12      	ldr	r3, [pc, #72]	; (3acc <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x34>)
    3a82:	f012 0f80 	tst.w	r2, #128	; 0x80
    3a86:	f002 0108 	and.w	r1, r2, #8
    3a8a:	d011      	beq.n	3ab0 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x18>
    {
        if (NRF_USBD_EPISO_CHECK(ep))
    3a8c:	b141      	cbz	r1, 3aa0 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x8>
        {
            ret = p_reg->ISOIN.AMOUNT;
    3a8e:	f8d3 36a8 	ldr.w	r3, [r3, #1704]	; 0x6a8
			ep_ctx->buf.len = nrf_usbd_ep_amount_get(NRF_USBD,
    3a92:	60e3      	str	r3, [r4, #12]
			ev->evt_type = USBD_EVT_EP;
    3a94:	2301      	movs	r3, #1
    3a96:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
    3a98:	2302      	movs	r3, #2
    3a9a:	7303      	strb	r3, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
    3a9c:	6084      	str	r4, [r0, #8]
    3a9e:	e7da      	b.n	3a56 <usbd_event_transfer_data+0x2e>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPIN[epnr].AMOUNT;
    3aa0:	f002 020f 	and.w	r2, r2, #15
    3aa4:	2114      	movs	r1, #20
    3aa6:	fb01 3302 	mla	r3, r1, r2, r3
    3aaa:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    3aae:	e7f0      	b.n	3a92 <usbd_event_transfer_data+0x6a>
        }
    }
    else
    {
        if (NRF_USBD_EPISO_CHECK(ep))
    3ab0:	b111      	cbz	r1, 3ab8 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x20>
        {
            ret = p_reg->ISOOUT.AMOUNT;
    3ab2:	f8d3 37a8 	ldr.w	r3, [r3, #1960]	; 0x7a8
    3ab6:	e7ec      	b.n	3a92 <usbd_event_transfer_data+0x6a>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPOUT[epnr].AMOUNT;
    3ab8:	f002 020f 	and.w	r2, r2, #15
    3abc:	2114      	movs	r1, #20
    3abe:	fb01 3302 	mla	r3, r1, r2, r3
    3ac2:	f8d3 3708 	ldr.w	r3, [r3, #1800]	; 0x708
    3ac6:	e7e4      	b.n	3a92 <usbd_event_transfer_data+0x6a>
}
    3ac8:	bd70      	pop	{r4, r5, r6, pc}
    3aca:	bf00      	nop
    3acc:	40027000 	.word	0x40027000

00003ad0 <usb_dc_power_event_handler>:
	switch (event) {
    3ad0:	2802      	cmp	r0, #2
{
    3ad2:	b510      	push	{r4, lr}
    3ad4:	d811      	bhi.n	3afa <usb_dc_power_event_handler+0x2a>
    3ad6:	4b09      	ldr	r3, [pc, #36]	; (3afc <usb_dc_power_event_handler+0x2c>)
    3ad8:	5c1c      	ldrb	r4, [r3, r0]
	struct usbd_event *ev = usbd_evt_alloc();
    3ada:	f7ff ff83 	bl	39e4 <usbd_evt_alloc>
	if (!ev) {
    3ade:	b160      	cbz	r0, 3afa <usb_dc_power_event_handler+0x2a>
	ev->evt_type = USBD_EVT_POWER;
    3ae0:	2200      	movs	r2, #0
    3ae2:	7402      	strb	r2, [r0, #16]
	ev->evt.pwr_evt.state = state;
    3ae4:	7204      	strb	r4, [r0, #8]
	usbd_evt_put(ev);
    3ae6:	f7ff ff35 	bl	3954 <usbd_evt_put>
	if (usbd_ctx.attached) {
    3aea:	4b05      	ldr	r3, [pc, #20]	; (3b00 <usb_dc_power_event_handler+0x30>)
    3aec:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    3af0:	b11b      	cbz	r3, 3afa <usb_dc_power_event_handler+0x2a>
}
    3af2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usbd_work_schedule();
    3af6:	f7ff bf33 	b.w	3960 <usbd_work_schedule>
}
    3afa:	bd10      	pop	{r4, pc}
    3afc:	00009cbf 	.word	0x00009cbf
    3b00:	20000db4 	.word	0x20000db4

00003b04 <hfxo_stop.constprop.0.isra.0>:
static int hfxo_stop(struct nrf_usbd_ctx *ctx)
    3b04:	b510      	push	{r4, lr}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    3b06:	490f      	ldr	r1, [pc, #60]	; (3b44 <hfxo_stop.constprop.0.isra.0+0x40>)
    3b08:	f3bf 8f5b 	dmb	ish
    3b0c:	f101 0320 	add.w	r3, r1, #32
    3b10:	2200      	movs	r2, #0
    3b12:	e853 0f00 	ldrex	r0, [r3]
    3b16:	2801      	cmp	r0, #1
    3b18:	d103      	bne.n	3b22 <hfxo_stop.constprop.0.isra.0+0x1e>
    3b1a:	e843 2400 	strex	r4, r2, [r3]
    3b1e:	2c00      	cmp	r4, #0
    3b20:	d1f7      	bne.n	3b12 <hfxo_stop.constprop.0.isra.0+0xe>
    3b22:	f3bf 8f5b 	dmb	ish
	if (atomic_cas(&ctx->clk_requested, 1, 0)) {
    3b26:	d10b      	bne.n	3b40 <hfxo_stop.constprop.0.isra.0+0x3c>
		return onoff_cancel_or_release(ctx->hfxo_mgr, &ctx->hfxo_cli);
    3b28:	69cc      	ldr	r4, [r1, #28]
 * @retval negative other errors produced by onoff_release().
 */
static inline int onoff_cancel_or_release(struct onoff_manager *mgr,
					  struct onoff_client *cli)
{
	int rv = onoff_cancel(mgr, cli);
    3b2a:	310c      	adds	r1, #12
    3b2c:	4620      	mov	r0, r4
    3b2e:	f004 fa53 	bl	7fd8 <onoff_cancel>

	if (rv == -EALREADY) {
    3b32:	3078      	adds	r0, #120	; 0x78
    3b34:	d104      	bne.n	3b40 <hfxo_stop.constprop.0.isra.0+0x3c>
		rv = onoff_release(mgr);
    3b36:	4620      	mov	r0, r4
}
    3b38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    3b3c:	f004 ba27 	b.w	7f8e <onoff_release>
    3b40:	bd10      	pop	{r4, pc}
    3b42:	bf00      	nop
    3b44:	20000db4 	.word	0x20000db4

00003b48 <usbd_event_handler>:
{
    3b48:	b5f0      	push	{r4, r5, r6, r7, lr}
    3b4a:	4606      	mov	r6, r0
    3b4c:	b089      	sub	sp, #36	; 0x24
	struct usbd_event evt = {0};
    3b4e:	2214      	movs	r2, #20
    3b50:	2100      	movs	r1, #0
    3b52:	a803      	add	r0, sp, #12
    3b54:	f004 febb 	bl	88ce <memset>
	switch (p_event->type) {
    3b58:	7833      	ldrb	r3, [r6, #0]
    3b5a:	3b01      	subs	r3, #1
    3b5c:	2b05      	cmp	r3, #5
    3b5e:	d821      	bhi.n	3ba4 <usbd_event_handler+0x5c>
    3b60:	e8df f003 	tbb	[pc, r3]
    3b64:	1414037a 	.word	0x1414037a
    3b68:	166a      	.short	0x166a
		evt.evt.pwr_evt.state = USBD_SUSPENDED;
    3b6a:	2303      	movs	r3, #3
		evt.evt.pwr_evt.state = USBD_RESUMED;
    3b6c:	f88d 3014 	strb.w	r3, [sp, #20]
		evt.evt_type = USBD_EVT_POWER;
    3b70:	2400      	movs	r4, #0
		ev = usbd_evt_alloc();
    3b72:	f7ff ff37 	bl	39e4 <usbd_evt_alloc>
		if (!ev) {
    3b76:	4603      	mov	r3, r0
    3b78:	b1a0      	cbz	r0, 3ba4 <usbd_event_handler+0x5c>
		ev->evt_type = evt.evt_type;
    3b7a:	7404      	strb	r4, [r0, #16]
		ev->evt = evt.evt;
    3b7c:	f100 0208 	add.w	r2, r0, #8
    3b80:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
    3b84:	e882 0003 	stmia.w	r2, {r0, r1}
		usbd_evt_put(ev);
    3b88:	4618      	mov	r0, r3
    3b8a:	e01d      	b.n	3bc8 <usbd_event_handler+0x80>
		evt.evt.pwr_evt.state = USBD_RESUMED;
    3b8c:	2304      	movs	r3, #4
    3b8e:	e7ed      	b.n	3b6c <usbd_event_handler+0x24>
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
    3b90:	78b1      	ldrb	r1, [r6, #2]
    3b92:	4608      	mov	r0, r1
    3b94:	f7ff feb6 	bl	3904 <endpoint_ctx>
		switch (ep_ctx->cfg.type) {
    3b98:	7a83      	ldrb	r3, [r0, #10]
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
    3b9a:	4604      	mov	r4, r0
		switch (ep_ctx->cfg.type) {
    3b9c:	b123      	cbz	r3, 3ba8 <usbd_event_handler+0x60>
    3b9e:	3b01      	subs	r3, #1
    3ba0:	2b02      	cmp	r3, #2
    3ba2:	d943      	bls.n	3c2c <usbd_event_handler+0xe4>
}
    3ba4:	b009      	add	sp, #36	; 0x24
    3ba6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
    3ba8:	060b      	lsls	r3, r1, #24
		switch (p_event->data.eptransfer.status) {
    3baa:	78f5      	ldrb	r5, [r6, #3]
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
    3bac:	d513      	bpl.n	3bd6 <usbd_event_handler+0x8e>
		switch (p_event->data.eptransfer.status) {
    3bae:	2d00      	cmp	r5, #0
    3bb0:	d1f8      	bne.n	3ba4 <usbd_event_handler+0x5c>
			struct usbd_event *ev = usbd_evt_alloc();
    3bb2:	f7ff ff17 	bl	39e4 <usbd_evt_alloc>
			if (!ev) {
    3bb6:	4603      	mov	r3, r0
    3bb8:	2800      	cmp	r0, #0
    3bba:	d0f3      	beq.n	3ba4 <usbd_event_handler+0x5c>
			ev->evt_type = USBD_EVT_EP;
    3bbc:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
    3bbe:	77a5      	strb	r5, [r4, #30]
			ev->evt_type = USBD_EVT_EP;
    3bc0:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
    3bc2:	2203      	movs	r2, #3
    3bc4:	7302      	strb	r2, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
    3bc6:	609c      	str	r4, [r3, #8]
		usbd_evt_put(ev);
    3bc8:	f7ff fec4 	bl	3954 <usbd_evt_put>
}
    3bcc:	b009      	add	sp, #36	; 0x24
    3bce:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		usbd_work_schedule();
    3bd2:	f7ff bec5 	b.w	3960 <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
    3bd6:	b155      	cbz	r5, 3bee <usbd_event_handler+0xa6>
    3bd8:	2d01      	cmp	r5, #1
    3bda:	d1e3      	bne.n	3ba4 <usbd_event_handler+0x5c>
			struct usbd_event *ev = usbd_evt_alloc();
    3bdc:	f7ff ff02 	bl	39e4 <usbd_evt_alloc>
			if (!ev) {
    3be0:	4603      	mov	r3, r0
    3be2:	2800      	cmp	r0, #0
    3be4:	d0de      	beq.n	3ba4 <usbd_event_handler+0x5c>
			ep_ctx->read_pending = true;
    3be6:	7765      	strb	r5, [r4, #29]
			ev->evt_type = USBD_EVT_EP;
    3be8:	7405      	strb	r5, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
    3bea:	7305      	strb	r5, [r0, #12]
    3bec:	e7eb      	b.n	3bc6 <usbd_event_handler+0x7e>
			struct usbd_event *ev = usbd_evt_alloc();
    3bee:	f7ff fef9 	bl	39e4 <usbd_evt_alloc>
			if (!ev) {
    3bf2:	4607      	mov	r7, r0
    3bf4:	2800      	cmp	r0, #0
    3bf6:	d0d5      	beq.n	3ba4 <usbd_event_handler+0x5c>
			ev->evt_type = USBD_EVT_EP;
    3bf8:	2301      	movs	r3, #1
    3bfa:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
    3bfc:	2302      	movs	r3, #2
    3bfe:	7303      	strb	r3, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
    3c00:	6084      	str	r4, [r0, #8]
			err_code = nrfx_usbd_ep_status_get(
    3c02:	f104 010c 	add.w	r1, r4, #12
    3c06:	78b0      	ldrb	r0, [r6, #2]
    3c08:	f005 fa9c 	bl	9144 <nrfx_usbd_ep_status_get>
			if (ctx->ctrl_read_len > ep_ctx->buf.len) {
    3c0c:	4a13      	ldr	r2, [pc, #76]	; (3c5c <usbd_event_handler+0x114>)
    3c0e:	68e1      	ldr	r1, [r4, #12]
    3c10:	f8b2 328c 	ldrh.w	r3, [r2, #652]	; 0x28c
    3c14:	428b      	cmp	r3, r1
    3c16:	d906      	bls.n	3c26 <usbd_event_handler+0xde>
				ctx->ctrl_read_len -= ep_ctx->buf.len;
    3c18:	1a5b      	subs	r3, r3, r1
    3c1a:	f8a2 328c 	strh.w	r3, [r2, #652]	; 0x28c
				nrfx_usbd_setup_data_clear();
    3c1e:	f002 fcb1 	bl	6584 <nrfx_usbd_setup_data_clear>
			usbd_evt_put(ev);
    3c22:	4638      	mov	r0, r7
    3c24:	e7d0      	b.n	3bc8 <usbd_event_handler+0x80>
				ctx->ctrl_read_len = 0U;
    3c26:	f8a2 528c 	strh.w	r5, [r2, #652]	; 0x28c
    3c2a:	e7fa      	b.n	3c22 <usbd_event_handler+0xda>
			usbd_event_transfer_data(p_event);
    3c2c:	4630      	mov	r0, r6
}
    3c2e:	b009      	add	sp, #36	; 0x24
    3c30:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			usbd_event_transfer_data(p_event);
    3c34:	f7ff bef8 	b.w	3a28 <usbd_event_transfer_data>
		nrfx_usbd_setup_get(&drv_setup);
    3c38:	a801      	add	r0, sp, #4
    3c3a:	f002 fc7d 	bl	6538 <nrfx_usbd_setup_get>
		if ((drv_setup.bRequest != USB_SREQ_SET_ADDRESS)
    3c3e:	f89d 3005 	ldrb.w	r3, [sp, #5]
    3c42:	2b05      	cmp	r3, #5
    3c44:	d104      	bne.n	3c50 <usbd_event_handler+0x108>
		    || (USB_REQTYPE_GET_TYPE(drv_setup.bmRequestType)
    3c46:	f89d 3004 	ldrb.w	r3, [sp, #4]
    3c4a:	f013 0f60 	tst.w	r3, #96	; 0x60
    3c4e:	d0a9      	beq.n	3ba4 <usbd_event_handler+0x5c>
			evt.evt.ep_evt.ep = ep_ctx;
    3c50:	4b03      	ldr	r3, [pc, #12]	; (3c60 <usbd_event_handler+0x118>)
    3c52:	9305      	str	r3, [sp, #20]
			evt.evt_type = USBD_EVT_EP;
    3c54:	2401      	movs	r4, #1
    3c56:	e78c      	b.n	3b72 <usbd_event_handler+0x2a>
	switch (p_event->type) {
    3c58:	2402      	movs	r4, #2
    3c5a:	e78a      	b.n	3b72 <usbd_event_handler+0x2a>
    3c5c:	20000db4 	.word	0x20000db4
    3c60:	20000f20 	.word	0x20000f20

00003c64 <eps_ctx_init>:
{
    3c64:	b538      	push	{r3, r4, r5, lr}
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
    3c66:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
    3c68:	f064 007f 	orn	r0, r4, #127	; 0x7f
    3c6c:	b2c0      	uxtb	r0, r0
    3c6e:	f7ff fe49 	bl	3904 <endpoint_ctx>
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
    3c72:	3401      	adds	r4, #1
		ep_ctx_reset(ep_ctx);
    3c74:	f004 fe55 	bl	8922 <ep_ctx_reset>
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
    3c78:	2c08      	cmp	r4, #8
    3c7a:	d1f5      	bne.n	3c68 <eps_ctx_init+0x4>
    3c7c:	4d0f      	ldr	r5, [pc, #60]	; (3cbc <eps_ctx_init+0x58>)
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
    3c7e:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
    3c80:	b2e0      	uxtb	r0, r4
    3c82:	f7ff fe3f 	bl	3904 <endpoint_ctx>
		if (!ep_ctx->buf.block.data) {
    3c86:	6903      	ldr	r3, [r0, #16]
    3c88:	b903      	cbnz	r3, 3c8c <eps_ctx_init+0x28>
			ep_ctx->buf.block.data = ep_out_bufs[i];
    3c8a:	6105      	str	r5, [r0, #16]
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
    3c8c:	3401      	adds	r4, #1
		ep_ctx_reset(ep_ctx);
    3c8e:	f004 fe48 	bl	8922 <ep_ctx_reset>
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
    3c92:	2c08      	cmp	r4, #8
    3c94:	f105 0540 	add.w	r5, r5, #64	; 0x40
    3c98:	d1f2      	bne.n	3c80 <eps_ctx_init+0x1c>
		ep_ctx_reset(ep_ctx);
    3c9a:	4c09      	ldr	r4, [pc, #36]	; (3cc0 <eps_ctx_init+0x5c>)
    3c9c:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
    3ca0:	f004 fe3f 	bl	8922 <ep_ctx_reset>
		if (!ep_ctx->buf.block.data) {
    3ca4:	f8d4 327c 	ldr.w	r3, [r4, #636]	; 0x27c
    3ca8:	b913      	cbnz	r3, 3cb0 <eps_ctx_init+0x4c>
			ep_ctx->buf.block.data = ep_isoout_bufs[0];
    3caa:	4b06      	ldr	r3, [pc, #24]	; (3cc4 <eps_ctx_init+0x60>)
    3cac:	f8c4 327c 	str.w	r3, [r4, #636]	; 0x27c
		ep_ctx_reset(ep_ctx);
    3cb0:	4805      	ldr	r0, [pc, #20]	; (3cc8 <eps_ctx_init+0x64>)
    3cb2:	f004 fe36 	bl	8922 <ep_ctx_reset>
}
    3cb6:	2000      	movs	r0, #0
    3cb8:	bd38      	pop	{r3, r4, r5, pc}
    3cba:	bf00      	nop
    3cbc:	20000bb4 	.word	0x20000bb4
    3cc0:	20000db4 	.word	0x20000db4
    3cc4:	200007b4 	.word	0x200007b4
    3cc8:	20001020 	.word	0x20001020

00003ccc <usbd_work_handler>:
{
    3ccc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return get_usbd_ctx()->ready;
    3cd0:	4ca8      	ldr	r4, [pc, #672]	; (3f74 <usbd_work_handler+0x2a8>)
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
    3cd2:	f8df 82a4 	ldr.w	r8, [pc, #676]	; 3f78 <usbd_work_handler+0x2ac>
{
    3cd6:	b085      	sub	sp, #20
    3cd8:	4607      	mov	r7, r0
	while ((ev = usbd_evt_get()) != NULL) {
    3cda:	f7ff fe6d 	bl	39b8 <usbd_evt_get>
    3cde:	b910      	cbnz	r0, 3ce6 <usbd_work_handler+0x1a>
}
    3ce0:	b005      	add	sp, #20
    3ce2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return get_usbd_ctx()->ready;
    3ce6:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
    3cea:	7c02      	ldrb	r2, [r0, #16]
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
    3cec:	f100 0904 	add.w	r9, r0, #4
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
    3cf0:	b93b      	cbnz	r3, 3d02 <usbd_work_handler+0x36>
    3cf2:	2a00      	cmp	r2, #0
    3cf4:	f000 8086 	beq.w	3e04 <usbd_work_handler+0x138>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
    3cf8:	4649      	mov	r1, r9
    3cfa:	4640      	mov	r0, r8
    3cfc:	f005 fa82 	bl	9204 <k_mem_slab_free>
}
    3d00:	e7eb      	b.n	3cda <usbd_work_handler+0xe>
		switch (ev->evt_type) {
    3d02:	2a04      	cmp	r2, #4
    3d04:	d8f8      	bhi.n	3cf8 <usbd_work_handler+0x2c>
    3d06:	e8df f012 	tbh	[pc, r2, lsl #1]
    3d0a:	007d      	.short	0x007d
    3d0c:	01030005 	.word	0x01030005
    3d10:	01430119 	.word	0x01430119
	switch (ep_evt->evt_type) {
    3d14:	7b03      	ldrb	r3, [r0, #12]
	struct nrf_usbd_ep_ctx *ep_ctx = ep_evt->ep;
    3d16:	6885      	ldr	r5, [r0, #8]
	switch (ep_evt->evt_type) {
    3d18:	2b03      	cmp	r3, #3
    3d1a:	d8ed      	bhi.n	3cf8 <usbd_work_handler+0x2c>
    3d1c:	e8df f003 	tbb	[pc, r3]
    3d20:	5f5a3d02 	.word	0x5f5a3d02
	usbd_setup = (struct usb_setup_packet *)ep_ctx->buf.data;
    3d24:	696e      	ldr	r6, [r5, #20]
	memset(usbd_setup, 0, sizeof(struct usb_setup_packet));
    3d26:	2208      	movs	r2, #8
    3d28:	2100      	movs	r1, #0
    3d2a:	4630      	mov	r0, r6
    3d2c:	f004 fdcf 	bl	88ce <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
    3d30:	4b92      	ldr	r3, [pc, #584]	; (3f7c <usbd_work_handler+0x2b0>)
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
    3d32:	4893      	ldr	r0, [pc, #588]	; (3f80 <usbd_work_handler+0x2b4>)
    3d34:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
    3d38:	7032      	strb	r2, [r6, #0]
    return (uint8_t)(p_reg->BREQUEST);
    3d3a:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
    3d3e:	7072      	strb	r2, [r6, #1]
    const uint16_t val = p_reg->WVALUEL;
    3d40:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
    3d44:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
    3d48:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	usbd_setup->wValue = nrf_usbd_setup_wvalue_get(NRF_USBD);
    3d4c:	8072      	strh	r2, [r6, #2]
    const uint16_t val = p_reg->WINDEXL;
    3d4e:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
    3d52:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
    3d56:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	usbd_setup->wIndex = nrf_usbd_setup_windex_get(NRF_USBD);
    3d5a:	80b2      	strh	r2, [r6, #4]
    const uint16_t val = p_reg->WLENGTHL;
    3d5c:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
    3d60:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
    3d64:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
    3d68:	2208      	movs	r2, #8
	usbd_setup->wLength = nrf_usbd_setup_wlength_get(NRF_USBD);
    3d6a:	80f3      	strh	r3, [r6, #6]
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
    3d6c:	4631      	mov	r1, r6
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
    3d6e:	60ea      	str	r2, [r5, #12]
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
    3d70:	f004 fda2 	bl	88b8 <memcpy>
	ep_ctx->cfg.cb(ep_ctx->cfg.addr, USB_DC_EP_SETUP);
    3d74:	682b      	ldr	r3, [r5, #0]
    3d76:	7a68      	ldrb	r0, [r5, #9]
    3d78:	2100      	movs	r1, #0
    3d7a:	4798      	blx	r3
	if (usb_reqtype_is_to_device(usbd_setup) && usbd_setup->wLength) {
    3d7c:	f996 3000 	ldrsb.w	r3, [r6]
    3d80:	2b00      	cmp	r3, #0
    3d82:	db06      	blt.n	3d92 <usbd_work_handler+0xc6>
    3d84:	88f3      	ldrh	r3, [r6, #6]
    3d86:	b123      	cbz	r3, 3d92 <usbd_work_handler+0xc6>
		ctx->ctrl_read_len = usbd_setup->wLength;
    3d88:	f8a4 328c 	strh.w	r3, [r4, #652]	; 0x28c
		nrfx_usbd_setup_data_clear();
    3d8c:	f002 fbfa 	bl	6584 <nrfx_usbd_setup_data_clear>
    3d90:	e7b2      	b.n	3cf8 <usbd_work_handler+0x2c>
		ctx->ctrl_read_len = 0U;
    3d92:	2300      	movs	r3, #0
    3d94:	f8a4 328c 	strh.w	r3, [r4, #652]	; 0x28c
    3d98:	e7ae      	b.n	3cf8 <usbd_work_handler+0x2c>
	if (!ep_ctx->read_pending) {
    3d9a:	7f6b      	ldrb	r3, [r5, #29]
    3d9c:	2b00      	cmp	r3, #0
    3d9e:	d0ab      	beq.n	3cf8 <usbd_work_handler+0x2c>
	if (!ep_ctx->read_complete) {
    3da0:	7f2b      	ldrb	r3, [r5, #28]
    3da2:	2b00      	cmp	r3, #0
    3da4:	d0a8      	beq.n	3cf8 <usbd_work_handler+0x2c>
	ep_ctx->read_pending = false;
    3da6:	2600      	movs	r6, #0
    3da8:	776e      	strb	r6, [r5, #29]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    3daa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3dae:	4875      	ldr	r0, [pc, #468]	; (3f84 <usbd_work_handler+0x2b8>)
	ep_ctx->read_complete = false;
    3db0:	772e      	strb	r6, [r5, #28]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    3db2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3db6:	f004 fdc7 	bl	8948 <k_mutex_lock.constprop.0.isra.0>
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
    3dba:	696b      	ldr	r3, [r5, #20]
    3dbc:	9301      	str	r3, [sp, #4]
    3dbe:	686b      	ldr	r3, [r5, #4]
    3dc0:	e9cd 3602 	strd	r3, r6, [sp, #8]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
    3dc4:	a901      	add	r1, sp, #4
    3dc6:	7a68      	ldrb	r0, [r5, #9]
    3dc8:	f002 f9e6 	bl	6198 <nrfx_usbd_ep_transfer>
	k_mutex_unlock(&ctx->drv_lock);
    3dcc:	486d      	ldr	r0, [pc, #436]	; (3f84 <usbd_work_handler+0x2b8>)
    3dce:	f004 fdbd 	bl	894c <k_mutex_unlock.isra.0>
    3dd2:	e791      	b.n	3cf8 <usbd_work_handler+0x2c>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
    3dd4:	682b      	ldr	r3, [r5, #0]
    3dd6:	2101      	movs	r1, #1
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
    3dd8:	7a68      	ldrb	r0, [r5, #9]
    3dda:	4798      	blx	r3
		break;
    3ddc:	e78c      	b.n	3cf8 <usbd_work_handler+0x2c>
		if (ep_ctx->cfg.type == USB_DC_EP_CONTROL &&
    3dde:	7aab      	ldrb	r3, [r5, #10]
    3de0:	b96b      	cbnz	r3, 3dfe <usbd_work_handler+0x132>
    3de2:	7feb      	ldrb	r3, [r5, #31]
    3de4:	b95b      	cbnz	r3, 3dfe <usbd_work_handler+0x132>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    3de6:	4867      	ldr	r0, [pc, #412]	; (3f84 <usbd_work_handler+0x2b8>)
    3de8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3dec:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3df0:	f004 fdaa 	bl	8948 <k_mutex_lock.constprop.0.isra.0>
			nrfx_usbd_setup_clear();
    3df4:	f002 fbf6 	bl	65e4 <nrfx_usbd_setup_clear>
			k_mutex_unlock(&ctx->drv_lock);
    3df8:	4862      	ldr	r0, [pc, #392]	; (3f84 <usbd_work_handler+0x2b8>)
    3dfa:	f004 fda7 	bl	894c <k_mutex_unlock.isra.0>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
    3dfe:	682b      	ldr	r3, [r5, #0]
    3e00:	2102      	movs	r1, #2
    3e02:	e7e9      	b.n	3dd8 <usbd_work_handler+0x10c>
	switch (pwr_evt->state) {
    3e04:	7a02      	ldrb	r2, [r0, #8]
    3e06:	2a04      	cmp	r2, #4
    3e08:	f63f af76 	bhi.w	3cf8 <usbd_work_handler+0x2c>
    3e0c:	e8df f002 	tbb	[pc, r2]
    3e10:	6925035b 	.word	0x6925035b
    3e14:	75          	.byte	0x75
    3e15:	00          	.byte	0x00
		if (!nrfx_usbd_is_enabled()) {
    3e16:	f002 f96f 	bl	60f8 <nrfx_usbd_is_enabled>
    3e1a:	4605      	mov	r5, r0
    3e1c:	2800      	cmp	r0, #0
    3e1e:	f47f af6b 	bne.w	3cf8 <usbd_work_handler+0x2c>
			nrfx_usbd_enable();
    3e22:	f002 f8ad 	bl	5f80 <nrfx_usbd_enable>
    3e26:	f3bf 8f5b 	dmb	ish
    3e2a:	4957      	ldr	r1, [pc, #348]	; (3f88 <usbd_work_handler+0x2bc>)
    3e2c:	2301      	movs	r3, #1
    3e2e:	e851 2f00 	ldrex	r2, [r1]
    3e32:	2a00      	cmp	r2, #0
    3e34:	d103      	bne.n	3e3e <usbd_work_handler+0x172>
    3e36:	e841 3000 	strex	r0, r3, [r1]
    3e3a:	2800      	cmp	r0, #0
    3e3c:	d1f7      	bne.n	3e2e <usbd_work_handler+0x162>
    3e3e:	f3bf 8f5b 	dmb	ish
	if (atomic_cas(&ctx->clk_requested, 0, 1)) {
    3e42:	f47f af59 	bne.w	3cf8 <usbd_work_handler+0x2c>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    3e46:	f841 5c10 	str.w	r5, [r1, #-16]
    3e4a:	f841 5c08 	str.w	r5, [r1, #-8]
		return onoff_request(ctx->hfxo_mgr, &ctx->hfxo_cli);
    3e4e:	69e0      	ldr	r0, [r4, #28]
    3e50:	6163      	str	r3, [r4, #20]
    3e52:	3914      	subs	r1, #20
    3e54:	f004 f852 	bl	7efc <onoff_request>
    3e58:	e74e      	b.n	3cf8 <usbd_work_handler+0x2c>
	switch (pwr_evt->state) {
    3e5a:	2500      	movs	r5, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
    3e5c:	f065 007f 	orn	r0, r5, #127	; 0x7f
    3e60:	b2c0      	uxtb	r0, r0
    3e62:	f7ff fd4f 	bl	3904 <endpoint_ctx>
		if (ep_ctx->cfg.en) {
    3e66:	7a03      	ldrb	r3, [r0, #8]
    3e68:	b113      	cbz	r3, 3e70 <usbd_work_handler+0x1a4>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    3e6a:	7a40      	ldrb	r0, [r0, #9]
    3e6c:	f002 fda4 	bl	69b8 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPIN_CNT; i++) {
    3e70:	3501      	adds	r5, #1
    3e72:	2d08      	cmp	r5, #8
    3e74:	d1f2      	bne.n	3e5c <usbd_work_handler+0x190>
		if (ep_ctx->cfg.en) {
    3e76:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
    3e7a:	b11b      	cbz	r3, 3e84 <usbd_work_handler+0x1b8>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    3e7c:	f894 0155 	ldrb.w	r0, [r4, #341]	; 0x155
    3e80:	f002 fd9a 	bl	69b8 <nrfx_usbd_ep_enable>
	switch (pwr_evt->state) {
    3e84:	2500      	movs	r5, #0
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
    3e86:	b2e8      	uxtb	r0, r5
    3e88:	f7ff fd3c 	bl	3904 <endpoint_ctx>
		if (ep_ctx->cfg.en) {
    3e8c:	7a03      	ldrb	r3, [r0, #8]
    3e8e:	b113      	cbz	r3, 3e96 <usbd_work_handler+0x1ca>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    3e90:	7a40      	ldrb	r0, [r0, #9]
    3e92:	f002 fd91 	bl	69b8 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPOUT_CNT; i++) {
    3e96:	3501      	adds	r5, #1
    3e98:	2d08      	cmp	r5, #8
    3e9a:	d1f4      	bne.n	3e86 <usbd_work_handler+0x1ba>
		if (ep_ctx->cfg.en) {
    3e9c:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
    3ea0:	b11b      	cbz	r3, 3eaa <usbd_work_handler+0x1de>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    3ea2:	f894 0275 	ldrb.w	r0, [r4, #629]	; 0x275
    3ea6:	f002 fd87 	bl	69b8 <nrfx_usbd_ep_enable>
		nrfx_usbd_start(true);
    3eaa:	2001      	movs	r0, #1
    3eac:	f002 f906 	bl	60bc <nrfx_usbd_start>
		ctx->ready = true;
    3eb0:	2301      	movs	r3, #1
    3eb2:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
		if (ctx->status_cb) {
    3eb6:	6823      	ldr	r3, [r4, #0]
    3eb8:	2b00      	cmp	r3, #0
    3eba:	f43f af1d 	beq.w	3cf8 <usbd_work_handler+0x2c>
			ctx->status_cb(USB_DC_CONNECTED, NULL);
    3ebe:	2100      	movs	r1, #0
    3ec0:	2002      	movs	r0, #2
				ctx->status_cb(USB_DC_SOF, NULL);
    3ec2:	4798      	blx	r3
    3ec4:	e718      	b.n	3cf8 <usbd_work_handler+0x2c>
		ctx->ready = false;
    3ec6:	2500      	movs	r5, #0
    3ec8:	f884 5025 	strb.w	r5, [r4, #37]	; 0x25
		nrfx_usbd_disable();
    3ecc:	f002 fd00 	bl	68d0 <nrfx_usbd_disable>
		err = hfxo_stop(ctx);
    3ed0:	f7ff fe18 	bl	3b04 <hfxo_stop.constprop.0.isra.0>
		if (ctx->status_cb) {
    3ed4:	6823      	ldr	r3, [r4, #0]
    3ed6:	2b00      	cmp	r3, #0
    3ed8:	f43f af0e 	beq.w	3cf8 <usbd_work_handler+0x2c>
			ctx->status_cb(USB_DC_DISCONNECTED, NULL);
    3edc:	4629      	mov	r1, r5
    3ede:	2004      	movs	r0, #4
    3ee0:	e7ef      	b.n	3ec2 <usbd_work_handler+0x1f6>
		if (dev_ready()) {
    3ee2:	2b00      	cmp	r3, #0
    3ee4:	f43f af08 	beq.w	3cf8 <usbd_work_handler+0x2c>
			nrfx_usbd_suspend();
    3ee8:	f002 fd0a 	bl	6900 <nrfx_usbd_suspend>
			if (ctx->status_cb) {
    3eec:	6823      	ldr	r3, [r4, #0]
    3eee:	2b00      	cmp	r3, #0
    3ef0:	f43f af02 	beq.w	3cf8 <usbd_work_handler+0x2c>
				ctx->status_cb(USB_DC_SUSPEND, NULL);
    3ef4:	2100      	movs	r1, #0
    3ef6:	2005      	movs	r0, #5
    3ef8:	e7e3      	b.n	3ec2 <usbd_work_handler+0x1f6>
		if (ctx->status_cb && dev_ready()) {
    3efa:	6822      	ldr	r2, [r4, #0]
    3efc:	2a00      	cmp	r2, #0
    3efe:	f43f aefb 	beq.w	3cf8 <usbd_work_handler+0x2c>
    3f02:	2b00      	cmp	r3, #0
    3f04:	f43f aef8 	beq.w	3cf8 <usbd_work_handler+0x2c>
			ctx->status_cb(USB_DC_RESUME, NULL);
    3f08:	2100      	movs	r1, #0
    3f0a:	2006      	movs	r0, #6
    3f0c:	4790      	blx	r2
    3f0e:	e6f3      	b.n	3cf8 <usbd_work_handler+0x2c>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    3f10:	f107 0510 	add.w	r5, r7, #16
    3f14:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3f18:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3f1c:	4628      	mov	r0, r5
    3f1e:	f004 fd13 	bl	8948 <k_mutex_lock.constprop.0.isra.0>
			eps_ctx_init();
    3f22:	f7ff fe9f 	bl	3c64 <eps_ctx_init>
			k_mutex_unlock(&ctx->drv_lock);
    3f26:	4628      	mov	r0, r5
    3f28:	f004 fd10 	bl	894c <k_mutex_unlock.isra.0>
			if (ctx->status_cb) {
    3f2c:	f857 3c28 	ldr.w	r3, [r7, #-40]
    3f30:	2b00      	cmp	r3, #0
    3f32:	f43f aee1 	beq.w	3cf8 <usbd_work_handler+0x2c>
				ctx->status_cb(USB_DC_RESET, NULL);
    3f36:	2100      	movs	r1, #0
    3f38:	2001      	movs	r0, #1
    3f3a:	e7c2      	b.n	3ec2 <usbd_work_handler+0x1f6>
	if (ep_ctx->cfg.en) {
    3f3c:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
    3f40:	b17b      	cbz	r3, 3f62 <usbd_work_handler+0x296>
		ep_ctx->read_pending = true;
    3f42:	2501      	movs	r5, #1
    3f44:	f884 5289 	strb.w	r5, [r4, #649]	; 0x289
		ep_ctx->read_complete = true;
    3f48:	f884 5288 	strb.w	r5, [r4, #648]	; 0x288
		ev = usbd_evt_alloc();
    3f4c:	f7ff fd4a 	bl	39e4 <usbd_evt_alloc>
		if (!ev) {
    3f50:	b138      	cbz	r0, 3f62 <usbd_work_handler+0x296>
		ev->evt.ep_evt.ep = ep_ctx;
    3f52:	4a0e      	ldr	r2, [pc, #56]	; (3f8c <usbd_work_handler+0x2c0>)
		ev->evt_type = USBD_EVT_EP;
    3f54:	7405      	strb	r5, [r0, #16]
		ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
    3f56:	7305      	strb	r5, [r0, #12]
		ev->evt.ep_evt.ep = ep_ctx;
    3f58:	6082      	str	r2, [r0, #8]
		usbd_evt_put(ev);
    3f5a:	f7ff fcfb 	bl	3954 <usbd_evt_put>
		usbd_work_schedule();
    3f5e:	f7ff fcff 	bl	3960 <usbd_work_schedule>
			if (ctx->status_cb) {
    3f62:	f857 3c28 	ldr.w	r3, [r7, #-40]
    3f66:	2b00      	cmp	r3, #0
    3f68:	f43f aec6 	beq.w	3cf8 <usbd_work_handler+0x2c>
				ctx->status_cb(USB_DC_SOF, NULL);
    3f6c:	2100      	movs	r1, #0
    3f6e:	200a      	movs	r0, #10
    3f70:	e7a7      	b.n	3ec2 <usbd_work_handler+0x1f6>
    3f72:	bf00      	nop
    3f74:	20000db4 	.word	0x20000db4
    3f78:	200001ac 	.word	0x200001ac
    3f7c:	40027000 	.word	0x40027000
    3f80:	20000db8 	.word	0x20000db8
    3f84:	20000dec 	.word	0x20000dec
    3f88:	20000dd4 	.word	0x20000dd4
    3f8c:	20001020 	.word	0x20001020
	nrfx_power_usbevt_disable();
    3f90:	f005 f845 	bl	901e <nrfx_power_usbevt_disable>
	nrfx_usbd_disable();
    3f94:	f002 fc9c 	bl	68d0 <nrfx_usbd_disable>
	nrfx_usbd_uninit();
    3f98:	f001 ffe8 	bl	5f6c <nrfx_usbd_uninit>
	usbd_evt_flush();
    3f9c:	f7ff fd14 	bl	39c8 <usbd_evt_flush>
	ret = eps_ctx_init();
    3fa0:	f7ff fe60 	bl	3c64 <eps_ctx_init>
	nrfx_power_usbevt_enable();
    3fa4:	f005 f834 	bl	9010 <nrfx_power_usbevt_enable>
	err = nrfx_usbd_init(usbd_event_handler);
    3fa8:	4801      	ldr	r0, [pc, #4]	; (3fb0 <usbd_work_handler+0x2e4>)
    3faa:	f002 f8af 	bl	610c <nrfx_usbd_init>
}
    3fae:	e6a3      	b.n	3cf8 <usbd_work_handler+0x2c>
    3fb0:	00003b49 	.word	0x00003b49

00003fb4 <usb_dc_attach>:
{
    3fb4:	b538      	push	{r3, r4, r5, lr}
	if (ctx->attached) {
    3fb6:	4d1a      	ldr	r5, [pc, #104]	; (4020 <usb_dc_attach+0x6c>)
    3fb8:	f895 4024 	ldrb.w	r4, [r5, #36]	; 0x24
    3fbc:	bb5c      	cbnz	r4, 4016 <usb_dc_attach+0x62>
	return z_impl_k_mutex_init(mutex);
    3fbe:	f105 0038 	add.w	r0, r5, #56	; 0x38
    3fc2:	f005 f962 	bl	928a <z_impl_k_mutex_init>
		z_nrf_clock_control_get_onoff(
    3fc6:	4620      	mov	r0, r4
    3fc8:	f000 fb3c 	bl	4644 <z_nrf_clock_control_get_onoff>
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    3fcc:	4622      	mov	r2, r4
	ctx->hfxo_mgr =
    3fce:	61e8      	str	r0, [r5, #28]
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    3fd0:	2101      	movs	r1, #1
    3fd2:	2027      	movs	r0, #39	; 0x27
    3fd4:	f7ff f918 	bl	3208 <z_arm_irq_priority_set>
	err = nrfx_usbd_init(usbd_event_handler);
    3fd8:	4812      	ldr	r0, [pc, #72]	; (4024 <usb_dc_attach+0x70>)
    3fda:	f002 f897 	bl	610c <nrfx_usbd_init>
	if (err != NRFX_SUCCESS) {
    3fde:	4b12      	ldr	r3, [pc, #72]	; (4028 <usb_dc_attach+0x74>)
    3fe0:	4298      	cmp	r0, r3
    3fe2:	d11a      	bne.n	401a <usb_dc_attach+0x66>
	nrfx_power_usbevt_enable();
    3fe4:	f005 f814 	bl	9010 <nrfx_power_usbevt_enable>
	ret = eps_ctx_init();
    3fe8:	f7ff fe3c 	bl	3c64 <eps_ctx_init>
	if (ret == 0) {
    3fec:	4604      	mov	r4, r0
    3fee:	b910      	cbnz	r0, 3ff6 <usb_dc_attach+0x42>
		ctx->attached = true;
    3ff0:	2301      	movs	r3, #1
    3ff2:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
	return list->head;
    3ff6:	4b0d      	ldr	r3, [pc, #52]	; (402c <usb_dc_attach+0x78>)
	if (!k_fifo_is_empty(&usbd_evt_fifo)) {
    3ff8:	681b      	ldr	r3, [r3, #0]
    3ffa:	b10b      	cbz	r3, 4000 <usb_dc_attach+0x4c>
		usbd_work_schedule();
    3ffc:	f7ff fcb0 	bl	3960 <usbd_work_schedule>
#endif // NRF_POWER_HAS_MAINREGSTATUS

#if NRF_POWER_HAS_USBREG
NRF_STATIC_INLINE uint32_t nrf_power_usbregstatus_get(NRF_POWER_Type const * p_reg)
{
    return p_reg->USBREGSTATUS;
    4000:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4004:	f8d3 3438 	ldr.w	r3, [r3, #1080]	; 0x438
#ifndef NRFX_DECLARE_ONLY
#if NRF_POWER_HAS_USBREG
NRFX_STATIC_INLINE nrfx_power_usb_state_t nrfx_power_usbstatus_get(void)
{
    uint32_t status = nrf_power_usbregstatus_get(NRF_POWER);
    if(0 == (status & NRF_POWER_USBREGSTATUS_VBUSDETECT_MASK))
    4008:	07db      	lsls	r3, r3, #31
    400a:	d502      	bpl.n	4012 <usb_dc_attach+0x5e>
		usb_dc_power_event_handler(NRFX_POWER_USB_EVT_DETECTED);
    400c:	2000      	movs	r0, #0
    400e:	f7ff fd5f 	bl	3ad0 <usb_dc_power_event_handler>
}
    4012:	4620      	mov	r0, r4
    4014:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
    4016:	2400      	movs	r4, #0
    4018:	e7fb      	b.n	4012 <usb_dc_attach+0x5e>
		return -EIO;
    401a:	f06f 0404 	mvn.w	r4, #4
    401e:	e7f8      	b.n	4012 <usb_dc_attach+0x5e>
    4020:	20000db4 	.word	0x20000db4
    4024:	00003b49 	.word	0x00003b49
    4028:	0bad0000 	.word	0x0bad0000
    402c:	200001dc 	.word	0x200001dc

00004030 <usb_dc_set_address>:
	return get_usbd_ctx()->attached;
    4030:	4b07      	ldr	r3, [pc, #28]	; (4050 <usb_dc_set_address+0x20>)
	if (!dev_attached() || !dev_ready()) {
    4032:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
    4036:	b13a      	cbz	r2, 4048 <usb_dc_set_address+0x18>
    4038:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
	return 0;
    403c:	2b00      	cmp	r3, #0
    403e:	bf0c      	ite	eq
    4040:	f06f 0012 	mvneq.w	r0, #18
    4044:	2000      	movne	r0, #0
    4046:	4770      	bx	lr
		return -ENODEV;
    4048:	f06f 0012 	mvn.w	r0, #18
}
    404c:	4770      	bx	lr
    404e:	bf00      	nop
    4050:	20000db4 	.word	0x20000db4

00004054 <usb_dc_ep_configure>:
	return get_usbd_ctx()->attached;
    4054:	4b0f      	ldr	r3, [pc, #60]	; (4094 <usb_dc_ep_configure+0x40>)
	if (!dev_attached()) {
    4056:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
{
    405a:	b510      	push	{r4, lr}
    405c:	4601      	mov	r1, r0
	if (!dev_attached()) {
    405e:	b1b3      	cbz	r3, 408e <usb_dc_ep_configure+0x3a>
	ep_ctx = endpoint_ctx(ep_cfg->ep_addr);
    4060:	7804      	ldrb	r4, [r0, #0]
    4062:	4620      	mov	r0, r4
    4064:	f7ff fc4e 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    4068:	b910      	cbnz	r0, 4070 <usb_dc_ep_configure+0x1c>
		return -EINVAL;
    406a:	f06f 0015 	mvn.w	r0, #21
}
    406e:	bd10      	pop	{r4, pc}
	ep_ctx->cfg.addr = ep_cfg->ep_addr;
    4070:	7244      	strb	r4, [r0, #9]
	ep_ctx->cfg.type = ep_cfg->ep_type;
    4072:	790b      	ldrb	r3, [r1, #4]
    4074:	7283      	strb	r3, [r0, #10]
	ep_ctx->cfg.max_sz = ep_cfg->ep_mps;
    4076:	8849      	ldrh	r1, [r1, #2]
    4078:	6041      	str	r1, [r0, #4]
	if (!NRF_USBD_EPISO_CHECK(ep_cfg->ep_addr)) {
    407a:	0723      	lsls	r3, r4, #28
    407c:	d402      	bmi.n	4084 <usb_dc_ep_configure+0x30>
		if ((ep_cfg->ep_mps & (ep_cfg->ep_mps - 1)) != 0U) {
    407e:	1e4b      	subs	r3, r1, #1
    4080:	420b      	tst	r3, r1
    4082:	d1f2      	bne.n	406a <usb_dc_ep_configure+0x16>
	nrfx_usbd_ep_max_packet_size_set(ep_addr_to_nrfx(ep_cfg->ep_addr),
    4084:	4620      	mov	r0, r4
    4086:	f005 f858 	bl	913a <nrfx_usbd_ep_max_packet_size_set>
	return 0;
    408a:	2000      	movs	r0, #0
    408c:	e7ef      	b.n	406e <usb_dc_ep_configure+0x1a>
		return -ENODEV;
    408e:	f06f 0012 	mvn.w	r0, #18
    4092:	e7ec      	b.n	406e <usb_dc_ep_configure+0x1a>
    4094:	20000db4 	.word	0x20000db4

00004098 <usb_dc_ep_set_stall>:
	return get_usbd_ctx()->attached;
    4098:	4b12      	ldr	r3, [pc, #72]	; (40e4 <usb_dc_ep_set_stall+0x4c>)
	if (!dev_attached() || !dev_ready()) {
    409a:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
    409e:	b510      	push	{r4, lr}
    40a0:	4601      	mov	r1, r0
	if (!dev_attached() || !dev_ready()) {
    40a2:	b1ca      	cbz	r2, 40d8 <usb_dc_ep_set_stall+0x40>
    40a4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    40a8:	b1b3      	cbz	r3, 40d8 <usb_dc_ep_set_stall+0x40>
	ep_ctx = endpoint_ctx(ep);
    40aa:	f7ff fc2b 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    40ae:	4604      	mov	r4, r0
    40b0:	b1a8      	cbz	r0, 40de <usb_dc_ep_set_stall+0x46>
	switch (ep_ctx->cfg.type) {
    40b2:	7a83      	ldrb	r3, [r0, #10]
    40b4:	2b01      	cmp	r3, #1
    40b6:	d012      	beq.n	40de <usb_dc_ep_set_stall+0x46>
    40b8:	d907      	bls.n	40ca <usb_dc_ep_set_stall+0x32>
    40ba:	3b02      	subs	r3, #2
    40bc:	2b01      	cmp	r3, #1
    40be:	d907      	bls.n	40d0 <usb_dc_ep_set_stall+0x38>
	ep_ctx->buf.curr = ep_ctx->buf.data;
    40c0:	6963      	ldr	r3, [r4, #20]
    40c2:	61a3      	str	r3, [r4, #24]
	ep_ctx->buf.len = 0U;
    40c4:	2000      	movs	r0, #0
    40c6:	60e0      	str	r0, [r4, #12]
}
    40c8:	bd10      	pop	{r4, pc}
		nrfx_usbd_setup_stall();
    40ca:	f002 fa93 	bl	65f4 <nrfx_usbd_setup_stall>
		break;
    40ce:	e7f7      	b.n	40c0 <usb_dc_ep_set_stall+0x28>
		nrfx_usbd_ep_stall(ep_addr_to_nrfx(ep));
    40d0:	4608      	mov	r0, r1
    40d2:	f002 fa03 	bl	64dc <nrfx_usbd_ep_stall>
		break;
    40d6:	e7f3      	b.n	40c0 <usb_dc_ep_set_stall+0x28>
		return -ENODEV;
    40d8:	f06f 0012 	mvn.w	r0, #18
    40dc:	e7f4      	b.n	40c8 <usb_dc_ep_set_stall+0x30>
	switch (ep_ctx->cfg.type) {
    40de:	f06f 0015 	mvn.w	r0, #21
    40e2:	e7f1      	b.n	40c8 <usb_dc_ep_set_stall+0x30>
    40e4:	20000db4 	.word	0x20000db4

000040e8 <usb_dc_ep_clear_stall>:
{
    40e8:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
    40ea:	4b0e      	ldr	r3, [pc, #56]	; (4124 <usb_dc_ep_clear_stall+0x3c>)
	if (!dev_attached() || !dev_ready()) {
    40ec:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
    40f0:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
    40f2:	b182      	cbz	r2, 4116 <usb_dc_ep_clear_stall+0x2e>
    40f4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    40f8:	b16b      	cbz	r3, 4116 <usb_dc_ep_clear_stall+0x2e>
	ep_ctx = endpoint_ctx(ep);
    40fa:	f7ff fc03 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    40fe:	b168      	cbz	r0, 411c <usb_dc_ep_clear_stall+0x34>
	if (NRF_USBD_EPISO_CHECK(ep)) {
    4100:	f015 0408 	ands.w	r4, r5, #8
    4104:	d10a      	bne.n	411c <usb_dc_ep_clear_stall+0x34>
	nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
    4106:	4628      	mov	r0, r5
    4108:	f002 fa0a 	bl	6520 <nrfx_usbd_ep_dtoggle_clear>
	nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
    410c:	4628      	mov	r0, r5
    410e:	f002 fca5 	bl	6a5c <nrfx_usbd_ep_stall_clear>
	return 0;
    4112:	4620      	mov	r0, r4
}
    4114:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    4116:	f06f 0012 	mvn.w	r0, #18
    411a:	e7fb      	b.n	4114 <usb_dc_ep_clear_stall+0x2c>
		return -EINVAL;
    411c:	f06f 0015 	mvn.w	r0, #21
    4120:	e7f8      	b.n	4114 <usb_dc_ep_clear_stall+0x2c>
    4122:	bf00      	nop
    4124:	20000db4 	.word	0x20000db4

00004128 <usb_dc_ep_is_stalled>:
{
    4128:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
    412a:	4b0c      	ldr	r3, [pc, #48]	; (415c <usb_dc_ep_is_stalled+0x34>)
	if (!dev_attached() || !dev_ready()) {
    412c:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
    4130:	4605      	mov	r5, r0
    4132:	460c      	mov	r4, r1
	if (!dev_attached() || !dev_ready()) {
    4134:	b162      	cbz	r2, 4150 <usb_dc_ep_is_stalled+0x28>
    4136:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    413a:	b14b      	cbz	r3, 4150 <usb_dc_ep_is_stalled+0x28>
	ep_ctx = endpoint_ctx(ep);
    413c:	f7ff fbe2 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    4140:	b148      	cbz	r0, 4156 <usb_dc_ep_is_stalled+0x2e>
	if (!stalled) {
    4142:	b141      	cbz	r1, 4156 <usb_dc_ep_is_stalled+0x2e>
	*stalled = (uint8_t) nrfx_usbd_ep_stall_check(ep_addr_to_nrfx(ep));
    4144:	4628      	mov	r0, r5
    4146:	f002 f9d1 	bl	64ec <nrfx_usbd_ep_stall_check>
    414a:	7020      	strb	r0, [r4, #0]
	return 0;
    414c:	2000      	movs	r0, #0
}
    414e:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    4150:	f06f 0012 	mvn.w	r0, #18
    4154:	e7fb      	b.n	414e <usb_dc_ep_is_stalled+0x26>
		return -EINVAL;
    4156:	f06f 0015 	mvn.w	r0, #21
    415a:	e7f8      	b.n	414e <usb_dc_ep_is_stalled+0x26>
    415c:	20000db4 	.word	0x20000db4

00004160 <usb_dc_ep_enable>:
{
    4160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return get_usbd_ctx()->attached;
    4162:	4f13      	ldr	r7, [pc, #76]	; (41b0 <usb_dc_ep_enable+0x50>)
	if (!dev_attached()) {
    4164:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
{
    4168:	4604      	mov	r4, r0
	if (!dev_attached()) {
    416a:	b1bb      	cbz	r3, 419c <usb_dc_ep_enable+0x3c>
	ep_ctx = endpoint_ctx(ep);
    416c:	f7ff fbca 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    4170:	4605      	mov	r5, r0
    4172:	b1b0      	cbz	r0, 41a2 <usb_dc_ep_enable+0x42>
	if (!NRF_USBD_EPISO_CHECK(ep)) {
    4174:	0723      	lsls	r3, r4, #28
    4176:	d405      	bmi.n	4184 <usb_dc_ep_enable+0x24>
		nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
    4178:	4620      	mov	r0, r4
    417a:	f002 f9d1 	bl	6520 <nrfx_usbd_ep_dtoggle_clear>
		nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
    417e:	4620      	mov	r0, r4
    4180:	f002 fc6c 	bl	6a5c <nrfx_usbd_ep_stall_clear>
	if (ep_ctx->cfg.en) {
    4184:	7a2e      	ldrb	r6, [r5, #8]
    4186:	b97e      	cbnz	r6, 41a8 <usb_dc_ep_enable+0x48>
	if (dev_ready()) {
    4188:	f897 0025 	ldrb.w	r0, [r7, #37]	; 0x25
	ep_ctx->cfg.en = true;
    418c:	2301      	movs	r3, #1
    418e:	722b      	strb	r3, [r5, #8]
	if (dev_ready()) {
    4190:	b118      	cbz	r0, 419a <usb_dc_ep_enable+0x3a>
		nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep));
    4192:	4620      	mov	r0, r4
    4194:	f002 fc10 	bl	69b8 <nrfx_usbd_ep_enable>
	return 0;
    4198:	4630      	mov	r0, r6
}
    419a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENODEV;
    419c:	f06f 0012 	mvn.w	r0, #18
    41a0:	e7fb      	b.n	419a <usb_dc_ep_enable+0x3a>
		return -EINVAL;
    41a2:	f06f 0015 	mvn.w	r0, #21
    41a6:	e7f8      	b.n	419a <usb_dc_ep_enable+0x3a>
		return -EALREADY;
    41a8:	f06f 0077 	mvn.w	r0, #119	; 0x77
    41ac:	e7f5      	b.n	419a <usb_dc_ep_enable+0x3a>
    41ae:	bf00      	nop
    41b0:	20000db4 	.word	0x20000db4

000041b4 <usb_dc_ep_disable>:
{
    41b4:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
    41b6:	4b11      	ldr	r3, [pc, #68]	; (41fc <usb_dc_ep_disable+0x48>)
	if (!dev_attached() || !dev_ready()) {
    41b8:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
    41bc:	4601      	mov	r1, r0
	if (!dev_attached() || !dev_ready()) {
    41be:	b19a      	cbz	r2, 41e8 <usb_dc_ep_disable+0x34>
    41c0:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    41c4:	b183      	cbz	r3, 41e8 <usb_dc_ep_disable+0x34>
	ep_ctx = endpoint_ctx(ep);
    41c6:	f7ff fb9d 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    41ca:	4605      	mov	r5, r0
    41cc:	b178      	cbz	r0, 41ee <usb_dc_ep_disable+0x3a>
	if (!ep_ctx->cfg.en) {
    41ce:	7a03      	ldrb	r3, [r0, #8]
    41d0:	b183      	cbz	r3, 41f4 <usb_dc_ep_disable+0x40>
	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
    41d2:	4608      	mov	r0, r1
	ep_ctx->write_in_progress = false;
    41d4:	2400      	movs	r4, #0
	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
    41d6:	f002 fbc3 	bl	6960 <nrfx_usbd_ep_disable>
	ep_ctx_reset(ep_ctx);
    41da:	4628      	mov	r0, r5
	ep_ctx->write_in_progress = false;
    41dc:	77ac      	strb	r4, [r5, #30]
	ep_ctx_reset(ep_ctx);
    41de:	f004 fba0 	bl	8922 <ep_ctx_reset>
	ep_ctx->cfg.en = false;
    41e2:	722c      	strb	r4, [r5, #8]
	return 0;
    41e4:	4620      	mov	r0, r4
}
    41e6:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    41e8:	f06f 0012 	mvn.w	r0, #18
    41ec:	e7fb      	b.n	41e6 <usb_dc_ep_disable+0x32>
		return -EINVAL;
    41ee:	f06f 0015 	mvn.w	r0, #21
    41f2:	e7f8      	b.n	41e6 <usb_dc_ep_disable+0x32>
		return -EALREADY;
    41f4:	f06f 0077 	mvn.w	r0, #119	; 0x77
    41f8:	e7f5      	b.n	41e6 <usb_dc_ep_disable+0x32>
    41fa:	bf00      	nop
    41fc:	20000db4 	.word	0x20000db4

00004200 <usb_dc_ep_write>:
{
    4200:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return get_usbd_ctx()->attached;
    4204:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 42e4 <usb_dc_ep_write+0xe4>
{
    4208:	461c      	mov	r4, r3
	if (!dev_attached() || !dev_ready()) {
    420a:	f898 3024 	ldrb.w	r3, [r8, #36]	; 0x24
{
    420e:	b085      	sub	sp, #20
    4210:	4607      	mov	r7, r0
    4212:	4689      	mov	r9, r1
    4214:	4616      	mov	r6, r2
	if (!dev_attached() || !dev_ready()) {
    4216:	2b00      	cmp	r3, #0
    4218:	d05d      	beq.n	42d6 <usb_dc_ep_write+0xd6>
    421a:	f898 3025 	ldrb.w	r3, [r8, #37]	; 0x25
    421e:	2b00      	cmp	r3, #0
    4220:	d059      	beq.n	42d6 <usb_dc_ep_write+0xd6>
	if (NRF_USBD_EPOUT_CHECK(ep)) {
    4222:	0603      	lsls	r3, r0, #24
    4224:	d55a      	bpl.n	42dc <usb_dc_ep_write+0xdc>
	ep_ctx = endpoint_ctx(ep);
    4226:	f7ff fb6d 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    422a:	4605      	mov	r5, r0
    422c:	2800      	cmp	r0, #0
    422e:	d055      	beq.n	42dc <usb_dc_ep_write+0xdc>
	if (!ep_ctx->cfg.en) {
    4230:	7a03      	ldrb	r3, [r0, #8]
    4232:	2b00      	cmp	r3, #0
    4234:	d052      	beq.n	42dc <usb_dc_ep_write+0xdc>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    4236:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    423a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    423e:	f108 0038 	add.w	r0, r8, #56	; 0x38
    4242:	f004 fb81 	bl	8948 <k_mutex_lock.constprop.0.isra.0>
	if (ep_ctx->write_in_progress) {
    4246:	7fab      	ldrb	r3, [r5, #30]
    4248:	b14b      	cbz	r3, 425e <usb_dc_ep_write+0x5e>
		k_mutex_unlock(&ctx->drv_lock);
    424a:	f108 0038 	add.w	r0, r8, #56	; 0x38
    424e:	f004 fb7d 	bl	894c <k_mutex_unlock.isra.0>
		return -EAGAIN;
    4252:	f06f 040a 	mvn.w	r4, #10
}
    4256:	4620      	mov	r0, r4
    4258:	b005      	add	sp, #20
    425a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (!data_len && ep_ctx->trans_zlp) {
    425e:	b916      	cbnz	r6, 4266 <usb_dc_ep_write+0x66>
    4260:	7feb      	ldrb	r3, [r5, #31]
    4262:	b103      	cbz	r3, 4266 <usb_dc_ep_write+0x66>
		ep_ctx->trans_zlp = false;
    4264:	77ee      	strb	r6, [r5, #31]
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
    4266:	7aab      	ldrb	r3, [r5, #10]
    4268:	b9bb      	cbnz	r3, 429a <usb_dc_ep_write+0x9a>
		if (data_len && usbd_ctx.setup.wLength > data_len &&
    426a:	b15e      	cbz	r6, 4284 <usb_dc_ep_write+0x84>
    426c:	f8b8 300a 	ldrh.w	r3, [r8, #10]
    4270:	42b3      	cmp	r3, r6
    4272:	d907      	bls.n	4284 <usb_dc_ep_write+0x84>
		    !(data_len % ep_ctx->cfg.max_sz)) {
    4274:	686a      	ldr	r2, [r5, #4]
    4276:	fbb6 f3f2 	udiv	r3, r6, r2
    427a:	fb02 6313 	mls	r3, r2, r3, r6
		if (data_len && usbd_ctx.setup.wLength > data_len &&
    427e:	b90b      	cbnz	r3, 4284 <usb_dc_ep_write+0x84>
			ep_ctx->trans_zlp = true;
    4280:	2301      	movs	r3, #1
    4282:	77eb      	strb	r3, [r5, #31]
	    && (nrfx_usbd_last_setup_dir_get() != ep)) {
    4284:	f002 f9be 	bl	6604 <nrfx_usbd_last_setup_dir_get>
    4288:	42b8      	cmp	r0, r7
    428a:	d006      	beq.n	429a <usb_dc_ep_write+0x9a>
		nrfx_usbd_setup_clear();
    428c:	f002 f9aa 	bl	65e4 <nrfx_usbd_setup_clear>
		k_mutex_unlock(&ctx->drv_lock);
    4290:	4815      	ldr	r0, [pc, #84]	; (42e8 <usb_dc_ep_write+0xe8>)
    4292:	f004 fb5b 	bl	894c <k_mutex_unlock.isra.0>
		return 0;
    4296:	2400      	movs	r4, #0
    4298:	e7dd      	b.n	4256 <usb_dc_ep_write+0x56>
	ep_ctx->write_in_progress = true;
    429a:	2301      	movs	r3, #1
    429c:	77ab      	strb	r3, [r5, #30]
	NRFX_USBD_TRANSFER_IN(transfer, data, data_len, 0);
    429e:	f04f 0800 	mov.w	r8, #0
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
    42a2:	a901      	add	r1, sp, #4
    42a4:	4638      	mov	r0, r7
	NRFX_USBD_TRANSFER_IN(transfer, data, data_len, 0);
    42a6:	e9cd 9601 	strd	r9, r6, [sp, #4]
    42aa:	f8cd 800c 	str.w	r8, [sp, #12]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
    42ae:	f001 ff73 	bl	6198 <nrfx_usbd_ep_transfer>
	if (err != NRFX_SUCCESS) {
    42b2:	4b0e      	ldr	r3, [pc, #56]	; (42ec <usb_dc_ep_write+0xec>)
    42b4:	4298      	cmp	r0, r3
    42b6:	d007      	beq.n	42c8 <usb_dc_ep_write+0xc8>
		ep_ctx->write_in_progress = false;
    42b8:	f885 801e 	strb.w	r8, [r5, #30]
		if (ret_bytes) {
    42bc:	b10c      	cbz	r4, 42c2 <usb_dc_ep_write+0xc2>
			*ret_bytes = 0;
    42be:	f8c4 8000 	str.w	r8, [r4]
		result = -EIO;
    42c2:	f06f 0404 	mvn.w	r4, #4
    42c6:	e002      	b.n	42ce <usb_dc_ep_write+0xce>
		if (ret_bytes) {
    42c8:	b10c      	cbz	r4, 42ce <usb_dc_ep_write+0xce>
			*ret_bytes = data_len;
    42ca:	6026      	str	r6, [r4, #0]
	int result = 0;
    42cc:	4644      	mov	r4, r8
	k_mutex_unlock(&ctx->drv_lock);
    42ce:	4806      	ldr	r0, [pc, #24]	; (42e8 <usb_dc_ep_write+0xe8>)
    42d0:	f004 fb3c 	bl	894c <k_mutex_unlock.isra.0>
	return result;
    42d4:	e7bf      	b.n	4256 <usb_dc_ep_write+0x56>
		return -ENODEV;
    42d6:	f06f 0412 	mvn.w	r4, #18
    42da:	e7bc      	b.n	4256 <usb_dc_ep_write+0x56>
		return -EINVAL;
    42dc:	f06f 0415 	mvn.w	r4, #21
    42e0:	e7b9      	b.n	4256 <usb_dc_ep_write+0x56>
    42e2:	bf00      	nop
    42e4:	20000db4 	.word	0x20000db4
    42e8:	20000dec 	.word	0x20000dec
    42ec:	0bad0000 	.word	0x0bad0000

000042f0 <usb_dc_ep_read_wait>:
{
    42f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    42f4:	461d      	mov	r5, r3
	return get_usbd_ctx()->attached;
    42f6:	4b20      	ldr	r3, [pc, #128]	; (4378 <usb_dc_ep_read_wait+0x88>)
{
    42f8:	4617      	mov	r7, r2
	if (!dev_attached() || !dev_ready()) {
    42fa:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
    42fe:	460e      	mov	r6, r1
	if (!dev_attached() || !dev_ready()) {
    4300:	2a00      	cmp	r2, #0
    4302:	d033      	beq.n	436c <usb_dc_ep_read_wait+0x7c>
    4304:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    4308:	b383      	cbz	r3, 436c <usb_dc_ep_read_wait+0x7c>
	if (NRF_USBD_EPIN_CHECK(ep)) {
    430a:	0603      	lsls	r3, r0, #24
    430c:	d431      	bmi.n	4372 <usb_dc_ep_read_wait+0x82>
	if (!data && max_data_len) {
    430e:	b901      	cbnz	r1, 4312 <usb_dc_ep_read_wait+0x22>
    4310:	bb7f      	cbnz	r7, 4372 <usb_dc_ep_read_wait+0x82>
	ep_ctx = endpoint_ctx(ep);
    4312:	f7ff faf7 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    4316:	4604      	mov	r4, r0
    4318:	b358      	cbz	r0, 4372 <usb_dc_ep_read_wait+0x82>
	if (!ep_ctx->cfg.en) {
    431a:	7a03      	ldrb	r3, [r0, #8]
    431c:	b34b      	cbz	r3, 4372 <usb_dc_ep_read_wait+0x82>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    431e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4322:	4816      	ldr	r0, [pc, #88]	; (437c <usb_dc_ep_read_wait+0x8c>)
    4324:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    4328:	f004 fb0e 	bl	8948 <k_mutex_lock.constprop.0.isra.0>
	bytes_to_copy = MIN(max_data_len, ep_ctx->buf.len);
    432c:	68e3      	ldr	r3, [r4, #12]
    432e:	429f      	cmp	r7, r3
    4330:	46b8      	mov	r8, r7
    4332:	bf28      	it	cs
    4334:	4698      	movcs	r8, r3
	if (!data && !max_data_len) {
    4336:	b946      	cbnz	r6, 434a <usb_dc_ep_read_wait+0x5a>
    4338:	b93f      	cbnz	r7, 434a <usb_dc_ep_read_wait+0x5a>
		if (read_bytes) {
    433a:	b105      	cbz	r5, 433e <usb_dc_ep_read_wait+0x4e>
			*read_bytes = ep_ctx->buf.len;
    433c:	602b      	str	r3, [r5, #0]
		k_mutex_unlock(&ctx->drv_lock);
    433e:	480f      	ldr	r0, [pc, #60]	; (437c <usb_dc_ep_read_wait+0x8c>)
    4340:	f004 fb04 	bl	894c <k_mutex_unlock.isra.0>
		return 0;
    4344:	2000      	movs	r0, #0
}
    4346:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	memcpy(data, ep_ctx->buf.curr, bytes_to_copy);
    434a:	69a1      	ldr	r1, [r4, #24]
    434c:	4642      	mov	r2, r8
    434e:	4630      	mov	r0, r6
    4350:	f004 fab2 	bl	88b8 <memcpy>
	ep_ctx->buf.curr += bytes_to_copy;
    4354:	69a3      	ldr	r3, [r4, #24]
    4356:	4443      	add	r3, r8
    4358:	61a3      	str	r3, [r4, #24]
	ep_ctx->buf.len -= bytes_to_copy;
    435a:	68e3      	ldr	r3, [r4, #12]
    435c:	eba3 0308 	sub.w	r3, r3, r8
    4360:	60e3      	str	r3, [r4, #12]
	if (read_bytes) {
    4362:	2d00      	cmp	r5, #0
    4364:	d0eb      	beq.n	433e <usb_dc_ep_read_wait+0x4e>
		*read_bytes = bytes_to_copy;
    4366:	f8c5 8000 	str.w	r8, [r5]
    436a:	e7e8      	b.n	433e <usb_dc_ep_read_wait+0x4e>
		return -ENODEV;
    436c:	f06f 0012 	mvn.w	r0, #18
    4370:	e7e9      	b.n	4346 <usb_dc_ep_read_wait+0x56>
		return -EINVAL;
    4372:	f06f 0015 	mvn.w	r0, #21
    4376:	e7e6      	b.n	4346 <usb_dc_ep_read_wait+0x56>
    4378:	20000db4 	.word	0x20000db4
    437c:	20000dec 	.word	0x20000dec

00004380 <usb_dc_ep_read_continue>:
{
    4380:	b570      	push	{r4, r5, r6, lr}
	return get_usbd_ctx()->attached;
    4382:	4d1e      	ldr	r5, [pc, #120]	; (43fc <usb_dc_ep_read_continue+0x7c>)
	if (!dev_attached() || !dev_ready()) {
    4384:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
{
    4388:	4603      	mov	r3, r0
	if (!dev_attached() || !dev_ready()) {
    438a:	b382      	cbz	r2, 43ee <usb_dc_ep_read_continue+0x6e>
    438c:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
    4390:	b36a      	cbz	r2, 43ee <usb_dc_ep_read_continue+0x6e>
	if (NRF_USBD_EPIN_CHECK(ep)) {
    4392:	061b      	lsls	r3, r3, #24
    4394:	d42e      	bmi.n	43f4 <usb_dc_ep_read_continue+0x74>
	ep_ctx = endpoint_ctx(ep);
    4396:	f7ff fab5 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    439a:	4604      	mov	r4, r0
    439c:	b350      	cbz	r0, 43f4 <usb_dc_ep_read_continue+0x74>
	if (!ep_ctx->cfg.en) {
    439e:	7a03      	ldrb	r3, [r0, #8]
    43a0:	b343      	cbz	r3, 43f4 <usb_dc_ep_read_continue+0x74>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    43a2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    43a6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    43aa:	f105 0038 	add.w	r0, r5, #56	; 0x38
    43ae:	f004 facb 	bl	8948 <k_mutex_lock.constprop.0.isra.0>
	if (!ep_ctx->buf.len) {
    43b2:	68e3      	ldr	r3, [r4, #12]
    43b4:	b9b3      	cbnz	r3, 43e4 <usb_dc_ep_read_continue+0x64>
		ep_ctx->read_complete = true;
    43b6:	2601      	movs	r6, #1
		ep_ctx->buf.curr = ep_ctx->buf.data;
    43b8:	6963      	ldr	r3, [r4, #20]
		ep_ctx->read_complete = true;
    43ba:	7726      	strb	r6, [r4, #28]
		ep_ctx->buf.curr = ep_ctx->buf.data;
    43bc:	61a3      	str	r3, [r4, #24]
		if (ep_ctx->read_pending) {
    43be:	7f63      	ldrb	r3, [r4, #29]
    43c0:	b183      	cbz	r3, 43e4 <usb_dc_ep_read_continue+0x64>
			struct usbd_event *ev = usbd_evt_alloc();
    43c2:	f7ff fb0f 	bl	39e4 <usbd_evt_alloc>
			if (!ev) {
    43c6:	b930      	cbnz	r0, 43d6 <usb_dc_ep_read_continue+0x56>
				k_mutex_unlock(&ctx->drv_lock);
    43c8:	f105 0038 	add.w	r0, r5, #56	; 0x38
    43cc:	f004 fabe 	bl	894c <k_mutex_unlock.isra.0>
				return -ENOMEM;
    43d0:	f06f 000b 	mvn.w	r0, #11
}
    43d4:	bd70      	pop	{r4, r5, r6, pc}
			ev->evt_type = USBD_EVT_EP;
    43d6:	7406      	strb	r6, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
    43d8:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
    43da:	7306      	strb	r6, [r0, #12]
			usbd_evt_put(ev);
    43dc:	f7ff faba 	bl	3954 <usbd_evt_put>
			usbd_work_schedule();
    43e0:	f7ff fabe 	bl	3960 <usbd_work_schedule>
	k_mutex_unlock(&ctx->drv_lock);
    43e4:	4806      	ldr	r0, [pc, #24]	; (4400 <usb_dc_ep_read_continue+0x80>)
    43e6:	f004 fab1 	bl	894c <k_mutex_unlock.isra.0>
	return 0;
    43ea:	2000      	movs	r0, #0
    43ec:	e7f2      	b.n	43d4 <usb_dc_ep_read_continue+0x54>
		return -ENODEV;
    43ee:	f06f 0012 	mvn.w	r0, #18
    43f2:	e7ef      	b.n	43d4 <usb_dc_ep_read_continue+0x54>
		return -EINVAL;
    43f4:	f06f 0015 	mvn.w	r0, #21
    43f8:	e7ec      	b.n	43d4 <usb_dc_ep_read_continue+0x54>
    43fa:	bf00      	nop
    43fc:	20000db4 	.word	0x20000db4
    4400:	20000dec 	.word	0x20000dec

00004404 <usb_dc_ep_set_callback>:
{
    4404:	b508      	push	{r3, lr}
	return get_usbd_ctx()->attached;
    4406:	4b08      	ldr	r3, [pc, #32]	; (4428 <usb_dc_ep_set_callback+0x24>)
	if (!dev_attached()) {
    4408:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    440c:	b12b      	cbz	r3, 441a <usb_dc_ep_set_callback+0x16>
	ep_ctx = endpoint_ctx(ep);
    440e:	f7ff fa79 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    4412:	b128      	cbz	r0, 4420 <usb_dc_ep_set_callback+0x1c>
	ep_ctx->cfg.cb = cb;
    4414:	6001      	str	r1, [r0, #0]
	return 0;
    4416:	2000      	movs	r0, #0
}
    4418:	bd08      	pop	{r3, pc}
		return -ENODEV;
    441a:	f06f 0012 	mvn.w	r0, #18
    441e:	e7fb      	b.n	4418 <usb_dc_ep_set_callback+0x14>
		return -EINVAL;
    4420:	f06f 0015 	mvn.w	r0, #21
    4424:	e7f8      	b.n	4418 <usb_dc_ep_set_callback+0x14>
    4426:	bf00      	nop
    4428:	20000db4 	.word	0x20000db4

0000442c <usb_dc_set_status_callback>:
	get_usbd_ctx()->status_cb = cb;
    442c:	4b01      	ldr	r3, [pc, #4]	; (4434 <usb_dc_set_status_callback+0x8>)
    442e:	6018      	str	r0, [r3, #0]
}
    4430:	4770      	bx	lr
    4432:	bf00      	nop
    4434:	20000db4 	.word	0x20000db4

00004438 <usb_dc_ep_mps>:
{
    4438:	b508      	push	{r3, lr}
	return get_usbd_ctx()->attached;
    443a:	4b07      	ldr	r3, [pc, #28]	; (4458 <usb_dc_ep_mps+0x20>)
	if (!dev_attached()) {
    443c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    4440:	b123      	cbz	r3, 444c <usb_dc_ep_mps+0x14>
	ep_ctx = endpoint_ctx(ep);
    4442:	f7ff fa5f 	bl	3904 <endpoint_ctx>
	if (!ep_ctx) {
    4446:	b120      	cbz	r0, 4452 <usb_dc_ep_mps+0x1a>
	return ep_ctx->cfg.max_sz;
    4448:	6840      	ldr	r0, [r0, #4]
}
    444a:	bd08      	pop	{r3, pc}
		return -ENODEV;
    444c:	f06f 0012 	mvn.w	r0, #18
    4450:	e7fb      	b.n	444a <usb_dc_ep_mps+0x12>
		return -EINVAL;
    4452:	f06f 0015 	mvn.w	r0, #21
    4456:	e7f8      	b.n	444a <usb_dc_ep_mps+0x12>
    4458:	20000db4 	.word	0x20000db4

0000445c <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    445c:	4b08      	ldr	r3, [pc, #32]	; (4480 <onoff_stop+0x24>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    445e:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
    4460:	1ac3      	subs	r3, r0, r3
{
    4462:	460d      	mov	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    4464:	4907      	ldr	r1, [pc, #28]	; (4484 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
    4466:	109b      	asrs	r3, r3, #2
{
    4468:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    446a:	4359      	muls	r1, r3
    446c:	4806      	ldr	r0, [pc, #24]	; (4488 <onoff_stop+0x2c>)
    446e:	2240      	movs	r2, #64	; 0x40
    4470:	f004 fab1 	bl	89d6 <stop>
	notify(mgr, res);
    4474:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    4476:	4601      	mov	r1, r0
	notify(mgr, res);
    4478:	4620      	mov	r0, r4
}
    447a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
    447e:	4718      	bx	r3
    4480:	20001054 	.word	0x20001054
    4484:	b6db6db7 	.word	0xb6db6db7
    4488:	00009818 	.word	0x00009818

0000448c <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    448c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
    448e:	4c0c      	ldr	r4, [pc, #48]	; (44c0 <onoff_start+0x34>)
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    4490:	4a0c      	ldr	r2, [pc, #48]	; (44c4 <onoff_start+0x38>)
    4492:	2340      	movs	r3, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
    4494:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    4496:	9300      	str	r3, [sp, #0]
{
    4498:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    449a:	460b      	mov	r3, r1
    449c:	490a      	ldr	r1, [pc, #40]	; (44c8 <onoff_start+0x3c>)
	size_t offset = (size_t)(mgr - data->mgr);
    449e:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    44a0:	4361      	muls	r1, r4
{
    44a2:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    44a4:	4809      	ldr	r0, [pc, #36]	; (44cc <onoff_start+0x40>)
    44a6:	f004 fac2 	bl	8a2e <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    44aa:	1e01      	subs	r1, r0, #0
    44ac:	da05      	bge.n	44ba <onoff_start+0x2e>
		notify(mgr, err);
    44ae:	4630      	mov	r0, r6
    44b0:	462b      	mov	r3, r5
	}
}
    44b2:	b002      	add	sp, #8
    44b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
    44b8:	4718      	bx	r3
}
    44ba:	b002      	add	sp, #8
    44bc:	bd70      	pop	{r4, r5, r6, pc}
    44be:	bf00      	nop
    44c0:	20001054 	.word	0x20001054
    44c4:	00008a9f 	.word	0x00008a9f
    44c8:	b6db6db7 	.word	0xb6db6db7
    44cc:	00009818 	.word	0x00009818

000044d0 <clk_init>:
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    44d0:	2200      	movs	r2, #0
{
    44d2:	b570      	push	{r4, r5, r6, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    44d4:	2101      	movs	r1, #1
{
    44d6:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    44d8:	4610      	mov	r0, r2
    44da:	f7fe fe95 	bl	3208 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
    44de:	2000      	movs	r0, #0
    44e0:	f7fe fe60 	bl	31a4 <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
    44e4:	480f      	ldr	r0, [pc, #60]	; (4524 <clk_init+0x54>)
    44e6:	f000 feb9 	bl	525c <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    44ea:	4b0f      	ldr	r3, [pc, #60]	; (4528 <clk_init+0x58>)
    44ec:	4298      	cmp	r0, r3
    44ee:	d115      	bne.n	451c <clk_init+0x4c>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    44f0:	f000 fec4 	bl	527c <nrfx_clock_enable>
	struct nrf_clock_control_data *data = dev->data;
    44f4:	6926      	ldr	r6, [r4, #16]
	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);

		err = onoff_manager_init(get_onoff_manager(dev, i),
    44f6:	490d      	ldr	r1, [pc, #52]	; (452c <clk_init+0x5c>)
    44f8:	4630      	mov	r0, r6
    44fa:	f003 fcec 	bl	7ed6 <onoff_manager_init>
					 &transitions);
		if (err < 0) {
    44fe:	2800      	cmp	r0, #0
    4500:	db0b      	blt.n	451a <clk_init+0x4a>
	struct nrf_clock_control_data *data = dev->data;
    4502:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
    4504:	4909      	ldr	r1, [pc, #36]	; (452c <clk_init+0x5c>)
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    4506:	2501      	movs	r5, #1
    4508:	6435      	str	r5, [r6, #64]	; 0x40
		err = onoff_manager_init(get_onoff_manager(dev, i),
    450a:	f104 001c 	add.w	r0, r4, #28
    450e:	f003 fce2 	bl	7ed6 <onoff_manager_init>
		if (err < 0) {
    4512:	2800      	cmp	r0, #0
    4514:	db01      	blt.n	451a <clk_init+0x4a>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    4516:	64e5      	str	r5, [r4, #76]	; 0x4c
	}

	return 0;
    4518:	2000      	movs	r0, #0
}
    451a:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
    451c:	f06f 0004 	mvn.w	r0, #4
    4520:	e7fb      	b.n	451a <clk_init+0x4a>
    4522:	bf00      	nop
    4524:	00004565 	.word	0x00004565
    4528:	0bad0000 	.word	0x0bad0000
    452c:	00009af4 	.word	0x00009af4

00004530 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
    4530:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
    4532:	230c      	movs	r3, #12
    4534:	4809      	ldr	r0, [pc, #36]	; (455c <clkstarted_handle.constprop.0+0x2c>)
    4536:	434b      	muls	r3, r1
static void clkstarted_handle(const struct device *dev,
    4538:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
    453a:	18c4      	adds	r4, r0, r3
	void *user_data = sub_data->user_data;
    453c:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	sub_data->cb = NULL;
    4540:	2200      	movs	r2, #0
	set_on_state(&sub_data->flags);
    4542:	3340      	adds	r3, #64	; 0x40
	sub_data->cb = NULL;
    4544:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
    4546:	4418      	add	r0, r3
    4548:	f004 fa32 	bl	89b0 <set_on_state>
	if (callback) {
    454c:	b12d      	cbz	r5, 455a <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
    454e:	4632      	mov	r2, r6
    4550:	462b      	mov	r3, r5
    4552:	4803      	ldr	r0, [pc, #12]	; (4560 <clkstarted_handle.constprop.0+0x30>)
}
    4554:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
    4558:	4718      	bx	r3
}
    455a:	bd70      	pop	{r4, r5, r6, pc}
    455c:	20001054 	.word	0x20001054
    4560:	00009818 	.word	0x00009818

00004564 <clock_event_handler>:
	switch (event) {
    4564:	b110      	cbz	r0, 456c <clock_event_handler+0x8>
    4566:	2801      	cmp	r0, #1
    4568:	d004      	beq.n	4574 <clock_event_handler+0x10>
    456a:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    456c:	4b03      	ldr	r3, [pc, #12]	; (457c <clock_event_handler+0x18>)
    456e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4570:	075b      	lsls	r3, r3, #29
    4572:	d101      	bne.n	4578 <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    4574:	f7ff bfdc 	b.w	4530 <clkstarted_handle.constprop.0>
}
    4578:	4770      	bx	lr
    457a:	bf00      	nop
    457c:	20001054 	.word	0x20001054

00004580 <generic_hfclk_start>:
{
    4580:	b508      	push	{r3, lr}
	__asm__ volatile(
    4582:	f04f 0320 	mov.w	r3, #32
    4586:	f3ef 8111 	mrs	r1, BASEPRI
    458a:	f383 8812 	msr	BASEPRI_MAX, r3
    458e:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
    4592:	4a12      	ldr	r2, [pc, #72]	; (45dc <generic_hfclk_start+0x5c>)
    4594:	6813      	ldr	r3, [r2, #0]
    4596:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
    459a:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
    459e:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    45a0:	d00c      	beq.n	45bc <generic_hfclk_start+0x3c>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    45a2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    45a6:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    45aa:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    45ae:	f013 0301 	ands.w	r3, r3, #1
    45b2:	d003      	beq.n	45bc <generic_hfclk_start+0x3c>
			set_on_state(get_hf_flags());
    45b4:	480a      	ldr	r0, [pc, #40]	; (45e0 <generic_hfclk_start+0x60>)
    45b6:	f004 f9fb 	bl	89b0 <set_on_state>
			already_started = true;
    45ba:	2301      	movs	r3, #1
	__asm__ volatile(
    45bc:	f381 8811 	msr	BASEPRI, r1
    45c0:	f3bf 8f6f 	isb	sy
	if (already_started) {
    45c4:	b123      	cbz	r3, 45d0 <generic_hfclk_start+0x50>
}
    45c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
    45ca:	2000      	movs	r0, #0
    45cc:	f7ff bfb0 	b.w	4530 <clkstarted_handle.constprop.0>
}
    45d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    45d4:	2001      	movs	r0, #1
    45d6:	f004 bc8d 	b.w	8ef4 <nrfx_clock_start>
    45da:	bf00      	nop
    45dc:	200010a4 	.word	0x200010a4
    45e0:	20001094 	.word	0x20001094

000045e4 <api_blocking_start>:
{
    45e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    45e6:	2200      	movs	r2, #0
    45e8:	2301      	movs	r3, #1
    45ea:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    45ee:	4a09      	ldr	r2, [pc, #36]	; (4614 <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    45f0:	f8cd d000 	str.w	sp, [sp]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    45f4:	466b      	mov	r3, sp
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    45f6:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    45fa:	f004 fa49 	bl	8a90 <api_start>
	if (err < 0) {
    45fe:	2800      	cmp	r0, #0
    4600:	db05      	blt.n	460e <api_blocking_start+0x2a>
	return z_impl_k_sem_take(sem, timeout);
    4602:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    4606:	2300      	movs	r3, #0
    4608:	4668      	mov	r0, sp
    460a:	f002 fd71 	bl	70f0 <z_impl_k_sem_take>
}
    460e:	b005      	add	sp, #20
    4610:	f85d fb04 	ldr.w	pc, [sp], #4
    4614:	00008abd 	.word	0x00008abd

00004618 <generic_hfclk_stop>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4618:	4b09      	ldr	r3, [pc, #36]	; (4640 <generic_hfclk_stop+0x28>)
    461a:	f3bf 8f5b 	dmb	ish
    461e:	e853 2f00 	ldrex	r2, [r3]
    4622:	f022 0102 	bic.w	r1, r2, #2
    4626:	e843 1000 	strex	r0, r1, [r3]
    462a:	2800      	cmp	r0, #0
    462c:	d1f7      	bne.n	461e <generic_hfclk_stop+0x6>
    462e:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    4632:	07d3      	lsls	r3, r2, #31
    4634:	d402      	bmi.n	463c <generic_hfclk_stop+0x24>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    4636:	2001      	movs	r0, #1
    4638:	f000 be2e 	b.w	5298 <nrfx_clock_stop>
}
    463c:	4770      	bx	lr
    463e:	bf00      	nop
    4640:	200010a4 	.word	0x200010a4

00004644 <z_nrf_clock_control_get_onoff>:
}
    4644:	4a02      	ldr	r2, [pc, #8]	; (4650 <z_nrf_clock_control_get_onoff+0xc>)
	return &data->mgr[type];
    4646:	b2c3      	uxtb	r3, r0
}
    4648:	201c      	movs	r0, #28
    464a:	fb03 2000 	mla	r0, r3, r0, r2
    464e:	4770      	bx	lr
    4650:	20001054 	.word	0x20001054

00004654 <z_nrf_clock_control_lf_on>:
{
    4654:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    4658:	4939      	ldr	r1, [pc, #228]	; (4740 <z_nrf_clock_control_lf_on+0xec>)
    465a:	f3bf 8f5b 	dmb	ish
    465e:	4607      	mov	r7, r0
    4660:	2201      	movs	r2, #1
    4662:	e851 3f00 	ldrex	r3, [r1]
    4666:	e841 2000 	strex	r0, r2, [r1]
    466a:	2800      	cmp	r0, #0
    466c:	d1f9      	bne.n	4662 <z_nrf_clock_control_lf_on+0xe>
    466e:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&on, 1) == 0) {
    4672:	b933      	cbnz	r3, 4682 <z_nrf_clock_control_lf_on+0x2e>
    4674:	4933      	ldr	r1, [pc, #204]	; (4744 <z_nrf_clock_control_lf_on+0xf0>)
		err = onoff_request(mgr, &cli);
    4676:	4834      	ldr	r0, [pc, #208]	; (4748 <z_nrf_clock_control_lf_on+0xf4>)
    4678:	604b      	str	r3, [r1, #4]
    467a:	60cb      	str	r3, [r1, #12]
    467c:	608a      	str	r2, [r1, #8]
    467e:	f003 fc3d 	bl	7efc <onoff_request>
	switch (start_mode) {
    4682:	1e7b      	subs	r3, r7, #1
    4684:	2b01      	cmp	r3, #1
    4686:	d82f      	bhi.n	46e8 <z_nrf_clock_control_lf_on+0x94>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    4688:	2f01      	cmp	r7, #1
    468a:	d107      	bne.n	469c <z_nrf_clock_control_lf_on+0x48>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    468c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4690:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
    4694:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    4698:	2b01      	cmp	r3, #1
    469a:	d025      	beq.n	46e8 <z_nrf_clock_control_lf_on+0x94>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    469c:	f004 fddb 	bl	9256 <k_is_in_isr>
    46a0:	4604      	mov	r4, r0
    46a2:	b918      	cbnz	r0, 46ac <z_nrf_clock_control_lf_on+0x58>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
    46a4:	4b29      	ldr	r3, [pc, #164]	; (474c <z_nrf_clock_control_lf_on+0xf8>)
	int key = isr_mode ? irq_lock() : 0;
    46a6:	781b      	ldrb	r3, [r3, #0]
    46a8:	2b00      	cmp	r3, #0
    46aa:	d141      	bne.n	4730 <z_nrf_clock_control_lf_on+0xdc>
	__asm__ volatile(
    46ac:	f04f 0320 	mov.w	r3, #32
    46b0:	f3ef 8611 	mrs	r6, BASEPRI
    46b4:	f383 8812 	msr	BASEPRI_MAX, r3
    46b8:	f3bf 8f6f 	isb	sy
    46bc:	2401      	movs	r4, #1
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    46be:	f8df 8090 	ldr.w	r8, [pc, #144]	; 4750 <z_nrf_clock_control_lf_on+0xfc>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    46c2:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    46c6:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    46ca:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
    46ce:	03d2      	lsls	r2, r2, #15
    46d0:	d50c      	bpl.n	46ec <z_nrf_clock_control_lf_on+0x98>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    46d2:	f003 0303 	and.w	r3, r3, #3
	while (!(nrfx_clock_is_running(d, (void *)&type)
    46d6:	2b01      	cmp	r3, #1
    46d8:	d001      	beq.n	46de <z_nrf_clock_control_lf_on+0x8a>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    46da:	2f01      	cmp	r7, #1
    46dc:	d106      	bne.n	46ec <z_nrf_clock_control_lf_on+0x98>
	if (isr_mode) {
    46de:	b30c      	cbz	r4, 4724 <z_nrf_clock_control_lf_on+0xd0>
	__asm__ volatile(
    46e0:	f386 8811 	msr	BASEPRI, r6
    46e4:	f3bf 8f6f 	isb	sy
}
    46e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
    46ec:	b1ac      	cbz	r4, 471a <z_nrf_clock_control_lf_on+0xc6>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    46ee:	4630      	mov	r0, r6
    46f0:	f7fe fd4e 	bl	3190 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    46f4:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    46f8:	2b00      	cmp	r3, #0
    46fa:	d1e4      	bne.n	46c6 <z_nrf_clock_control_lf_on+0x72>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    46fc:	f8d5 2104 	ldr.w	r2, [r5, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
    4700:	2a00      	cmp	r2, #0
    4702:	d0e0      	beq.n	46c6 <z_nrf_clock_control_lf_on+0x72>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4704:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
    4708:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
    470c:	2301      	movs	r3, #1
    470e:	f8c5 3518 	str.w	r3, [r5, #1304]	; 0x518
    4712:	f8c8 3180 	str.w	r3, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    4716:	60ab      	str	r3, [r5, #8]
}
    4718:	e7d5      	b.n	46c6 <z_nrf_clock_control_lf_on+0x72>
	return z_impl_k_sleep(timeout);
    471a:	2100      	movs	r1, #0
    471c:	2021      	movs	r0, #33	; 0x21
    471e:	f003 f903 	bl	7928 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    4722:	e7e7      	b.n	46f4 <z_nrf_clock_control_lf_on+0xa0>
    p_reg->INTENSET = mask;
    4724:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4728:	2202      	movs	r2, #2
    472a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    472e:	e7db      	b.n	46e8 <z_nrf_clock_control_lf_on+0x94>
    p_reg->INTENCLR = mask;
    4730:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4734:	2202      	movs	r2, #2
    4736:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	int key = isr_mode ? irq_lock() : 0;
    473a:	4606      	mov	r6, r0
}
    473c:	e7bf      	b.n	46be <z_nrf_clock_control_lf_on+0x6a>
    473e:	bf00      	nop
    4740:	200010a8 	.word	0x200010a8
    4744:	20001044 	.word	0x20001044
    4748:	20001070 	.word	0x20001070
    474c:	200013a9 	.word	0x200013a9
    4750:	e000e100 	.word	0xe000e100

00004754 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    4754:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    4756:	4b08      	ldr	r3, [pc, #32]	; (4778 <uart_console_init+0x24>)
    4758:	4808      	ldr	r0, [pc, #32]	; (477c <uart_console_init+0x28>)
    475a:	6018      	str	r0, [r3, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
    475c:	f004 fd21 	bl	91a2 <z_device_ready>
    4760:	b138      	cbz	r0, 4772 <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
    4762:	4807      	ldr	r0, [pc, #28]	; (4780 <uart_console_init+0x2c>)
    4764:	f7ff f850 	bl	3808 <__stdout_hook_install>
	__printk_hook_install(console_out);
    4768:	4805      	ldr	r0, [pc, #20]	; (4780 <uart_console_init+0x2c>)
    476a:	f7fc fe8b 	bl	1484 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
    476e:	2000      	movs	r0, #0
}
    4770:	bd08      	pop	{r3, pc}
		return -ENODEV;
    4772:	f06f 0012 	mvn.w	r0, #18
    4776:	e7fb      	b.n	4770 <uart_console_init+0x1c>
    4778:	200010ac 	.word	0x200010ac
    477c:	00009860 	.word	0x00009860
    4780:	00004785 	.word	0x00004785

00004784 <console_out>:
	if ('\n' == c) {
    4784:	280a      	cmp	r0, #10
{
    4786:	b538      	push	{r3, r4, r5, lr}
    4788:	4d07      	ldr	r5, [pc, #28]	; (47a8 <console_out+0x24>)
    478a:	4604      	mov	r4, r0
	if ('\n' == c) {
    478c:	d104      	bne.n	4798 <console_out+0x14>
		uart_poll_out(uart_console_dev, '\r');
    478e:	6828      	ldr	r0, [r5, #0]
	api->poll_out(dev, out_char);
    4790:	6883      	ldr	r3, [r0, #8]
    4792:	210d      	movs	r1, #13
    4794:	685b      	ldr	r3, [r3, #4]
    4796:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
    4798:	6828      	ldr	r0, [r5, #0]
    479a:	6883      	ldr	r3, [r0, #8]
    479c:	b2e1      	uxtb	r1, r4
    479e:	685b      	ldr	r3, [r3, #4]
    47a0:	4798      	blx	r3
}
    47a2:	4620      	mov	r0, r4
    47a4:	bd38      	pop	{r3, r4, r5, pc}
    47a6:	bf00      	nop
    47a8:	200010ac 	.word	0x200010ac

000047ac <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
    47ac:	b530      	push	{r4, r5, lr}
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    47ae:	6840      	ldr	r0, [r0, #4]
    47b0:	7a04      	ldrb	r4, [r0, #8]
    47b2:	f001 011f 	and.w	r1, r1, #31
	nrfx_err_t err;

	if (mode == GPIO_INT_MODE_DISABLED) {
    47b6:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
{
    47ba:	b085      	sub	sp, #20
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    47bc:	ea41 1444 	orr.w	r4, r1, r4, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
    47c0:	f04f 0500 	mov.w	r5, #0
    47c4:	d104      	bne.n	47d0 <gpio_nrfx_pin_interrupt_configure+0x24>
		nrfx_gpiote_trigger_disable(abs_pin);
    47c6:	4620      	mov	r0, r4
    47c8:	f001 f814 	bl	57f4 <nrfx_gpiote_trigger_disable>
		return -EIO;
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
    47cc:	2000      	movs	r0, #0
    47ce:	e02d      	b.n	482c <gpio_nrfx_pin_interrupt_configure+0x80>
	if (mode == GPIO_INT_MODE_LEVEL) {
    47d0:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
	nrfx_gpiote_trigger_config_t trigger_config = {
    47d4:	e9cd 5502 	strd	r5, r5, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
    47d8:	d12a      	bne.n	4830 <gpio_nrfx_pin_interrupt_configure+0x84>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
    47da:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    47de:	bf0c      	ite	eq
    47e0:	2304      	moveq	r3, #4
    47e2:	2305      	movne	r3, #5
	if (IS_ENABLED(CONFIG_GPIO_NRF_INT_EDGE_USING_GPIOTE) &&
    47e4:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
	nrfx_gpiote_trigger_config_t trigger_config = {
    47e8:	f88d 3008 	strb.w	r3, [sp, #8]
	if (IS_ENABLED(CONFIG_GPIO_NRF_INT_EDGE_USING_GPIOTE) &&
    47ec:	d12c      	bne.n	4848 <gpio_nrfx_pin_interrupt_configure+0x9c>
NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;

    return pin_number >> 5;
    47ee:	0962      	lsrs	r2, r4, #5
        case 1: return NRF_P1;
    47f0:	2a01      	cmp	r2, #1
    *p_pin = pin_number & 0x1F;
    47f2:	f004 031f 	and.w	r3, r4, #31
        case 1: return NRF_P1;
    47f6:	4a1d      	ldr	r2, [pc, #116]	; (486c <gpio_nrfx_pin_interrupt_configure+0xc0>)
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    47f8:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
        case 1: return NRF_P1;
    47fc:	bf18      	it	ne
    47fe:	f04f 42a0 	movne.w	r2, #1342177280	; 0x50000000
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    4802:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
    4806:	07db      	lsls	r3, r3, #31
    4808:	d41e      	bmi.n	4848 <gpio_nrfx_pin_interrupt_configure+0x9c>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
    480a:	f10d 0507 	add.w	r5, sp, #7
    480e:	4629      	mov	r1, r5
    4810:	4620      	mov	r0, r4
    4812:	f000 ff53 	bl	56bc <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
    4816:	4b16      	ldr	r3, [pc, #88]	; (4870 <gpio_nrfx_pin_interrupt_configure+0xc4>)
    4818:	4298      	cmp	r0, r3
    481a:	d114      	bne.n	4846 <gpio_nrfx_pin_interrupt_configure+0x9a>
			err = nrfx_gpiote_channel_alloc(&ch);
    481c:	4628      	mov	r0, r5
    481e:	f000 ff9b 	bl	5758 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
    4822:	4b14      	ldr	r3, [pc, #80]	; (4874 <gpio_nrfx_pin_interrupt_configure+0xc8>)
    4824:	4298      	cmp	r0, r3
    4826:	d00e      	beq.n	4846 <gpio_nrfx_pin_interrupt_configure+0x9a>
				return -ENOMEM;
    4828:	f06f 000b 	mvn.w	r0, #11
}
    482c:	b005      	add	sp, #20
    482e:	bd30      	pop	{r4, r5, pc}
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
    4830:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    4834:	d005      	beq.n	4842 <gpio_nrfx_pin_interrupt_configure+0x96>
    4836:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    483a:	bf0c      	ite	eq
    483c:	2302      	moveq	r3, #2
    483e:	2301      	movne	r3, #1
    4840:	e7d0      	b.n	47e4 <gpio_nrfx_pin_interrupt_configure+0x38>
    4842:	2303      	movs	r3, #3
    4844:	e7ce      	b.n	47e4 <gpio_nrfx_pin_interrupt_configure+0x38>
		trigger_config.p_in_channel = &ch;
    4846:	9503      	str	r5, [sp, #12]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    4848:	2300      	movs	r3, #0
    484a:	4619      	mov	r1, r3
    484c:	aa02      	add	r2, sp, #8
    484e:	4620      	mov	r0, r4
    4850:	f000 fe0e 	bl	5470 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    4854:	4b07      	ldr	r3, [pc, #28]	; (4874 <gpio_nrfx_pin_interrupt_configure+0xc8>)
    4856:	4298      	cmp	r0, r3
    4858:	d104      	bne.n	4864 <gpio_nrfx_pin_interrupt_configure+0xb8>
	nrfx_gpiote_trigger_enable(abs_pin, true);
    485a:	2101      	movs	r1, #1
    485c:	4620      	mov	r0, r4
    485e:	f000 ff81 	bl	5764 <nrfx_gpiote_trigger_enable>
    4862:	e7b3      	b.n	47cc <gpio_nrfx_pin_interrupt_configure+0x20>
		return -EIO;
    4864:	f06f 0004 	mvn.w	r0, #4
    4868:	e7e0      	b.n	482c <gpio_nrfx_pin_interrupt_configure+0x80>
    486a:	bf00      	nop
    486c:	50000300 	.word	0x50000300
    4870:	0bad0004 	.word	0x0bad0004
    4874:	0bad0000 	.word	0x0bad0000

00004878 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    4878:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
    487a:	f000 ff5d 	bl	5738 <nrfx_gpiote_is_init>
    487e:	4604      	mov	r4, r0
    4880:	b968      	cbnz	r0, 489e <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
    4882:	f000 ff31 	bl	56e8 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
    4886:	4b08      	ldr	r3, [pc, #32]	; (48a8 <gpio_nrfx_init+0x30>)
    4888:	4298      	cmp	r0, r3
    488a:	d10a      	bne.n	48a2 <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
    488c:	4807      	ldr	r0, [pc, #28]	; (48ac <gpio_nrfx_init+0x34>)
    488e:	4621      	mov	r1, r4
    4890:	f000 ff0e 	bl	56b0 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    4894:	4622      	mov	r2, r4
    4896:	2105      	movs	r1, #5
    4898:	2006      	movs	r0, #6
    489a:	f7fe fcb5 	bl	3208 <z_arm_irq_priority_set>
		return 0;
    489e:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
    48a0:	bd10      	pop	{r4, pc}
		return -EIO;
    48a2:	f06f 0004 	mvn.w	r0, #4
    48a6:	e7fb      	b.n	48a0 <gpio_nrfx_init+0x28>
    48a8:	0bad0000 	.word	0x0bad0000
    48ac:	000048b1 	.word	0x000048b1

000048b0 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    48b0:	0942      	lsrs	r2, r0, #5
{
    48b2:	b570      	push	{r4, r5, r6, lr}
    48b4:	4603      	mov	r3, r0
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    48b6:	d002      	beq.n	48be <nrfx_gpio_handler+0xe>
    48b8:	2a01      	cmp	r2, #1
    48ba:	d015      	beq.n	48e8 <nrfx_gpio_handler+0x38>
}
    48bc:	bd70      	pop	{r4, r5, r6, pc}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    48be:	4e0b      	ldr	r6, [pc, #44]	; (48ec <nrfx_gpio_handler+0x3c>)
	gpio_fire_callbacks(list, port, BIT(pin));
    48c0:	6932      	ldr	r2, [r6, #16]
    48c2:	6851      	ldr	r1, [r2, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    48c4:	2900      	cmp	r1, #0
    48c6:	d0f9      	beq.n	48bc <nrfx_gpio_handler+0xc>
    *p_pin = pin_number & 0x1F;
    48c8:	f003 031f 	and.w	r3, r3, #31
    48cc:	2501      	movs	r5, #1
    48ce:	680c      	ldr	r4, [r1, #0]
    48d0:	409d      	lsls	r5, r3
		if (cb->pin_mask & pins) {
    48d2:	688a      	ldr	r2, [r1, #8]
    48d4:	402a      	ands	r2, r5
    48d6:	d002      	beq.n	48de <nrfx_gpio_handler+0x2e>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
    48d8:	684b      	ldr	r3, [r1, #4]
    48da:	4630      	mov	r0, r6
    48dc:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    48de:	2c00      	cmp	r4, #0
    48e0:	d0ec      	beq.n	48bc <nrfx_gpio_handler+0xc>
    48e2:	4621      	mov	r1, r4
    48e4:	6824      	ldr	r4, [r4, #0]
    48e6:	e7f4      	b.n	48d2 <nrfx_gpio_handler+0x22>
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    48e8:	4e01      	ldr	r6, [pc, #4]	; (48f0 <nrfx_gpio_handler+0x40>)
    48ea:	e7e9      	b.n	48c0 <nrfx_gpio_handler+0x10>
    48ec:	00009830 	.word	0x00009830
    48f0:	00009848 	.word	0x00009848

000048f4 <gpio_nrfx_pin_configure>:
{
    48f4:	b5f0      	push	{r4, r5, r6, r7, lr}
	return port->config;
    48f6:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    48f8:	7a3b      	ldrb	r3, [r7, #8]
    48fa:	f001 051f 	and.w	r5, r1, #31
{
    48fe:	b085      	sub	sp, #20
    4900:	460e      	mov	r6, r1
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    4902:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
    4906:	4614      	mov	r4, r2
    4908:	b9c2      	cbnz	r2, 493c <gpio_nrfx_pin_configure+0x48>
	err = nrfx_gpiote_channel_get(pin, &ch);
    490a:	a902      	add	r1, sp, #8
    490c:	4628      	mov	r0, r5
    490e:	f000 fed5 	bl	56bc <nrfx_gpiote_channel_get>
    4912:	4604      	mov	r4, r0
	err = nrfx_gpiote_pin_uninit(pin);
    4914:	4628      	mov	r0, r5
    4916:	f000 ff95 	bl	5844 <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
    491a:	4b41      	ldr	r3, [pc, #260]	; (4a20 <gpio_nrfx_pin_configure+0x12c>)
    491c:	4298      	cmp	r0, r3
    491e:	d003      	beq.n	4928 <gpio_nrfx_pin_configure+0x34>
		return -EIO;
    4920:	f06f 0004 	mvn.w	r0, #4
}
    4924:	b005      	add	sp, #20
    4926:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (free_ch) {
    4928:	4284      	cmp	r4, r0
    492a:	d105      	bne.n	4938 <gpio_nrfx_pin_configure+0x44>
		err = nrfx_gpiote_channel_free(ch);
    492c:	f89d 0008 	ldrb.w	r0, [sp, #8]
    4930:	f000 ff0c 	bl	574c <nrfx_gpiote_channel_free>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
    4934:	42a0      	cmp	r0, r4
    4936:	d1f3      	bne.n	4920 <gpio_nrfx_pin_configure+0x2c>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    4938:	2000      	movs	r0, #0
    493a:	e7f3      	b.n	4924 <gpio_nrfx_pin_configure+0x30>
	nrfx_gpiote_trigger_config_t trigger_config = {
    493c:	2300      	movs	r3, #0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    493e:	4619      	mov	r1, r3
    4940:	aa02      	add	r2, sp, #8
    4942:	4628      	mov	r0, r5
	nrfx_gpiote_trigger_config_t trigger_config = {
    4944:	e9cd 3302 	strd	r3, r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    4948:	f000 fd92 	bl	5470 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    494c:	4b34      	ldr	r3, [pc, #208]	; (4a20 <gpio_nrfx_pin_configure+0x12c>)
    494e:	4298      	cmp	r0, r3
    4950:	d002      	beq.n	4958 <gpio_nrfx_pin_configure+0x64>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    4952:	f06f 0015 	mvn.w	r0, #21
    4956:	e7e5      	b.n	4924 <gpio_nrfx_pin_configure+0x30>
	if (flags & GPIO_OUTPUT) {
    4958:	05a3      	lsls	r3, r4, #22
    495a:	d54e      	bpl.n	49fa <gpio_nrfx_pin_configure+0x106>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    495c:	4b31      	ldr	r3, [pc, #196]	; (4a24 <gpio_nrfx_pin_configure+0x130>)
    495e:	4a32      	ldr	r2, [pc, #200]	; (4a28 <gpio_nrfx_pin_configure+0x134>)
    4960:	4023      	ands	r3, r4
    4962:	4293      	cmp	r3, r2
    4964:	d03a      	beq.n	49dc <gpio_nrfx_pin_configure+0xe8>
    4966:	d80c      	bhi.n	4982 <gpio_nrfx_pin_configure+0x8e>
    4968:	2b06      	cmp	r3, #6
    496a:	d014      	beq.n	4996 <gpio_nrfx_pin_configure+0xa2>
    496c:	d804      	bhi.n	4978 <gpio_nrfx_pin_configure+0x84>
    496e:	b193      	cbz	r3, 4996 <gpio_nrfx_pin_configure+0xa2>
    4970:	2b02      	cmp	r3, #2
    4972:	d1ee      	bne.n	4952 <gpio_nrfx_pin_configure+0x5e>
    4974:	2304      	movs	r3, #4
    4976:	e00e      	b.n	4996 <gpio_nrfx_pin_configure+0xa2>
    4978:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    497c:	d1e9      	bne.n	4952 <gpio_nrfx_pin_configure+0x5e>
		*drive = NRF_GPIO_PIN_H0S1;
    497e:	2301      	movs	r3, #1
    4980:	e009      	b.n	4996 <gpio_nrfx_pin_configure+0xa2>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    4982:	4a2a      	ldr	r2, [pc, #168]	; (4a2c <gpio_nrfx_pin_configure+0x138>)
    4984:	4293      	cmp	r3, r2
    4986:	d02b      	beq.n	49e0 <gpio_nrfx_pin_configure+0xec>
    4988:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    498c:	d02a      	beq.n	49e4 <gpio_nrfx_pin_configure+0xf0>
    498e:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    4992:	d1de      	bne.n	4952 <gpio_nrfx_pin_configure+0x5e>
		*drive = NRF_GPIO_PIN_S0H1;
    4994:	2302      	movs	r3, #2
		nrfx_gpiote_output_config_t output_config = {
    4996:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
    499a:	f484 7380 	eor.w	r3, r4, #256	; 0x100
    499e:	f3c3 2300 	ubfx	r3, r3, #8, #1
	if (flags & GPIO_PULL_UP) {
    49a2:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
    49a4:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLDOWN;
    49a8:	bf54      	ite	pl
    49aa:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		return NRF_GPIO_PIN_PULLUP;
    49ae:	2303      	movmi	r3, #3
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
    49b0:	0521      	lsls	r1, r4, #20
		nrfx_gpiote_output_config_t output_config = {
    49b2:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
    49b6:	d517      	bpl.n	49e8 <gpio_nrfx_pin_configure+0xf4>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
    49b8:	687b      	ldr	r3, [r7, #4]
    49ba:	2101      	movs	r1, #1
    49bc:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
    49c0:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
    49c4:	2200      	movs	r2, #0
    49c6:	a901      	add	r1, sp, #4
    49c8:	4628      	mov	r0, r5
    49ca:	f000 fdff 	bl	55cc <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    49ce:	4b14      	ldr	r3, [pc, #80]	; (4a20 <gpio_nrfx_pin_configure+0x12c>)
    49d0:	4298      	cmp	r0, r3
    49d2:	bf14      	ite	ne
    49d4:	f06f 0015 	mvnne.w	r0, #21
    49d8:	2000      	moveq	r0, #0
    49da:	e7a3      	b.n	4924 <gpio_nrfx_pin_configure+0x30>
		*drive = NRF_GPIO_PIN_H0D1;
    49dc:	2307      	movs	r3, #7
    49de:	e7da      	b.n	4996 <gpio_nrfx_pin_configure+0xa2>
		*drive = NRF_GPIO_PIN_D0H1;
    49e0:	2305      	movs	r3, #5
    49e2:	e7d8      	b.n	4996 <gpio_nrfx_pin_configure+0xa2>
		*drive = NRF_GPIO_PIN_H0H1;
    49e4:	2303      	movs	r3, #3
    49e6:	e7d6      	b.n	4996 <gpio_nrfx_pin_configure+0xa2>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
    49e8:	0562      	lsls	r2, r4, #21
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
    49ea:	bf41      	itttt	mi
    49ec:	687b      	ldrmi	r3, [r7, #4]
    49ee:	2101      	movmi	r1, #1
    49f0:	fa01 f606 	lslmi.w	r6, r1, r6
    p_reg->OUTCLR = clr_mask;
    49f4:	f8c3 650c 	strmi.w	r6, [r3, #1292]	; 0x50c
}
    49f8:	e7e4      	b.n	49c4 <gpio_nrfx_pin_configure+0xd0>
	if (flags & GPIO_PULL_UP) {
    49fa:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    49fc:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
    4a00:	bf54      	ite	pl
    4a02:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
    4a06:	2403      	movmi	r4, #3
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    4a08:	461a      	mov	r2, r3
    4a0a:	a901      	add	r1, sp, #4
    4a0c:	4628      	mov	r0, r5
	nrfx_gpiote_input_config_t input_config = {
    4a0e:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    4a12:	f000 fd2d 	bl	5470 <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    4a16:	4b02      	ldr	r3, [pc, #8]	; (4a20 <gpio_nrfx_pin_configure+0x12c>)
    4a18:	4298      	cmp	r0, r3
    4a1a:	d08d      	beq.n	4938 <gpio_nrfx_pin_configure+0x44>
    4a1c:	e799      	b.n	4952 <gpio_nrfx_pin_configure+0x5e>
    4a1e:	bf00      	nop
    4a20:	0bad0000 	.word	0x0bad0000
    4a24:	00f00006 	.word	0x00f00006
    4a28:	00100006 	.word	0x00100006
    4a2c:	00400002 	.word	0x00400002

00004a30 <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
    4a30:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
    4a32:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    4a36:	095b      	lsrs	r3, r3, #5
        case 1: return NRF_P1;
    4a38:	2b01      	cmp	r3, #1
    *p_pin = pin_number & 0x1F;
    4a3a:	6002      	str	r2, [r0, #0]
}
    4a3c:	4802      	ldr	r0, [pc, #8]	; (4a48 <nrf_gpio_pin_port_decode+0x18>)
    4a3e:	bf18      	it	ne
    4a40:	f04f 40a0 	movne.w	r0, #1342177280	; 0x50000000
    4a44:	4770      	bx	lr
    4a46:	bf00      	nop
    4a48:	50000300 	.word	0x50000300

00004a4c <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
    4a4c:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
    4a4e:	794b      	ldrb	r3, [r1, #5]
    4a50:	2b01      	cmp	r3, #1
    4a52:	d026      	beq.n	4aa2 <uarte_nrfx_configure+0x56>
    4a54:	2b03      	cmp	r3, #3
    4a56:	d121      	bne.n	4a9c <uarte_nrfx_configure+0x50>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
    4a58:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    4a5a:	798b      	ldrb	r3, [r1, #6]
    4a5c:	2b03      	cmp	r3, #3
    4a5e:	d11d      	bne.n	4a9c <uarte_nrfx_configure+0x50>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    4a60:	79cc      	ldrb	r4, [r1, #7]
    4a62:	b10c      	cbz	r4, 4a68 <uarte_nrfx_configure+0x1c>
    4a64:	2c01      	cmp	r4, #1
    4a66:	d119      	bne.n	4a9c <uarte_nrfx_configure+0x50>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
    4a68:	790a      	ldrb	r2, [r1, #4]
    4a6a:	b112      	cbz	r2, 4a72 <uarte_nrfx_configure+0x26>
    4a6c:	2a02      	cmp	r2, #2
    4a6e:	d115      	bne.n	4a9c <uarte_nrfx_configure+0x50>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
    4a70:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
    4a72:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
    4a74:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
    4a76:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
    4a7a:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
    4a7c:	d065      	beq.n	4b4a <uarte_nrfx_configure+0xfe>
    4a7e:	d82d      	bhi.n	4adc <uarte_nrfx_configure+0x90>
    4a80:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    4a84:	d064      	beq.n	4b50 <uarte_nrfx_configure+0x104>
    4a86:	d816      	bhi.n	4ab6 <uarte_nrfx_configure+0x6a>
    4a88:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    4a8c:	d062      	beq.n	4b54 <uarte_nrfx_configure+0x108>
    4a8e:	d80a      	bhi.n	4aa6 <uarte_nrfx_configure+0x5a>
    4a90:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    4a94:	d061      	beq.n	4b5a <uarte_nrfx_configure+0x10e>
    4a96:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    4a9a:	d061      	beq.n	4b60 <uarte_nrfx_configure+0x114>
    4a9c:	f06f 0085 	mvn.w	r0, #133	; 0x85
    4aa0:	e052      	b.n	4b48 <uarte_nrfx_configure+0xfc>
	switch (cfg->stop_bits) {
    4aa2:	2600      	movs	r6, #0
    4aa4:	e7d9      	b.n	4a5a <uarte_nrfx_configure+0xe>
	switch (baudrate) {
    4aa6:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    4aaa:	d05c      	beq.n	4b66 <uarte_nrfx_configure+0x11a>
    4aac:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    4ab0:	d1f4      	bne.n	4a9c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    4ab2:	4b37      	ldr	r3, [pc, #220]	; (4b90 <uarte_nrfx_configure+0x144>)
    4ab4:	e03c      	b.n	4b30 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    4ab6:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    4aba:	d057      	beq.n	4b6c <uarte_nrfx_configure+0x120>
    4abc:	d807      	bhi.n	4ace <uarte_nrfx_configure+0x82>
    4abe:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    4ac2:	d055      	beq.n	4b70 <uarte_nrfx_configure+0x124>
    4ac4:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    4ac8:	d1e8      	bne.n	4a9c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    4aca:	4b32      	ldr	r3, [pc, #200]	; (4b94 <uarte_nrfx_configure+0x148>)
    4acc:	e030      	b.n	4b30 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    4ace:	f647 2712 	movw	r7, #31250	; 0x7a12
    4ad2:	42bb      	cmp	r3, r7
    4ad4:	d1e2      	bne.n	4a9c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    4ad6:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    4ada:	e029      	b.n	4b30 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    4adc:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    4ae0:	d048      	beq.n	4b74 <uarte_nrfx_configure+0x128>
    4ae2:	d813      	bhi.n	4b0c <uarte_nrfx_configure+0xc0>
    4ae4:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    4ae8:	d047      	beq.n	4b7a <uarte_nrfx_configure+0x12e>
    4aea:	d809      	bhi.n	4b00 <uarte_nrfx_configure+0xb4>
    4aec:	f64d 27c0 	movw	r7, #56000	; 0xdac0
    4af0:	42bb      	cmp	r3, r7
    4af2:	d044      	beq.n	4b7e <uarte_nrfx_configure+0x132>
    4af4:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    4af8:	d1d0      	bne.n	4a9c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    4afa:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    4afe:	e017      	b.n	4b30 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    4b00:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    4b04:	d1ca      	bne.n	4a9c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    4b06:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    4b0a:	e011      	b.n	4b30 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    4b0c:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    4b10:	d038      	beq.n	4b84 <uarte_nrfx_configure+0x138>
    4b12:	d808      	bhi.n	4b26 <uarte_nrfx_configure+0xda>
    4b14:	4f20      	ldr	r7, [pc, #128]	; (4b98 <uarte_nrfx_configure+0x14c>)
    4b16:	42bb      	cmp	r3, r7
    4b18:	d037      	beq.n	4b8a <uarte_nrfx_configure+0x13e>
    4b1a:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    4b1e:	d1bd      	bne.n	4a9c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    4b20:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    4b24:	e004      	b.n	4b30 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    4b26:	4f1d      	ldr	r7, [pc, #116]	; (4b9c <uarte_nrfx_configure+0x150>)
    4b28:	42bb      	cmp	r3, r7
    4b2a:	d1b7      	bne.n	4a9c <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    4b2c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    4b30:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
    4b34:	6903      	ldr	r3, [r0, #16]
    4b36:	c903      	ldmia	r1, {r0, r1}
                    | (uint32_t)p_cfg->hwfc;
    4b38:	4334      	orrs	r4, r6
    4b3a:	4322      	orrs	r2, r4
    4b3c:	3304      	adds	r3, #4
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    4b3e:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
    4b42:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
    4b46:	2000      	movs	r0, #0
}
    4b48:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    4b4a:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    4b4e:	e7ef      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    4b50:	4b13      	ldr	r3, [pc, #76]	; (4ba0 <uarte_nrfx_configure+0x154>)
    4b52:	e7ed      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    4b54:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    4b58:	e7ea      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = 0x00014000;
    4b5a:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    4b5e:	e7e7      	b.n	4b30 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    4b60:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    4b64:	e7e4      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    4b66:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    4b6a:	e7e1      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    4b6c:	4b0d      	ldr	r3, [pc, #52]	; (4ba4 <uarte_nrfx_configure+0x158>)
    4b6e:	e7df      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    4b70:	4b0d      	ldr	r3, [pc, #52]	; (4ba8 <uarte_nrfx_configure+0x15c>)
    4b72:	e7dd      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    4b74:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    4b78:	e7da      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    4b7a:	4b0c      	ldr	r3, [pc, #48]	; (4bac <uarte_nrfx_configure+0x160>)
    4b7c:	e7d8      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    4b7e:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    4b82:	e7d5      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    4b84:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    4b88:	e7d2      	b.n	4b30 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    4b8a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    4b8e:	e7cf      	b.n	4b30 <uarte_nrfx_configure+0xe4>
    4b90:	0013b000 	.word	0x0013b000
    4b94:	004ea000 	.word	0x004ea000
    4b98:	0003d090 	.word	0x0003d090
    4b9c:	000f4240 	.word	0x000f4240
    4ba0:	00275000 	.word	0x00275000
    4ba4:	0075c000 	.word	0x0075c000
    4ba8:	003af000 	.word	0x003af000
    4bac:	013a9000 	.word	0x013a9000

00004bb0 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
    4bb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return dev->data;
    4bb2:	6906      	ldr	r6, [r0, #16]
{
    4bb4:	4605      	mov	r5, r0
    4bb6:	460f      	mov	r7, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    4bb8:	f004 fb4d 	bl	9256 <k_is_in_isr>
    4bbc:	b910      	cbnz	r0, 4bc4 <uarte_nrfx_poll_out+0x14>
	return !z_sys_post_kernel;
    4bbe:	4b20      	ldr	r3, [pc, #128]	; (4c40 <uarte_nrfx_poll_out+0x90>)
	int key;

	if (isr_mode) {
    4bc0:	781b      	ldrb	r3, [r3, #0]
    4bc2:	b983      	cbnz	r3, 4be6 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
    4bc4:	f04f 0320 	mov.w	r3, #32
    4bc8:	f3ef 8411 	mrs	r4, BASEPRI
    4bcc:	f383 8812 	msr	BASEPRI_MAX, r3
    4bd0:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
    4bd4:	6868      	ldr	r0, [r5, #4]
    4bd6:	f004 f8d2 	bl	8d7e <is_tx_ready.isra.0>
    4bda:	bb28      	cbnz	r0, 4c28 <uarte_nrfx_poll_out+0x78>
	__asm__ volatile(
    4bdc:	f384 8811 	msr	BASEPRI, r4
    4be0:	f3bf 8f6f 	isb	sy
}
    4be4:	e7ee      	b.n	4bc4 <uarte_nrfx_poll_out+0x14>
{
    4be6:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
    4be8:	6868      	ldr	r0, [r5, #4]
    4bea:	f004 f8c8 	bl	8d7e <is_tx_ready.isra.0>
    4bee:	b970      	cbnz	r0, 4c0e <uarte_nrfx_poll_out+0x5e>
    4bf0:	2001      	movs	r0, #1
    4bf2:	f004 f97d 	bl	8ef0 <nrfx_busy_wait>
    4bf6:	3c01      	subs	r4, #1
    4bf8:	d1f6      	bne.n	4be8 <uarte_nrfx_poll_out+0x38>
    4bfa:	2100      	movs	r1, #0
    4bfc:	2021      	movs	r0, #33	; 0x21
    4bfe:	f002 fe93 	bl	7928 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    4c02:	e7f0      	b.n	4be6 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
    4c04:	f384 8811 	msr	BASEPRI, r4
    4c08:	f3bf 8f6f 	isb	sy
}
    4c0c:	e7f5      	b.n	4bfa <uarte_nrfx_poll_out+0x4a>
	__asm__ volatile(
    4c0e:	f04f 0320 	mov.w	r3, #32
    4c12:	f3ef 8411 	mrs	r4, BASEPRI
    4c16:	f383 8812 	msr	BASEPRI_MAX, r3
    4c1a:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
    4c1e:	6868      	ldr	r0, [r5, #4]
    4c20:	f004 f8ad 	bl	8d7e <is_tx_ready.isra.0>
    4c24:	2800      	cmp	r0, #0
    4c26:	d0ed      	beq.n	4c04 <uarte_nrfx_poll_out+0x54>
		}
	} else {
		key = wait_tx_ready(dev);
	}

	data->char_out = c;
    4c28:	4631      	mov	r1, r6
	tx_start(dev, &data->char_out, 1);
    4c2a:	2201      	movs	r2, #1
	data->char_out = c;
    4c2c:	f801 7f14 	strb.w	r7, [r1, #20]!
	tx_start(dev, &data->char_out, 1);
    4c30:	6868      	ldr	r0, [r5, #4]
    4c32:	f004 f889 	bl	8d48 <tx_start.isra.0>
	__asm__ volatile(
    4c36:	f384 8811 	msr	BASEPRI, r4
    4c3a:	f3bf 8f6f 	isb	sy

	irq_unlock(key);
}
    4c3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4c40:	200013a9 	.word	0x200013a9

00004c44 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
    4c44:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4c48:	2200      	movs	r2, #0
    4c4a:	4606      	mov	r6, r0
    4c4c:	2101      	movs	r1, #1
    4c4e:	2002      	movs	r0, #2
    4c50:	f7fe fada 	bl	3208 <z_arm_irq_priority_set>
    4c54:	2002      	movs	r0, #2
    4c56:	f7fe faa5 	bl	31a4 <arch_irq_enable>
	return dev->config;
    4c5a:	f8d6 8004 	ldr.w	r8, [r6, #4]
	return dev->data;
    4c5e:	6937      	ldr	r7, [r6, #16]
	return config->uarte_regs;
    4c60:	f8d8 4000 	ldr.w	r4, [r8]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
    4c64:	2300      	movs	r3, #0
    4c66:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	data->dev = dev;
    4c6a:	603e      	str	r6, [r7, #0]
	uarte_nrfx_pins_configure(dev, false);
    4c6c:	6875      	ldr	r5, [r6, #4]
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    4c6e:	68eb      	ldr	r3, [r5, #12]
    4c70:	1c5a      	adds	r2, r3, #1
    4c72:	d013      	beq.n	4c9c <uarte_0_init+0x58>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    4c74:	a801      	add	r0, sp, #4
    4c76:	9301      	str	r3, [sp, #4]
    4c78:	f7ff feda 	bl	4a30 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    4c7c:	9a01      	ldr	r2, [sp, #4]
    4c7e:	2301      	movs	r3, #1
    4c80:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    4c82:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
    nrf_gpio_cfg(
    4c86:	68eb      	ldr	r3, [r5, #12]
    4c88:	9301      	str	r3, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    4c8a:	a801      	add	r0, sp, #4
    4c8c:	f7ff fed0 	bl	4a30 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    4c90:	9b01      	ldr	r3, [sp, #4]
    4c92:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    4c96:	2203      	movs	r2, #3
    4c98:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
		if (cfg->rx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    4c9c:	6928      	ldr	r0, [r5, #16]
    4c9e:	1c43      	adds	r3, r0, #1
    4ca0:	d006      	beq.n	4cb0 <uarte_0_init+0x6c>
			nrf_gpio_cfg_input(cfg->rx_pin,
    4ca2:	7f2b      	ldrb	r3, [r5, #28]
    4ca4:	2b00      	cmp	r3, #0
    4ca6:	bf14      	ite	ne
    4ca8:	2103      	movne	r1, #3
    4caa:	2100      	moveq	r1, #0
    4cac:	f004 f83e 	bl	8d2c <nrf_gpio_cfg_input>
		if (cfg->rts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    4cb0:	696b      	ldr	r3, [r5, #20]
    4cb2:	1c5a      	adds	r2, r3, #1
    4cb4:	d013      	beq.n	4cde <uarte_0_init+0x9a>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    4cb6:	a801      	add	r0, sp, #4
    4cb8:	9301      	str	r3, [sp, #4]
    4cba:	f7ff feb9 	bl	4a30 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    4cbe:	9a01      	ldr	r2, [sp, #4]
    4cc0:	2301      	movs	r3, #1
    4cc2:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    4cc4:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
    nrf_gpio_cfg(
    4cc8:	696b      	ldr	r3, [r5, #20]
    4cca:	9301      	str	r3, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    4ccc:	a801      	add	r0, sp, #4
    4cce:	f7ff feaf 	bl	4a30 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    4cd2:	9b01      	ldr	r3, [sp, #4]
    4cd4:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    4cd8:	2203      	movs	r2, #3
    4cda:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
		if (cfg->cts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    4cde:	69a8      	ldr	r0, [r5, #24]
    4ce0:	1c43      	adds	r3, r0, #1
    4ce2:	d006      	beq.n	4cf2 <uarte_0_init+0xae>
			nrf_gpio_cfg_input(cfg->cts_pin,
    4ce4:	7f6b      	ldrb	r3, [r5, #29]
    4ce6:	2b00      	cmp	r3, #0
    4ce8:	bf14      	ite	ne
    4cea:	2103      	movne	r1, #3
    4cec:	2100      	moveq	r1, #0
    4cee:	f004 f81d 	bl	8d2c <nrf_gpio_cfg_input>
	nrf_uarte_txrx_pins_set(cfg->uarte_regs, cfg->tx_pin, cfg->rx_pin);
    4cf2:	e9d5 1203 	ldrd	r1, r2, [r5, #12]
    4cf6:	682b      	ldr	r3, [r5, #0]
    p_reg->PSEL.TXD = pseltxd;
    4cf8:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    4cfc:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
	nrf_uarte_hwfc_pins_set(cfg->uarte_regs, cfg->rts_pin, cfg->cts_pin);
    4d00:	e9d5 1205 	ldrd	r1, r2, [r5, #20]
    p_reg->PSEL.RTS = pselrts;
    4d04:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    4d08:	6931      	ldr	r1, [r6, #16]
    p_reg->PSEL.CTS = pselcts;
    4d0a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    4d0e:	3104      	adds	r1, #4
    4d10:	4630      	mov	r0, r6
    4d12:	f7ff fe9b 	bl	4a4c <uarte_nrfx_configure>
	if (err) {
    4d16:	4605      	mov	r5, r0
    4d18:	2800      	cmp	r0, #0
    4d1a:	d146      	bne.n	4daa <uarte_0_init+0x166>
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
    4d1c:	f8d8 3004 	ldr.w	r3, [r8, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
    4d20:	0799      	lsls	r1, r3, #30
    4d22:	d519      	bpl.n	4d58 <uarte_0_init+0x114>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
    4d24:	f107 0016 	add.w	r0, r7, #22
    4d28:	f000 ff26 	bl	5b78 <nrfx_ppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
    4d2c:	4b22      	ldr	r3, [pc, #136]	; (4db8 <uarte_0_init+0x174>)
    4d2e:	4298      	cmp	r0, r3
    4d30:	d13f      	bne.n	4db2 <uarte_0_init+0x16e>
	nrfx_gppi_channel_endpoints_setup(data->ppi_ch_endtx,
    4d32:	7db8      	ldrb	r0, [r7, #22]
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
    4d34:	00c3      	lsls	r3, r0, #3
    4d36:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    4d3a:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
    return (uint32_t)p_reg + (uint32_t)task;
    4d3e:	f104 020c 	add.w	r2, r4, #12
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
    4d42:	f504 7190 	add.w	r1, r4, #288	; 0x120
NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                      nrf_ppi_channel_t channel,
                                                      uint32_t          eep,
                                                      uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
    4d46:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
    p_reg->CH[(uint32_t) channel].TEP = tep;
    4d4a:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
    p_reg->CHENSET = mask;
    4d4e:	4a1b      	ldr	r2, [pc, #108]	; (4dbc <uarte_0_init+0x178>)
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
    4d50:	2301      	movs	r3, #1
    4d52:	4083      	lsls	r3, r0
    4d54:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    4d58:	2308      	movs	r3, #8
    4d5a:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		if (!cfg->disable_rx) {
    4d5e:	f898 3008 	ldrb.w	r3, [r8, #8]
    4d62:	b95b      	cbnz	r3, 4d7c <uarte_0_init+0x138>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4d64:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
    4d68:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    4d6c:	f107 0315 	add.w	r3, r7, #21

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    4d70:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    4d74:	2301      	movs	r3, #1
    4d76:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    4d7a:	6023      	str	r3, [r4, #0]
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
    4d7c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    4d80:	079a      	lsls	r2, r3, #30
    p_reg->INTENSET = mask;
    4d82:	bf5c      	itt	pl
    4d84:	f44f 7280 	movpl.w	r2, #256	; 0x100
    4d88:	f8c4 2304 	strpl.w	r2, [r4, #772]	; 0x304
	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
    4d8c:	06db      	lsls	r3, r3, #27
    4d8e:	bf44      	itt	mi
    4d90:	f44f 0380 	movmi.w	r3, #4194304	; 0x400000
    4d94:	f8c4 3304 	strmi.w	r3, [r4, #772]	; 0x304
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
    4d98:	3714      	adds	r7, #20
    p_reg->TXD.MAXCNT = length;
    4d9a:	2300      	movs	r3, #0
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    4d9c:	f8c4 7544 	str.w	r7, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    4da0:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    4da4:	2301      	movs	r3, #1
    4da6:	60a3      	str	r3, [r4, #8]
    4da8:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
    4daa:	4628      	mov	r0, r5
    4dac:	b002      	add	sp, #8
    4dae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -EIO;
    4db2:	f06f 0504 	mvn.w	r5, #4
UART_NRF_UARTE_DEVICE(0);
    4db6:	e7f8      	b.n	4daa <uarte_0_init+0x166>
    4db8:	0bad0000 	.word	0x0bad0000
    4dbc:	4001f000 	.word	0x4001f000

00004dc0 <sys_clock_timeout_handler>:

static void sys_clock_timeout_handler(int32_t chan,
				      uint32_t cc_value,
				      void *user_data)
{
	uint32_t dticks = counter_sub(cc_value, last_count) / CYC_PER_TICK;
    4dc0:	4a04      	ldr	r2, [pc, #16]	; (4dd4 <sys_clock_timeout_handler+0x14>)
    4dc2:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    4dc4:	1ac8      	subs	r0, r1, r3
    4dc6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    4dca:	4403      	add	r3, r0
    4dcc:	6013      	str	r3, [r2, #0]
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
    4dce:	f002 bf1f 	b.w	7c10 <sys_clock_announce>
    4dd2:	bf00      	nop
    4dd4:	200010d4 	.word	0x200010d4

00004dd8 <sys_clock_driver_init>:
	k_spin_unlock(&lock, key);
	return ret;
}

static int sys_clock_driver_init(const struct device *dev)
{
    4dd8:	b538      	push	{r3, r4, r5, lr}
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
    4dda:	4c0f      	ldr	r4, [pc, #60]	; (4e18 <sys_clock_driver_init+0x40>)
    4ddc:	2500      	movs	r5, #0
    p_reg->INTENSET = mask;
    4dde:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->PRESCALER = val;
    4de2:	f8c4 5508 	str.w	r5, [r4, #1288]	; 0x508
    p_reg->INTENSET = mask;
    4de6:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    4dea:	4b0c      	ldr	r3, [pc, #48]	; (4e1c <sys_clock_driver_init+0x44>)
    4dec:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    4df0:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
	}

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    4df4:	2101      	movs	r1, #1
    4df6:	462a      	mov	r2, r5
    4df8:	2011      	movs	r0, #17
    4dfa:	f7fe fa05 	bl	3208 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    4dfe:	2011      	movs	r0, #17
    4e00:	f7fe f9d0 	bl	31a4 <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    4e04:	2301      	movs	r3, #1

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
    4e06:	4a06      	ldr	r2, [pc, #24]	; (4e20 <sys_clock_driver_init+0x48>)
    4e08:	60a3      	str	r3, [r4, #8]
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		compare_set(0, counter() + CYC_PER_TICK,
			    sys_clock_timeout_handler, NULL);
	}

	z_nrf_clock_control_lf_on(mode);
    4e0a:	2002      	movs	r0, #2
    4e0c:	6023      	str	r3, [r4, #0]
	int_mask = BIT_MASK(CHAN_COUNT);
    4e0e:	6013      	str	r3, [r2, #0]
	z_nrf_clock_control_lf_on(mode);
    4e10:	f7ff fc20 	bl	4654 <z_nrf_clock_control_lf_on>

	return 0;
}
    4e14:	4628      	mov	r0, r5
    4e16:	bd38      	pop	{r3, r4, r5, pc}
    4e18:	40011000 	.word	0x40011000
    4e1c:	e000e100 	.word	0xe000e100
    4e20:	200010d0 	.word	0x200010d0

00004e24 <set_absolute_alarm>:
{
    4e24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4e28:	0086      	lsls	r6, r0, #2
    4e2a:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    4e2e:	f100 0450 	add.w	r4, r0, #80	; 0x50
    4e32:	f506 3688 	add.w	r6, r6, #69632	; 0x11000
    4e36:	00a4      	lsls	r4, r4, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    4e38:	b2a4      	uxth	r4, r4
    4e3a:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    4e3e:	f44f 3780 	mov.w	r7, #65536	; 0x10000
    return p_reg->CC[ch];
    4e42:	f8d6 3540 	ldr.w	r3, [r6, #1344]	; 0x540
     return p_reg->COUNTER;
    4e46:	f8df 806c 	ldr.w	r8, [pc, #108]	; 4eb4 <set_absolute_alarm+0x90>
	uint32_t cc_val = abs_val & COUNTER_MAX;
    4e4a:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    4e4e:	f504 3488 	add.w	r4, r4, #69632	; 0x11000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    4e52:	4087      	lsls	r7, r0
     return p_reg->COUNTER;
    4e54:	f8d8 9504 	ldr.w	r9, [r8, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    4e58:	eba3 0309 	sub.w	r3, r3, r9
    4e5c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    4e60:	f029 427f 	bic.w	r2, r9, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
    4e64:	2b01      	cmp	r3, #1
    p_reg->CC[ch] = cc_val;
    4e66:	f8c6 2540 	str.w	r2, [r6, #1344]	; 0x540
    4e6a:	d102      	bne.n	4e72 <set_absolute_alarm+0x4e>
	z_impl_k_busy_wait(usec_to_wait);
    4e6c:	2013      	movs	r0, #19
    4e6e:	f004 fbf5 	bl	965c <z_impl_k_busy_wait>
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
    4e72:	f109 0202 	add.w	r2, r9, #2
	return (a - b) & COUNTER_MAX;
    4e76:	1aab      	subs	r3, r5, r2
    4e78:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
			cc_val = now + 2;
    4e7c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    4e80:	bf88      	it	hi
    4e82:	4615      	movhi	r5, r2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    4e84:	2300      	movs	r3, #0
    4e86:	6023      	str	r3, [r4, #0]
    4e88:	6823      	ldr	r3, [r4, #0]
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    4e8a:	f8c8 7344 	str.w	r7, [r8, #836]	; 0x344
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    4e8e:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    4e92:	f8c6 3540 	str.w	r3, [r6, #1344]	; 0x540
     return p_reg->COUNTER;
    4e96:	f8d8 3504 	ldr.w	r3, [r8, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
    4e9a:	4599      	cmp	r9, r3
    4e9c:	d006      	beq.n	4eac <set_absolute_alarm+0x88>
	return (a - b) & COUNTER_MAX;
    4e9e:	1aeb      	subs	r3, r5, r3
    4ea0:	3b02      	subs	r3, #2
    4ea2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	} while ((now2 != now) &&
    4ea6:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    4eaa:	d801      	bhi.n	4eb0 <set_absolute_alarm+0x8c>
}
    4eac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		prev_cc = cc_val;
    4eb0:	462b      	mov	r3, r5
    4eb2:	e7cf      	b.n	4e54 <set_absolute_alarm+0x30>
    4eb4:	40011000 	.word	0x40011000

00004eb8 <rtc_nrf_isr>:
{
    4eb8:	b570      	push	{r4, r5, r6, lr}
    4eba:	4d15      	ldr	r5, [pc, #84]	; (4f10 <rtc_nrf_isr+0x58>)
    return p_reg->INTENSET & mask;
    4ebc:	4c15      	ldr	r4, [pc, #84]	; (4f14 <rtc_nrf_isr+0x5c>)
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    4ebe:	2600      	movs	r6, #0
    4ec0:	682b      	ldr	r3, [r5, #0]
    4ec2:	2000      	movs	r0, #0
    4ec4:	b106      	cbz	r6, 4ec8 <rtc_nrf_isr+0x10>
}
    4ec6:	bd70      	pop	{r4, r5, r6, pc}
    4ec8:	f8d4 2304 	ldr.w	r2, [r4, #772]	; 0x304
		if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan)) &&
    4ecc:	03d2      	lsls	r2, r2, #15
    4ece:	d5fa      	bpl.n	4ec6 <rtc_nrf_isr+0xe>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    4ed0:	f8d4 2140 	ldr.w	r2, [r4, #320]	; 0x140
    4ed4:	2a00      	cmp	r2, #0
    4ed6:	d0f6      	beq.n	4ec6 <rtc_nrf_isr+0xe>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    4ed8:	f8c4 6140 	str.w	r6, [r4, #320]	; 0x140
    4edc:	f8d4 2140 	ldr.w	r2, [r4, #320]	; 0x140
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    4ee0:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    4ee4:	f8c4 2348 	str.w	r2, [r4, #840]	; 0x348
    return p_reg->CC[ch];
    4ee8:	f8d4 1540 	ldr.w	r1, [r4, #1344]	; 0x540
     return p_reg->COUNTER;
    4eec:	f8d4 6504 	ldr.w	r6, [r4, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    4ef0:	1a72      	subs	r2, r6, r1
    4ef2:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
				cc_val = now;
    4ef6:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    4efa:	bf88      	it	hi
    4efc:	4631      	movhi	r1, r6
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    4efe:	2601      	movs	r6, #1
			if (handler) {
    4f00:	b11b      	cbz	r3, 4f0a <rtc_nrf_isr+0x52>
				handler(chan, cc_val,
    4f02:	686a      	ldr	r2, [r5, #4]
    4f04:	6028      	str	r0, [r5, #0]
    4f06:	4798      	blx	r3
    4f08:	e7da      	b.n	4ec0 <rtc_nrf_isr+0x8>
    4f0a:	602b      	str	r3, [r5, #0]
}
    4f0c:	e7db      	b.n	4ec6 <rtc_nrf_isr+0xe>
    4f0e:	bf00      	nop
    4f10:	200010c8 	.word	0x200010c8
    4f14:	40011000 	.word	0x40011000

00004f18 <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    4f18:	4a13      	ldr	r2, [pc, #76]	; (4f68 <sys_clock_set_timeout+0x50>)
    4f1a:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    4f1e:	bf14      	ite	ne
    4f20:	4603      	movne	r3, r0
    4f22:	4613      	moveq	r3, r2
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    4f24:	3b01      	subs	r3, #1
    4f26:	2b00      	cmp	r3, #0
    4f28:	dd1c      	ble.n	4f64 <sys_clock_set_timeout+0x4c>
    4f2a:	4293      	cmp	r3, r2
    4f2c:	bfa8      	it	ge
    4f2e:	4613      	movge	r3, r2
    4f30:	4a0e      	ldr	r2, [pc, #56]	; (4f6c <sys_clock_set_timeout+0x54>)
    4f32:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	uint32_t unannounced = counter_sub(counter(), last_count);
    4f36:	4a0e      	ldr	r2, [pc, #56]	; (4f70 <sys_clock_set_timeout+0x58>)
    4f38:	6811      	ldr	r1, [r2, #0]
	return (a - b) & COUNTER_MAX;
    4f3a:	1a40      	subs	r0, r0, r1
		ticks = 0;
    4f3c:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
	return (a - b) & COUNTER_MAX;
    4f40:	f020 427f 	bic.w	r2, r0, #4278190080	; 0xff000000
		ticks = 0;
    4f44:	bf18      	it	ne
    4f46:	2300      	movne	r3, #0
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    4f48:	3201      	adds	r2, #1
    4f4a:	4413      	add	r3, r2
	cc_data[chan].callback = handler;
    4f4c:	4a09      	ldr	r2, [pc, #36]	; (4f74 <sys_clock_set_timeout+0x5c>)
    4f4e:	480a      	ldr	r0, [pc, #40]	; (4f78 <sys_clock_set_timeout+0x60>)
    4f50:	6010      	str	r0, [r2, #0]
	cc_data[chan].user_context = user_data;
    4f52:	2000      	movs	r0, #0
    4f54:	6050      	str	r0, [r2, #4]
	set_absolute_alarm(chan, cc_value);
    4f56:	4a04      	ldr	r2, [pc, #16]	; (4f68 <sys_clock_set_timeout+0x50>)
    4f58:	4293      	cmp	r3, r2
    4f5a:	bf94      	ite	ls
    4f5c:	18c9      	addls	r1, r1, r3
    4f5e:	1889      	addhi	r1, r1, r2
    4f60:	f7ff bf60 	b.w	4e24 <set_absolute_alarm>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    4f64:	2300      	movs	r3, #0
    4f66:	e7e3      	b.n	4f30 <sys_clock_set_timeout+0x18>
    4f68:	007fffff 	.word	0x007fffff
    4f6c:	40011000 	.word	0x40011000
    4f70:	200010d4 	.word	0x200010d4
    4f74:	200010c8 	.word	0x200010c8
    4f78:	00004dc1 	.word	0x00004dc1

00004f7c <sys_clock_elapsed>:
    4f7c:	4b04      	ldr	r3, [pc, #16]	; (4f90 <sys_clock_elapsed+0x14>)
    4f7e:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	return counter_sub(counter(), last_count) / CYC_PER_TICK;
    4f82:	4b04      	ldr	r3, [pc, #16]	; (4f94 <sys_clock_elapsed+0x18>)
	return (a - b) & COUNTER_MAX;
    4f84:	681b      	ldr	r3, [r3, #0]
    4f86:	1ac0      	subs	r0, r0, r3
}
    4f88:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    4f8c:	4770      	bx	lr
    4f8e:	bf00      	nop
    4f90:	40011000 	.word	0x40011000
    4f94:	200010d4 	.word	0x200010d4

00004f98 <__NVIC_SystemReset>:
    4f98:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    4f9c:	4905      	ldr	r1, [pc, #20]	; (4fb4 <__NVIC_SystemReset+0x1c>)
    4f9e:	4b06      	ldr	r3, [pc, #24]	; (4fb8 <__NVIC_SystemReset+0x20>)
    4fa0:	68ca      	ldr	r2, [r1, #12]
    4fa2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    4fa6:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    4fa8:	60cb      	str	r3, [r1, #12]
    4faa:	f3bf 8f4f 	dsb	sy
    __NOP();
    4fae:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    4fb0:	e7fd      	b.n	4fae <__NVIC_SystemReset+0x16>
    4fb2:	bf00      	nop
    4fb4:	e000ed00 	.word	0xe000ed00
    4fb8:	05fa0004 	.word	0x05fa0004

00004fbc <nrf52_errata_103>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    4fbc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
    4fc0:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
    4fc4:	2a08      	cmp	r2, #8
    4fc6:	d106      	bne.n	4fd6 <nrf52_errata_103+0x1a>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    4fc8:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                switch(var2)
    4fcc:	2b05      	cmp	r3, #5
    4fce:	d802      	bhi.n	4fd6 <nrf52_errata_103+0x1a>
    4fd0:	4a02      	ldr	r2, [pc, #8]	; (4fdc <nrf52_errata_103+0x20>)
    4fd2:	5cd0      	ldrb	r0, [r2, r3]
    4fd4:	4770      	bx	lr
        return false;
    4fd6:	2000      	movs	r0, #0
}
    4fd8:	4770      	bx	lr
    4fda:	bf00      	nop
    4fdc:	00009cdd 	.word	0x00009cdd

00004fe0 <nvmc_wait>:

/* -- NVMC utility functions -- */
/* Waits until NVMC is done with the current pending action */
void nvmc_wait(void)
{
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    4fe0:	4a02      	ldr	r2, [pc, #8]	; (4fec <nvmc_wait+0xc>)
    4fe2:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    4fe6:	2b00      	cmp	r3, #0
    4fe8:	d0fb      	beq.n	4fe2 <nvmc_wait+0x2>
}
    4fea:	4770      	bx	lr
    4fec:	4001e000 	.word	0x4001e000

00004ff0 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
    4ff0:	b510      	push	{r4, lr}
    #endif

    #if NRF52_ERRATA_36_ENABLE_WORKAROUND
        /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_36()){
    4ff2:	f003 ff73 	bl	8edc <nrf52_errata_136>
    4ff6:	b140      	cbz	r0, 500a <SystemInit+0x1a>
            NRF_CLOCK->EVENTS_DONE = 0;
    4ff8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4ffc:	2200      	movs	r2, #0
    4ffe:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
            NRF_CLOCK->EVENTS_CTTO = 0;
    5002:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            NRF_CLOCK->CTIV = 0;
    5006:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    #endif

    #if NRF52_ERRATA_66_ENABLE_WORKAROUND
        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_66()){
    500a:	f003 ff67 	bl	8edc <nrf52_errata_136>
    500e:	2800      	cmp	r0, #0
    5010:	d046      	beq.n	50a0 <SystemInit+0xb0>
            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    5012:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    5016:	4b65      	ldr	r3, [pc, #404]	; (51ac <SystemInit+0x1bc>)
    5018:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    501c:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    5020:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    5024:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    5028:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    502c:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    5030:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    5034:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    5038:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    503c:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    5040:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    5044:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    5048:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    504c:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    5050:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    5054:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    5058:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    505c:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    5060:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    5064:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    5068:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    506c:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    5070:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    5074:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    5078:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    507c:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    5080:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    5084:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    5088:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    508c:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    5090:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    5094:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    5098:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    509c:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    #endif

    #if NRF52_ERRATA_98_ENABLE_WORKAROUND
        /* Workaround for Errata 98 "NFCT: Not able to communicate with the peer" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_98()){
    50a0:	f7ff ff8c 	bl	4fbc <nrf52_errata_103>
    50a4:	b118      	cbz	r0, 50ae <SystemInit+0xbe>
            *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
    50a6:	4b42      	ldr	r3, [pc, #264]	; (51b0 <SystemInit+0x1c0>)
    50a8:	4a42      	ldr	r2, [pc, #264]	; (51b4 <SystemInit+0x1c4>)
    50aa:	f8c3 268c 	str.w	r2, [r3, #1676]	; 0x68c
    #endif

    #if NRF52_ERRATA_103_ENABLE_WORKAROUND && defined(CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos)
        /* Workaround for Errata 103 "CCM: Wrong reset value of CCM MAXPACKETSIZE" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_103()){
    50ae:	f7ff ff85 	bl	4fbc <nrf52_errata_103>
    50b2:	b118      	cbz	r0, 50bc <SystemInit+0xcc>
            NRF_CCM->MAXPACKETSIZE = 0xFBul;
    50b4:	4b40      	ldr	r3, [pc, #256]	; (51b8 <SystemInit+0x1c8>)
    50b6:	22fb      	movs	r2, #251	; 0xfb
    50b8:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    #endif

    #if NRF52_ERRATA_115_ENABLE_WORKAROUND
        /* Workaround for Errata 115 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_115()){
    50bc:	f7ff ff7e 	bl	4fbc <nrf52_errata_103>
    50c0:	b170      	cbz	r0, 50e0 <SystemInit+0xf0>
            *(volatile uint32_t *)0x40000EE4 = (*(volatile uint32_t *)0x40000EE4 & 0xFFFFFFF0) | (*(uint32_t *)0x10000258 & 0x0000000F);
    50c2:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    50c6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    50ca:	f8d1 2ee4 	ldr.w	r2, [r1, #3812]	; 0xee4
    50ce:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
    50d2:	f022 020f 	bic.w	r2, r2, #15
    50d6:	f003 030f 	and.w	r3, r3, #15
    50da:	4313      	orrs	r3, r2
    50dc:	f8c1 3ee4 	str.w	r3, [r1, #3812]	; 0xee4
    #endif

    #if NRF52_ERRATA_120_ENABLE_WORKAROUND
        /* Workaround for Errata 120 "QSPI: Data read or written is corrupted" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_120()){
    50e0:	f7ff ff6c 	bl	4fbc <nrf52_errata_103>
    50e4:	b120      	cbz	r0, 50f0 <SystemInit+0x100>
            *(volatile uint32_t *)0x40029640ul = 0x200ul;
    50e6:	4b35      	ldr	r3, [pc, #212]	; (51bc <SystemInit+0x1cc>)
    50e8:	f44f 7200 	mov.w	r2, #512	; 0x200
    50ec:	f8c3 2640 	str.w	r2, [r3, #1600]	; 0x640
    #endif

    #if NRF52_ERRATA_136_ENABLE_WORKAROUND
        /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_136()){
    50f0:	f003 fef4 	bl	8edc <nrf52_errata_136>
    50f4:	b148      	cbz	r0, 510a <SystemInit+0x11a>
            if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    50f6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    50fa:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    50fe:	07d2      	lsls	r2, r2, #31
                NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
    5100:	bf44      	itt	mi
    5102:	f06f 0201 	mvnmi.w	r2, #1
    5106:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
         || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    510a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                        return true;
                }
            }
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
    510e:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
    5112:	2a08      	cmp	r2, #8
    5114:	d10e      	bne.n	5134 <SystemInit+0x144>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    5116:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            {
                switch(var2)
    511a:	2b05      	cmp	r3, #5
    511c:	d802      	bhi.n	5124 <SystemInit+0x134>
            {
                /* Prevent processor from unlocking APPROTECT soft branch after this point. */
                NRF_APPROTECT->FORCEPROTECT = APPROTECT_FORCEPROTECT_FORCEPROTECT_Force;
            }
        #else
            if (nrf52_configuration_249())
    511e:	4a28      	ldr	r2, [pc, #160]	; (51c0 <SystemInit+0x1d0>)
    5120:	5cd3      	ldrb	r3, [r2, r3]
    5122:	b13b      	cbz	r3, 5134 <SystemInit+0x144>
            {
                /* Load APPROTECT soft branch from UICR.
                   If UICR->APPROTECT is disabled, POWER->APPROTECT will be disabled. */
                NRF_APPROTECT->DISABLE = NRF_UICR->APPROTECT;
    5124:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    5128:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
    512c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    5130:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558

    /* Configure NFCT pins as GPIOs if NFCT is not to be used in your code. If CONFIG_NFCT_PINS_AS_GPIOS is not defined,
       two GPIOs (see Product Specification to see which ones) will be reserved for NFC and will not be available as
       normal GPIOs. */
    #if defined (CONFIG_NFCT_PINS_AS_GPIOS) && defined(NFCT_PRESENT)
        if ((NRF_UICR->NFCPINS & UICR_NFCPINS_PROTECT_Msk) == (UICR_NFCPINS_PROTECT_NFC << UICR_NFCPINS_PROTECT_Pos)){
    5134:	f04f 2110 	mov.w	r1, #268439552	; 0x10001000
    5138:	f8d1 320c 	ldr.w	r3, [r1, #524]	; 0x20c
    513c:	07db      	lsls	r3, r3, #31
    513e:	d514      	bpl.n	516a <SystemInit+0x17a>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    5140:	4820      	ldr	r0, [pc, #128]	; (51c4 <SystemInit+0x1d4>)
    5142:	2301      	movs	r3, #1
    5144:	f8c0 3504 	str.w	r3, [r0, #1284]	; 0x504
    nvmc_wait();
    5148:	f7ff ff4a 	bl	4fe0 <nvmc_wait>
            nvmc_config(NVMC_CONFIG_WEN_Wen);
            NRF_UICR->NFCPINS &= ~UICR_NFCPINS_PROTECT_Msk;
    514c:	f8d1 320c 	ldr.w	r3, [r1, #524]	; 0x20c
    5150:	f023 0301 	bic.w	r3, r3, #1
    5154:	f8c1 320c 	str.w	r3, [r1, #524]	; 0x20c
            nvmc_wait();
    5158:	f7ff ff42 	bl	4fe0 <nvmc_wait>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    515c:	2300      	movs	r3, #0
    515e:	f8c0 3504 	str.w	r3, [r0, #1284]	; 0x504
    nvmc_wait();
    5162:	f7ff ff3d 	bl	4fe0 <nvmc_wait>
            NRF_UICR->PSELRESET[0] = RESET_PIN;
            nvmc_wait();
            NRF_UICR->PSELRESET[1] = RESET_PIN;
            nvmc_wait();
            nvmc_config(NVMC_CONFIG_WEN_Ren);
            NVIC_SystemReset();
    5166:	f7ff ff17 	bl	4f98 <__NVIC_SystemReset>
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    516a:	f8d1 3200 	ldr.w	r3, [r1, #512]	; 0x200
    516e:	2b00      	cmp	r3, #0
    5170:	db03      	blt.n	517a <SystemInit+0x18a>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
    5172:	f8d1 3204 	ldr.w	r3, [r1, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    5176:	2b00      	cmp	r3, #0
    5178:	da14      	bge.n	51a4 <SystemInit+0x1b4>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    517a:	4912      	ldr	r1, [pc, #72]	; (51c4 <SystemInit+0x1d4>)
    517c:	2301      	movs	r3, #1
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    517e:	f04f 2010 	mov.w	r0, #268439552	; 0x10001000
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    5182:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    5186:	2412      	movs	r4, #18
    nvmc_wait();
    5188:	f7ff ff2a 	bl	4fe0 <nvmc_wait>
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    518c:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
            nvmc_wait();
    5190:	f7ff ff26 	bl	4fe0 <nvmc_wait>
            NRF_UICR->PSELRESET[1] = RESET_PIN;
    5194:	f8c0 4204 	str.w	r4, [r0, #516]	; 0x204
            nvmc_wait();
    5198:	f7ff ff22 	bl	4fe0 <nvmc_wait>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    519c:	2300      	movs	r3, #0
    519e:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
    51a2:	e7de      	b.n	5162 <SystemInit+0x172>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    51a4:	4b08      	ldr	r3, [pc, #32]	; (51c8 <SystemInit+0x1d8>)
    51a6:	4a09      	ldr	r2, [pc, #36]	; (51cc <SystemInit+0x1dc>)
    51a8:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
    51aa:	bd10      	pop	{r4, pc}
    51ac:	4000c000 	.word	0x4000c000
    51b0:	40005000 	.word	0x40005000
    51b4:	00038148 	.word	0x00038148
    51b8:	4000f000 	.word	0x4000f000
    51bc:	40029000 	.word	0x40029000
    51c0:	00009cd7 	.word	0x00009cd7
    51c4:	4001e000 	.word	0x4001e000
    51c8:	2000010c 	.word	0x2000010c
    51cc:	03d09000 	.word	0x03d09000

000051d0 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
    51d0:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
    51d2:	2501      	movs	r5, #1
        prev_mask = *p_mask;
    51d4:	6803      	ldr	r3, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
    51d6:	fab3 f283 	clz	r2, r3
        if (idx < 0) {
    51da:	2a20      	cmp	r2, #32
        idx = 31 - NRF_CLZ(prev_mask);
    51dc:	f1c2 041f 	rsb	r4, r2, #31
        if (idx < 0) {
    51e0:	d014      	beq.n	520c <nrfx_flag32_alloc+0x3c>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    51e2:	f3bf 8f5b 	dmb	ish
        new_mask = prev_mask & ~NRFX_BIT(idx);
    51e6:	fa05 f204 	lsl.w	r2, r5, r4
    51ea:	ea23 0202 	bic.w	r2, r3, r2
    51ee:	e850 6f00 	ldrex	r6, [r0]
    51f2:	429e      	cmp	r6, r3
    51f4:	d104      	bne.n	5200 <nrfx_flag32_alloc+0x30>
    51f6:	e840 2c00 	strex	ip, r2, [r0]
    51fa:	f1bc 0f00 	cmp.w	ip, #0
    51fe:	d1f6      	bne.n	51ee <nrfx_flag32_alloc+0x1e>
    5200:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    5204:	d1e6      	bne.n	51d4 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
    5206:	4802      	ldr	r0, [pc, #8]	; (5210 <nrfx_flag32_alloc+0x40>)
    *p_flag = idx;
    5208:	700c      	strb	r4, [r1, #0]
}
    520a:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_NO_MEM;
    520c:	4801      	ldr	r0, [pc, #4]	; (5214 <nrfx_flag32_alloc+0x44>)
    520e:	e7fc      	b.n	520a <nrfx_flag32_alloc+0x3a>
    5210:	0bad0000 	.word	0x0bad0000
    5214:	0bad0002 	.word	0x0bad0002

00005218 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
    5218:	6803      	ldr	r3, [r0, #0]
    521a:	40cb      	lsrs	r3, r1
    521c:	07db      	lsls	r3, r3, #31
{
    521e:	b510      	push	{r4, lr}
    if ((NRFX_BIT(flag) & *p_mask))
    5220:	d415      	bmi.n	524e <nrfx_flag32_free+0x36>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
    5222:	2301      	movs	r3, #1
    5224:	fa03 f101 	lsl.w	r1, r3, r1
        prev_mask = *p_mask;
    5228:	6803      	ldr	r3, [r0, #0]
    522a:	f3bf 8f5b 	dmb	ish
        new_mask = prev_mask | NRFX_BIT(flag);
    522e:	ea41 0203 	orr.w	r2, r1, r3
    5232:	e850 4f00 	ldrex	r4, [r0]
    5236:	429c      	cmp	r4, r3
    5238:	d104      	bne.n	5244 <nrfx_flag32_free+0x2c>
    523a:	e840 2c00 	strex	ip, r2, [r0]
    523e:	f1bc 0f00 	cmp.w	ip, #0
    5242:	d1f6      	bne.n	5232 <nrfx_flag32_free+0x1a>
    5244:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    5248:	d1ee      	bne.n	5228 <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
    524a:	4802      	ldr	r0, [pc, #8]	; (5254 <nrfx_flag32_free+0x3c>)
}
    524c:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
    524e:	4802      	ldr	r0, [pc, #8]	; (5258 <nrfx_flag32_free+0x40>)
    5250:	e7fc      	b.n	524c <nrfx_flag32_free+0x34>
    5252:	bf00      	nop
    5254:	0bad0000 	.word	0x0bad0000
    5258:	0bad0004 	.word	0x0bad0004

0000525c <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    525c:	4b04      	ldr	r3, [pc, #16]	; (5270 <nrfx_clock_init+0x14>)
    525e:	791a      	ldrb	r2, [r3, #4]
    5260:	b922      	cbnz	r2, 526c <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
    5262:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
    5264:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    5266:	809a      	strh	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
    5268:	4802      	ldr	r0, [pc, #8]	; (5274 <nrfx_clock_init+0x18>)
    526a:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    526c:	4802      	ldr	r0, [pc, #8]	; (5278 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    526e:	4770      	bx	lr
    5270:	200010d8 	.word	0x200010d8
    5274:	0bad0000 	.word	0x0bad0000
    5278:	0bad000c 	.word	0x0bad000c

0000527c <nrfx_clock_enable>:

void nrfx_clock_enable(void)
{
    527c:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
    527e:	2000      	movs	r0, #0
    5280:	f7fd ffb4 	bl	31ec <arch_irq_is_enabled>
    5284:	b908      	cbnz	r0, 528a <nrfx_clock_enable+0xe>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
    5286:	f7fd ff8d 	bl	31a4 <arch_irq_enable>
#endif
#if NRF_CLOCK_HAS_HFCLK192M
    nrf_clock_hfclk192m_src_set(NRF_CLOCK, (nrf_clock_hfclk_t)NRFX_CLOCK_CONFIG_HFCLK192M_SRC);
#endif
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
    528a:	4b02      	ldr	r3, [pc, #8]	; (5294 <nrfx_clock_enable+0x18>)
    528c:	2201      	movs	r2, #1
    528e:	701a      	strb	r2, [r3, #0]
#endif

    NRFX_LOG_INFO("Module enabled.");
}
    5290:	bd08      	pop	{r3, pc}
    5292:	bf00      	nop
    5294:	200013a3 	.word	0x200013a3

00005298 <nrfx_clock_stop>:
            break;
    }
}

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    5298:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    529a:	b110      	cbz	r0, 52a2 <nrfx_clock_stop+0xa>
    529c:	2801      	cmp	r0, #1
    529e:	d017      	beq.n	52d0 <nrfx_clock_stop+0x38>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    52a0:	bd38      	pop	{r3, r4, r5, pc}
    p_reg->INTENCLR = mask;
    52a2:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
    52a6:	2302      	movs	r3, #2
    52a8:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    52ac:	f8c4 0104 	str.w	r0, [r4, #260]	; 0x104
    52b0:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    52b4:	2301      	movs	r3, #1
    52b6:	60e3      	str	r3, [r4, #12]
    52b8:	f242 7510 	movw	r5, #10000	; 0x2710
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    52bc:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
    52c0:	03db      	lsls	r3, r3, #15
    52c2:	d5ed      	bpl.n	52a0 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    52c4:	2001      	movs	r0, #1
    52c6:	f003 fe13 	bl	8ef0 <nrfx_busy_wait>
    52ca:	3d01      	subs	r5, #1
    52cc:	d1f6      	bne.n	52bc <nrfx_clock_stop+0x24>
    52ce:	e7e7      	b.n	52a0 <nrfx_clock_stop+0x8>
    p_reg->INTENCLR = mask;
    52d0:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    52d4:	2300      	movs	r3, #0
    p_reg->INTENCLR = mask;
    52d6:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    52da:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
    52de:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    52e2:	6060      	str	r0, [r4, #4]
    52e4:	f242 7510 	movw	r5, #10000	; 0x2710
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    52e8:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    52ec:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
    52f0:	03d2      	lsls	r2, r2, #15
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    52f2:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    52f6:	d505      	bpl.n	5304 <nrfx_clock_stop+0x6c>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
    52f8:	b123      	cbz	r3, 5304 <nrfx_clock_stop+0x6c>
    52fa:	2001      	movs	r0, #1
    52fc:	f003 fdf8 	bl	8ef0 <nrfx_busy_wait>
    5300:	3d01      	subs	r5, #1
    5302:	d1f1      	bne.n	52e8 <nrfx_clock_stop+0x50>
            m_clock_cb.hfclk_started = false;
    5304:	4b01      	ldr	r3, [pc, #4]	; (530c <nrfx_clock_stop+0x74>)
    5306:	2200      	movs	r2, #0
    5308:	715a      	strb	r2, [r3, #5]
    530a:	e7c9      	b.n	52a0 <nrfx_clock_stop+0x8>
    530c:	200010d8 	.word	0x200010d8

00005310 <nrfx_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    5310:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    5314:	b510      	push	{r4, lr}
    5316:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    531a:	b16a      	cbz	r2, 5338 <nrfx_clock_irq_handler+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    531c:	2200      	movs	r2, #0
    531e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    5322:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
    5326:	2201      	movs	r2, #1
    5328:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);

#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        if (!m_clock_cb.hfclk_started)
    532c:	4b11      	ldr	r3, [pc, #68]	; (5374 <nrfx_clock_irq_handler+0x64>)
    532e:	7958      	ldrb	r0, [r3, #5]
    5330:	b910      	cbnz	r0, 5338 <nrfx_clock_irq_handler+0x28>
        {
            m_clock_cb.hfclk_started = true;
    5332:	715a      	strb	r2, [r3, #5]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    5334:	681b      	ldr	r3, [r3, #0]
    5336:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    5338:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    533c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    5340:	b172      	cbz	r2, 5360 <nrfx_clock_irq_handler+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    5342:	2200      	movs	r2, #0
    5344:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    5348:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    534c:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    5350:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    5354:	0792      	lsls	r2, r2, #30
    5356:	d104      	bne.n	5362 <nrfx_clock_irq_handler+0x52>
    p_reg->LFCLKSRC = (uint32_t)(source);
    5358:	2201      	movs	r2, #1
    535a:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    535e:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    5360:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
    5362:	2202      	movs	r2, #2
    5364:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    5368:	4b02      	ldr	r3, [pc, #8]	; (5374 <nrfx_clock_irq_handler+0x64>)
}
    536a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    536e:	681b      	ldr	r3, [r3, #0]
    5370:	2001      	movs	r0, #1
    5372:	4718      	bx	r3
    5374:	200010d8 	.word	0x200010d8

00005378 <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
    5378:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
    537a:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    537e:	095b      	lsrs	r3, r3, #5
        case 1: return NRF_P1;
    5380:	2b01      	cmp	r3, #1
    *p_pin = pin_number & 0x1F;
    5382:	6002      	str	r2, [r0, #0]
}
    5384:	4802      	ldr	r0, [pc, #8]	; (5390 <nrf_gpio_pin_port_decode+0x18>)
    5386:	bf18      	it	ne
    5388:	f04f 40a0 	movne.w	r0, #1342177280	; 0x50000000
    538c:	4770      	bx	lr
    538e:	bf00      	nop
    5390:	50000300 	.word	0x50000300

00005394 <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
    5394:	4b03      	ldr	r3, [pc, #12]	; (53a4 <pin_in_use_by_te+0x10>)
    5396:	3008      	adds	r0, #8
    5398:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    539c:	f3c0 1040 	ubfx	r0, r0, #5, #1
    53a0:	4770      	bx	lr
    53a2:	bf00      	nop
    53a4:	20000110 	.word	0x20000110

000053a8 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
    53a8:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    53aa:	f100 0308 	add.w	r3, r0, #8
    53ae:	4c0c      	ldr	r4, [pc, #48]	; (53e0 <call_handler+0x38>)
    53b0:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
    53b4:	05da      	lsls	r2, r3, #23
{
    53b6:	4605      	mov	r5, r0
    53b8:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    53ba:	d507      	bpl.n	53cc <call_handler+0x24>
    53bc:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
    53c0:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    53c4:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
    53c8:	6852      	ldr	r2, [r2, #4]
    53ca:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
    53cc:	68a3      	ldr	r3, [r4, #8]
    53ce:	b12b      	cbz	r3, 53dc <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
    53d0:	68e2      	ldr	r2, [r4, #12]
    53d2:	4631      	mov	r1, r6
    53d4:	4628      	mov	r0, r5
    }
}
    53d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
    53da:	4718      	bx	r3
}
    53dc:	bd70      	pop	{r4, r5, r6, pc}
    53de:	bf00      	nop
    53e0:	20000110 	.word	0x20000110

000053e4 <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    53e4:	4a12      	ldr	r2, [pc, #72]	; (5430 <release_handler+0x4c>)
    53e6:	3008      	adds	r0, #8
{
    53e8:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    53ea:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
    53ee:	05d9      	lsls	r1, r3, #23
    53f0:	d51b      	bpl.n	542a <release_handler+0x46>
    53f2:	f3c3 2143 	ubfx	r1, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
    53f6:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
    53fa:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    53fe:	f102 0410 	add.w	r4, r2, #16
    5402:	2000      	movs	r0, #0
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
    5404:	f834 3b02 	ldrh.w	r3, [r4], #2
    5408:	f413 7f80 	tst.w	r3, #256	; 0x100
    540c:	d003      	beq.n	5416 <release_handler+0x32>
    540e:	f3c3 2343 	ubfx	r3, r3, #9, #4
    5412:	4299      	cmp	r1, r3
    5414:	d009      	beq.n	542a <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    5416:	3001      	adds	r0, #1
    5418:	2830      	cmp	r0, #48	; 0x30
    541a:	d1f3      	bne.n	5404 <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
    541c:	2300      	movs	r3, #0
    541e:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
    5422:	4804      	ldr	r0, [pc, #16]	; (5434 <release_handler+0x50>)
}
    5424:	bc10      	pop	{r4}
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
    5426:	f7ff bef7 	b.w	5218 <nrfx_flag32_free>
}
    542a:	bc10      	pop	{r4}
    542c:	4770      	bx	lr
    542e:	bf00      	nop
    5430:	20000110 	.word	0x20000110
    5434:	20000184 	.word	0x20000184

00005438 <pin_handler_trigger_uninit>:
{
    5438:	b538      	push	{r3, r4, r5, lr}
    543a:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
    543c:	f7ff ffaa 	bl	5394 <pin_in_use_by_te>
    5440:	4c09      	ldr	r4, [pc, #36]	; (5468 <pin_handler_trigger_uninit+0x30>)
    5442:	f102 0508 	add.w	r5, r2, #8
    5446:	b140      	cbz	r0, 545a <pin_handler_trigger_uninit+0x22>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    5448:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
    544c:	4907      	ldr	r1, [pc, #28]	; (546c <pin_handler_trigger_uninit+0x34>)
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
    544e:	0b5b      	lsrs	r3, r3, #13
    5450:	f503 73a2 	add.w	r3, r3, #324	; 0x144
    5454:	2000      	movs	r0, #0
    5456:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
    release_handler(pin);
    545a:	4610      	mov	r0, r2
    545c:	f7ff ffc2 	bl	53e4 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
    5460:	2300      	movs	r3, #0
    5462:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
    5466:	bd38      	pop	{r3, r4, r5, pc}
    5468:	20000110 	.word	0x20000110
    546c:	40006000 	.word	0x40006000

00005470 <nrfx_gpiote_input_configure>:
{
    5470:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    5474:	4604      	mov	r4, r0
    5476:	4617      	mov	r7, r2
    5478:	461d      	mov	r5, r3
    if (p_input_config)
    547a:	b321      	cbz	r1, 54c6 <nrfx_gpiote_input_configure+0x56>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    547c:	4e4e      	ldr	r6, [pc, #312]	; (55b8 <nrfx_gpiote_input_configure+0x148>)
    547e:	f100 0808 	add.w	r8, r0, #8
    return pin_is_output(pin) && pin_in_use_by_te(pin);
    5482:	f836 3018 	ldrh.w	r3, [r6, r8, lsl #1]
    5486:	079b      	lsls	r3, r3, #30
    5488:	d506      	bpl.n	5498 <nrfx_gpiote_input_configure+0x28>
    548a:	f7ff ff83 	bl	5394 <pin_in_use_by_te>
        if (pin_is_task_output(pin))
    548e:	b118      	cbz	r0, 5498 <nrfx_gpiote_input_configure+0x28>
                return NRFX_ERROR_INVALID_PARAM;
    5490:	484a      	ldr	r0, [pc, #296]	; (55bc <nrfx_gpiote_input_configure+0x14c>)
}
    5492:	b004      	add	sp, #16
    5494:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
    5498:	2300      	movs	r3, #0
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
    549a:	e9cd 3300 	strd	r3, r3, [sp]
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
    549e:	f88d 300e 	strb.w	r3, [sp, #14]
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
    54a2:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
    54a6:	f10d 020f 	add.w	r2, sp, #15
    54aa:	460b      	mov	r3, r1
    54ac:	4620      	mov	r0, r4
    54ae:	f10d 010e 	add.w	r1, sp, #14
    54b2:	f003 fd4b 	bl	8f4c <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
    54b6:	f836 3018 	ldrh.w	r3, [r6, r8, lsl #1]
    54ba:	f023 0302 	bic.w	r3, r3, #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
    54be:	f043 0301 	orr.w	r3, r3, #1
    54c2:	f826 3018 	strh.w	r3, [r6, r8, lsl #1]
    if (p_trigger_config)
    54c6:	b197      	cbz	r7, 54ee <nrfx_gpiote_input_configure+0x7e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    54c8:	4b3b      	ldr	r3, [pc, #236]	; (55b8 <nrfx_gpiote_input_configure+0x148>)
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
    54ca:	783e      	ldrb	r6, [r7, #0]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
    54cc:	687a      	ldr	r2, [r7, #4]
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    54ce:	f104 0008 	add.w	r0, r4, #8
    54d2:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
        if (pin_is_output(pin))
    54d6:	078f      	lsls	r7, r1, #30
    54d8:	d50c      	bpl.n	54f4 <nrfx_gpiote_input_configure+0x84>
            if (use_evt)
    54da:	2a00      	cmp	r2, #0
    54dc:	d1d8      	bne.n	5490 <nrfx_gpiote_input_configure+0x20>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
    54de:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
    54e2:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
    54e6:	ea42 0286 	orr.w	r2, r2, r6, lsl #2
    54ea:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
    if (p_handler_config)
    54ee:	bbcd      	cbnz	r5, 5564 <nrfx_gpiote_input_configure+0xf4>
    return NRFX_SUCCESS;
    54f0:	4833      	ldr	r0, [pc, #204]	; (55c0 <nrfx_gpiote_input_configure+0x150>)
    54f2:	e7ce      	b.n	5492 <nrfx_gpiote_input_configure+0x22>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
    54f4:	f021 0120 	bic.w	r1, r1, #32
    54f8:	04c9      	lsls	r1, r1, #19
    54fa:	0cc9      	lsrs	r1, r1, #19
    54fc:	f823 1010 	strh.w	r1, [r3, r0, lsl #1]
            if (use_evt)
    5500:	2a00      	cmp	r2, #0
    5502:	d0ec      	beq.n	54de <nrfx_gpiote_input_configure+0x6e>
                if (!edge)
    5504:	2e03      	cmp	r6, #3
    5506:	d8c3      	bhi.n	5490 <nrfx_gpiote_input_configure+0x20>
                uint8_t ch = *p_trigger_config->p_in_channel;
    5508:	7817      	ldrb	r7, [r2, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
    550a:	b92e      	cbnz	r6, 5518 <nrfx_gpiote_input_configure+0xa8>
    550c:	4a2d      	ldr	r2, [pc, #180]	; (55c4 <nrfx_gpiote_input_configure+0x154>)
    550e:	f507 71a2 	add.w	r1, r7, #324	; 0x144
    5512:	f842 6021 	str.w	r6, [r2, r1, lsl #2]
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
#endif
}
    5516:	e7e2      	b.n	54de <nrfx_gpiote_input_configure+0x6e>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    5518:	00ba      	lsls	r2, r7, #2
    551a:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    551e:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    5522:	ea41 3147 	orr.w	r1, r1, r7, lsl #13
    5526:	f8d2 c510 	ldr.w	ip, [r2, #1296]	; 0x510
    552a:	f02c 0c03 	bic.w	ip, ip, #3
    552e:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    5532:	f8d2 c510 	ldr.w	ip, [r2, #1296]	; 0x510
    5536:	f42c 3c4f 	bic.w	ip, ip, #211968	; 0x33c00
    553a:	f42c 7c40 	bic.w	ip, ip, #768	; 0x300
    553e:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    5542:	f8d2 e510 	ldr.w	lr, [r2, #1296]	; 0x510
    5546:	ea4f 2c04 	mov.w	ip, r4, lsl #8
    554a:	f40c 5c7c 	and.w	ip, ip, #16128	; 0x3f00
    554e:	ea4e 4e06 	orr.w	lr, lr, r6, lsl #16
    5552:	ea4c 0c0e 	orr.w	ip, ip, lr
    5556:	f041 0120 	orr.w	r1, r1, #32
    555a:	f823 1010 	strh.w	r1, [r3, r0, lsl #1]
    555e:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
    5562:	e7bc      	b.n	54de <nrfx_gpiote_input_configure+0x6e>
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
    5564:	e9d5 6700 	ldrd	r6, r7, [r5]
    release_handler(pin);
    5568:	4620      	mov	r0, r4
    556a:	f7ff ff3b 	bl	53e4 <release_handler>
    if (!handler)
    556e:	2e00      	cmp	r6, #0
    5570:	d0be      	beq.n	54f0 <nrfx_gpiote_input_configure+0x80>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
    5572:	4d11      	ldr	r5, [pc, #68]	; (55b8 <nrfx_gpiote_input_configure+0x148>)
    5574:	682b      	ldr	r3, [r5, #0]
    5576:	429e      	cmp	r6, r3
    5578:	d104      	bne.n	5584 <nrfx_gpiote_input_configure+0x114>
    557a:	686b      	ldr	r3, [r5, #4]
    557c:	429f      	cmp	r7, r3
    557e:	d101      	bne.n	5584 <nrfx_gpiote_input_configure+0x114>
    5580:	2200      	movs	r2, #0
    5582:	e00a      	b.n	559a <nrfx_gpiote_input_configure+0x12a>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
    5584:	4810      	ldr	r0, [pc, #64]	; (55c8 <nrfx_gpiote_input_configure+0x158>)
    5586:	f10d 010f 	add.w	r1, sp, #15
    558a:	f7ff fe21 	bl	51d0 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
    558e:	4b0c      	ldr	r3, [pc, #48]	; (55c0 <nrfx_gpiote_input_configure+0x150>)
    5590:	4298      	cmp	r0, r3
    5592:	f47f af7e 	bne.w	5492 <nrfx_gpiote_input_configure+0x22>
        handler_id = (int32_t)id;
    5596:	f89d 200f 	ldrb.w	r2, [sp, #15]
    m_cb.handlers[handler_id].handler = handler;
    559a:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.handlers[handler_id].p_context = p_context;
    559e:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
    55a2:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
    55a4:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
    55a6:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    55aa:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
    55ae:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    55b2:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
    55b6:	e79b      	b.n	54f0 <nrfx_gpiote_input_configure+0x80>
    55b8:	20000110 	.word	0x20000110
    55bc:	0bad0004 	.word	0x0bad0004
    55c0:	0bad0000 	.word	0x0bad0000
    55c4:	40006000 	.word	0x40006000
    55c8:	20000184 	.word	0x20000184

000055cc <nrfx_gpiote_output_configure>:
{
    55cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    55ce:	4604      	mov	r4, r0
    55d0:	b085      	sub	sp, #20
    55d2:	4615      	mov	r5, r2
    if (p_config)
    55d4:	b319      	cbz	r1, 561e <nrfx_gpiote_output_configure+0x52>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    55d6:	4e33      	ldr	r6, [pc, #204]	; (56a4 <nrfx_gpiote_output_configure+0xd8>)
    55d8:	f100 0708 	add.w	r7, r0, #8
    55dc:	f836 2017 	ldrh.w	r2, [r6, r7, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
    55e0:	0793      	lsls	r3, r2, #30
    55e2:	d403      	bmi.n	55ec <nrfx_gpiote_output_configure+0x20>
    55e4:	f7ff fed6 	bl	5394 <pin_in_use_by_te>
    55e8:	2800      	cmp	r0, #0
    55ea:	d158      	bne.n	569e <nrfx_gpiote_output_configure+0xd2>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
    55ec:	f012 0f1c 	tst.w	r2, #28
    55f0:	d002      	beq.n	55f8 <nrfx_gpiote_output_configure+0x2c>
    55f2:	784b      	ldrb	r3, [r1, #1]
    55f4:	2b01      	cmp	r3, #1
    55f6:	d052      	beq.n	569e <nrfx_gpiote_output_configure+0xd2>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
    55f8:	2301      	movs	r3, #1
    55fa:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
    55fe:	2300      	movs	r3, #0
    5600:	e9cd 1300 	strd	r1, r3, [sp]
    5604:	1c4a      	adds	r2, r1, #1
    5606:	1c8b      	adds	r3, r1, #2
    5608:	4620      	mov	r0, r4
    560a:	f10d 010f 	add.w	r1, sp, #15
    560e:	f003 fc9d 	bl	8f4c <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
    5612:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
    5616:	f043 0303 	orr.w	r3, r3, #3
    561a:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_task_config)
    561e:	b915      	cbnz	r5, 5626 <nrfx_gpiote_output_configure+0x5a>
    return NRFX_SUCCESS;
    5620:	4821      	ldr	r0, [pc, #132]	; (56a8 <nrfx_gpiote_output_configure+0xdc>)
}
    5622:	b005      	add	sp, #20
    5624:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    5626:	4e1f      	ldr	r6, [pc, #124]	; (56a4 <nrfx_gpiote_output_configure+0xd8>)
    5628:	f104 0708 	add.w	r7, r4, #8
    562c:	f836 0017 	ldrh.w	r0, [r6, r7, lsl #1]
        if (pin_is_input(pin))
    5630:	0783      	lsls	r3, r0, #30
    5632:	d534      	bpl.n	569e <nrfx_gpiote_output_configure+0xd2>
        uint32_t ch = p_task_config->task_ch;
    5634:	f895 c000 	ldrb.w	ip, [r5]
    p_reg->CONFIG[idx] = 0;
    5638:	4661      	mov	r1, ip
    563a:	0089      	lsls	r1, r1, #2
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
    563c:	f020 0020 	bic.w	r0, r0, #32
    5640:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
    5644:	04c0      	lsls	r0, r0, #19
    5646:	f501 41c0 	add.w	r1, r1, #24576	; 0x6000
    564a:	0cc0      	lsrs	r0, r0, #19
    564c:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
    5650:	2300      	movs	r3, #0
    5652:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
    5656:	786a      	ldrb	r2, [r5, #1]
    5658:	2a00      	cmp	r2, #0
    565a:	d0e1      	beq.n	5620 <nrfx_gpiote_output_configure+0x54>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
    565c:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
    5660:	78ad      	ldrb	r5, [r5, #2]
    5662:	f423 1399 	bic.w	r3, r3, #1253376	; 0x132000
    5666:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
    566a:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    566e:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
    5672:	0223      	lsls	r3, r4, #8
    5674:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
    5678:	0412      	lsls	r2, r2, #16
    567a:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    567e:	ea43 030e 	orr.w	r3, r3, lr
    5682:	4313      	orrs	r3, r2
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
    5684:	052a      	lsls	r2, r5, #20
    5686:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    568a:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    568e:	4313      	orrs	r3, r2
    5690:	f040 0020 	orr.w	r0, r0, #32
    5694:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
    5698:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
    569c:	e7c0      	b.n	5620 <nrfx_gpiote_output_configure+0x54>
            return NRFX_ERROR_INVALID_PARAM;
    569e:	4803      	ldr	r0, [pc, #12]	; (56ac <nrfx_gpiote_output_configure+0xe0>)
    56a0:	e7bf      	b.n	5622 <nrfx_gpiote_output_configure+0x56>
    56a2:	bf00      	nop
    56a4:	20000110 	.word	0x20000110
    56a8:	0bad0000 	.word	0x0bad0000
    56ac:	0bad0004 	.word	0x0bad0004

000056b0 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
    56b0:	4b01      	ldr	r3, [pc, #4]	; (56b8 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
    56b2:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
    56b6:	4770      	bx	lr
    56b8:	20000110 	.word	0x20000110

000056bc <nrfx_gpiote_channel_get>:
{
    56bc:	b508      	push	{r3, lr}
    56be:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
    56c0:	f7ff fe68 	bl	5394 <pin_in_use_by_te>
    56c4:	b138      	cbz	r0, 56d6 <nrfx_gpiote_channel_get+0x1a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    56c6:	4b05      	ldr	r3, [pc, #20]	; (56dc <nrfx_gpiote_channel_get+0x20>)
        return NRFX_SUCCESS;
    56c8:	4805      	ldr	r0, [pc, #20]	; (56e0 <nrfx_gpiote_channel_get+0x24>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    56ca:	3208      	adds	r2, #8
    56cc:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    56d0:	0b5b      	lsrs	r3, r3, #13
    56d2:	700b      	strb	r3, [r1, #0]
}
    56d4:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_PARAM;
    56d6:	4803      	ldr	r0, [pc, #12]	; (56e4 <nrfx_gpiote_channel_get+0x28>)
    56d8:	e7fc      	b.n	56d4 <nrfx_gpiote_channel_get+0x18>
    56da:	bf00      	nop
    56dc:	20000110 	.word	0x20000110
    56e0:	0bad0000 	.word	0x0bad0000
    56e4:	0bad0004 	.word	0x0bad0004

000056e8 <nrfx_gpiote_init>:
{
    56e8:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
    56ea:	4c0f      	ldr	r4, [pc, #60]	; (5728 <nrfx_gpiote_init+0x40>)
    56ec:	f894 5078 	ldrb.w	r5, [r4, #120]	; 0x78
    56f0:	b9bd      	cbnz	r5, 5722 <nrfx_gpiote_init+0x3a>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
    56f2:	2260      	movs	r2, #96	; 0x60
    56f4:	4629      	mov	r1, r5
    56f6:	f104 0010 	add.w	r0, r4, #16
    56fa:	f003 f8e8 	bl	88ce <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
    56fe:	2006      	movs	r0, #6
    5700:	f7fd fd50 	bl	31a4 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    5704:	4b09      	ldr	r3, [pc, #36]	; (572c <nrfx_gpiote_init+0x44>)
    return err_code;
    5706:	480a      	ldr	r0, [pc, #40]	; (5730 <nrfx_gpiote_init+0x48>)
    5708:	f8c3 517c 	str.w	r5, [r3, #380]	; 0x17c
    570c:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
    5710:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    5714:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
    5718:	2301      	movs	r3, #1
    571a:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
    571e:	6763      	str	r3, [r4, #116]	; 0x74
}
    5720:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
    5722:	4804      	ldr	r0, [pc, #16]	; (5734 <nrfx_gpiote_init+0x4c>)
    5724:	e7fc      	b.n	5720 <nrfx_gpiote_init+0x38>
    5726:	bf00      	nop
    5728:	20000110 	.word	0x20000110
    572c:	40006000 	.word	0x40006000
    5730:	0bad0000 	.word	0x0bad0000
    5734:	0bad0005 	.word	0x0bad0005

00005738 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
    5738:	4b03      	ldr	r3, [pc, #12]	; (5748 <nrfx_gpiote_is_init+0x10>)
    573a:	f893 0078 	ldrb.w	r0, [r3, #120]	; 0x78
}
    573e:	3800      	subs	r0, #0
    5740:	bf18      	it	ne
    5742:	2001      	movne	r0, #1
    5744:	4770      	bx	lr
    5746:	bf00      	nop
    5748:	20000110 	.word	0x20000110

0000574c <nrfx_gpiote_channel_free>:
{
    574c:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
    574e:	4801      	ldr	r0, [pc, #4]	; (5754 <nrfx_gpiote_channel_free+0x8>)
    5750:	f7ff bd62 	b.w	5218 <nrfx_flag32_free>
    5754:	20000180 	.word	0x20000180

00005758 <nrfx_gpiote_channel_alloc>:
{
    5758:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
    575a:	4801      	ldr	r0, [pc, #4]	; (5760 <nrfx_gpiote_channel_alloc+0x8>)
    575c:	f7ff bd38 	b.w	51d0 <nrfx_flag32_alloc>
    5760:	20000180 	.word	0x20000180

00005764 <nrfx_gpiote_trigger_enable>:
{
    5764:	b537      	push	{r0, r1, r2, r4, r5, lr}
    5766:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    5768:	f7ff fe14 	bl	5394 <pin_in_use_by_te>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    576c:	f104 0208 	add.w	r2, r4, #8
    5770:	4b1e      	ldr	r3, [pc, #120]	; (57ec <nrfx_gpiote_trigger_enable+0x88>)
    5772:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    5776:	b1e8      	cbz	r0, 57b4 <nrfx_gpiote_trigger_enable+0x50>
    5778:	f013 0502 	ands.w	r5, r3, #2
    577c:	d11a      	bne.n	57b4 <nrfx_gpiote_trigger_enable+0x50>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    577e:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
    5780:	009a      	lsls	r2, r3, #2
    return ((uint32_t)p_reg + event);
    5782:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
    5786:	f500 40c2 	add.w	r0, r0, #24832	; 0x6100
    578a:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    578e:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    5792:	6005      	str	r5, [r0, #0]
    5794:	6800      	ldr	r0, [r0, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    5796:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
    579a:	f040 0001 	orr.w	r0, r0, #1
    579e:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
    57a2:	b129      	cbz	r1, 57b0 <nrfx_gpiote_trigger_enable+0x4c>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
    57a4:	2201      	movs	r2, #1
    57a6:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
    57aa:	4a11      	ldr	r2, [pc, #68]	; (57f0 <nrfx_gpiote_trigger_enable+0x8c>)
    57ac:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
    57b0:	b003      	add	sp, #12
    57b2:	bd30      	pop	{r4, r5, pc}
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    57b4:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
    57b8:	2b04      	cmp	r3, #4
    57ba:	d012      	beq.n	57e2 <nrfx_gpiote_trigger_enable+0x7e>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
    57bc:	2b05      	cmp	r3, #5
    57be:	d012      	beq.n	57e6 <nrfx_gpiote_trigger_enable+0x82>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    57c0:	a801      	add	r0, sp, #4
    57c2:	9401      	str	r4, [sp, #4]
    57c4:	f7ff fdd8 	bl	5378 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
    57c8:	9b01      	ldr	r3, [sp, #4]
    return p_reg->IN;
    57ca:	f8d0 1510 	ldr.w	r1, [r0, #1296]	; 0x510
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
    57ce:	40d9      	lsrs	r1, r3
    57d0:	f001 0101 	and.w	r1, r1, #1
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    57d4:	3102      	adds	r1, #2
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
    57d6:	4620      	mov	r0, r4
}
    57d8:	b003      	add	sp, #12
    57da:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
    57de:	f003 bbfc 	b.w	8fda <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
    57e2:	2103      	movs	r1, #3
    57e4:	e7f7      	b.n	57d6 <nrfx_gpiote_trigger_enable+0x72>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
    57e6:	2102      	movs	r1, #2
    57e8:	e7f5      	b.n	57d6 <nrfx_gpiote_trigger_enable+0x72>
    57ea:	bf00      	nop
    57ec:	20000110 	.word	0x20000110
    57f0:	40006000 	.word	0x40006000

000057f4 <nrfx_gpiote_trigger_disable>:
{
    57f4:	b508      	push	{r3, lr}
    57f6:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    57f8:	f7ff fdcc 	bl	5394 <pin_in_use_by_te>
    57fc:	b1c0      	cbz	r0, 5830 <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    57fe:	f102 0108 	add.w	r1, r2, #8
    5802:	4b0e      	ldr	r3, [pc, #56]	; (583c <nrfx_gpiote_trigger_disable+0x48>)
    5804:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    5808:	0799      	lsls	r1, r3, #30
    580a:	d411      	bmi.n	5830 <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    580c:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
    580e:	2201      	movs	r2, #1
    5810:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
    5812:	009b      	lsls	r3, r3, #2
    5814:	490a      	ldr	r1, [pc, #40]	; (5840 <nrfx_gpiote_trigger_disable+0x4c>)
    5816:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    581a:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    581e:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    5822:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    5826:	f022 0203 	bic.w	r2, r2, #3
    582a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
    582e:	bd08      	pop	{r3, pc}
    5830:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
    5834:	2100      	movs	r1, #0
    5836:	4610      	mov	r0, r2
    5838:	f003 bbcf 	b.w	8fda <nrf_gpio_cfg_sense_set>
    583c:	20000110 	.word	0x20000110
    5840:	40006000 	.word	0x40006000

00005844 <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    5844:	4b0e      	ldr	r3, [pc, #56]	; (5880 <nrfx_gpiote_pin_uninit+0x3c>)
    5846:	f100 0208 	add.w	r2, r0, #8
{
    584a:	b513      	push	{r0, r1, r4, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    584c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (!pin_in_use(pin))
    5850:	07db      	lsls	r3, r3, #31
{
    5852:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
    5854:	d511      	bpl.n	587a <nrfx_gpiote_pin_uninit+0x36>
    nrfx_gpiote_trigger_disable(pin);
    5856:	f7ff ffcd 	bl	57f4 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
    585a:	4620      	mov	r0, r4
    585c:	f7ff fdec 	bl	5438 <pin_handler_trigger_uninit>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    5860:	a801      	add	r0, sp, #4
    5862:	9401      	str	r4, [sp, #4]
    5864:	f7ff fd88 	bl	5378 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    5868:	9b01      	ldr	r3, [sp, #4]
    586a:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    586e:	2202      	movs	r2, #2
    5870:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    nrf_gpio_cfg(
    5874:	4803      	ldr	r0, [pc, #12]	; (5884 <nrfx_gpiote_pin_uninit+0x40>)
}
    5876:	b002      	add	sp, #8
    5878:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
    587a:	4803      	ldr	r0, [pc, #12]	; (5888 <nrfx_gpiote_pin_uninit+0x44>)
    587c:	e7fb      	b.n	5876 <nrfx_gpiote_pin_uninit+0x32>
    587e:	bf00      	nop
    5880:	20000110 	.word	0x20000110
    5884:	0bad0000 	.word	0x0bad0000
    5888:	0bad0004 	.word	0x0bad0004

0000588c <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
    588c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5890:	4b64      	ldr	r3, [pc, #400]	; (5a24 <nrfx_gpiote_irq_handler+0x198>)
    return p_reg->INTENSET & mask;
    5892:	4865      	ldr	r0, [pc, #404]	; (5a28 <nrfx_gpiote_irq_handler+0x19c>)
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    5894:	4965      	ldr	r1, [pc, #404]	; (5a2c <nrfx_gpiote_irq_handler+0x1a0>)
    uint32_t status = 0;
    5896:	2600      	movs	r6, #0
{
    5898:	b087      	sub	sp, #28
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
    589a:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    589c:	4634      	mov	r4, r6
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    589e:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
    58a0:	b135      	cbz	r5, 58b0 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
    58a2:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
    58a6:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    58a8:	bf1e      	ittt	ne
    58aa:	601c      	strne	r4, [r3, #0]
    58ac:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
    58ae:	4316      	orrne	r6, r2
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    58b0:	3304      	adds	r3, #4
    58b2:	428b      	cmp	r3, r1
        }
        mask <<= 1;
    58b4:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    58b8:	d1f1      	bne.n	589e <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    58ba:	f8df 816c 	ldr.w	r8, [pc, #364]	; 5a28 <nrfx_gpiote_irq_handler+0x19c>
    58be:	f8d8 317c 	ldr.w	r3, [r8, #380]	; 0x17c
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
    58c2:	2b00      	cmp	r3, #0
    58c4:	f000 8091 	beq.w	59ea <nrfx_gpiote_irq_handler+0x15e>
        *p_masks = gpio_regs[i]->LATCH;
    58c8:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    58cc:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
    58d0:	9204      	str	r2, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
    58d2:	f8c3 2520 	str.w	r2, [r3, #1312]	; 0x520
        *p_masks = gpio_regs[i]->LATCH;
    58d6:	f8d3 2820 	ldr.w	r2, [r3, #2080]	; 0x820
    58da:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
    58dc:	f8c3 2820 	str.w	r2, [r3, #2080]	; 0x820
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
    58e0:	2700      	movs	r7, #0
            while (latch[i])
    58e2:	f10d 0910 	add.w	r9, sp, #16
    58e6:	017b      	lsls	r3, r7, #5
    58e8:	9300      	str	r3, [sp, #0]
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
    58ea:	f04f 0a01 	mov.w	sl, #1
    58ee:	e049      	b.n	5984 <nrfx_gpiote_irq_handler+0xf8>
                pin += 32 * i;
    58f0:	9b00      	ldr	r3, [sp, #0]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    58f2:	4a4f      	ldr	r2, [pc, #316]	; (5a30 <nrfx_gpiote_irq_handler+0x1a4>)
                uint32_t pin = NRF_CTZ(latch[i]);
    58f4:	fa94 f4a4 	rbit	r4, r4
    58f8:	fab4 f484 	clz	r4, r4
                pin += 32 * i;
    58fc:	441c      	add	r4, r3
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    58fe:	f104 0308 	add.w	r3, r4, #8
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    5902:	08e0      	lsrs	r0, r4, #3
    5904:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
    5908:	9403      	str	r4, [sp, #12]
    bit = BITMASK_RELBIT_GET(bit);
    590a:	f004 0207 	and.w	r2, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
    590e:	fa0a fc02 	lsl.w	ip, sl, r2
    5912:	f819 2000 	ldrb.w	r2, [r9, r0]
    5916:	ea22 020c 	bic.w	r2, r2, ip
    591a:	f809 2000 	strb.w	r2, [r9, r0]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    591e:	a803      	add	r0, sp, #12
    5920:	f3c3 0582 	ubfx	r5, r3, #2, #3
    5924:	0899      	lsrs	r1, r3, #2
    5926:	f7ff fd27 	bl	5378 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    592a:	9a03      	ldr	r2, [sp, #12]
    592c:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    if (is_level(trigger))
    5930:	074b      	lsls	r3, r1, #29
    5932:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    5936:	46ab      	mov	fp, r5
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
    5938:	f3c2 4201 	ubfx	r2, r2, #16, #2
    if (is_level(trigger))
    593c:	d529      	bpl.n	5992 <nrfx_gpiote_irq_handler+0x106>
        call_handler(pin, trigger);
    593e:	4620      	mov	r0, r4
    5940:	4659      	mov	r1, fp
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    5942:	b2d5      	uxtb	r5, r2
    5944:	f7ff fd30 	bl	53a8 <call_handler>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    5948:	a803      	add	r0, sp, #12
    594a:	9403      	str	r4, [sp, #12]
    594c:	f7ff fd14 	bl	5378 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    5950:	9b03      	ldr	r3, [sp, #12]
    5952:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    5956:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
        if (nrf_gpio_pin_sense_get(pin) == sense)
    595a:	f3c3 4301 	ubfx	r3, r3, #16, #2
    595e:	429d      	cmp	r5, r3
    5960:	d107      	bne.n	5972 <nrfx_gpiote_irq_handler+0xe6>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
    5962:	2100      	movs	r1, #0
    5964:	4620      	mov	r0, r4
    5966:	f003 fb38 	bl	8fda <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
    596a:	4629      	mov	r1, r5
    596c:	4620      	mov	r0, r4
    596e:	f003 fb34 	bl	8fda <nrf_gpio_cfg_sense_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    5972:	a803      	add	r0, sp, #12
    5974:	9403      	str	r4, [sp, #12]
    5976:	f7ff fcff 	bl	5378 <nrf_gpio_pin_port_decode>
    reg->LATCH = (1 << pin_number);
    597a:	9b03      	ldr	r3, [sp, #12]
    597c:	fa0a f303 	lsl.w	r3, sl, r3
    5980:	f8c0 3520 	str.w	r3, [r0, #1312]	; 0x520
            while (latch[i])
    5984:	f859 4027 	ldr.w	r4, [r9, r7, lsl #2]
    5988:	2c00      	cmp	r4, #0
    598a:	d1b1      	bne.n	58f0 <nrfx_gpiote_irq_handler+0x64>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
    598c:	b9cf      	cbnz	r7, 59c2 <nrfx_gpiote_irq_handler+0x136>
    598e:	2701      	movs	r7, #1
    5990:	e7a9      	b.n	58e6 <nrfx_gpiote_irq_handler+0x5a>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    5992:	2a02      	cmp	r2, #2
        nrf_gpio_cfg_sense_set(pin, next_sense);
    5994:	bf0c      	ite	eq
    5996:	2103      	moveq	r1, #3
    5998:	2102      	movne	r1, #2
    599a:	4620      	mov	r0, r4
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    599c:	9201      	str	r2, [sp, #4]
        nrf_gpio_cfg_sense_set(pin, next_sense);
    599e:	f003 fb1c 	bl	8fda <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
    59a2:	2d03      	cmp	r5, #3
    59a4:	d004      	beq.n	59b0 <nrfx_gpiote_irq_handler+0x124>
    59a6:	9a01      	ldr	r2, [sp, #4]
    59a8:	2a02      	cmp	r2, #2
    59aa:	d106      	bne.n	59ba <nrfx_gpiote_irq_handler+0x12e>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
    59ac:	2d01      	cmp	r5, #1
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
    59ae:	d1e0      	bne.n	5972 <nrfx_gpiote_irq_handler+0xe6>
            call_handler(pin, trigger);
    59b0:	4659      	mov	r1, fp
    59b2:	4620      	mov	r0, r4
    59b4:	f7ff fcf8 	bl	53a8 <call_handler>
    59b8:	e7db      	b.n	5972 <nrfx_gpiote_irq_handler+0xe6>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
    59ba:	2a03      	cmp	r2, #3
    59bc:	d1d9      	bne.n	5972 <nrfx_gpiote_irq_handler+0xe6>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
    59be:	2d02      	cmp	r5, #2
    59c0:	e7f5      	b.n	59ae <nrfx_gpiote_irq_handler+0x122>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    59c2:	f8c8 417c 	str.w	r4, [r8, #380]	; 0x17c
    59c6:	f8d8 317c 	ldr.w	r3, [r8, #380]	; 0x17c
        *p_masks = gpio_regs[i]->LATCH;
    59ca:	491a      	ldr	r1, [pc, #104]	; (5a34 <nrfx_gpiote_irq_handler+0x1a8>)
    59cc:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    59d0:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
    59d4:	9204      	str	r2, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
    59d6:	f8c3 2520 	str.w	r2, [r3, #1312]	; 0x520
        *p_masks = gpio_regs[i]->LATCH;
    59da:	f8d1 3520 	ldr.w	r3, [r1, #1312]	; 0x520
    59de:	9305      	str	r3, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
    59e0:	f8c1 3520 	str.w	r3, [r1, #1312]	; 0x520
        if (latch[port_idx])
    59e4:	4313      	orrs	r3, r2
    59e6:	f47f af7b 	bne.w	58e0 <nrfx_gpiote_irq_handler+0x54>
        mask &= ~NRFX_BIT(ch);
    59ea:	2401      	movs	r4, #1
    while (mask)
    59ec:	b916      	cbnz	r6, 59f4 <nrfx_gpiote_irq_handler+0x168>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
    59ee:	b007      	add	sp, #28
    59f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        uint32_t ch = NRF_CTZ(mask);
    59f4:	fa96 f3a6 	rbit	r3, r6
    59f8:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
    59fc:	fa04 f203 	lsl.w	r2, r4, r3
    5a00:	009b      	lsls	r3, r3, #2
    5a02:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    5a06:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    5a0a:	ea26 0602 	bic.w	r6, r6, r2
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    5a0e:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
    5a12:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    5a16:	f3c0 2005 	ubfx	r0, r0, #8, #6
    5a1a:	f3c1 4101 	ubfx	r1, r1, #16, #2
    5a1e:	f7ff fcc3 	bl	53a8 <call_handler>
    5a22:	e7e3      	b.n	59ec <nrfx_gpiote_irq_handler+0x160>
    5a24:	40006100 	.word	0x40006100
    5a28:	40006000 	.word	0x40006000
    5a2c:	40006120 	.word	0x40006120
    5a30:	20000110 	.word	0x20000110
    5a34:	50000300 	.word	0x50000300

00005a38 <nrfx_power_init>:
    return m_usbevt_handler;
}
#endif

nrfx_err_t nrfx_power_init(nrfx_power_config_t const * p_config)
{
    5a38:	b510      	push	{r4, lr}
    NRFX_ASSERT(p_config);
    if (m_initialized)
    5a3a:	4c18      	ldr	r4, [pc, #96]	; (5a9c <nrfx_power_init+0x64>)
    5a3c:	7823      	ldrb	r3, [r4, #0]
    5a3e:	bb53      	cbnz	r3, 5a96 <nrfx_power_init+0x5e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

#if NRF_POWER_HAS_DCDCEN_VDDH
    nrf_power_dcdcen_vddh_set(NRF_POWER, p_config->dcdcenhv);
    5a40:	7802      	ldrb	r2, [r0, #0]
    if (enable && nrf52_errata_197())
    5a42:	0791      	lsls	r1, r2, #30
    5a44:	f3c2 0340 	ubfx	r3, r2, #1, #1
    5a48:	d511      	bpl.n	5a6e <nrfx_power_init+0x36>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    5a4a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
    5a4e:	f8d3 1130 	ldr.w	r1, [r3, #304]	; 0x130
    5a52:	2908      	cmp	r1, #8
    5a54:	d11d      	bne.n	5a92 <nrfx_power_init+0x5a>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    5a56:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                switch(var2)
    5a5a:	2b05      	cmp	r3, #5
    5a5c:	d819      	bhi.n	5a92 <nrfx_power_init+0x5a>
    5a5e:	4910      	ldr	r1, [pc, #64]	; (5aa0 <nrfx_power_init+0x68>)
    5a60:	5cc9      	ldrb	r1, [r1, r3]
    5a62:	2301      	movs	r3, #1
    5a64:	b119      	cbz	r1, 5a6e <nrfx_power_init+0x36>
        *(volatile uint32_t *)0x40000638ul = 1ul;
    5a66:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    5a6a:	f8c1 3638 	str.w	r3, [r1, #1592]	; 0x638
    p_reg->DCDCEN0 = (enable ? POWER_DCDCEN0_DCDCEN_Enabled : POWER_DCDCEN0_DCDCEN_Disabled) <<
    5a6e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    5a72:	f002 0201 	and.w	r2, r2, #1
    p_reg->DCDCEN0 = (enable ? POWER_DCDCEN0_DCDCEN_Enabled : POWER_DCDCEN0_DCDCEN_Disabled) <<
    5a76:	f8c1 3580 	str.w	r3, [r1, #1408]	; 0x580
    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
    5a7a:	2000      	movs	r0, #0
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    5a7c:	f8c1 2578 	str.w	r2, [r1, #1400]	; 0x578
    5a80:	f7fd fbb4 	bl	31ec <arch_irq_is_enabled>
    5a84:	b908      	cbnz	r0, 5a8a <nrfx_power_init+0x52>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
    5a86:	f7fd fb8d 	bl	31a4 <arch_irq_enable>
#endif
#endif // defined(REGULATORS_PRESENT)

    nrfx_power_clock_irq_init();

    m_initialized = true;
    5a8a:	2301      	movs	r3, #1
    return NRFX_SUCCESS;
    5a8c:	4805      	ldr	r0, [pc, #20]	; (5aa4 <nrfx_power_init+0x6c>)
    m_initialized = true;
    5a8e:	7023      	strb	r3, [r4, #0]
}
    5a90:	bd10      	pop	{r4, pc}
    p_reg->DCDCEN0 = (enable ? POWER_DCDCEN0_DCDCEN_Enabled : POWER_DCDCEN0_DCDCEN_Disabled) <<
    5a92:	2301      	movs	r3, #1
    5a94:	e7eb      	b.n	5a6e <nrfx_power_init+0x36>
        return NRFX_ERROR_ALREADY_INITIALIZED;
    5a96:	4804      	ldr	r0, [pc, #16]	; (5aa8 <nrfx_power_init+0x70>)
    5a98:	e7fa      	b.n	5a90 <nrfx_power_init+0x58>
    5a9a:	bf00      	nop
    5a9c:	200013a4 	.word	0x200013a4
    5aa0:	00009ce3 	.word	0x00009ce3
    5aa4:	0bad0000 	.word	0x0bad0000
    5aa8:	0bad000c 	.word	0x0bad000c

00005aac <nrfx_power_usbevt_uninit>:
    p_reg->INTENCLR = mask;
    5aac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    5ab0:	f44f 7260 	mov.w	r2, #896	; 0x380
    5ab4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}

void nrfx_power_usbevt_uninit(void)
{
    nrfx_power_usbevt_disable();
    m_usbevt_handler = NULL;
    5ab8:	4b01      	ldr	r3, [pc, #4]	; (5ac0 <nrfx_power_usbevt_uninit+0x14>)
    5aba:	2200      	movs	r2, #0
    5abc:	601a      	str	r2, [r3, #0]
}
    5abe:	4770      	bx	lr
    5ac0:	200010e8 	.word	0x200010e8

00005ac4 <nrfx_power_usbevt_init>:
{
    5ac4:	b508      	push	{r3, lr}
    nrfx_power_usbevt_uninit();
    5ac6:	f7ff fff1 	bl	5aac <nrfx_power_usbevt_uninit>
    if (p_config->handler != NULL)
    5aca:	6803      	ldr	r3, [r0, #0]
    5acc:	b10b      	cbz	r3, 5ad2 <nrfx_power_usbevt_init+0xe>
        m_usbevt_handler = p_config->handler;
    5ace:	4a01      	ldr	r2, [pc, #4]	; (5ad4 <nrfx_power_usbevt_init+0x10>)
    5ad0:	6013      	str	r3, [r2, #0]
}
    5ad2:	bd08      	pop	{r3, pc}
    5ad4:	200010e8 	.word	0x200010e8

00005ad8 <nrfx_power_irq_handler>:
    return p_reg->INTENSET;
    5ad8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

#endif /* NRF_POWER_HAS_USBREG */


void nrfx_power_irq_handler(void)
{
    5adc:	b510      	push	{r4, lr}
    5ade:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
    uint32_t enabled = nrf_power_int_enable_get(NRF_POWER);
    /* Prevent "unused variable" warning when all below blocks are disabled. */
    (void)enabled;

#if NRFX_POWER_SUPPORTS_POFCON
    if ((0 != (enabled & NRF_POWER_INT_POFWARN_MASK)) &&
    5ae2:	0762      	lsls	r2, r4, #29
    5ae4:	d507      	bpl.n	5af6 <nrfx_power_irq_handler+0x1e>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_POFWARN))
    5ae6:	f44f 7084 	mov.w	r0, #264	; 0x108
    5aea:	f003 fa85 	bl	8ff8 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_POFWARN_MASK)) &&
    5aee:	b110      	cbz	r0, 5af6 <nrfx_power_irq_handler+0x1e>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_pofwarn_handler != NULL);
        m_pofwarn_handler();
    5af0:	4b1e      	ldr	r3, [pc, #120]	; (5b6c <nrfx_power_irq_handler+0x94>)
    5af2:	681b      	ldr	r3, [r3, #0]
    5af4:	4798      	blx	r3
    }
#endif
#if NRF_POWER_HAS_SLEEPEVT
    if ((0 != (enabled & NRF_POWER_INT_SLEEPENTER_MASK)) &&
    5af6:	06a3      	lsls	r3, r4, #26
    5af8:	d508      	bpl.n	5b0c <nrfx_power_irq_handler+0x34>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_SLEEPENTER))
    5afa:	f44f 708a 	mov.w	r0, #276	; 0x114
    5afe:	f003 fa7b 	bl	8ff8 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_SLEEPENTER_MASK)) &&
    5b02:	b118      	cbz	r0, 5b0c <nrfx_power_irq_handler+0x34>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_sleepevt_handler != NULL);
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_ENTER);
    5b04:	4b1a      	ldr	r3, [pc, #104]	; (5b70 <nrfx_power_irq_handler+0x98>)
    5b06:	2000      	movs	r0, #0
    5b08:	681b      	ldr	r3, [r3, #0]
    5b0a:	4798      	blx	r3
    }
    if ((0 != (enabled & NRF_POWER_INT_SLEEPEXIT_MASK)) &&
    5b0c:	0660      	lsls	r0, r4, #25
    5b0e:	d508      	bpl.n	5b22 <nrfx_power_irq_handler+0x4a>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_SLEEPEXIT))
    5b10:	f44f 708c 	mov.w	r0, #280	; 0x118
    5b14:	f003 fa70 	bl	8ff8 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_SLEEPEXIT_MASK)) &&
    5b18:	b118      	cbz	r0, 5b22 <nrfx_power_irq_handler+0x4a>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_sleepevt_handler != NULL);
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_EXIT);
    5b1a:	4b15      	ldr	r3, [pc, #84]	; (5b70 <nrfx_power_irq_handler+0x98>)
    5b1c:	2001      	movs	r0, #1
    5b1e:	681b      	ldr	r3, [r3, #0]
    5b20:	4798      	blx	r3
    }
#endif
#if NRF_POWER_HAS_USBREG
    if ((0 != (enabled & NRF_POWER_INT_USBDETECTED_MASK)) &&
    5b22:	0621      	lsls	r1, r4, #24
    5b24:	d508      	bpl.n	5b38 <nrfx_power_irq_handler+0x60>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_USBDETECTED))
    5b26:	f44f 708e 	mov.w	r0, #284	; 0x11c
    5b2a:	f003 fa65 	bl	8ff8 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_USBDETECTED_MASK)) &&
    5b2e:	b118      	cbz	r0, 5b38 <nrfx_power_irq_handler+0x60>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_usbevt_handler != NULL);
        m_usbevt_handler(NRFX_POWER_USB_EVT_DETECTED);
    5b30:	4b10      	ldr	r3, [pc, #64]	; (5b74 <nrfx_power_irq_handler+0x9c>)
    5b32:	2000      	movs	r0, #0
    5b34:	681b      	ldr	r3, [r3, #0]
    5b36:	4798      	blx	r3
    }
    if ((0 != (enabled & NRF_POWER_INT_USBREMOVED_MASK)) &&
    5b38:	05e2      	lsls	r2, r4, #23
    5b3a:	d508      	bpl.n	5b4e <nrfx_power_irq_handler+0x76>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_USBREMOVED))
    5b3c:	f44f 7090 	mov.w	r0, #288	; 0x120
    5b40:	f003 fa5a 	bl	8ff8 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_USBREMOVED_MASK)) &&
    5b44:	b118      	cbz	r0, 5b4e <nrfx_power_irq_handler+0x76>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_usbevt_handler != NULL);
        m_usbevt_handler(NRFX_POWER_USB_EVT_REMOVED);
    5b46:	4b0b      	ldr	r3, [pc, #44]	; (5b74 <nrfx_power_irq_handler+0x9c>)
    5b48:	2001      	movs	r0, #1
    5b4a:	681b      	ldr	r3, [r3, #0]
    5b4c:	4798      	blx	r3
    }
    if ((0 != (enabled & NRF_POWER_INT_USBPWRRDY_MASK)) &&
    5b4e:	05a3      	lsls	r3, r4, #22
    5b50:	d50a      	bpl.n	5b68 <nrfx_power_irq_handler+0x90>
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_USBPWRRDY))
    5b52:	f44f 7092 	mov.w	r0, #292	; 0x124
    5b56:	f003 fa4f 	bl	8ff8 <nrf_power_event_get_and_clear.constprop.0>
    if ((0 != (enabled & NRF_POWER_INT_USBPWRRDY_MASK)) &&
    5b5a:	b128      	cbz	r0, 5b68 <nrfx_power_irq_handler+0x90>
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_usbevt_handler != NULL);
        m_usbevt_handler(NRFX_POWER_USB_EVT_READY);
    5b5c:	4b05      	ldr	r3, [pc, #20]	; (5b74 <nrfx_power_irq_handler+0x9c>)
    }
#endif
}
    5b5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_usbevt_handler(NRFX_POWER_USB_EVT_READY);
    5b62:	681b      	ldr	r3, [r3, #0]
    5b64:	2002      	movs	r0, #2
    5b66:	4718      	bx	r3
}
    5b68:	bd10      	pop	{r4, pc}
    5b6a:	bf00      	nop
    5b6c:	200010e0 	.word	0x200010e0
    5b70:	200010e4 	.word	0x200010e4
    5b74:	200010e8 	.word	0x200010e8

00005b78 <nrfx_ppi_channel_alloc>:
    nrfx_flag32_init(&m_groups_allocated, NRFX_PPI_ALL_APP_GROUPS_MASK);
}


nrfx_err_t nrfx_ppi_channel_alloc(nrf_ppi_channel_t * p_channel)
{
    5b78:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_channels_allocated, (uint8_t *)p_channel);
    5b7a:	4801      	ldr	r0, [pc, #4]	; (5b80 <nrfx_ppi_channel_alloc+0x8>)
    5b7c:	f7ff bb28 	b.w	51d0 <nrfx_flag32_alloc>
    5b80:	2000018c 	.word	0x2000018c

00005b84 <nrf52_errata_187>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    5b84:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
    5b88:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
    5b8c:	2a08      	cmp	r2, #8
    5b8e:	d106      	bne.n	5b9e <nrf52_errata_187+0x1a>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    5b90:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                switch(var2)
    5b94:	2b05      	cmp	r3, #5
    5b96:	d804      	bhi.n	5ba2 <nrf52_errata_187+0x1e>
    5b98:	4a03      	ldr	r2, [pc, #12]	; (5ba8 <nrf52_errata_187+0x24>)
    5b9a:	5cd0      	ldrb	r0, [r2, r3]
    5b9c:	4770      	bx	lr
        return false;
    5b9e:	2000      	movs	r0, #0
    5ba0:	4770      	bx	lr
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    5ba2:	2001      	movs	r0, #1
}
    5ba4:	4770      	bx	lr
    5ba6:	bf00      	nop
    5ba8:	00009ce9 	.word	0x00009ce9

00005bac <ep_state_access>:
 * @param ep Endpoint number.
 */
static inline usbd_ep_state_t* ep_state_access(nrfx_usbd_ep_t ep)
{
    NRFX_USBD_ASSERT_EP_VALID(ep);
    return ((NRF_USBD_EPIN_CHECK(ep) ? m_ep_state.ep_in : m_ep_state.ep_out) +
    5bac:	4b05      	ldr	r3, [pc, #20]	; (5bc4 <ep_state_access+0x18>)
    5bae:	f010 0f80 	tst.w	r0, #128	; 0x80
    5bb2:	f1a3 0290 	sub.w	r2, r3, #144	; 0x90
    5bb6:	bf08      	it	eq
    5bb8:	4613      	moveq	r3, r2
        NRF_USBD_EP_NR_GET(ep));
    5bba:	f000 000f 	and.w	r0, r0, #15
}
    5bbe:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    5bc2:	4770      	bx	lr
    5bc4:	2000125c 	.word	0x2000125c

00005bc8 <usbd_dma_pending_clear>:
 *
 * Internal function to clear the flag informing about EasyDMA transfer pending.
 * This function is called always just after the finished EasyDMA transfer is detected.
 */
static inline void usbd_dma_pending_clear(void)
{
    5bc8:	b508      	push	{r3, lr}
}

/* Errata: USBD cannot receive tasks during DMA. **/
static inline bool nrfx_usbd_errata_199(void)
{
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_199();
    5bca:	f003 fa36 	bl	903a <nrf52_errata_166>
    if (nrfx_usbd_errata_199())
    5bce:	b118      	cbz	r0, 5bd8 <usbd_dma_pending_clear+0x10>
    {
        *((volatile uint32_t *)0x40027C1C) = 0x00000000;
    5bd0:	4b03      	ldr	r3, [pc, #12]	; (5be0 <usbd_dma_pending_clear+0x18>)
    5bd2:	2200      	movs	r2, #0
    5bd4:	f8c3 2c1c 	str.w	r2, [r3, #3100]	; 0xc1c
    }
    m_dma_pending = false;
    5bd8:	4b02      	ldr	r3, [pc, #8]	; (5be4 <usbd_dma_pending_clear+0x1c>)
    5bda:	2200      	movs	r2, #0
    5bdc:	701a      	strb	r2, [r3, #0]
}
    5bde:	bd08      	pop	{r3, pc}
    5be0:	40027000 	.word	0x40027000
    5be4:	200013a6 	.word	0x200013a6

00005be8 <ev_usbreset_handler>:
 * Interrupt runtimes that would be vectorized using @ref m_isr.
 * @{
 */

static void ev_usbreset_handler(void)
{
    5be8:	b507      	push	{r0, r1, r2, lr}
    m_bus_suspend = false;
    5bea:	4a09      	ldr	r2, [pc, #36]	; (5c10 <ev_usbreset_handler+0x28>)
    5bec:	2300      	movs	r3, #0
    5bee:	7013      	strb	r3, [r2, #0]
    m_last_setup_dir = NRFX_USBD_EPOUT0;
    5bf0:	4a08      	ldr	r2, [pc, #32]	; (5c14 <ev_usbreset_handler+0x2c>)

    const nrfx_usbd_evt_t evt = {
    5bf2:	f8ad 3005 	strh.w	r3, [sp, #5]
    m_last_setup_dir = NRFX_USBD_EPOUT0;
    5bf6:	7013      	strb	r3, [r2, #0]
    const nrfx_usbd_evt_t evt = {
    5bf8:	f88d 3007 	strb.w	r3, [sp, #7]
    5bfc:	2301      	movs	r3, #1
    5bfe:	f88d 3004 	strb.w	r3, [sp, #4]
            .type = NRFX_USBD_EVT_RESET
    };

    m_event_handler(&evt);
    5c02:	4b05      	ldr	r3, [pc, #20]	; (5c18 <ev_usbreset_handler+0x30>)
    5c04:	a801      	add	r0, sp, #4
    5c06:	681b      	ldr	r3, [r3, #0]
    5c08:	4798      	blx	r3
}
    5c0a:	b003      	add	sp, #12
    5c0c:	f85d fb04 	ldr.w	pc, [sp], #4
    5c10:	200013a5 	.word	0x200013a5
    5c14:	200013a8 	.word	0x200013a8
    5c18:	200012ec 	.word	0x200012ec

00005c1c <ev_usbevent_handler>:
    return p_reg->EVENTCAUSE;
    5c1c:	4b21      	ldr	r3, [pc, #132]	; (5ca4 <ev_usbevent_handler+0x88>)
    };
    m_event_handler(&evt);
}

static void ev_usbevent_handler(void)
{
    5c1e:	b513      	push	{r0, r1, r4, lr}
    5c20:	f8d3 4400 	ldr.w	r4, [r3, #1024]	; 0x400
    p_reg->EVENTCAUSE = flags;
    5c24:	f8c3 4400 	str.w	r4, [r3, #1024]	; 0x400
    if (event & NRF_USBD_EVENTCAUSE_ISOOUTCRC_MASK)
    {
        NRFX_LOG_DEBUG("USBD event: ISOOUTCRC");
        /* Currently no support */
    }
    if (event & NRF_USBD_EVENTCAUSE_SUSPEND_MASK)
    5c28:	05e1      	lsls	r1, r4, #23
    (void) p_reg->EVENTCAUSE;
    5c2a:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    5c2e:	d50e      	bpl.n	5c4e <ev_usbevent_handler+0x32>
    {
        NRFX_LOG_DEBUG("USBD event: SUSPEND");
        m_bus_suspend = true;
    5c30:	4b1d      	ldr	r3, [pc, #116]	; (5ca8 <ev_usbevent_handler+0x8c>)
    5c32:	2201      	movs	r2, #1
    5c34:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
    5c36:	2300      	movs	r3, #0
    5c38:	f8ad 3005 	strh.w	r3, [sp, #5]
    5c3c:	f88d 3007 	strb.w	r3, [sp, #7]
    5c40:	2302      	movs	r3, #2
    5c42:	f88d 3004 	strb.w	r3, [sp, #4]
                .type = NRFX_USBD_EVT_SUSPEND
        };
        m_event_handler(&evt);
    5c46:	4b19      	ldr	r3, [pc, #100]	; (5cac <ev_usbevent_handler+0x90>)
    5c48:	a801      	add	r0, sp, #4
    5c4a:	681b      	ldr	r3, [r3, #0]
    5c4c:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_RESUME_MASK)
    5c4e:	05a2      	lsls	r2, r4, #22
    5c50:	d50d      	bpl.n	5c6e <ev_usbevent_handler+0x52>
    {
        NRFX_LOG_DEBUG("USBD event: RESUME");
        m_bus_suspend = false;
    5c52:	4a15      	ldr	r2, [pc, #84]	; (5ca8 <ev_usbevent_handler+0x8c>)
    5c54:	2300      	movs	r3, #0
    5c56:	7013      	strb	r3, [r2, #0]
        const nrfx_usbd_evt_t evt = {
    5c58:	f8ad 3005 	strh.w	r3, [sp, #5]
    5c5c:	f88d 3007 	strb.w	r3, [sp, #7]
    5c60:	2303      	movs	r3, #3
    5c62:	f88d 3004 	strb.w	r3, [sp, #4]
                .type = NRFX_USBD_EVT_RESUME
        };
        m_event_handler(&evt);
    5c66:	4b11      	ldr	r3, [pc, #68]	; (5cac <ev_usbevent_handler+0x90>)
    5c68:	a801      	add	r0, sp, #4
    5c6a:	681b      	ldr	r3, [r3, #0]
    5c6c:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_WUREQ_MASK)
    5c6e:	0563      	lsls	r3, r4, #21
    5c70:	d515      	bpl.n	5c9e <ev_usbevent_handler+0x82>
    {
        NRFX_LOG_DEBUG("USBD event: WUREQ (%s)", m_bus_suspend ? "In Suspend" : "Active");
        if (m_bus_suspend)
    5c72:	4a0d      	ldr	r2, [pc, #52]	; (5ca8 <ev_usbevent_handler+0x8c>)
    5c74:	7813      	ldrb	r3, [r2, #0]
    5c76:	b193      	cbz	r3, 5c9e <ev_usbevent_handler+0x82>
        {
            NRFX_ASSERT(!nrf_usbd_lowpower_check(NRF_USBD));
            m_bus_suspend = false;
    5c78:	2300      	movs	r3, #0
    5c7a:	7013      	strb	r3, [r2, #0]
    p_reg->DPDMVALUE = ((uint32_t)val) << USBD_DPDMVALUE_STATE_Pos;
    5c7c:	4a09      	ldr	r2, [pc, #36]	; (5ca4 <ev_usbevent_handler+0x88>)
    5c7e:	2101      	movs	r1, #1
    5c80:	f8c2 1508 	str.w	r1, [r2, #1288]	; 0x508
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
    5c84:	6591      	str	r1, [r2, #88]	; 0x58
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
    5c86:	6d92      	ldr	r2, [r2, #88]	; 0x58

            nrf_usbd_dpdmvalue_set(NRF_USBD, NRF_USBD_DPDMVALUE_RESUME);
            nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_DRIVEDPDM);

            const nrfx_usbd_evt_t evt = {
    5c88:	f8ad 3005 	strh.w	r3, [sp, #5]
    5c8c:	f88d 3007 	strb.w	r3, [sp, #7]
    5c90:	2304      	movs	r3, #4
    5c92:	f88d 3004 	strb.w	r3, [sp, #4]
                    .type = NRFX_USBD_EVT_WUREQ
            };
            m_event_handler(&evt);
    5c96:	4b05      	ldr	r3, [pc, #20]	; (5cac <ev_usbevent_handler+0x90>)
    5c98:	a801      	add	r0, sp, #4
    5c9a:	681b      	ldr	r3, [r3, #0]
    5c9c:	4798      	blx	r3
        }
    }
}
    5c9e:	b002      	add	sp, #8
    5ca0:	bd10      	pop	{r4, pc}
    5ca2:	bf00      	nop
    5ca4:	40027000 	.word	0x40027000
    5ca8:	200013a5 	.word	0x200013a5
    5cac:	200012ec 	.word	0x200012ec

00005cb0 <usbd_errata_187_211_begin>:
	__asm__ volatile(
    5cb0:	f04f 0320 	mov.w	r3, #32
    5cb4:	f3ef 8011 	mrs	r0, BASEPRI
    5cb8:	f383 8812 	msr	BASEPRI_MAX, r3
    5cbc:	f3bf 8f6f 	isb	sy
 * @brief Begin erratas 187 and 211.
 */
static inline void usbd_errata_187_211_begin(void)
{
    NRFX_CRITICAL_SECTION_ENTER();
    if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
    5cc0:	4b0a      	ldr	r3, [pc, #40]	; (5cec <usbd_errata_187_211_begin+0x3c>)
    5cc2:	f8d3 1c00 	ldr.w	r1, [r3, #3072]	; 0xc00
    5cc6:	2203      	movs	r2, #3
    5cc8:	b961      	cbnz	r1, 5ce4 <usbd_errata_187_211_begin+0x34>
    {
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5cca:	f249 3175 	movw	r1, #37749	; 0x9375
    5cce:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
    5cd2:	f8c3 2d14 	str.w	r2, [r3, #3348]	; 0xd14
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5cd6:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
	__asm__ volatile(
    5cda:	f380 8811 	msr	BASEPRI, r0
    5cde:	f3bf 8f6f 	isb	sy
    else
    {
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
    }
    NRFX_CRITICAL_SECTION_EXIT();
}
    5ce2:	4770      	bx	lr
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
    5ce4:	f8c3 2d14 	str.w	r2, [r3, #3348]	; 0xd14
    5ce8:	e7f7      	b.n	5cda <usbd_errata_187_211_begin+0x2a>
    5cea:	bf00      	nop
    5cec:	4006e000 	.word	0x4006e000

00005cf0 <usbd_errata_187_211_end>:
	__asm__ volatile(
    5cf0:	f04f 0320 	mov.w	r3, #32
    5cf4:	f3ef 8011 	mrs	r0, BASEPRI
    5cf8:	f383 8812 	msr	BASEPRI_MAX, r3
    5cfc:	f3bf 8f6f 	isb	sy
 * @brief End erratas 187 and 211.
 */
static inline void usbd_errata_187_211_end(void)
{
    NRFX_CRITICAL_SECTION_ENTER();
    if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
    5d00:	4b0a      	ldr	r3, [pc, #40]	; (5d2c <usbd_errata_187_211_end+0x3c>)
    5d02:	f8d3 1c00 	ldr.w	r1, [r3, #3072]	; 0xc00
    5d06:	b961      	cbnz	r1, 5d22 <usbd_errata_187_211_end+0x32>
    {
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5d08:	f249 3275 	movw	r2, #37749	; 0x9375
    5d0c:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
    5d10:	f8c3 1d14 	str.w	r1, [r3, #3348]	; 0xd14
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5d14:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
	__asm__ volatile(
    5d18:	f380 8811 	msr	BASEPRI, r0
    5d1c:	f3bf 8f6f 	isb	sy
    else
    {
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
    }
    NRFX_CRITICAL_SECTION_EXIT();
}
    5d20:	4770      	bx	lr
        *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
    5d22:	2200      	movs	r2, #0
    5d24:	f8c3 2d14 	str.w	r2, [r3, #3348]	; 0xd14
    5d28:	e7f6      	b.n	5d18 <usbd_errata_187_211_end+0x28>
    5d2a:	bf00      	nop
    5d2c:	4006e000 	.word	0x4006e000

00005d30 <nrfx_usbd_feeder_flash>:
{
    5d30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    size_t tx_size  = p_transfer->size;
    5d32:	684d      	ldr	r5, [r1, #4]
    memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
    5d34:	4f0b      	ldr	r7, [pc, #44]	; (5d64 <nrfx_usbd_feeder_flash+0x34>)
    5d36:	4295      	cmp	r5, r2
    5d38:	bf28      	it	cs
    5d3a:	4615      	movcs	r5, r2
{
    5d3c:	460c      	mov	r4, r1
    5d3e:	4606      	mov	r6, r0
    memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
    5d40:	462a      	mov	r2, r5
    5d42:	6809      	ldr	r1, [r1, #0]
    5d44:	4638      	mov	r0, r7
    5d46:	f002 fdb7 	bl	88b8 <memcpy>
    p_transfer->size -= tx_size;
    5d4a:	6860      	ldr	r0, [r4, #4]
    p_transfer->p_data.addr += tx_size;
    5d4c:	6822      	ldr	r2, [r4, #0]
    p_transfer->size -= tx_size;
    5d4e:	1b40      	subs	r0, r0, r5
    p_next->size = tx_size;
    5d50:	e9c6 7500 	strd	r7, r5, [r6]
    p_transfer->p_data.addr += tx_size;
    5d54:	442a      	add	r2, r5
    p_transfer->size -= tx_size;
    5d56:	6060      	str	r0, [r4, #4]
}
    5d58:	3800      	subs	r0, #0
    p_transfer->p_data.addr += tx_size;
    5d5a:	6022      	str	r2, [r4, #0]
}
    5d5c:	bf18      	it	ne
    5d5e:	2001      	movne	r0, #1
    5d60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5d62:	bf00      	nop
    5d64:	200012f0 	.word	0x200012f0

00005d68 <nrfx_usbd_feeder_flash_zlp>:
{
    5d68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    size_t tx_size  = p_transfer->size;
    5d6a:	684c      	ldr	r4, [r1, #4]
    if (tx_size > ep_size)
    5d6c:	4294      	cmp	r4, r2
    5d6e:	bf28      	it	cs
    5d70:	4614      	movcs	r4, r2
{
    5d72:	4606      	mov	r6, r0
    5d74:	460d      	mov	r5, r1
    if (tx_size != 0)
    5d76:	b18c      	cbz	r4, 5d9c <nrfx_usbd_feeder_flash_zlp+0x34>
        memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
    5d78:	4f09      	ldr	r7, [pc, #36]	; (5da0 <nrfx_usbd_feeder_flash_zlp+0x38>)
    5d7a:	6809      	ldr	r1, [r1, #0]
    5d7c:	4622      	mov	r2, r4
    5d7e:	4638      	mov	r0, r7
    5d80:	f002 fd9a 	bl	88b8 <memcpy>
        p_next->p_data.tx = p_buffer;
    5d84:	6037      	str	r7, [r6, #0]
    p_transfer->size -= tx_size;
    5d86:	686b      	ldr	r3, [r5, #4]
    p_next->size = tx_size;
    5d88:	6074      	str	r4, [r6, #4]
    p_transfer->size -= tx_size;
    5d8a:	1b1b      	subs	r3, r3, r4
    5d8c:	606b      	str	r3, [r5, #4]
    p_transfer->p_data.addr += tx_size;
    5d8e:	682b      	ldr	r3, [r5, #0]
}
    5d90:	1e20      	subs	r0, r4, #0
    p_transfer->p_data.addr += tx_size;
    5d92:	4423      	add	r3, r4
    5d94:	602b      	str	r3, [r5, #0]
}
    5d96:	bf18      	it	ne
    5d98:	2001      	movne	r0, #1
    5d9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        p_next->p_data.tx = NULL;
    5d9c:	6004      	str	r4, [r0, #0]
    5d9e:	e7f2      	b.n	5d86 <nrfx_usbd_feeder_flash_zlp+0x1e>
    5da0:	200012f0 	.word	0x200012f0

00005da4 <ev_sof_handler>:
{
    5da4:	b507      	push	{r0, r1, r2, lr}
    nrfx_usbd_evt_t evt =  {
    5da6:	2300      	movs	r3, #0
    5da8:	f88d 3004 	strb.w	r3, [sp, #4]
    return p_reg->FRAMECNTR;
    5dac:	4b0b      	ldr	r3, [pc, #44]	; (5ddc <ev_sof_handler+0x38>)
    5dae:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
            .data = { .sof = { .framecnt = (uint16_t)nrf_usbd_framecntr_get(NRF_USBD) }}
    5db2:	f8ad 2006 	strh.w	r2, [sp, #6]
    size_t size_isoout = p_reg->SIZE.ISOOUT;
    5db6:	f8d3 34c0 	ldr.w	r3, [r3, #1216]	; 0x4c0
    m_ep_ready |= iso_ready_mask;
    5dba:	4a09      	ldr	r2, [pc, #36]	; (5de0 <ev_sof_handler+0x3c>)
        iso_ready_mask |= (1U << ep2bit(NRFX_USBD_EPOUT8));
    5dbc:	2b00      	cmp	r3, #0
    m_ep_ready |= iso_ready_mask;
    5dbe:	6813      	ldr	r3, [r2, #0]
        iso_ready_mask |= (1U << ep2bit(NRFX_USBD_EPOUT8));
    5dc0:	bf0c      	ite	eq
    5dc2:	f44f 7180 	moveq.w	r1, #256	; 0x100
    5dc6:	f04f 2101 	movne.w	r1, #16777472	; 0x1000100
    m_ep_ready |= iso_ready_mask;
    5dca:	430b      	orrs	r3, r1
    5dcc:	6013      	str	r3, [r2, #0]
    m_event_handler(&evt);
    5dce:	4b05      	ldr	r3, [pc, #20]	; (5de4 <ev_sof_handler+0x40>)
    5dd0:	a801      	add	r0, sp, #4
    5dd2:	681b      	ldr	r3, [r3, #0]
    5dd4:	4798      	blx	r3
}
    5dd6:	b003      	add	sp, #12
    5dd8:	f85d fb04 	ldr.w	pc, [sp], #4
    5ddc:	40027000 	.word	0x40027000
    5de0:	200011c8 	.word	0x200011c8
    5de4:	200012ec 	.word	0x200012ec

00005de8 <atomic_and.constprop.0.isra.0>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    5de8:	4b06      	ldr	r3, [pc, #24]	; (5e04 <atomic_and.constprop.0.isra.0+0x1c>)
    5dea:	f3bf 8f5b 	dmb	ish
    5dee:	e853 2f00 	ldrex	r2, [r3]
    5df2:	4002      	ands	r2, r0
    5df4:	e843 2100 	strex	r1, r2, [r3]
    5df8:	2900      	cmp	r1, #0
    5dfa:	d1f8      	bne.n	5dee <atomic_and.constprop.0.isra.0+0x6>
    5dfc:	f3bf 8f5b 	dmb	ish
}
    5e00:	4770      	bx	lr
    5e02:	bf00      	nop
    5e04:	20001158 	.word	0x20001158

00005e08 <nrf_usbd_ep0in_dma_handler>:
{
    5e08:	b508      	push	{r3, lr}
    usbd_dma_pending_clear();
    5e0a:	f7ff fedd 	bl	5bc8 <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    5e0e:	4b08      	ldr	r3, [pc, #32]	; (5e30 <nrf_usbd_ep0in_dma_handler+0x28>)
    5e10:	f893 209e 	ldrb.w	r2, [r3, #158]	; 0x9e
    5e14:	2a03      	cmp	r2, #3
    5e16:	d105      	bne.n	5e24 <nrf_usbd_ep0in_dma_handler+0x1c>
}
    5e18:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    5e1c:	f06f 0001 	mvn.w	r0, #1
    5e20:	f7ff bfe2 	b.w	5de8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
    5e24:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    5e28:	2b00      	cmp	r3, #0
    5e2a:	d0f5      	beq.n	5e18 <nrf_usbd_ep0in_dma_handler+0x10>
}
    5e2c:	bd08      	pop	{r3, pc}
    5e2e:	bf00      	nop
    5e30:	200011cc 	.word	0x200011cc

00005e34 <usbd_ep_data_handler>:
    m_ep_ready |= (1U << bitpos);
    5e34:	2201      	movs	r2, #1
{
    5e36:	b573      	push	{r0, r1, r4, r5, r6, lr}
    m_ep_ready |= (1U << bitpos);
    5e38:	fa02 f501 	lsl.w	r5, r2, r1
    5e3c:	491c      	ldr	r1, [pc, #112]	; (5eb0 <usbd_ep_data_handler+0x7c>)
    5e3e:	4e1d      	ldr	r6, [pc, #116]	; (5eb4 <usbd_ep_data_handler+0x80>)
    5e40:	680b      	ldr	r3, [r1, #0]
    if (NRF_USBD_EPIN_CHECK(ep))
    5e42:	f010 0f80 	tst.w	r0, #128	; 0x80
    m_ep_ready |= (1U << bitpos);
    5e46:	ea43 0305 	orr.w	r3, r3, r5
{
    5e4a:	4604      	mov	r4, r0
    m_ep_ready |= (1U << bitpos);
    5e4c:	600b      	str	r3, [r1, #0]
    if (NRF_USBD_EPIN_CHECK(ep))
    5e4e:	d024      	beq.n	5e9a <usbd_ep_data_handler+0x66>
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
    5e50:	f000 020f 	and.w	r2, r0, #15
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
    5e54:	4b18      	ldr	r3, [pc, #96]	; (5eb8 <usbd_ep_data_handler+0x84>)
    5e56:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
    5e5a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    5e5e:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
    5e62:	681a      	ldr	r2, [r3, #0]
    if (ret)
    5e64:	b132      	cbz	r2, 5e74 <usbd_ep_data_handler+0x40>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
    5e66:	2200      	movs	r2, #0
    5e68:	601a      	str	r2, [r3, #0]
            if (ep != NRFX_USBD_EPIN0)
    5e6a:	2880      	cmp	r0, #128	; 0x80
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
    5e6c:	681b      	ldr	r3, [r3, #0]
    5e6e:	d011      	beq.n	5e94 <usbd_ep_data_handler+0x60>
                nrf_usbd_epin_dma_handler(ep);
    5e70:	f003 f933 	bl	90da <nrf_usbd_epin_dma_handler>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
    5e74:	6831      	ldr	r1, [r6, #0]
    5e76:	4029      	ands	r1, r5
    5e78:	d10a      	bne.n	5e90 <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    5e7a:	2306      	movs	r3, #6
    5e7c:	f88d 3004 	strb.w	r3, [sp, #4]
    5e80:	f88d 4006 	strb.w	r4, [sp, #6]
    5e84:	f88d 1007 	strb.w	r1, [sp, #7]
            m_event_handler(&evt);
    5e88:	4b0c      	ldr	r3, [pc, #48]	; (5ebc <usbd_ep_data_handler+0x88>)
    5e8a:	a801      	add	r0, sp, #4
    5e8c:	681b      	ldr	r3, [r3, #0]
    5e8e:	4798      	blx	r3
}
    5e90:	b002      	add	sp, #8
    5e92:	bd70      	pop	{r4, r5, r6, pc}
                nrf_usbd_ep0in_dma_handler();
    5e94:	f7ff ffb8 	bl	5e08 <nrf_usbd_ep0in_dma_handler>
    5e98:	e7ec      	b.n	5e74 <usbd_ep_data_handler+0x40>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
    5e9a:	6833      	ldr	r3, [r6, #0]
    5e9c:	421d      	tst	r5, r3
    5e9e:	d1f7      	bne.n	5e90 <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_WAITING);
    5ea0:	2306      	movs	r3, #6
    5ea2:	f88d 3004 	strb.w	r3, [sp, #4]
    5ea6:	f88d 0006 	strb.w	r0, [sp, #6]
    5eaa:	f88d 2007 	strb.w	r2, [sp, #7]
    5eae:	e7eb      	b.n	5e88 <usbd_ep_data_handler+0x54>
    5eb0:	200011c8 	.word	0x200011c8
    5eb4:	20001158 	.word	0x20001158
    5eb8:	00009c2c 	.word	0x00009c2c
    5ebc:	200012ec 	.word	0x200012ec

00005ec0 <ev_setup_data_handler>:
{
    5ec0:	b508      	push	{r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
    5ec2:	4b05      	ldr	r3, [pc, #20]	; (5ed8 <ev_setup_data_handler+0x18>)
    5ec4:	781a      	ldrb	r2, [r3, #0]
    5ec6:	4610      	mov	r0, r2
    5ec8:	f003 f8fd 	bl	90c6 <ep2bit>
}
    5ecc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
    5ed0:	4601      	mov	r1, r0
    5ed2:	4610      	mov	r0, r2
    5ed4:	f7ff bfae 	b.w	5e34 <usbd_ep_data_handler>
    5ed8:	200013a8 	.word	0x200013a8

00005edc <ev_dma_epout8_handler>:
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
    5edc:	b507      	push	{r0, r1, r2, lr}
    usbd_dma_pending_clear();
    5ede:	f7ff fe73 	bl	5bc8 <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    5ee2:	4b0c      	ldr	r3, [pc, #48]	; (5f14 <ev_dma_epout8_handler+0x38>)
    5ee4:	f893 208e 	ldrb.w	r2, [r3, #142]	; 0x8e
    5ee8:	2a03      	cmp	r2, #3
    5eea:	d010      	beq.n	5f0e <ev_dma_epout8_handler+0x32>
    else if (p_state->handler.consumer == NULL)
    5eec:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    5ef0:	b96b      	cbnz	r3, 5f0e <ev_dma_epout8_handler+0x32>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    5ef2:	f06f 7080 	mvn.w	r0, #16777216	; 0x1000000
    5ef6:	f7ff ff77 	bl	5de8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    5efa:	2306      	movs	r3, #6
    5efc:	f88d 3004 	strb.w	r3, [sp, #4]
    5f00:	2308      	movs	r3, #8
    5f02:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
    5f06:	4b04      	ldr	r3, [pc, #16]	; (5f18 <ev_dma_epout8_handler+0x3c>)
    5f08:	a801      	add	r0, sp, #4
    5f0a:	681b      	ldr	r3, [r3, #0]
    5f0c:	4798      	blx	r3
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
    5f0e:	b003      	add	sp, #12
    5f10:	f85d fb04 	ldr.w	pc, [sp], #4
    5f14:	200011cc 	.word	0x200011cc
    5f18:	200012ec 	.word	0x200012ec

00005f1c <ev_dma_epin8_handler>:
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
    5f1c:	b507      	push	{r0, r1, r2, lr}
    usbd_dma_pending_clear();
    5f1e:	f7ff fe53 	bl	5bc8 <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    5f22:	4b10      	ldr	r3, [pc, #64]	; (5f64 <ev_dma_epin8_handler+0x48>)
    5f24:	f893 211e 	ldrb.w	r2, [r3, #286]	; 0x11e
    5f28:	2a03      	cmp	r2, #3
    5f2a:	d106      	bne.n	5f3a <ev_dma_epin8_handler+0x1e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    5f2c:	f46f 7080 	mvn.w	r0, #256	; 0x100
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
    5f30:	b003      	add	sp, #12
    5f32:	f85d eb04 	ldr.w	lr, [sp], #4
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    5f36:	f7ff bf57 	b.w	5de8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
    5f3a:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
    5f3e:	b96b      	cbnz	r3, 5f5c <ev_dma_epin8_handler+0x40>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    5f40:	f46f 7080 	mvn.w	r0, #256	; 0x100
    5f44:	f7ff ff50 	bl	5de8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    5f48:	2306      	movs	r3, #6
    5f4a:	f88d 3004 	strb.w	r3, [sp, #4]
    5f4e:	2388      	movs	r3, #136	; 0x88
    5f50:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
    5f54:	4b04      	ldr	r3, [pc, #16]	; (5f68 <ev_dma_epin8_handler+0x4c>)
    5f56:	a801      	add	r0, sp, #4
    5f58:	681b      	ldr	r3, [r3, #0]
    5f5a:	4798      	blx	r3
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
    5f5c:	b003      	add	sp, #12
    5f5e:	f85d fb04 	ldr.w	pc, [sp], #4
    5f62:	bf00      	nop
    5f64:	200011cc 	.word	0x200011cc
    5f68:	200012ec 	.word	0x200012ec

00005f6c <nrfx_usbd_uninit>:

void nrfx_usbd_uninit(void)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_INITIALIZED);

    m_event_handler = NULL;
    5f6c:	4a02      	ldr	r2, [pc, #8]	; (5f78 <nrfx_usbd_uninit+0xc>)
    5f6e:	2300      	movs	r3, #0
    5f70:	6013      	str	r3, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_UNINITIALIZED;
    5f72:	4a02      	ldr	r2, [pc, #8]	; (5f7c <nrfx_usbd_uninit+0x10>)
    5f74:	7013      	strb	r3, [r2, #0]
    return;
}
    5f76:	4770      	bx	lr
    5f78:	200012ec 	.word	0x200012ec
    5f7c:	200013a7 	.word	0x200013a7

00005f80 <nrfx_usbd_enable>:


void nrfx_usbd_enable(void)
{
    5f80:	b508      	push	{r3, lr}
    p_reg->EVENTCAUSE = flags;
    5f82:	4b48      	ldr	r3, [pc, #288]	; (60a4 <nrfx_usbd_enable+0x124>)
    5f84:	f44f 6200 	mov.w	r2, #2048	; 0x800
    5f88:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
    5f8c:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_187();
    5f90:	f7ff fdf8 	bl	5b84 <nrf52_errata_187>
    if (nrfx_usbd_errata_187())
    5f94:	b108      	cbz	r0, 5f9a <nrfx_usbd_enable+0x1a>
        usbd_errata_187_211_begin();
    5f96:	f7ff fe8b 	bl	5cb0 <usbd_errata_187_211_begin>
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_171();
    5f9a:	f003 f84e 	bl	903a <nrf52_errata_166>
    if (nrfx_usbd_errata_171())
    5f9e:	b1c8      	cbz	r0, 5fd4 <nrfx_usbd_enable+0x54>
	__asm__ volatile(
    5fa0:	f04f 0320 	mov.w	r3, #32
    5fa4:	f3ef 8011 	mrs	r0, BASEPRI
    5fa8:	f383 8812 	msr	BASEPRI_MAX, r3
    5fac:	f3bf 8f6f 	isb	sy
    if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
    5fb0:	4b3d      	ldr	r3, [pc, #244]	; (60a8 <nrfx_usbd_enable+0x128>)
    5fb2:	f8d3 1c00 	ldr.w	r1, [r3, #3072]	; 0xc00
    5fb6:	22c0      	movs	r2, #192	; 0xc0
    5fb8:	2900      	cmp	r1, #0
    5fba:	d16a      	bne.n	6092 <nrfx_usbd_enable+0x112>
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5fbc:	f249 3175 	movw	r1, #37749	; 0x9375
    5fc0:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
        *((volatile uint32_t *)(0x4006EC14)) = 0x000000C0;
    5fc4:	f8c3 2c14 	str.w	r2, [r3, #3092]	; 0xc14
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5fc8:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
	__asm__ volatile(
    5fcc:	f380 8811 	msr	BASEPRI, r0
    5fd0:	f3bf 8f6f 	isb	sy
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Enabled << USBD_ENABLE_ENABLE_Pos;
    5fd4:	4b33      	ldr	r3, [pc, #204]	; (60a4 <nrfx_usbd_enable+0x124>)
    5fd6:	2201      	movs	r2, #1
    5fd8:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
    5fdc:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
    return p_reg->EVENTCAUSE;
    5fe0:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    while (0 == (eventcause & nrf_usbd_eventcause_get(NRF_USBD)))
    5fe4:	0512      	lsls	r2, r2, #20
    5fe6:	d5fb      	bpl.n	5fe0 <nrfx_usbd_enable+0x60>
    p_reg->EVENTCAUSE = flags;
    5fe8:	f44f 6200 	mov.w	r2, #2048	; 0x800
    5fec:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
    5ff0:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    5ff4:	f003 f821 	bl	903a <nrf52_errata_166>
    if (nrfx_usbd_errata_171())
    5ff8:	b1c0      	cbz	r0, 602c <nrfx_usbd_enable+0xac>
	__asm__ volatile(
    5ffa:	f04f 0320 	mov.w	r3, #32
    5ffe:	f3ef 8011 	mrs	r0, BASEPRI
    6002:	f383 8812 	msr	BASEPRI_MAX, r3
    6006:	f3bf 8f6f 	isb	sy
    if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
    600a:	4b27      	ldr	r3, [pc, #156]	; (60a8 <nrfx_usbd_enable+0x128>)
    600c:	f8d3 1c00 	ldr.w	r1, [r3, #3072]	; 0xc00
    6010:	2900      	cmp	r1, #0
    6012:	d141      	bne.n	6098 <nrfx_usbd_enable+0x118>
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    6014:	f249 3275 	movw	r2, #37749	; 0x9375
    6018:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
        *((volatile uint32_t *)(0x4006EC14)) = 0x00000000;
    601c:	f8c3 1c14 	str.w	r1, [r3, #3092]	; 0xc14
        *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    6020:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
	__asm__ volatile(
    6024:	f380 8811 	msr	BASEPRI, r0
    6028:	f3bf 8f6f 	isb	sy
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_187();
    602c:	f7ff fdaa 	bl	5b84 <nrf52_errata_187>
    if (nrfx_usbd_errata_187())
    6030:	b130      	cbz	r0, 6040 <nrfx_usbd_enable+0xc0>
        usbd_errata_187_211_end();
    6032:	f7ff fe5d 	bl	5cf0 <usbd_errata_187_211_end>
    6036:	f7ff fda5 	bl	5b84 <nrf52_errata_187>
    }

#if NRFX_USBD_USE_WORKAROUND_FOR_ANOMALY_211
    if (nrfx_usbd_errata_187() || nrfx_usbd_errata_211())
#else
    if (nrfx_usbd_errata_187())
    603a:	b108      	cbz	r0, 6040 <nrfx_usbd_enable+0xc0>
#endif
    {
        usbd_errata_187_211_begin();
    603c:	f7ff fe38 	bl	5cb0 <usbd_errata_187_211_begin>
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_166();
    6040:	f002 fffb 	bl	903a <nrf52_errata_166>
    6044:	4b17      	ldr	r3, [pc, #92]	; (60a4 <nrfx_usbd_enable+0x124>)
    }

    if (nrfx_usbd_errata_166())
    6046:	b150      	cbz	r0, 605e <nrfx_usbd_enable+0xde>
    {
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7E3;
    6048:	f240 72e3 	movw	r2, #2019	; 0x7e3
    604c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
        *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) = 0x40;
    6050:	2240      	movs	r2, #64	; 0x40
    6052:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
  __ASM volatile ("isb 0xF":::"memory");
    6056:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    605a:	f3bf 8f4f 	dsb	sy
    p_reg->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
    605e:	2100      	movs	r1, #0
    p_reg->ISOSPLIT = split << USBD_ISOSPLIT_SPLIT_Pos;
    6060:	2280      	movs	r2, #128	; 0x80
    6062:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
    p_reg->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
    6066:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
    else
    {
        nrfx_usbd_isoinconfig_set(NRF_USBD_ISOINCONFIG_NORESP);
    }

    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
    606a:	4b10      	ldr	r3, [pc, #64]	; (60ac <nrfx_usbd_enable+0x12c>)
    606c:	f240 12ff 	movw	r2, #511	; 0x1ff
    6070:	601a      	str	r2, [r3, #0]
    m_ep_dma_waiting = 0;
    6072:	4b0f      	ldr	r3, [pc, #60]	; (60b0 <nrfx_usbd_enable+0x130>)
    6074:	6019      	str	r1, [r3, #0]
    usbd_dma_pending_clear();
    6076:	f7ff fda7 	bl	5bc8 <usbd_dma_pending_clear>
    m_last_setup_dir = NRFX_USBD_EPOUT0;
    607a:	4b0e      	ldr	r3, [pc, #56]	; (60b4 <nrfx_usbd_enable+0x134>)
    607c:	7019      	strb	r1, [r3, #0]

    m_drv_state = NRFX_DRV_STATE_POWERED_ON;
    607e:	4b0e      	ldr	r3, [pc, #56]	; (60b8 <nrfx_usbd_enable+0x138>)
    6080:	2202      	movs	r2, #2
    6082:	701a      	strb	r2, [r3, #0]
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_187();
    6084:	f7ff fd7e 	bl	5b84 <nrf52_errata_187>

#if NRFX_USBD_USE_WORKAROUND_FOR_ANOMALY_211
    if (nrfx_usbd_errata_187() && !nrfx_usbd_errata_211())
#else
    if (nrfx_usbd_errata_187())
    6088:	b150      	cbz	r0, 60a0 <nrfx_usbd_enable+0x120>
#endif
    {
        usbd_errata_187_211_end();
    }
}
    608a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        usbd_errata_187_211_end();
    608e:	f7ff be2f 	b.w	5cf0 <usbd_errata_187_211_end>
        *((volatile uint32_t *)(0x4006EC14)) = 0x000000C0;
    6092:	f8c3 2c14 	str.w	r2, [r3, #3092]	; 0xc14
    6096:	e799      	b.n	5fcc <nrfx_usbd_enable+0x4c>
        *((volatile uint32_t *)(0x4006EC14)) = 0x00000000;
    6098:	2200      	movs	r2, #0
    609a:	f8c3 2c14 	str.w	r2, [r3, #3092]	; 0xc14
    609e:	e7c1      	b.n	6024 <nrfx_usbd_enable+0xa4>
}
    60a0:	bd08      	pop	{r3, pc}
    60a2:	bf00      	nop
    60a4:	40027000 	.word	0x40027000
    60a8:	4006e000 	.word	0x4006e000
    60ac:	200011c8 	.word	0x200011c8
    60b0:	20001158 	.word	0x20001158
    60b4:	200013a8 	.word	0x200013a8
    60b8:	200013a7 	.word	0x200013a7

000060bc <nrfx_usbd_start>:
}

void nrfx_usbd_start(bool enable_sof)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_POWERED_ON);
    m_bus_suspend = false;
    60bc:	4b0a      	ldr	r3, [pc, #40]	; (60e8 <nrfx_usbd_start+0x2c>)
    60be:	2200      	movs	r2, #0
{
    60c0:	b510      	push	{r4, lr}
    m_bus_suspend = false;
    60c2:	701a      	strb	r2, [r3, #0]
       NRF_USBD_INT_EP0SETUP_MASK     |
       NRF_USBD_INT_DATAEP_MASK;

   if (enable_sof)
   {
       ints_to_enable |= NRF_USBD_INT_SOF_MASK;
    60c4:	4a09      	ldr	r2, [pc, #36]	; (60ec <nrfx_usbd_start+0x30>)
    60c6:	4b0a      	ldr	r3, [pc, #40]	; (60f0 <nrfx_usbd_start+0x34>)
    p_reg->INTENSET = mask;
    60c8:	4c0a      	ldr	r4, [pc, #40]	; (60f4 <nrfx_usbd_start+0x38>)
    60ca:	2800      	cmp	r0, #0
    60cc:	bf18      	it	ne
    60ce:	4613      	movne	r3, r2
    60d0:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   /* Enable all required interrupts */
   nrf_usbd_int_enable(NRF_USBD, ints_to_enable);

   /* Enable interrupt globally */
   NRFX_IRQ_PRIORITY_SET(USBD_IRQn, NRFX_USBD_DEFAULT_CONFIG_IRQ_PRIORITY);
   NRFX_IRQ_ENABLE(USBD_IRQn);
    60d4:	2027      	movs	r0, #39	; 0x27
    60d6:	f7fd f865 	bl	31a4 <arch_irq_enable>
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Enabled << USBD_USBPULLUP_CONNECT_Pos;
    60da:	2301      	movs	r3, #1
    60dc:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    (void) p_reg->USBPULLUP;
    60e0:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504

   /* Enable pullups */
   nrf_usbd_pullup_enable(NRF_USBD);
}
    60e4:	bd10      	pop	{r4, pc}
    60e6:	bf00      	nop
    60e8:	200013a5 	.word	0x200013a5
    60ec:	01e01407 	.word	0x01e01407
    60f0:	01c01407 	.word	0x01c01407
    60f4:	40027000 	.word	0x40027000

000060f8 <nrfx_usbd_is_enabled>:
    return (m_drv_state >= NRFX_DRV_STATE_INITIALIZED);
}

bool nrfx_usbd_is_enabled(void)
{
    return (m_drv_state >= NRFX_DRV_STATE_POWERED_ON);
    60f8:	4b03      	ldr	r3, [pc, #12]	; (6108 <nrfx_usbd_is_enabled+0x10>)
    60fa:	7818      	ldrb	r0, [r3, #0]
}
    60fc:	2801      	cmp	r0, #1
    60fe:	bf94      	ite	ls
    6100:	2000      	movls	r0, #0
    6102:	2001      	movhi	r0, #1
    6104:	4770      	bx	lr
    6106:	bf00      	nop
    6108:	200013a7 	.word	0x200013a7

0000610c <nrfx_usbd_init>:
{
    610c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (m_drv_state != NRFX_DRV_STATE_UNINITIALIZED)
    6110:	4b1d      	ldr	r3, [pc, #116]	; (6188 <nrfx_usbd_init+0x7c>)
    6112:	781c      	ldrb	r4, [r3, #0]
    6114:	2c00      	cmp	r4, #0
    6116:	d135      	bne.n	6184 <nrfx_usbd_init+0x78>
    m_event_handler = event_handler;
    6118:	4a1c      	ldr	r2, [pc, #112]	; (618c <nrfx_usbd_init+0x80>)
    611a:	6010      	str	r0, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
    611c:	2201      	movs	r2, #1
    611e:	701a      	strb	r2, [r3, #0]
    6120:	4625      	mov	r5, r4
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    6122:	f240 18ff 	movw	r8, #511	; 0x1ff
        p_state->status = NRFX_USBD_EP_OK;
    6126:	4627      	mov	r7, r4
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
    6128:	f065 067f 	orn	r6, r5, #127	; 0x7f
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    612c:	f015 0f08 	tst.w	r5, #8
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
    6130:	b2f6      	uxtb	r6, r6
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    6132:	bf14      	ite	ne
    6134:	4641      	movne	r1, r8
    6136:	2140      	moveq	r1, #64	; 0x40
    6138:	4630      	mov	r0, r6
    613a:	f002 fffe 	bl	913a <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
    613e:	4630      	mov	r0, r6
    6140:	f7ff fd34 	bl	5bac <ep_state_access>
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
    6144:	3501      	adds	r5, #1
    6146:	2d09      	cmp	r5, #9
        p_state->status = NRFX_USBD_EP_OK;
    6148:	7387      	strb	r7, [r0, #14]
        p_state->handler.feeder = NULL;
    614a:	6007      	str	r7, [r0, #0]
        p_state->transfer_cnt = 0;
    614c:	6087      	str	r7, [r0, #8]
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
    614e:	d1eb      	bne.n	6128 <nrfx_usbd_init+0x1c>
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    6150:	2140      	movs	r1, #64	; 0x40
        p_state->status = NRFX_USBD_EP_OK;
    6152:	2500      	movs	r5, #0
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    6154:	f240 16ff 	movw	r6, #511	; 0x1ff
    6158:	4620      	mov	r0, r4
    615a:	f002 ffee 	bl	913a <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
    615e:	4620      	mov	r0, r4
    6160:	f7ff fd24 	bl	5bac <ep_state_access>
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
    6164:	3401      	adds	r4, #1
    6166:	b2e4      	uxtb	r4, r4
    6168:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
    616a:	7385      	strb	r5, [r0, #14]
        p_state->handler.consumer = NULL;
    616c:	6005      	str	r5, [r0, #0]
        p_state->transfer_cnt = 0;
    616e:	6085      	str	r5, [r0, #8]
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
    6170:	d102      	bne.n	6178 <nrfx_usbd_init+0x6c>
    return NRFX_SUCCESS;
    6172:	4807      	ldr	r0, [pc, #28]	; (6190 <nrfx_usbd_init+0x84>)
}
    6174:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    6178:	f014 0f08 	tst.w	r4, #8
    617c:	bf14      	ite	ne
    617e:	4631      	movne	r1, r6
    6180:	2140      	moveq	r1, #64	; 0x40
    6182:	e7e9      	b.n	6158 <nrfx_usbd_init+0x4c>
        return NRFX_ERROR_INVALID_STATE;
    6184:	4803      	ldr	r0, [pc, #12]	; (6194 <nrfx_usbd_init+0x88>)
    6186:	e7f5      	b.n	6174 <nrfx_usbd_init+0x68>
    6188:	200013a7 	.word	0x200013a7
    618c:	200012ec 	.word	0x200012ec
    6190:	0bad0000 	.word	0x0bad0000
    6194:	0bad0005 	.word	0x0bad0005

00006198 <nrfx_usbd_ep_transfer>:
}

nrfx_err_t nrfx_usbd_ep_transfer(
    nrfx_usbd_ep_t               ep,
    nrfx_usbd_transfer_t const * p_transfer)
{
    6198:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    619c:	4605      	mov	r5, r0
	__asm__ volatile(
    619e:	f04f 0320 	mov.w	r3, #32
    61a2:	f3ef 8811 	mrs	r8, BASEPRI
    61a6:	f383 8812 	msr	BASEPRI_MAX, r3
    61aa:	f3bf 8f6f 	isb	sy
    const uint8_t ep_bitpos = ep2bit(ep);
    NRFX_ASSERT(NULL != p_transfer);

    NRFX_CRITICAL_SECTION_ENTER();
    /* Setup data transaction can go only in one direction at a time */
    if ((NRF_USBD_EP_NR_GET(ep) == 0) && (ep != m_last_setup_dir))
    61ae:	f010 040f 	ands.w	r4, r0, #15
    61b2:	d103      	bne.n	61bc <nrfx_usbd_ep_transfer+0x24>
    61b4:	4b27      	ldr	r3, [pc, #156]	; (6254 <nrfx_usbd_ep_transfer+0xbc>)
    61b6:	781b      	ldrb	r3, [r3, #0]
    61b8:	4283      	cmp	r3, r0
    61ba:	d146      	bne.n	624a <nrfx_usbd_ep_transfer+0xb2>
            (NRFX_USBD_ISO_DEBUG || (!NRF_USBD_EPISO_CHECK(ep))))
        {
            NRFX_LOG_DEBUG("Transfer failed: Invalid EPr\n");
        }
    }
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
    61bc:	4b26      	ldr	r3, [pc, #152]	; (6258 <nrfx_usbd_ep_transfer+0xc0>)
    61be:	4f27      	ldr	r7, [pc, #156]	; (625c <nrfx_usbd_ep_transfer+0xc4>)
    61c0:	681a      	ldr	r2, [r3, #0]
    61c2:	683e      	ldr	r6, [r7, #0]
    const uint8_t ep_bitpos = ep2bit(ep);
    61c4:	4628      	mov	r0, r5
    61c6:	f002 ff7e 	bl	90c6 <ep2bit>
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
    61ca:	43d2      	mvns	r2, r2
    61cc:	b292      	uxth	r2, r2
    61ce:	f04f 0901 	mov.w	r9, #1
    61d2:	4332      	orrs	r2, r6
    61d4:	fa09 f900 	lsl.w	r9, r9, r0
    61d8:	ea12 0f09 	tst.w	r2, r9
    61dc:	d137      	bne.n	624e <nrfx_usbd_ep_transfer+0xb6>
            NRFX_LOG_DEBUG("Transfer failed: EP is busy");
        }
    }
    else
    {
        usbd_ep_state_t * p_state =  ep_state_access(ep);
    61de:	4628      	mov	r0, r5
    61e0:	f7ff fce4 	bl	5bac <ep_state_access>
        /* Prepare transfer context and handler description */
        nrfx_usbd_transfer_t * p_context;
        if (NRF_USBD_EPIN_CHECK(ep))
        {
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
    61e4:	220c      	movs	r2, #12
    61e6:	4354      	muls	r4, r2
        if (NRF_USBD_EPIN_CHECK(ep))
    61e8:	062a      	lsls	r2, r5, #24
        usbd_ep_state_t * p_state =  ep_state_access(ep);
    61ea:	4603      	mov	r3, r0
        if (NRF_USBD_EPIN_CHECK(ep))
    61ec:	d529      	bpl.n	6242 <nrfx_usbd_ep_transfer+0xaa>
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
    61ee:	4a1c      	ldr	r2, [pc, #112]	; (6260 <nrfx_usbd_ep_transfer+0xc8>)

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
    61f0:	6808      	ldr	r0, [r1, #0]
    61f2:	4414      	add	r4, r2
    61f4:	f000 4060 	and.w	r0, r0, #3758096384	; 0xe0000000
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
            {
                /* RAM */
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
    61f8:	688a      	ldr	r2, [r1, #8]
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
    61fa:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
    61fe:	f002 0201 	and.w	r2, r2, #1
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
    6202:	d119      	bne.n	6238 <nrfx_usbd_ep_transfer+0xa0>
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
    6204:	b9b2      	cbnz	r2, 6234 <nrfx_usbd_ep_transfer+0x9c>
                {
                    p_state->handler.feeder = nrfx_usbd_feeder_ram;
    6206:	4a17      	ldr	r2, [pc, #92]	; (6264 <nrfx_usbd_ep_transfer+0xcc>)
        }
        else
        {
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT((p_transfer->p_data.rx == NULL) || (nrfx_is_in_ram(p_transfer->p_data.rx)));
            p_state->handler.consumer = nrfx_usbd_consumer;
    6208:	601a      	str	r2, [r3, #0]
        }
        *p_context = *p_transfer;
    620a:	c907      	ldmia	r1, {r0, r1, r2}
    620c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        p_state->p_context = p_context;

        p_state->transfer_cnt = 0;
    6210:	2200      	movs	r2, #0
    6212:	609a      	str	r2, [r3, #8]
        p_state->status    =  NRFX_USBD_EP_OK;
    6214:	739a      	strb	r2, [r3, #14]
        p_state->p_context = p_context;
    6216:	605c      	str	r4, [r3, #4]
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    6218:	4b13      	ldr	r3, [pc, #76]	; (6268 <nrfx_usbd_ep_transfer+0xd0>)
        m_ep_dma_waiting   |= 1U << ep_bitpos;
        ret = NRFX_SUCCESS;
    621a:	4814      	ldr	r0, [pc, #80]	; (626c <nrfx_usbd_ep_transfer+0xd4>)
        m_ep_dma_waiting   |= 1U << ep_bitpos;
    621c:	ea46 0609 	orr.w	r6, r6, r9
    6220:	2280      	movs	r2, #128	; 0x80
    6222:	603e      	str	r6, [r7, #0]
    6224:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	__asm__ volatile(
    6228:	f388 8811 	msr	BASEPRI, r8
    622c:	f3bf 8f6f 	isb	sy
        usbd_int_rise();
    }
    NRFX_CRITICAL_SECTION_EXIT();
    return ret;
}
    6230:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                    p_state->handler.feeder = nrfx_usbd_feeder_ram_zlp;
    6234:	4a0e      	ldr	r2, [pc, #56]	; (6270 <nrfx_usbd_ep_transfer+0xd8>)
    6236:	e7e7      	b.n	6208 <nrfx_usbd_ep_transfer+0x70>
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
    6238:	b90a      	cbnz	r2, 623e <nrfx_usbd_ep_transfer+0xa6>
                    p_state->handler.feeder = nrfx_usbd_feeder_flash;
    623a:	4a0e      	ldr	r2, [pc, #56]	; (6274 <nrfx_usbd_ep_transfer+0xdc>)
    623c:	e7e4      	b.n	6208 <nrfx_usbd_ep_transfer+0x70>
                    p_state->handler.feeder = nrfx_usbd_feeder_flash_zlp;
    623e:	4a0e      	ldr	r2, [pc, #56]	; (6278 <nrfx_usbd_ep_transfer+0xe0>)
    6240:	e7e2      	b.n	6208 <nrfx_usbd_ep_transfer+0x70>
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
    6242:	4a0e      	ldr	r2, [pc, #56]	; (627c <nrfx_usbd_ep_transfer+0xe4>)
    6244:	4414      	add	r4, r2
            p_state->handler.consumer = nrfx_usbd_consumer;
    6246:	4a0e      	ldr	r2, [pc, #56]	; (6280 <nrfx_usbd_ep_transfer+0xe8>)
    6248:	e7de      	b.n	6208 <nrfx_usbd_ep_transfer+0x70>
        ret = NRFX_ERROR_INVALID_ADDR;
    624a:	480e      	ldr	r0, [pc, #56]	; (6284 <nrfx_usbd_ep_transfer+0xec>)
    624c:	e7ec      	b.n	6228 <nrfx_usbd_ep_transfer+0x90>
        ret = NRFX_ERROR_BUSY;
    624e:	480e      	ldr	r0, [pc, #56]	; (6288 <nrfx_usbd_ep_transfer+0xf0>)
    6250:	e7ea      	b.n	6228 <nrfx_usbd_ep_transfer+0x90>
    6252:	bf00      	nop
    6254:	200013a8 	.word	0x200013a8
    6258:	200011c8 	.word	0x200011c8
    625c:	20001158 	.word	0x20001158
    6260:	2000115c 	.word	0x2000115c
    6264:	0000907b 	.word	0x0000907b
    6268:	e000e100 	.word	0xe000e100
    626c:	0bad0000 	.word	0x0bad0000
    6270:	0000909d 	.word	0x0000909d
    6274:	00005d31 	.word	0x00005d31
    6278:	00005d69 	.word	0x00005d69
    627c:	200010ec 	.word	0x200010ec
    6280:	0000904d 	.word	0x0000904d
    6284:	0bad000a 	.word	0x0bad000a
    6288:	0bad000b 	.word	0x0bad000b

0000628c <nrfx_usbd_epout_size_get>:
    if (NRF_USBD_EPISO_CHECK(ep))
    628c:	f010 0f08 	tst.w	r0, #8
    6290:	4b07      	ldr	r3, [pc, #28]	; (62b0 <nrfx_usbd_epout_size_get+0x24>)
    6292:	d006      	beq.n	62a2 <nrfx_usbd_epout_size_get+0x16>
        size_t size_isoout = p_reg->SIZE.ISOOUT;
    6294:	f8d3 04c0 	ldr.w	r0, [r3, #1216]	; 0x4c0
            size_isoout = 0;
    6298:	f410 3f80 	tst.w	r0, #65536	; 0x10000
    629c:	bf18      	it	ne
    629e:	2000      	movne	r0, #0
    62a0:	4770      	bx	lr
    return p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
    62a2:	f000 000f 	and.w	r0, r0, #15
    62a6:	f500 7094 	add.w	r0, r0, #296	; 0x128
    62aa:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}

size_t nrfx_usbd_epout_size_get(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_epout_size_get(NRF_USBD, ep_to_hal(ep));
}
    62ae:	4770      	bx	lr
    62b0:	40027000 	.word	0x40027000

000062b4 <usbd_dmareq_process>:
{
    62b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (!m_dma_pending)
    62b8:	f8df 815c 	ldr.w	r8, [pc, #348]	; 6418 <usbd_dmareq_process+0x164>
    62bc:	f898 3000 	ldrb.w	r3, [r8]
{
    62c0:	b085      	sub	sp, #20
    if (!m_dma_pending)
    62c2:	2b00      	cmp	r3, #0
    62c4:	d16b      	bne.n	639e <usbd_dmareq_process+0xea>
        while (0 != (req = m_ep_dma_waiting & m_ep_ready))
    62c6:	f8df 9154 	ldr.w	r9, [pc, #340]	; 641c <usbd_dmareq_process+0x168>
    62ca:	4e55      	ldr	r6, [pc, #340]	; (6420 <usbd_dmareq_process+0x16c>)
    62cc:	f8d9 1000 	ldr.w	r1, [r9]
    62d0:	6833      	ldr	r3, [r6, #0]
    62d2:	4019      	ands	r1, r3
    62d4:	d063      	beq.n	639e <usbd_dmareq_process+0xea>
            if (NRFX_USBD_CONFIG_DMASCHEDULER_ISO_BOOST && ((req & USBD_EPISO_BIT_MASK) != 0))
    62d6:	f011 2301 	ands.w	r3, r1, #16777472	; 0x1000100
    return NRF_CTZ(req);
    62da:	bf14      	ite	ne
    62dc:	fa93 f1a3 	rbitne	r1, r3
    62e0:	fa91 f1a1 	rbiteq	r1, r1
    62e4:	fab1 f181 	clz	r1, r1
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    62e8:	290f      	cmp	r1, #15
        NRF_USBD_EPOUT(bitpos - NRFX_USBD_EPOUT_BITPOS_0) : NRF_USBD_EPIN(bitpos));
    62ea:	bf8a      	itet	hi
    62ec:	f1a1 0410 	subhi.w	r4, r1, #16
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    62f0:	f041 0480 	orrls.w	r4, r1, #128	; 0x80
    62f4:	b2e4      	uxtbhi	r4, r4
            usbd_ep_state_t * p_state = ep_state_access(ep);
    62f6:	4620      	mov	r0, r4
    62f8:	f7ff fc58 	bl	5bac <ep_state_access>
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
    62fc:	f04f 0b01 	mov.w	fp, #1
            if (NRF_USBD_EPIN_CHECK(ep))
    6300:	fa4f fa84 	sxtb.w	sl, r4
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
    6304:	fa0b f101 	lsl.w	r1, fp, r1
            if (NRF_USBD_EPIN_CHECK(ep))
    6308:	f1ba 0f00 	cmp.w	sl, #0
            usbd_ep_state_t * p_state = ep_state_access(ep);
    630c:	4605      	mov	r5, r0
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
    630e:	ea6f 0b01 	mvn.w	fp, r1
            if (NRF_USBD_EPIN_CHECK(ep))
    6312:	da47      	bge.n	63a4 <usbd_dmareq_process+0xf0>
                continue_transfer = p_state->handler.feeder(
    6314:	6803      	ldr	r3, [r0, #0]
    6316:	8982      	ldrh	r2, [r0, #12]
    6318:	6841      	ldr	r1, [r0, #4]
    631a:	a802      	add	r0, sp, #8
    631c:	4798      	blx	r3
                if (!continue_transfer)
    631e:	b900      	cbnz	r0, 6322 <usbd_dmareq_process+0x6e>
                    p_state->handler.consumer = NULL;
    6320:	6028      	str	r0, [r5, #0]
    return NRFX_USBD_ERRATA_ENABLE && nrf52_errata_199();
    6322:	f002 fe8a 	bl	903a <nrf52_errata_166>
    if (nrfx_usbd_errata_199())
    6326:	b118      	cbz	r0, 6330 <usbd_dmareq_process+0x7c>
        *((volatile uint32_t *)0x40027C1C) = 0x00000082;
    6328:	4b3e      	ldr	r3, [pc, #248]	; (6424 <usbd_dmareq_process+0x170>)
    632a:	2282      	movs	r2, #130	; 0x82
    632c:	f8c3 2c1c 	str.w	r2, [r3, #3100]	; 0xc1c
    m_dma_pending = true;
    6330:	2301      	movs	r3, #1
            m_ep_ready &= ~(1U << pos);
    6332:	6831      	ldr	r1, [r6, #0]
            p_state->transfer_cnt += transfer.size;
    6334:	9a03      	ldr	r2, [sp, #12]
    m_dma_pending = true;
    6336:	f888 3000 	strb.w	r3, [r8]
            p_state->transfer_cnt += transfer.size;
    633a:	68ab      	ldr	r3, [r5, #8]
            m_ep_ready &= ~(1U << pos);
    633c:	ea01 010b 	and.w	r1, r1, fp
            p_state->transfer_cnt += transfer.size;
    6340:	4413      	add	r3, r2
    if (NRF_USBD_EPIN_CHECK(ep))
    6342:	f1ba 0f00 	cmp.w	sl, #0
            m_ep_ready &= ~(1U << pos);
    6346:	6031      	str	r1, [r6, #0]
            p_state->transfer_cnt += transfer.size;
    6348:	60ab      	str	r3, [r5, #8]
            nrf_usbd_ep_easydma_set(NRF_USBD, ep, transfer.p_data.addr, (uint32_t)transfer.size);
    634a:	f004 0008 	and.w	r0, r4, #8
    634e:	9902      	ldr	r1, [sp, #8]
    6350:	4b34      	ldr	r3, [pc, #208]	; (6424 <usbd_dmareq_process+0x170>)
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
    6352:	f004 040f 	and.w	r4, r4, #15
    if (NRF_USBD_EPIN_CHECK(ep))
    6356:	da4f      	bge.n	63f8 <usbd_dmareq_process+0x144>
        if (NRF_USBD_EPISO_CHECK(ep))
    6358:	2800      	cmp	r0, #0
    635a:	d045      	beq.n	63e8 <usbd_dmareq_process+0x134>
            p_reg->ISOIN.PTR    = ptr;
    635c:	f8c3 16a0 	str.w	r1, [r3, #1696]	; 0x6a0
            p_reg->ISOIN.MAXCNT = maxcnt;
    6360:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
    return (nrf_usbd_task_t)(
    6364:	2304      	movs	r3, #4
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
    6366:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    return (volatile uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
    636a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    636e:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
    6372:	2201      	movs	r2, #1
    6374:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
    6376:	681b      	ldr	r3, [r3, #0]
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
    6378:	4a2b      	ldr	r2, [pc, #172]	; (6428 <usbd_dmareq_process+0x174>)
    637a:	4b2c      	ldr	r3, [pc, #176]	; (642c <usbd_dmareq_process+0x178>)
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
    637c:	4929      	ldr	r1, [pc, #164]	; (6424 <usbd_dmareq_process+0x170>)
    637e:	ea13 032a 	ands.w	r3, r3, sl, asr #32
    6382:	bf38      	it	cc
    6384:	4613      	movcc	r3, r2
    6386:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
    638a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    638e:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
    6392:	681a      	ldr	r2, [r3, #0]
            while (!nrf_usbd_event_check(NRF_USBD, nrfx_usbd_ep_to_endevent(ep)) &&
    6394:	b91a      	cbnz	r2, 639e <usbd_dmareq_process+0xea>
    6396:	f8d1 2100 	ldr.w	r2, [r1, #256]	; 0x100
    639a:	2a00      	cmp	r2, #0
    639c:	d0f9      	beq.n	6392 <usbd_dmareq_process+0xde>
}
    639e:	b005      	add	sp, #20
    63a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
    63a4:	4620      	mov	r0, r4
    63a6:	f7ff ff71 	bl	628c <nrfx_usbd_epout_size_get>
                continue_transfer = p_state->handler.consumer(
    63aa:	89aa      	ldrh	r2, [r5, #12]
    63ac:	6869      	ldr	r1, [r5, #4]
    63ae:	f8d5 c000 	ldr.w	ip, [r5]
    63b2:	4603      	mov	r3, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
    63b4:	4607      	mov	r7, r0
                continue_transfer = p_state->handler.consumer(
    63b6:	a802      	add	r0, sp, #8
    63b8:	47e0      	blx	ip
                if (transfer.p_data.rx == NULL)
    63ba:	9a02      	ldr	r2, [sp, #8]
    63bc:	2a00      	cmp	r2, #0
    63be:	d0ae      	beq.n	631e <usbd_dmareq_process+0x6a>
                else if (transfer.size < rx_size)
    63c0:	9a03      	ldr	r2, [sp, #12]
    63c2:	4297      	cmp	r7, r2
    63c4:	d9ab      	bls.n	631e <usbd_dmareq_process+0x6a>
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
    63c6:	2702      	movs	r7, #2
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
    63c8:	4658      	mov	r0, fp
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
    63ca:	73af      	strb	r7, [r5, #14]
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
    63cc:	f7ff fd0c 	bl	5de8 <atomic_and.constprop.0.isra.0>
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
    63d0:	2306      	movs	r3, #6
    63d2:	f88d 3004 	strb.w	r3, [sp, #4]
                    m_event_handler(&evt);
    63d6:	4b16      	ldr	r3, [pc, #88]	; (6430 <usbd_dmareq_process+0x17c>)
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
    63d8:	f88d 4006 	strb.w	r4, [sp, #6]
                    m_event_handler(&evt);
    63dc:	681b      	ldr	r3, [r3, #0]
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
    63de:	f88d 7007 	strb.w	r7, [sp, #7]
                    m_event_handler(&evt);
    63e2:	a801      	add	r0, sp, #4
    63e4:	4798      	blx	r3
                    continue;
    63e6:	e771      	b.n	62cc <usbd_dmareq_process+0x18>
            p_reg->EPIN[epnr].PTR    = ptr;
    63e8:	2014      	movs	r0, #20
    63ea:	fb00 3304 	mla	r3, r0, r4, r3
    63ee:	f8c3 1600 	str.w	r1, [r3, #1536]	; 0x600
            p_reg->EPIN[epnr].MAXCNT = maxcnt;
    63f2:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
    63f6:	e7b5      	b.n	6364 <usbd_dmareq_process+0xb0>
        if (NRF_USBD_EPISO_CHECK(ep))
    63f8:	b128      	cbz	r0, 6406 <usbd_dmareq_process+0x152>
            p_reg->ISOOUT.PTR    = ptr;
    63fa:	f8c3 17a0 	str.w	r1, [r3, #1952]	; 0x7a0
            p_reg->ISOOUT.MAXCNT = maxcnt;
    63fe:	f8c3 27a4 	str.w	r2, [r3, #1956]	; 0x7a4
    return (nrf_usbd_task_t)(
    6402:	2328      	movs	r3, #40	; 0x28
    6404:	e7af      	b.n	6366 <usbd_dmareq_process+0xb2>
            p_reg->EPOUT[epnr].PTR    = ptr;
    6406:	2014      	movs	r0, #20
    6408:	fb00 3304 	mla	r3, r0, r4, r3
    640c:	f8c3 1700 	str.w	r1, [r3, #1792]	; 0x700
            p_reg->EPOUT[epnr].MAXCNT = maxcnt;
    6410:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
    6414:	e7f5      	b.n	6402 <usbd_dmareq_process+0x14e>
    6416:	bf00      	nop
    6418:	200013a6 	.word	0x200013a6
    641c:	20001158 	.word	0x20001158
    6420:	200011c8 	.word	0x200011c8
    6424:	40027000 	.word	0x40027000
    6428:	00009c3e 	.word	0x00009c3e
    642c:	00009c2c 	.word	0x00009c2c
    6430:	200012ec 	.word	0x200012ec

00006434 <ev_epdata_handler>:
{
    6434:	b538      	push	{r3, r4, r5, lr}
    return p_reg->EPDATASTATUS;
    6436:	4b0f      	ldr	r3, [pc, #60]	; (6474 <ev_epdata_handler+0x40>)
    6438:	f8d3 446c 	ldr.w	r4, [r3, #1132]	; 0x46c
    p_reg->EPDATASTATUS = flags;
    643c:	f8c3 446c 	str.w	r4, [r3, #1132]	; 0x46c
        dataepstatus &= ~(1UL << bitpos);
    6440:	2501      	movs	r5, #1
    while (dataepstatus)
    6442:	b91c      	cbnz	r4, 644c <ev_epdata_handler+0x18>
}
    6444:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        usbd_dmareq_process();
    6448:	f7ff bf34 	b.w	62b4 <usbd_dmareq_process>
        uint8_t bitpos    = NRF_CTZ(dataepstatus);
    644c:	fa94 f3a4 	rbit	r3, r4
    6450:	fab3 f383 	clz	r3, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    6454:	2b0f      	cmp	r3, #15
        NRF_USBD_EPOUT(bitpos - NRFX_USBD_EPOUT_BITPOS_0) : NRF_USBD_EPIN(bitpos));
    6456:	bfc8      	it	gt
    6458:	f1a3 0010 	subgt.w	r0, r3, #16
        uint8_t bitpos    = NRF_CTZ(dataepstatus);
    645c:	4619      	mov	r1, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    645e:	bfd4      	ite	le
    6460:	f043 0080 	orrle.w	r0, r3, #128	; 0x80
    6464:	b2c0      	uxtbgt	r0, r0
        dataepstatus &= ~(1UL << bitpos);
    6466:	fa05 f303 	lsl.w	r3, r5, r3
    646a:	ea24 0403 	bic.w	r4, r4, r3
        (void)(usbd_ep_data_handler(ep, bitpos));
    646e:	f7ff fce1 	bl	5e34 <usbd_ep_data_handler>
    6472:	e7e6      	b.n	6442 <ev_epdata_handler+0xe>
    6474:	40027000 	.word	0x40027000

00006478 <nrf_usbd_epout_dma_handler>:
{
    6478:	b537      	push	{r0, r1, r2, r4, r5, lr}
    647a:	4604      	mov	r4, r0
    usbd_dma_pending_clear();
    647c:	f7ff fba4 	bl	5bc8 <usbd_dma_pending_clear>
    usbd_ep_state_t * p_state = ep_state_access(ep);
    6480:	4620      	mov	r0, r4
    6482:	f7ff fb93 	bl	5bac <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    6486:	7b83      	ldrb	r3, [r0, #14]
    6488:	2b03      	cmp	r3, #3
    648a:	d10d      	bne.n	64a8 <nrf_usbd_epout_dma_handler+0x30>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    648c:	4620      	mov	r0, r4
    648e:	f002 fe1a 	bl	90c6 <ep2bit>
    6492:	2301      	movs	r3, #1
    6494:	fa03 f000 	lsl.w	r0, r3, r0
    6498:	43c0      	mvns	r0, r0
    649a:	f7ff fca5 	bl	5de8 <atomic_and.constprop.0.isra.0>
}
    649e:	b003      	add	sp, #12
    64a0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    usbd_dmareq_process();
    64a4:	f7ff bf06 	b.w	62b4 <usbd_dmareq_process>
    else if (p_state->handler.consumer == NULL)
    64a8:	6805      	ldr	r5, [r0, #0]
    64aa:	2d00      	cmp	r5, #0
    64ac:	d1f7      	bne.n	649e <nrf_usbd_epout_dma_handler+0x26>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    64ae:	4620      	mov	r0, r4
    64b0:	f002 fe09 	bl	90c6 <ep2bit>
    64b4:	2301      	movs	r3, #1
    64b6:	fa03 f000 	lsl.w	r0, r3, r0
    64ba:	43c0      	mvns	r0, r0
    64bc:	f7ff fc94 	bl	5de8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    64c0:	2306      	movs	r3, #6
    64c2:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
    64c6:	4b04      	ldr	r3, [pc, #16]	; (64d8 <nrf_usbd_epout_dma_handler+0x60>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    64c8:	f88d 4006 	strb.w	r4, [sp, #6]
        m_event_handler(&evt);
    64cc:	681b      	ldr	r3, [r3, #0]
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    64ce:	f88d 5007 	strb.w	r5, [sp, #7]
        m_event_handler(&evt);
    64d2:	a801      	add	r0, sp, #4
    64d4:	4798      	blx	r3
    64d6:	e7e2      	b.n	649e <nrf_usbd_epout_dma_handler+0x26>
    64d8:	200012ec 	.word	0x200012ec

000064dc <nrfx_usbd_ep_stall>:
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_Stall << USBD_EPSTALL_STALL_Pos) | ep;
    64dc:	4b02      	ldr	r3, [pc, #8]	; (64e8 <nrfx_usbd_ep_stall+0xc>)
    64de:	f440 7080 	orr.w	r0, r0, #256	; 0x100
    64e2:	f8c3 0518 	str.w	r0, [r3, #1304]	; 0x518

void nrfx_usbd_ep_stall(nrfx_usbd_ep_t ep)
{
    NRFX_LOG_DEBUG("USB: EP %x stalled.", ep);
    nrf_usbd_ep_stall(NRF_USBD, ep_to_hal(ep));
}
    64e6:	4770      	bx	lr
    64e8:	40027000 	.word	0x40027000

000064ec <nrfx_usbd_ep_stall_check>:
    if (NRF_USBD_EPISO_CHECK(ep))
    64ec:	0702      	lsls	r2, r0, #28
    64ee:	d413      	bmi.n	6518 <nrfx_usbd_ep_stall_check+0x2c>
        return p_reg->HALTED.EPIN[epnr];
    64f0:	f000 030f 	and.w	r3, r0, #15
    if (NRF_USBD_EPIN_CHECK(ep))
    64f4:	f010 0f80 	tst.w	r0, #128	; 0x80
    64f8:	4a08      	ldr	r2, [pc, #32]	; (651c <nrfx_usbd_ep_stall_check+0x30>)
        return p_reg->HALTED.EPOUT[epnr];
    64fa:	bf0b      	itete	eq
    64fc:	f503 7388 	addeq.w	r3, r3, #272	; 0x110
        return p_reg->HALTED.EPIN[epnr];
    6500:	f503 7384 	addne.w	r3, r3, #264	; 0x108
        return p_reg->HALTED.EPOUT[epnr];
    6504:	eb02 0383 	addeq.w	r3, r2, r3, lsl #2
        return p_reg->HALTED.EPIN[epnr];
    6508:	f852 0023 	ldrne.w	r0, [r2, r3, lsl #2]
        return p_reg->HALTED.EPOUT[epnr];
    650c:	bf08      	it	eq
    650e:	6858      	ldreq	r0, [r3, #4]
    return USBD_HALTED_EPOUT_GETSTATUS_Halted == nrf_usbd_halted_get(p_reg, ep);
    6510:	1e43      	subs	r3, r0, #1
    6512:	4258      	negs	r0, r3
    6514:	4158      	adcs	r0, r3
    6516:	4770      	bx	lr
        return false;
    6518:	2000      	movs	r0, #0
}

bool nrfx_usbd_ep_stall_check(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_ep_is_stall(NRF_USBD, ep_to_hal(ep));
}
    651a:	4770      	bx	lr
    651c:	40027000 	.word	0x40027000

00006520 <nrfx_usbd_ep_dtoggle_clear>:
    p_reg->DTOGGLE = ep | (NRF_USBD_DTOGGLE_NOP << USBD_DTOGGLE_VALUE_Pos);
    6520:	4b04      	ldr	r3, [pc, #16]	; (6534 <nrfx_usbd_ep_dtoggle_clear+0x14>)
    6522:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->DTOGGLE = ep | (op << USBD_DTOGGLE_VALUE_Pos);
    6526:	f440 7080 	orr.w	r0, r0, #256	; 0x100
    652a:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    (void) p_reg->DTOGGLE;
    652e:	f8d3 350c 	ldr.w	r3, [r3, #1292]	; 0x50c

void nrfx_usbd_ep_dtoggle_clear(nrfx_usbd_ep_t ep)
{
    nrf_usbd_dtoggle_set(NRF_USBD, ep, NRF_USBD_DTOGGLE_DATA0);
}
    6532:	4770      	bx	lr
    6534:	40027000 	.word	0x40027000

00006538 <nrfx_usbd_setup_get>:

void nrfx_usbd_setup_get(nrfx_usbd_setup_t * p_setup)
{
    6538:	b510      	push	{r4, lr}
    memset(p_setup, 0, sizeof(nrfx_usbd_setup_t));
    653a:	2208      	movs	r2, #8
    653c:	2100      	movs	r1, #0
{
    653e:	4604      	mov	r4, r0
    memset(p_setup, 0, sizeof(nrfx_usbd_setup_t));
    6540:	f002 f9c5 	bl	88ce <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
    6544:	4b0e      	ldr	r3, [pc, #56]	; (6580 <nrfx_usbd_setup_get+0x48>)
    6546:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
    654a:	7022      	strb	r2, [r4, #0]
    return (uint8_t)(p_reg->BREQUEST);
    654c:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
    6550:	7062      	strb	r2, [r4, #1]
    const uint16_t val = p_reg->WVALUEL;
    6552:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
    6556:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
    655a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->bmRequestType = nrf_usbd_setup_bmrequesttype_get(NRF_USBD);
    p_setup->bRequest      = nrf_usbd_setup_brequest_get(NRF_USBD);
    p_setup->wValue        = nrf_usbd_setup_wvalue_get(NRF_USBD);
    655e:	8062      	strh	r2, [r4, #2]
    const uint16_t val = p_reg->WINDEXL;
    6560:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
    6564:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
    6568:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->wIndex        = nrf_usbd_setup_windex_get(NRF_USBD);
    656c:	80a2      	strh	r2, [r4, #4]
    const uint16_t val = p_reg->WLENGTHL;
    656e:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
    6572:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
    6576:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    p_setup->wLength       = nrf_usbd_setup_wlength_get(NRF_USBD);
    657a:	80e3      	strh	r3, [r4, #6]
}
    657c:	bd10      	pop	{r4, pc}
    657e:	bf00      	nop
    6580:	40027000 	.word	0x40027000

00006584 <nrfx_usbd_setup_data_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
    6584:	4b02      	ldr	r3, [pc, #8]	; (6590 <nrfx_usbd_setup_data_clear+0xc>)
    6586:	2201      	movs	r2, #1
    6588:	64da      	str	r2, [r3, #76]	; 0x4c
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
    658a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c

void nrfx_usbd_setup_data_clear(void)
{
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0RCVOUT);
}
    658c:	4770      	bx	lr
    658e:	bf00      	nop
    6590:	40027000 	.word	0x40027000

00006594 <ev_dma_epout0_handler>:
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
    6594:	b513      	push	{r0, r1, r4, lr}
    usbd_dma_pending_clear();
    6596:	f7ff fb17 	bl	5bc8 <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    659a:	4b10      	ldr	r3, [pc, #64]	; (65dc <ev_dma_epout0_handler+0x48>)
    659c:	7b9a      	ldrb	r2, [r3, #14]
    659e:	2a03      	cmp	r2, #3
    65a0:	d106      	bne.n	65b0 <ev_dma_epout0_handler+0x1c>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    65a2:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
    65a6:	b002      	add	sp, #8
    65a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    65ac:	f7ff bc1c 	b.w	5de8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.consumer == NULL)
    65b0:	681c      	ldr	r4, [r3, #0]
    65b2:	b974      	cbnz	r4, 65d2 <ev_dma_epout0_handler+0x3e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    65b4:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
    65b8:	f7ff fc16 	bl	5de8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    65bc:	2306      	movs	r3, #6
    65be:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
    65c2:	4b07      	ldr	r3, [pc, #28]	; (65e0 <ev_dma_epout0_handler+0x4c>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    65c4:	f8ad 4006 	strh.w	r4, [sp, #6]
        m_event_handler(&evt);
    65c8:	681b      	ldr	r3, [r3, #0]
    65ca:	a801      	add	r0, sp, #4
    65cc:	4798      	blx	r3
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
    65ce:	b002      	add	sp, #8
    65d0:	bd10      	pop	{r4, pc}
    65d2:	b002      	add	sp, #8
    65d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        nrfx_usbd_setup_data_clear();
    65d8:	f7ff bfd4 	b.w	6584 <nrfx_usbd_setup_data_clear>
    65dc:	200011cc 	.word	0x200011cc
    65e0:	200012ec 	.word	0x200012ec

000065e4 <nrfx_usbd_setup_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
    65e4:	4b02      	ldr	r3, [pc, #8]	; (65f0 <nrfx_usbd_setup_clear+0xc>)
    65e6:	2201      	movs	r2, #1
    65e8:	651a      	str	r2, [r3, #80]	; 0x50
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
    65ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50

void nrfx_usbd_setup_clear(void)
{
    NRFX_LOG_DEBUG(">> ep0status >>");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STATUS);
}
    65ec:	4770      	bx	lr
    65ee:	bf00      	nop
    65f0:	40027000 	.word	0x40027000

000065f4 <nrfx_usbd_setup_stall>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
    65f4:	4b02      	ldr	r3, [pc, #8]	; (6600 <nrfx_usbd_setup_stall+0xc>)
    65f6:	2201      	movs	r2, #1
    65f8:	655a      	str	r2, [r3, #84]	; 0x54
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
    65fa:	6d5b      	ldr	r3, [r3, #84]	; 0x54

void nrfx_usbd_setup_stall(void)
{
    NRFX_LOG_DEBUG("Setup stalled.");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STALL);
}
    65fc:	4770      	bx	lr
    65fe:	bf00      	nop
    6600:	40027000 	.word	0x40027000

00006604 <nrfx_usbd_last_setup_dir_get>:

nrfx_usbd_ep_t nrfx_usbd_last_setup_dir_get(void)
{
    return m_last_setup_dir;
}
    6604:	4b01      	ldr	r3, [pc, #4]	; (660c <nrfx_usbd_last_setup_dir_get+0x8>)
    6606:	7818      	ldrb	r0, [r3, #0]
    6608:	4770      	bx	lr
    660a:	bf00      	nop
    660c:	200013a8 	.word	0x200013a8

00006610 <nrfx_usbd_transfer_out_drop>:

void nrfx_usbd_transfer_out_drop(nrfx_usbd_ep_t ep)
{
    6610:	b510      	push	{r4, lr}
    6612:	4602      	mov	r2, r0
	__asm__ volatile(
    6614:	f04f 0320 	mov.w	r3, #32
    6618:	f3ef 8411 	mrs	r4, BASEPRI
    661c:	f383 8812 	msr	BASEPRI_MAX, r3
    6620:	f3bf 8f6f 	isb	sy
    NRFX_ASSERT(NRF_USBD_EPOUT_CHECK(ep));

    NRFX_CRITICAL_SECTION_ENTER();
    m_ep_ready &= ~(1U << ep2bit(ep));
    6624:	f002 fd4f 	bl	90c6 <ep2bit>
    6628:	490d      	ldr	r1, [pc, #52]	; (6660 <nrfx_usbd_transfer_out_drop+0x50>)
    662a:	2301      	movs	r3, #1
    662c:	fa03 f000 	lsl.w	r0, r3, r0
    6630:	680b      	ldr	r3, [r1, #0]
    6632:	ea23 0300 	bic.w	r3, r3, r0
    6636:	600b      	str	r3, [r1, #0]
    if (!NRF_USBD_EPISO_CHECK(ep))
    6638:	f012 0108 	ands.w	r1, r2, #8
    663c:	d10a      	bne.n	6654 <nrfx_usbd_transfer_out_drop+0x44>
    p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)] = 0;
    663e:	f002 030f 	and.w	r3, r2, #15
    6642:	009b      	lsls	r3, r3, #2
    6644:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    6648:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    664c:	f8c3 14a0 	str.w	r1, [r3, #1184]	; 0x4a0
    (void) p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
    6650:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
	__asm__ volatile(
    6654:	f384 8811 	msr	BASEPRI, r4
    6658:	f3bf 8f6f 	isb	sy
    {
        nrf_usbd_epout_clear(NRF_USBD, ep);
    }
    NRFX_CRITICAL_SECTION_EXIT();
}
    665c:	bd10      	pop	{r4, pc}
    665e:	bf00      	nop
    6660:	200011c8 	.word	0x200011c8

00006664 <usbd_ep_abort>:
{
    6664:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6666:	4601      	mov	r1, r0
	__asm__ volatile(
    6668:	f04f 0320 	mov.w	r3, #32
    666c:	f3ef 8511 	mrs	r5, BASEPRI
    6670:	f383 8812 	msr	BASEPRI_MAX, r3
    6674:	f3bf 8f6f 	isb	sy
    usbd_ep_state_t * p_state = ep_state_access(ep);
    6678:	f7ff fa98 	bl	5bac <ep_state_access>
    667c:	4606      	mov	r6, r0
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
    667e:	4608      	mov	r0, r1
    6680:	f002 fd21 	bl	90c6 <ep2bit>
    6684:	2201      	movs	r2, #1
    if (NRF_USBD_EPOUT_CHECK(ep))
    6686:	f011 0f80 	tst.w	r1, #128	; 0x80
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
    668a:	fa02 f200 	lsl.w	r2, r2, r0
    668e:	482e      	ldr	r0, [pc, #184]	; (6748 <usbd_ep_abort+0xe4>)
    if (NRF_USBD_EPOUT_CHECK(ep))
    6690:	d118      	bne.n	66c4 <usbd_ep_abort+0x60>
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
    6692:	6803      	ldr	r3, [r0, #0]
    6694:	ea32 0403 	bics.w	r4, r2, r3
    6698:	d00a      	beq.n	66b0 <usbd_ep_abort+0x4c>
            nrfx_usbd_transfer_out_drop(ep);
    669a:	4608      	mov	r0, r1
    669c:	f7ff ffb8 	bl	6610 <nrfx_usbd_transfer_out_drop>
        p_state->status = NRFX_USBD_EP_ABORTED;
    66a0:	2303      	movs	r3, #3
    66a2:	73b3      	strb	r3, [r6, #14]
	__asm__ volatile(
    66a4:	f385 8811 	msr	BASEPRI, r5
    66a8:	f3bf 8f6f 	isb	sy
}
    66ac:	b003      	add	sp, #12
    66ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
    66b0:	ea23 0302 	bic.w	r3, r3, r2
            p_state->handler.consumer = NULL;
    66b4:	6034      	str	r4, [r6, #0]
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
    66b6:	6003      	str	r3, [r0, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
    66b8:	4b24      	ldr	r3, [pc, #144]	; (674c <usbd_ep_abort+0xe8>)
    66ba:	6818      	ldr	r0, [r3, #0]
    66bc:	ea20 0002 	bic.w	r0, r0, r2
    66c0:	6018      	str	r0, [r3, #0]
    66c2:	e7ed      	b.n	66a0 <usbd_ep_abort+0x3c>
        if(!NRF_USBD_EPISO_CHECK(ep))
    66c4:	070b      	lsls	r3, r1, #28
    66c6:	d415      	bmi.n	66f4 <usbd_ep_abort+0x90>
            if(ep != NRFX_USBD_EPIN0)
    66c8:	2980      	cmp	r1, #128	; 0x80
    66ca:	4b21      	ldr	r3, [pc, #132]	; (6750 <usbd_ep_abort+0xec>)
    66cc:	d02f      	beq.n	672e <usbd_ep_abort+0xca>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B6 + (2u * (NRF_USBD_EP_NR_GET(ep) - 1));
    66ce:	f001 040f 	and.w	r4, r1, #15
    66d2:	f204 34da 	addw	r4, r4, #986	; 0x3da
    66d6:	0064      	lsls	r4, r4, #1
    66d8:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
    66dc:	f8d3 4804 	ldr.w	r4, [r3, #2052]	; 0x804
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
    66e0:	f8d3 7804 	ldr.w	r7, [r3, #2052]	; 0x804
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
    66e4:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
    66e6:	f044 0402 	orr.w	r4, r4, #2
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
    66ea:	433c      	orrs	r4, r7
    66ec:	f8c3 4804 	str.w	r4, [r3, #2052]	; 0x804
                (void)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
    66f0:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
        if ((m_ep_dma_waiting | (~m_ep_ready)) & (1U << ep2bit(ep)))
    66f4:	4f15      	ldr	r7, [pc, #84]	; (674c <usbd_ep_abort+0xe8>)
    66f6:	6804      	ldr	r4, [r0, #0]
    66f8:	683b      	ldr	r3, [r7, #0]
    66fa:	ea64 0c03 	orn	ip, r4, r3
    66fe:	ea1c 0f02 	tst.w	ip, r2
    6702:	d0cf      	beq.n	66a4 <usbd_ep_abort+0x40>
            m_ep_ready       |=   1U << ep2bit(ep) ;
    6704:	4313      	orrs	r3, r2
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
    6706:	ea24 0402 	bic.w	r4, r4, r2
            m_ep_ready       |=   1U << ep2bit(ep) ;
    670a:	603b      	str	r3, [r7, #0]
            p_state->handler.feeder = NULL;
    670c:	2300      	movs	r3, #0
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
    670e:	6004      	str	r4, [r0, #0]
            p_state->handler.feeder = NULL;
    6710:	6033      	str	r3, [r6, #0]
            p_state->status = NRFX_USBD_EP_ABORTED;
    6712:	2303      	movs	r3, #3
    6714:	73b3      	strb	r3, [r6, #14]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
    6716:	f88d 3007 	strb.w	r3, [sp, #7]
            m_event_handler(&evt);
    671a:	4b0e      	ldr	r3, [pc, #56]	; (6754 <usbd_ep_abort+0xf0>)
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
    671c:	f88d 1006 	strb.w	r1, [sp, #6]
    6720:	2206      	movs	r2, #6
            m_event_handler(&evt);
    6722:	681b      	ldr	r3, [r3, #0]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
    6724:	f88d 2004 	strb.w	r2, [sp, #4]
            m_event_handler(&evt);
    6728:	a801      	add	r0, sp, #4
    672a:	4798      	blx	r3
    672c:	e7ba      	b.n	66a4 <usbd_ep_abort+0x40>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B4;
    672e:	f240 74b4 	movw	r4, #1972	; 0x7b4
    6732:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
    6736:	f8d3 4804 	ldr.w	r4, [r3, #2052]	; 0x804
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
    673a:	f8d3 7804 	ldr.w	r7, [r3, #2052]	; 0x804
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
    673e:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
    6740:	f044 0404 	orr.w	r4, r4, #4
    6744:	e7d1      	b.n	66ea <usbd_ep_abort+0x86>
    6746:	bf00      	nop
    6748:	20001158 	.word	0x20001158
    674c:	200011c8 	.word	0x200011c8
    6750:	40027000 	.word	0x40027000
    6754:	200012ec 	.word	0x200012ec

00006758 <ev_setup_handler>:
{
    6758:	b573      	push	{r0, r1, r4, r5, r6, lr}
    return (uint8_t)(p_reg->BMREQUESTTYPE);
    675a:	4b17      	ldr	r3, [pc, #92]	; (67b8 <ev_setup_handler+0x60>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
    675c:	4c17      	ldr	r4, [pc, #92]	; (67bc <ev_setup_handler+0x64>)
    675e:	f8d3 5480 	ldr.w	r5, [r3, #1152]	; 0x480
    6762:	6823      	ldr	r3, [r4, #0]
        & (1U <<ep2bit(m_last_setup_dir)))
    6764:	4e16      	ldr	r6, [pc, #88]	; (67c0 <ev_setup_handler+0x68>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
    6766:	43da      	mvns	r2, r3
    6768:	4b16      	ldr	r3, [pc, #88]	; (67c4 <ev_setup_handler+0x6c>)
        & (1U <<ep2bit(m_last_setup_dir)))
    676a:	7831      	ldrb	r1, [r6, #0]
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
    676c:	681b      	ldr	r3, [r3, #0]
    676e:	b292      	uxth	r2, r2
        & (1U <<ep2bit(m_last_setup_dir)))
    6770:	4608      	mov	r0, r1
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
    6772:	431a      	orrs	r2, r3
        & (1U <<ep2bit(m_last_setup_dir)))
    6774:	f002 fca7 	bl	90c6 <ep2bit>
    6778:	2301      	movs	r3, #1
    677a:	4083      	lsls	r3, r0
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
    677c:	4213      	tst	r3, r2
    677e:	d002      	beq.n	6786 <ev_setup_handler+0x2e>
        usbd_ep_abort(m_last_setup_dir);
    6780:	4608      	mov	r0, r1
    6782:	f7ff ff6f 	bl	6664 <usbd_ep_abort>
        NRFX_USBD_EPOUT0 : NRFX_USBD_EPIN0;
    6786:	f005 0580 	and.w	r5, r5, #128	; 0x80
    (void)(NRFX_ATOMIC_FETCH_AND(
    678a:	f06f 1001 	mvn.w	r0, #65537	; 0x10001
    m_last_setup_dir =
    678e:	7035      	strb	r5, [r6, #0]
    (void)(NRFX_ATOMIC_FETCH_AND(
    6790:	f7ff fb2a 	bl	5de8 <atomic_and.constprop.0.isra.0>
    m_ep_ready |= 1U << ep2bit(NRFX_USBD_EPIN0);
    6794:	6823      	ldr	r3, [r4, #0]
    6796:	f043 0301 	orr.w	r3, r3, #1
    679a:	6023      	str	r3, [r4, #0]
    const nrfx_usbd_evt_t evt = {
    679c:	2300      	movs	r3, #0
    679e:	f8ad 3005 	strh.w	r3, [sp, #5]
    67a2:	f88d 3007 	strb.w	r3, [sp, #7]
    67a6:	2305      	movs	r3, #5
    67a8:	f88d 3004 	strb.w	r3, [sp, #4]
    m_event_handler(&evt);
    67ac:	4b06      	ldr	r3, [pc, #24]	; (67c8 <ev_setup_handler+0x70>)
    67ae:	a801      	add	r0, sp, #4
    67b0:	681b      	ldr	r3, [r3, #0]
    67b2:	4798      	blx	r3
}
    67b4:	b002      	add	sp, #8
    67b6:	bd70      	pop	{r4, r5, r6, pc}
    67b8:	40027000 	.word	0x40027000
    67bc:	200011c8 	.word	0x200011c8
    67c0:	200013a8 	.word	0x200013a8
    67c4:	20001158 	.word	0x20001158
    67c8:	200012ec 	.word	0x200012ec

000067cc <nrfx_usbd_irq_handler>:
    return p_reg->INTENSET;
    67cc:	4b1b      	ldr	r3, [pc, #108]	; (683c <nrfx_usbd_irq_handler+0x70>)
    67ce:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
    uint32_t active = 0;
    67d2:	2300      	movs	r3, #0
{
    67d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            active |= 1UL << event_nr;
    67d8:	2401      	movs	r4, #1
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
    67da:	461d      	mov	r5, r3
    while (to_process)
    67dc:	b970      	cbnz	r0, 67fc <nrfx_usbd_irq_handler+0x30>
        m_isr[event_nr]();
    67de:	4f18      	ldr	r7, [pc, #96]	; (6840 <nrfx_usbd_irq_handler+0x74>)
    bool setup_active = 0 != (active & NRF_USBD_INT_EP0SETUP_MASK);
    67e0:	f403 0600 	and.w	r6, r3, #8388608	; 0x800000
    active &= ~NRF_USBD_INT_EP0SETUP_MASK;
    67e4:	f423 0400 	bic.w	r4, r3, #8388608	; 0x800000
        active &= ~(1UL << event_nr);
    67e8:	f04f 0801 	mov.w	r8, #1
    while (active)
    67ec:	b9bc      	cbnz	r4, 681e <nrfx_usbd_irq_handler+0x52>
    usbd_dmareq_process();
    67ee:	f7ff fd61 	bl	62b4 <usbd_dmareq_process>
    if (setup_active)
    67f2:	b306      	cbz	r6, 6836 <nrfx_usbd_irq_handler+0x6a>
}
    67f4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        m_isr[USBD_INTEN_EP0SETUP_Pos]();
    67f8:	f7ff bfae 	b.w	6758 <ev_setup_handler>
        uint8_t event_nr = NRF_CTZ(to_process);
    67fc:	fa90 f2a0 	rbit	r2, r0
    6800:	fab2 f282 	clz	r2, r2
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
    6804:	490f      	ldr	r1, [pc, #60]	; (6844 <nrfx_usbd_irq_handler+0x78>)
}

NRF_STATIC_INLINE uint32_t nrfx_bitpos_to_event(uint32_t bit)
{
    static const uint32_t event_reg_offset = 0x100u;
    return event_reg_offset + (bit * sizeof(uint32_t));
    6806:	0096      	lsls	r6, r2, #2
    6808:	4431      	add	r1, r6
            active |= 1UL << event_nr;
    680a:	fa04 f202 	lsl.w	r2, r4, r2
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
    680e:	680e      	ldr	r6, [r1, #0]
    if (ret)
    6810:	b116      	cbz	r6, 6818 <nrfx_usbd_irq_handler+0x4c>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
    6812:	600d      	str	r5, [r1, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
    6814:	6809      	ldr	r1, [r1, #0]
    6816:	4313      	orrs	r3, r2
        to_process &= ~(1UL << event_nr);
    6818:	ea20 0002 	bic.w	r0, r0, r2
    681c:	e7de      	b.n	67dc <nrfx_usbd_irq_handler+0x10>
        uint8_t event_nr = NRF_CTZ(active);
    681e:	fa94 f5a4 	rbit	r5, r4
    6822:	fab5 f585 	clz	r5, r5
        m_isr[event_nr]();
    6826:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
        active &= ~(1UL << event_nr);
    682a:	fa08 f505 	lsl.w	r5, r8, r5
        m_isr[event_nr]();
    682e:	4798      	blx	r3
        active &= ~(1UL << event_nr);
    6830:	ea24 0405 	bic.w	r4, r4, r5
    6834:	e7da      	b.n	67ec <nrfx_usbd_irq_handler+0x20>
}
    6836:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    683a:	bf00      	nop
    683c:	40027000 	.word	0x40027000
    6840:	00009bb0 	.word	0x00009bb0
    6844:	40027100 	.word	0x40027100

00006848 <usbd_ep_abort_all>:
{
    6848:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint32_t ep_waiting = m_ep_dma_waiting | (m_ep_ready & NRFX_USBD_EPOUT_BIT_MASK);
    684a:	4e10      	ldr	r6, [pc, #64]	; (688c <usbd_ep_abort_all+0x44>)
    684c:	4b10      	ldr	r3, [pc, #64]	; (6890 <usbd_ep_abort_all+0x48>)
    684e:	6834      	ldr	r4, [r6, #0]
    6850:	681b      	ldr	r3, [r3, #0]
    6852:	0c24      	lsrs	r4, r4, #16
    6854:	0424      	lsls	r4, r4, #16
    6856:	431c      	orrs	r4, r3
        ep_waiting &= ~(1U << bitpos);
    6858:	2701      	movs	r7, #1
    while (0 != ep_waiting)
    685a:	b91c      	cbnz	r4, 6864 <usbd_ep_abort_all+0x1c>
    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
    685c:	f240 13ff 	movw	r3, #511	; 0x1ff
    6860:	6033      	str	r3, [r6, #0]
}
    6862:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        uint8_t bitpos = NRF_CTZ(ep_waiting);
    6864:	fa94 f5a4 	rbit	r5, r4
    6868:	fab5 f585 	clz	r5, r5
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    686c:	2d0f      	cmp	r5, #15
        NRF_USBD_EPOUT(bitpos - NRFX_USBD_EPOUT_BITPOS_0) : NRF_USBD_EPIN(bitpos));
    686e:	bfc6      	itte	gt
    6870:	f1a5 0010 	subgt.w	r0, r5, #16
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    6874:	b2c0      	uxtbgt	r0, r0
    6876:	f045 0080 	orrle.w	r0, r5, #128	; 0x80
        if (!NRF_USBD_EPISO_CHECK(bit2ep(bitpos)))
    687a:	0703      	lsls	r3, r0, #28
    687c:	d401      	bmi.n	6882 <usbd_ep_abort_all+0x3a>
            usbd_ep_abort(bit2ep(bitpos));
    687e:	f7ff fef1 	bl	6664 <usbd_ep_abort>
        ep_waiting &= ~(1U << bitpos);
    6882:	fa07 f505 	lsl.w	r5, r7, r5
    6886:	ea24 0405 	bic.w	r4, r4, r5
    688a:	e7e6      	b.n	685a <usbd_ep_abort_all+0x12>
    688c:	200011c8 	.word	0x200011c8
    6890:	20001158 	.word	0x20001158

00006894 <nrfx_usbd_stop>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    6894:	4b0c      	ldr	r3, [pc, #48]	; (68c8 <nrfx_usbd_stop+0x34>)
    6896:	2280      	movs	r2, #128	; 0x80
{
    6898:	b510      	push	{r4, lr}
    if (NRFX_IRQ_IS_ENABLED(USBD_IRQn))
    689a:	2027      	movs	r0, #39	; 0x27
    689c:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    68a0:	f7fc fca4 	bl	31ec <arch_irq_is_enabled>
    68a4:	b170      	cbz	r0, 68c4 <nrfx_usbd_stop+0x30>
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Disabled << USBD_USBPULLUP_CONNECT_Pos;
    68a6:	4c09      	ldr	r4, [pc, #36]	; (68cc <nrfx_usbd_stop+0x38>)
        usbd_ep_abort_all();
    68a8:	f7ff ffce 	bl	6848 <usbd_ep_abort_all>
    68ac:	2300      	movs	r3, #0
    68ae:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
        NRFX_IRQ_DISABLE(USBD_IRQn);
    68b2:	2027      	movs	r0, #39	; 0x27
    (void) p_reg->USBPULLUP;
    68b4:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
    68b8:	f7fc fc84 	bl	31c4 <arch_irq_disable>
    p_reg->INTENCLR = mask;
    68bc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    68c0:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
}
    68c4:	bd10      	pop	{r4, pc}
    68c6:	bf00      	nop
    68c8:	e000e100 	.word	0xe000e100
    68cc:	40027000 	.word	0x40027000

000068d0 <nrfx_usbd_disable>:
{
    68d0:	b508      	push	{r3, lr}
    nrfx_usbd_stop();
    68d2:	f7ff ffdf 	bl	6894 <nrfx_usbd_stop>
    return p_reg->INTENSET;
    68d6:	4b08      	ldr	r3, [pc, #32]	; (68f8 <nrfx_usbd_disable+0x28>)
    68d8:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
    p_reg->INTENCLR = mask;
    68dc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Disabled << USBD_ENABLE_ENABLE_Pos;
    68e0:	2200      	movs	r2, #0
    68e2:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
    68e6:	f8d3 3500 	ldr.w	r3, [r3, #1280]	; 0x500
    usbd_dma_pending_clear();
    68ea:	f7ff f96d 	bl	5bc8 <usbd_dma_pending_clear>
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
    68ee:	4b03      	ldr	r3, [pc, #12]	; (68fc <nrfx_usbd_disable+0x2c>)
    68f0:	2201      	movs	r2, #1
    68f2:	701a      	strb	r2, [r3, #0]
}
    68f4:	bd08      	pop	{r3, pc}
    68f6:	bf00      	nop
    68f8:	40027000 	.word	0x40027000
    68fc:	200013a7 	.word	0x200013a7

00006900 <nrfx_usbd_suspend>:
{
    6900:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    6902:	f04f 0320 	mov.w	r3, #32
    6906:	f3ef 8511 	mrs	r5, BASEPRI
    690a:	f383 8812 	msr	BASEPRI_MAX, r3
    690e:	f3bf 8f6f 	isb	sy
    if (m_bus_suspend)
    6912:	4b11      	ldr	r3, [pc, #68]	; (6958 <nrfx_usbd_suspend+0x58>)
    6914:	781b      	ldrb	r3, [r3, #0]
    6916:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    691a:	b933      	cbnz	r3, 692a <nrfx_usbd_suspend+0x2a>
    bool suspended = false;
    691c:	2400      	movs	r4, #0
	__asm__ volatile(
    691e:	f385 8811 	msr	BASEPRI, r5
    6922:	f3bf 8f6f 	isb	sy
}
    6926:	4620      	mov	r0, r4
    6928:	bd38      	pop	{r3, r4, r5, pc}
        usbd_ep_abort_all();
    692a:	f7ff ff8d 	bl	6848 <usbd_ep_abort_all>
    return p_reg->EVENTCAUSE;
    692e:	4b0b      	ldr	r3, [pc, #44]	; (695c <nrfx_usbd_suspend+0x5c>)
    6930:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        if (!(nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK))
    6934:	f412 7200 	ands.w	r2, r2, #512	; 0x200
    6938:	d1f0      	bne.n	691c <nrfx_usbd_suspend+0x1c>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_LowPower << USBD_LOWPOWER_LOWPOWER_Pos;
    693a:	2101      	movs	r1, #1
    693c:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
    6940:	f8d3 152c 	ldr.w	r1, [r3, #1324]	; 0x52c
    return p_reg->EVENTCAUSE;
    6944:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
            if (nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK)
    6948:	0589      	lsls	r1, r1, #22
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos;
    694a:	bf42      	ittt	mi
    694c:	f8c3 252c 	strmi.w	r2, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
    6950:	f8d3 352c 	ldrmi.w	r3, [r3, #1324]	; 0x52c
    bool suspended = false;
    6954:	4614      	movmi	r4, r2
}
    6956:	e7e2      	b.n	691e <nrfx_usbd_suspend+0x1e>
    6958:	200013a5 	.word	0x200013a5
    695c:	40027000 	.word	0x40027000

00006960 <nrfx_usbd_ep_disable>:
{
    6960:	b510      	push	{r4, lr}
    6962:	4604      	mov	r4, r0
    usbd_ep_abort(ep);
    6964:	f7ff fe7e 	bl	6664 <usbd_ep_abort>
    uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
    6968:	4a10      	ldr	r2, [pc, #64]	; (69ac <nrfx_usbd_ep_disable+0x4c>)
    if (NRF_USBD_EPIN_CHECK(ep))
    696a:	f014 0f80 	tst.w	r4, #128	; 0x80
    uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
    696e:	f004 000f 	and.w	r0, r4, #15
        p_reg->EPINEN &= ~(1UL << epnr);
    6972:	f04f 0301 	mov.w	r3, #1
    6976:	bf14      	ite	ne
    6978:	f8d2 1510 	ldrne.w	r1, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
    697c:	f8d2 1514 	ldreq.w	r1, [r2, #1300]	; 0x514
        p_reg->EPINEN &= ~(1UL << epnr);
    6980:	fa03 f300 	lsl.w	r3, r3, r0
    6984:	ea6f 0303 	mvn.w	r3, r3
    6988:	bf15      	itete	ne
    698a:	400b      	andne	r3, r1
        p_reg->EPOUTEN &= ~(1UL << epnr);
    698c:	400b      	andeq	r3, r1
        p_reg->EPINEN &= ~(1UL << epnr);
    698e:	f8c2 3510 	strne.w	r3, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
    6992:	f8c2 3514 	streq.w	r3, [r2, #1300]	; 0x514
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
    6996:	bf14      	ite	ne
    6998:	4b05      	ldrne	r3, [pc, #20]	; (69b0 <nrfx_usbd_ep_disable+0x50>)
    699a:	4b06      	ldreq	r3, [pc, #24]	; (69b4 <nrfx_usbd_ep_disable+0x54>)
    699c:	5c1a      	ldrb	r2, [r3, r0]
    699e:	2301      	movs	r3, #1
    69a0:	4093      	lsls	r3, r2
    p_reg->INTENCLR = mask;
    69a2:	4a02      	ldr	r2, [pc, #8]	; (69ac <nrfx_usbd_ep_disable+0x4c>)
    69a4:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
}
    69a8:	bd10      	pop	{r4, pc}
    69aa:	bf00      	nop
    69ac:	40027000 	.word	0x40027000
    69b0:	00009cef 	.word	0x00009cef
    69b4:	00009cf8 	.word	0x00009cf8

000069b8 <nrfx_usbd_ep_enable>:
{
    69b8:	b570      	push	{r4, r5, r6, lr}
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
    69ba:	b243      	sxtb	r3, r0
    69bc:	2b00      	cmp	r3, #0
    69be:	4b23      	ldr	r3, [pc, #140]	; (6a4c <nrfx_usbd_ep_enable+0x94>)
    69c0:	4a23      	ldr	r2, [pc, #140]	; (6a50 <nrfx_usbd_ep_enable+0x98>)
    69c2:	bfa8      	it	ge
    69c4:	461a      	movge	r2, r3
    69c6:	f000 030f 	and.w	r3, r0, #15
    69ca:	f04f 0401 	mov.w	r4, #1
    69ce:	5cd1      	ldrb	r1, [r2, r3]
    p_reg->INTENSET = mask;
    69d0:	4a20      	ldr	r2, [pc, #128]	; (6a54 <nrfx_usbd_ep_enable+0x9c>)
    69d2:	fa04 f101 	lsl.w	r1, r4, r1
{
    69d6:	4605      	mov	r5, r0
    69d8:	f8c2 1304 	str.w	r1, [r2, #772]	; 0x304
    if (NRF_USBD_EPIN_CHECK(ep))
    69dc:	da0c      	bge.n	69f8 <nrfx_usbd_ep_enable+0x40>
        return 0 != (p_reg->EPINEN & (1UL << epnr));
    69de:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
    69e2:	40d9      	lsrs	r1, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
    69e4:	07c8      	lsls	r0, r1, #31
    69e6:	d406      	bmi.n	69f6 <nrfx_usbd_ep_enable+0x3e>
        p_reg->EPINEN |= 1UL << epnr;
    69e8:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
    69ec:	fa04 f303 	lsl.w	r3, r4, r3
    69f0:	4303      	orrs	r3, r0
    69f2:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
}
    69f6:	bd70      	pop	{r4, r5, r6, pc}
        return 0 != (p_reg->EPOUTEN & (1UL << epnr));
    69f8:	f8d2 1514 	ldr.w	r1, [r2, #1300]	; 0x514
    69fc:	40d9      	lsrs	r1, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
    69fe:	07c9      	lsls	r1, r1, #31
    6a00:	d4f9      	bmi.n	69f6 <nrfx_usbd_ep_enable+0x3e>
        p_reg->EPOUTEN |= 1UL << epnr;
    6a02:	f8d2 6514 	ldr.w	r6, [r2, #1300]	; 0x514
    6a06:	fa04 f103 	lsl.w	r1, r4, r3
    6a0a:	4331      	orrs	r1, r6
    6a0c:	f8c2 1514 	str.w	r1, [r2, #1300]	; 0x514
    if ((NRF_USBD_EP_NR_GET(ep) != 0) &&
    6a10:	2b00      	cmp	r3, #0
    6a12:	d0f0      	beq.n	69f6 <nrfx_usbd_ep_enable+0x3e>
        NRF_USBD_EPOUT_CHECK(ep) &&
    6a14:	0703      	lsls	r3, r0, #28
    6a16:	d4ee      	bmi.n	69f6 <nrfx_usbd_ep_enable+0x3e>
	__asm__ volatile(
    6a18:	f04f 0320 	mov.w	r3, #32
    6a1c:	f3ef 8611 	mrs	r6, BASEPRI
    6a20:	f383 8812 	msr	BASEPRI_MAX, r3
    6a24:	f3bf 8f6f 	isb	sy
        nrfx_usbd_transfer_out_drop(ep);
    6a28:	f7ff fdf2 	bl	6610 <nrfx_usbd_transfer_out_drop>
        m_ep_dma_waiting &= ~(1U << ep2bit(ep));
    6a2c:	4628      	mov	r0, r5
    6a2e:	f002 fb4a 	bl	90c6 <ep2bit>
    6a32:	4a09      	ldr	r2, [pc, #36]	; (6a58 <nrfx_usbd_ep_enable+0xa0>)
    6a34:	6813      	ldr	r3, [r2, #0]
    6a36:	fa04 f000 	lsl.w	r0, r4, r0
    6a3a:	ea23 0000 	bic.w	r0, r3, r0
    6a3e:	6010      	str	r0, [r2, #0]
	__asm__ volatile(
    6a40:	f386 8811 	msr	BASEPRI, r6
    6a44:	f3bf 8f6f 	isb	sy
}
    6a48:	e7d5      	b.n	69f6 <nrfx_usbd_ep_enable+0x3e>
    6a4a:	bf00      	nop
    6a4c:	00009cf8 	.word	0x00009cf8
    6a50:	00009cef 	.word	0x00009cef
    6a54:	40027000 	.word	0x40027000
    6a58:	20001158 	.word	0x20001158

00006a5c <nrfx_usbd_ep_stall_clear>:
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
    6a5c:	0603      	lsls	r3, r0, #24
{
    6a5e:	b510      	push	{r4, lr}
    6a60:	4604      	mov	r4, r0
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
    6a62:	d405      	bmi.n	6a70 <nrfx_usbd_ep_stall_clear+0x14>
    6a64:	f7ff fd42 	bl	64ec <nrfx_usbd_ep_stall_check>
    6a68:	b110      	cbz	r0, 6a70 <nrfx_usbd_ep_stall_clear+0x14>
        nrfx_usbd_transfer_out_drop(ep);
    6a6a:	4620      	mov	r0, r4
    6a6c:	f7ff fdd0 	bl	6610 <nrfx_usbd_transfer_out_drop>
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_UnStall << USBD_EPSTALL_STALL_Pos) | ep;
    6a70:	4b01      	ldr	r3, [pc, #4]	; (6a78 <nrfx_usbd_ep_stall_clear+0x1c>)
    6a72:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
}
    6a76:	bd10      	pop	{r4, pc}
    6a78:	40027000 	.word	0x40027000

00006a7c <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    6a7c:	4b0e      	ldr	r3, [pc, #56]	; (6ab8 <z_sys_init_run_level+0x3c>)
{
    6a7e:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    6a80:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    6a84:	3001      	adds	r0, #1
    6a86:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
    6a8a:	42a6      	cmp	r6, r4
    6a8c:	d800      	bhi.n	6a90 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
    6a8e:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
    6a90:	e9d4 3500 	ldrd	r3, r5, [r4]
    6a94:	4628      	mov	r0, r5
    6a96:	4798      	blx	r3
		if (dev != NULL) {
    6a98:	b165      	cbz	r5, 6ab4 <z_sys_init_run_level+0x38>
				dev->state->init_res = rc;
    6a9a:	68eb      	ldr	r3, [r5, #12]
			if (rc != 0) {
    6a9c:	b130      	cbz	r0, 6aac <z_sys_init_run_level+0x30>
				if (rc < 0) {
    6a9e:	2800      	cmp	r0, #0
    6aa0:	bfb8      	it	lt
    6aa2:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
    6aa4:	28ff      	cmp	r0, #255	; 0xff
    6aa6:	bfa8      	it	ge
    6aa8:	20ff      	movge	r0, #255	; 0xff
    6aaa:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
    6aac:	785a      	ldrb	r2, [r3, #1]
    6aae:	f042 0201 	orr.w	r2, r2, #1
    6ab2:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    6ab4:	3408      	adds	r4, #8
    6ab6:	e7e8      	b.n	6a8a <z_sys_init_run_level+0xe>
    6ab8:	00009c14 	.word	0x00009c14

00006abc <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
    6abc:	b570      	push	{r4, r5, r6, lr}
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
    6abe:	4605      	mov	r5, r0
    6ac0:	b910      	cbnz	r0, 6ac8 <z_impl_device_get_binding+0xc>
		return NULL;
    6ac2:	2400      	movs	r4, #0
			return dev;
		}
	}

	return NULL;
}
    6ac4:	4620      	mov	r0, r4
    6ac6:	bd70      	pop	{r4, r5, r6, pc}
	if ((name == NULL) || (name[0] == '\0')) {
    6ac8:	7803      	ldrb	r3, [r0, #0]
    6aca:	2b00      	cmp	r3, #0
    6acc:	d0f9      	beq.n	6ac2 <z_impl_device_get_binding+0x6>
	for (dev = __device_start; dev != __device_end; dev++) {
    6ace:	4c0e      	ldr	r4, [pc, #56]	; (6b08 <z_impl_device_get_binding+0x4c>)
    6ad0:	4e0e      	ldr	r6, [pc, #56]	; (6b0c <z_impl_device_get_binding+0x50>)
    6ad2:	42b4      	cmp	r4, r6
    6ad4:	d108      	bne.n	6ae8 <z_impl_device_get_binding+0x2c>
	for (dev = __device_start; dev != __device_end; dev++) {
    6ad6:	4c0c      	ldr	r4, [pc, #48]	; (6b08 <z_impl_device_get_binding+0x4c>)
    6ad8:	42b4      	cmp	r4, r6
    6ada:	d0f2      	beq.n	6ac2 <z_impl_device_get_binding+0x6>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    6adc:	4620      	mov	r0, r4
    6ade:	f002 fb60 	bl	91a2 <z_device_ready>
    6ae2:	b950      	cbnz	r0, 6afa <z_impl_device_get_binding+0x3e>
	for (dev = __device_start; dev != __device_end; dev++) {
    6ae4:	3418      	adds	r4, #24
    6ae6:	e7f7      	b.n	6ad8 <z_impl_device_get_binding+0x1c>
		if (z_device_ready(dev) && (dev->name == name)) {
    6ae8:	4620      	mov	r0, r4
    6aea:	f002 fb5a 	bl	91a2 <z_device_ready>
    6aee:	b110      	cbz	r0, 6af6 <z_impl_device_get_binding+0x3a>
    6af0:	6823      	ldr	r3, [r4, #0]
    6af2:	42ab      	cmp	r3, r5
    6af4:	d0e6      	beq.n	6ac4 <z_impl_device_get_binding+0x8>
	for (dev = __device_start; dev != __device_end; dev++) {
    6af6:	3418      	adds	r4, #24
    6af8:	e7eb      	b.n	6ad2 <z_impl_device_get_binding+0x16>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    6afa:	6821      	ldr	r1, [r4, #0]
    6afc:	4628      	mov	r0, r5
    6afe:	f001 fecf 	bl	88a0 <strcmp>
    6b02:	2800      	cmp	r0, #0
    6b04:	d1ee      	bne.n	6ae4 <z_impl_device_get_binding+0x28>
    6b06:	e7dd      	b.n	6ac4 <z_impl_device_get_binding+0x8>
    6b08:	00009818 	.word	0x00009818
    6b0c:	00009890 	.word	0x00009890

00006b10 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    6b10:	b530      	push	{r4, r5, lr}
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
    6b12:	2300      	movs	r3, #0
{
    6b14:	b087      	sub	sp, #28
	z_setup_new_thread(thread, stack,
    6b16:	2201      	movs	r2, #1
    6b18:	e9cd 2304 	strd	r2, r3, [sp, #16]
    6b1c:	220f      	movs	r2, #15
    6b1e:	e9cd 3202 	strd	r3, r2, [sp, #8]
    6b22:	9301      	str	r3, [sp, #4]
	struct k_thread *thread = &z_idle_threads[i];
    6b24:	4c0c      	ldr	r4, [pc, #48]	; (6b58 <init_idle_thread+0x48>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    6b26:	4b0d      	ldr	r3, [pc, #52]	; (6b5c <init_idle_thread+0x4c>)
	z_setup_new_thread(thread, stack,
    6b28:	490d      	ldr	r1, [pc, #52]	; (6b60 <init_idle_thread+0x50>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    6b2a:	2218      	movs	r2, #24
	struct k_thread *thread = &z_idle_threads[i];
    6b2c:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    6b30:	fb02 3300 	mla	r3, r2, r0, r3
	z_setup_new_thread(thread, stack,
    6b34:	f44f 75b0 	mov.w	r5, #352	; 0x160
    6b38:	9300      	str	r3, [sp, #0]
    6b3a:	fb05 1100 	mla	r1, r5, r0, r1
    6b3e:	4b09      	ldr	r3, [pc, #36]	; (6b64 <init_idle_thread+0x54>)
    6b40:	f44f 72a0 	mov.w	r2, #320	; 0x140
    6b44:	4620      	mov	r0, r4
    6b46:	f000 f8f5 	bl	6d34 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    6b4a:	7b63      	ldrb	r3, [r4, #13]
    6b4c:	f023 0304 	bic.w	r3, r3, #4
    6b50:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    6b52:	b007      	add	sp, #28
    6b54:	bd30      	pop	{r4, r5, pc}
    6b56:	bf00      	nop
    6b58:	20000418 	.word	0x20000418
    6b5c:	20001330 	.word	0x20001330
    6b60:	20002020 	.word	0x20002020
    6b64:	00006ea9 	.word	0x00006ea9

00006b68 <bg_thread_main>:
{
    6b68:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
    6b6a:	4b0a      	ldr	r3, [pc, #40]	; (6b94 <bg_thread_main+0x2c>)
    6b6c:	2201      	movs	r2, #1
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    6b6e:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
    6b70:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    6b72:	f7ff ff83 	bl	6a7c <z_sys_init_run_level>
	boot_banner();
    6b76:	f001 f8df 	bl	7d38 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    6b7a:	2003      	movs	r0, #3
    6b7c:	f7ff ff7e 	bl	6a7c <z_sys_init_run_level>
	z_init_static_threads();
    6b80:	f000 f936 	bl	6df0 <z_init_static_threads>
	main();
    6b84:	f7fa fc2a 	bl	13dc <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    6b88:	4a03      	ldr	r2, [pc, #12]	; (6b98 <bg_thread_main+0x30>)
    6b8a:	7b13      	ldrb	r3, [r2, #12]
    6b8c:	f023 0301 	bic.w	r3, r3, #1
    6b90:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    6b92:	bd08      	pop	{r3, pc}
    6b94:	200013a9 	.word	0x200013a9
    6b98:	20000498 	.word	0x20000498

00006b9c <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    6b9c:	4802      	ldr	r0, [pc, #8]	; (6ba8 <z_bss_zero+0xc>)
    6b9e:	4a03      	ldr	r2, [pc, #12]	; (6bac <z_bss_zero+0x10>)
    6ba0:	2100      	movs	r1, #0
    6ba2:	1a12      	subs	r2, r2, r0
    6ba4:	f001 be93 	b.w	88ce <memset>
    6ba8:	200002d8 	.word	0x200002d8
    6bac:	200013ac 	.word	0x200013ac

00006bb0 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    6bb0:	b580      	push	{r7, lr}
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
    6bb2:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 6c74 <z_cstart+0xc4>
    6bb6:	b0a6      	sub	sp, #152	; 0x98
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    6bb8:	f388 8808 	msr	MSP, r8
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    6bbc:	4d2e      	ldr	r5, [pc, #184]	; (6c78 <z_cstart+0xc8>)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    6bbe:	4e2f      	ldr	r6, [pc, #188]	; (6c7c <z_cstart+0xcc>)
    6bc0:	696b      	ldr	r3, [r5, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    6bc2:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 6c80 <z_cstart+0xd0>
    6bc6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    6bca:	2400      	movs	r4, #0
    6bcc:	616b      	str	r3, [r5, #20]
    6bce:	23e0      	movs	r3, #224	; 0xe0
    6bd0:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
    6bd4:	77ec      	strb	r4, [r5, #31]
    6bd6:	762c      	strb	r4, [r5, #24]
    6bd8:	766c      	strb	r4, [r5, #25]
    6bda:	76ac      	strb	r4, [r5, #26]
    6bdc:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    6be0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    6be2:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    6be6:	626b      	str	r3, [r5, #36]	; 0x24
    6be8:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    6bec:	f7fc fcfe 	bl	35ec <z_arm_fault_init>
	z_arm_cpu_idle_init();
    6bf0:	f7fc faba 	bl	3168 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    6bf4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6bf8:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    6bfa:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
    6bfc:	f7fc fdd4 	bl	37a8 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    6c00:	f7fc fd3c 	bl	367c <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
    6c04:	f240 1301 	movw	r3, #257	; 0x101
    6c08:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
    6c0c:	ab06      	add	r3, sp, #24
    6c0e:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
    6c10:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    6c14:	f002 fac4 	bl	91a0 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    6c18:	4620      	mov	r0, r4
    6c1a:	f7ff ff2f 	bl	6a7c <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    6c1e:	2001      	movs	r0, #1
	_kernel.ready_q.cache = &z_main_thread;
    6c20:	4d18      	ldr	r5, [pc, #96]	; (6c84 <z_cstart+0xd4>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    6c22:	f7ff ff2b 	bl	6a7c <z_sys_init_run_level>
	z_sched_init();
    6c26:	f000 fdeb 	bl	7800 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    6c2a:	4b17      	ldr	r3, [pc, #92]	; (6c88 <z_cstart+0xd8>)
    6c2c:	9305      	str	r3, [sp, #20]
    6c2e:	2301      	movs	r3, #1
    6c30:	4916      	ldr	r1, [pc, #88]	; (6c8c <z_cstart+0xdc>)
    6c32:	9400      	str	r4, [sp, #0]
    6c34:	e9cd 4303 	strd	r4, r3, [sp, #12]
    6c38:	f44f 6280 	mov.w	r2, #1024	; 0x400
    6c3c:	464b      	mov	r3, r9
    6c3e:	e9cd 4401 	strd	r4, r4, [sp, #4]
    6c42:	4628      	mov	r0, r5
	_kernel.ready_q.cache = &z_main_thread;
    6c44:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    6c46:	f000 f875 	bl	6d34 <z_setup_new_thread>
    6c4a:	7b6a      	ldrb	r2, [r5, #13]
    6c4c:	4607      	mov	r7, r0
    6c4e:	f022 0204 	bic.w	r2, r2, #4
	z_ready_thread(&z_main_thread);
    6c52:	4628      	mov	r0, r5
    6c54:	736a      	strb	r2, [r5, #13]
    6c56:	f002 fc1c 	bl	9492 <z_ready_thread>
		init_idle_thread(i);
    6c5a:	4620      	mov	r0, r4
    6c5c:	f7ff ff58 	bl	6b10 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    6c60:	4b0b      	ldr	r3, [pc, #44]	; (6c90 <z_cstart+0xe0>)
    6c62:	60f3      	str	r3, [r6, #12]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    6c64:	464a      	mov	r2, r9
    6c66:	4639      	mov	r1, r7
    6c68:	4628      	mov	r0, r5
		_kernel.cpus[i].id = i;
    6c6a:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
    6c6c:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    6c70:	f7fc fb90 	bl	3394 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    6c74:	200029a0 	.word	0x200029a0
    6c78:	e000ed00 	.word	0xe000ed00
    6c7c:	20001330 	.word	0x20001330
    6c80:	00006b69 	.word	0x00006b69
    6c84:	20000498 	.word	0x20000498
    6c88:	00009d01 	.word	0x00009d01
    6c8c:	20001c00 	.word	0x20001c00
    6c90:	20000418 	.word	0x20000418

00006c94 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
    6c94:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    6c96:	4b0e      	ldr	r3, [pc, #56]	; (6cd0 <init_mem_slab_module+0x3c>)
    6c98:	4c0e      	ldr	r4, [pc, #56]	; (6cd4 <init_mem_slab_module+0x40>)
    6c9a:	42a3      	cmp	r3, r4
    6c9c:	d301      	bcc.n	6ca2 <init_mem_slab_module+0xe>
			goto out;
		}
		z_object_init(slab);
	}

out:
    6c9e:	2000      	movs	r0, #0
	return rc;
}
    6ca0:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    6ca2:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
    6ca6:	ea41 0200 	orr.w	r2, r1, r0
    6caa:	f012 0203 	ands.w	r2, r2, #3
    6cae:	d10b      	bne.n	6cc8 <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
    6cb0:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
    6cb2:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    6cb4:	42aa      	cmp	r2, r5
    6cb6:	d101      	bne.n	6cbc <init_mem_slab_module+0x28>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    6cb8:	331c      	adds	r3, #28
    6cba:	e7ee      	b.n	6c9a <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
    6cbc:	695e      	ldr	r6, [r3, #20]
    6cbe:	600e      	str	r6, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
    6cc0:	3201      	adds	r2, #1
		slab->free_list = p;
    6cc2:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
    6cc4:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
    6cc6:	e7f5      	b.n	6cb4 <init_mem_slab_module+0x20>
	return rc;
    6cc8:	f06f 0015 	mvn.w	r0, #21
    6ccc:	e7e8      	b.n	6ca0 <init_mem_slab_module+0xc>
    6cce:	bf00      	nop
    6cd0:	200001ac 	.word	0x200001ac
    6cd4:	200001c8 	.word	0x200001c8

00006cd8 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
    6cd8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    6cda:	460c      	mov	r4, r1
	__asm__ volatile(
    6cdc:	f04f 0520 	mov.w	r5, #32
    6ce0:	f3ef 8111 	mrs	r1, BASEPRI
    6ce4:	f385 8812 	msr	BASEPRI_MAX, r5
    6ce8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
    6cec:	6945      	ldr	r5, [r0, #20]
    6cee:	b15d      	cbz	r5, 6d08 <k_mem_slab_alloc+0x30>
		/* take a free block */
		*mem = slab->free_list;
    6cf0:	6025      	str	r5, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
    6cf2:	682b      	ldr	r3, [r5, #0]
    6cf4:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    6cf6:	6983      	ldr	r3, [r0, #24]
    6cf8:	3301      	adds	r3, #1
    6cfa:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
    6cfc:	2000      	movs	r0, #0
	__asm__ volatile(
    6cfe:	f381 8811 	msr	BASEPRI, r1
    6d02:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
    6d06:	e011      	b.n	6d2c <k_mem_slab_alloc+0x54>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
    6d08:	ea52 0c03 	orrs.w	ip, r2, r3
    6d0c:	d103      	bne.n	6d16 <k_mem_slab_alloc+0x3e>
		*mem = NULL;
    6d0e:	6025      	str	r5, [r4, #0]
		result = -ENOMEM;
    6d10:	f06f 000b 	mvn.w	r0, #11
    6d14:	e7f3      	b.n	6cfe <k_mem_slab_alloc+0x26>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
    6d16:	e9cd 2300 	strd	r2, r3, [sp]
    6d1a:	4602      	mov	r2, r0
    6d1c:	3008      	adds	r0, #8
    6d1e:	f000 fcc5 	bl	76ac <z_pend_curr>
		if (result == 0) {
    6d22:	b918      	cbnz	r0, 6d2c <k_mem_slab_alloc+0x54>
			*mem = _current->base.swap_data;
    6d24:	4b02      	ldr	r3, [pc, #8]	; (6d30 <k_mem_slab_alloc+0x58>)
    6d26:	689b      	ldr	r3, [r3, #8]
    6d28:	695b      	ldr	r3, [r3, #20]
    6d2a:	6023      	str	r3, [r4, #0]
}
    6d2c:	b003      	add	sp, #12
    6d2e:	bd30      	pop	{r4, r5, pc}
    6d30:	20001330 	.word	0x20001330

00006d34 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    6d34:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    6d38:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    6d3a:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
    6d3c:	2604      	movs	r6, #4
    6d3e:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
    6d40:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    6d42:	7386      	strb	r6, [r0, #14]
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    6d44:	f100 0558 	add.w	r5, r0, #88	; 0x58
{
    6d48:	460f      	mov	r7, r1
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    6d4a:	1dd6      	adds	r6, r2, #7
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
    6d4c:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    6d50:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	thread_base->pended_on = NULL;
    6d52:	2500      	movs	r5, #0
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    6d54:	f026 0607 	bic.w	r6, r6, #7

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
    6d58:	3720      	adds	r7, #32
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
    6d5a:	e9c0 5506 	strd	r5, r5, [r0, #24]
	new_thread->stack_info.size = stack_buf_size;
    6d5e:	e9c0 7619 	strd	r7, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
    6d62:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
    6d64:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
    6d66:	66c5      	str	r5, [r0, #108]	; 0x6c
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    6d68:	f106 0820 	add.w	r8, r6, #32
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    6d6c:	9202      	str	r2, [sp, #8]
    6d6e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    6d70:	9201      	str	r2, [sp, #4]
	stack_ptr = (char *)stack + stack_obj_size;
    6d72:	4488      	add	r8, r1
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    6d74:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    6d76:	9200      	str	r2, [sp, #0]
    6d78:	4642      	mov	r2, r8
{
    6d7a:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    6d7c:	f7fc fad8 	bl	3330 <arch_new_thread>
	if (!_current) {
    6d80:	4b04      	ldr	r3, [pc, #16]	; (6d94 <z_setup_new_thread+0x60>)
	new_thread->init_data = NULL;
    6d82:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
    6d84:	689b      	ldr	r3, [r3, #8]
    6d86:	b103      	cbz	r3, 6d8a <z_setup_new_thread+0x56>
	new_thread->resource_pool = _current->resource_pool;
    6d88:	6f1b      	ldr	r3, [r3, #112]	; 0x70
	return stack_ptr;
    6d8a:	6723      	str	r3, [r4, #112]	; 0x70
}
    6d8c:	4640      	mov	r0, r8
    6d8e:	b004      	add	sp, #16
    6d90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6d94:	20001330 	.word	0x20001330

00006d98 <z_impl_k_thread_create>:
{
    6d98:	b5f0      	push	{r4, r5, r6, r7, lr}
    6d9a:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    6d9c:	2700      	movs	r7, #0
    6d9e:	9705      	str	r7, [sp, #20]
    6da0:	9f10      	ldr	r7, [sp, #64]	; 0x40
    6da2:	9704      	str	r7, [sp, #16]
    6da4:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    6da6:	9703      	str	r7, [sp, #12]
    6da8:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    6daa:	9702      	str	r7, [sp, #8]
{
    6dac:	e9dd 6512 	ldrd	r6, r5, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    6db0:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    6db2:	9701      	str	r7, [sp, #4]
    6db4:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    6db6:	9700      	str	r7, [sp, #0]
{
    6db8:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    6dba:	f7ff ffbb 	bl	6d34 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    6dbe:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
    6dc2:	bf08      	it	eq
    6dc4:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
    6dc8:	d005      	beq.n	6dd6 <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    6dca:	ea55 0306 	orrs.w	r3, r5, r6
    6dce:	d105      	bne.n	6ddc <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
    6dd0:	4620      	mov	r0, r4
    6dd2:	f000 fc0f 	bl	75f4 <z_sched_start>
}
    6dd6:	4620      	mov	r0, r4
    6dd8:	b007      	add	sp, #28
    6dda:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    6ddc:	4903      	ldr	r1, [pc, #12]	; (6dec <z_impl_k_thread_create+0x54>)
    6dde:	4632      	mov	r2, r6
    6de0:	462b      	mov	r3, r5
    6de2:	f104 0018 	add.w	r0, r4, #24
    6de6:	f000 fe99 	bl	7b1c <z_add_timeout>
    6dea:	e7f4      	b.n	6dd6 <z_impl_k_thread_create+0x3e>
    6dec:	000094b3 	.word	0x000094b3

00006df0 <z_init_static_threads>:
{
    6df0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6df4:	4c29      	ldr	r4, [pc, #164]	; (6e9c <z_init_static_threads+0xac>)
	_FOREACH_STATIC_THREAD(thread_data) {
    6df6:	4d2a      	ldr	r5, [pc, #168]	; (6ea0 <z_init_static_threads+0xb0>)
{
    6df8:	b087      	sub	sp, #28
    6dfa:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
    6dfc:	42ae      	cmp	r6, r5
    6dfe:	f104 0430 	add.w	r4, r4, #48	; 0x30
    6e02:	d30f      	bcc.n	6e24 <z_init_static_threads+0x34>
	k_sched_lock();
    6e04:	f000 fb12 	bl	742c <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    6e08:	4c24      	ldr	r4, [pc, #144]	; (6e9c <z_init_static_threads+0xac>)
    6e0a:	f8df 9098 	ldr.w	r9, [pc, #152]	; 6ea4 <z_init_static_threads+0xb4>
		} else {
			return (t * to_hz + off) / from_hz;
    6e0e:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    6e12:	f240 37e7 	movw	r7, #999	; 0x3e7
    6e16:	42ac      	cmp	r4, r5
    6e18:	d320      	bcc.n	6e5c <z_init_static_threads+0x6c>
}
    6e1a:	b007      	add	sp, #28
    6e1c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
    6e20:	f000 bcd2 	b.w	77c8 <k_sched_unlock>
		z_setup_new_thread(
    6e24:	f854 3c04 	ldr.w	r3, [r4, #-4]
    6e28:	9305      	str	r3, [sp, #20]
    6e2a:	f854 3c10 	ldr.w	r3, [r4, #-16]
    6e2e:	9304      	str	r3, [sp, #16]
    6e30:	f854 3c14 	ldr.w	r3, [r4, #-20]
    6e34:	9303      	str	r3, [sp, #12]
    6e36:	f854 3c18 	ldr.w	r3, [r4, #-24]
    6e3a:	9302      	str	r3, [sp, #8]
    6e3c:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    6e40:	9301      	str	r3, [sp, #4]
    6e42:	f854 3c20 	ldr.w	r3, [r4, #-32]
    6e46:	9300      	str	r3, [sp, #0]
    6e48:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
    6e4c:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
    6e50:	f7ff ff70 	bl	6d34 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    6e54:	f854 3c30 	ldr.w	r3, [r4, #-48]
    6e58:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
    6e5a:	e7ce      	b.n	6dfa <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    6e5c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    6e5e:	1c5a      	adds	r2, r3, #1
    6e60:	d00d      	beq.n	6e7e <z_init_static_threads+0x8e>
					    K_MSEC(thread_data->init_delay));
    6e62:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    6e66:	2100      	movs	r1, #0
    6e68:	4638      	mov	r0, r7
    6e6a:	fbc3 0106 	smlal	r0, r1, r3, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    6e6e:	ea51 33c3 	orrs.w	r3, r1, r3, lsl #15
			schedule_new_thread(thread_data->init_thread,
    6e72:	f8d4 8000 	ldr.w	r8, [r4]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    6e76:	d104      	bne.n	6e82 <z_init_static_threads+0x92>
	z_sched_start(thread);
    6e78:	4640      	mov	r0, r8
    6e7a:	f000 fbbb 	bl	75f4 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    6e7e:	3430      	adds	r4, #48	; 0x30
    6e80:	e7c9      	b.n	6e16 <z_init_static_threads+0x26>
    6e82:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    6e86:	2300      	movs	r3, #0
    6e88:	f7fa f93a 	bl	1100 <__aeabi_uldivmod>
    6e8c:	4602      	mov	r2, r0
    6e8e:	460b      	mov	r3, r1
    6e90:	f108 0018 	add.w	r0, r8, #24
    6e94:	4649      	mov	r1, r9
    6e96:	f000 fe41 	bl	7b1c <z_add_timeout>
    6e9a:	e7f0      	b.n	6e7e <z_init_static_threads+0x8e>
    6e9c:	200001ac 	.word	0x200001ac
    6ea0:	200001ac 	.word	0x200001ac
    6ea4:	000094b3 	.word	0x000094b3

00006ea8 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    6ea8:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
    6eaa:	4c09      	ldr	r4, [pc, #36]	; (6ed0 <idle+0x28>)
	__asm__ volatile(
    6eac:	f04f 0220 	mov.w	r2, #32
    6eb0:	f3ef 8311 	mrs	r3, BASEPRI
    6eb4:	f382 8812 	msr	BASEPRI_MAX, r2
    6eb8:	f3bf 8f6f 	isb	sy
    6ebc:	f002 fba0 	bl	9600 <z_get_next_timeout_expiry>
    6ec0:	61a0      	str	r0, [r4, #24]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (pm_system_suspend(_kernel.idle) == false) {
    6ec2:	f7fc f8d1 	bl	3068 <pm_system_suspend>
    6ec6:	2800      	cmp	r0, #0
    6ec8:	d1f0      	bne.n	6eac <idle+0x4>
	arch_cpu_idle();
    6eca:	f7fc f953 	bl	3174 <arch_cpu_idle>
}
    6ece:	e7ed      	b.n	6eac <idle+0x4>
    6ed0:	20001330 	.word	0x20001330

00006ed4 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    6ed4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    6ed8:	4604      	mov	r4, r0
    6eda:	4617      	mov	r7, r2
    6edc:	461e      	mov	r6, r3
    6ede:	f04f 0320 	mov.w	r3, #32
    6ee2:	f3ef 8811 	mrs	r8, BASEPRI
    6ee6:	f383 8812 	msr	BASEPRI_MAX, r3
    6eea:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    6eee:	68c3      	ldr	r3, [r0, #12]
    6ef0:	4a32      	ldr	r2, [pc, #200]	; (6fbc <z_impl_k_mutex_lock+0xe8>)
    6ef2:	b16b      	cbz	r3, 6f10 <z_impl_k_mutex_lock+0x3c>
    6ef4:	6880      	ldr	r0, [r0, #8]
    6ef6:	6891      	ldr	r1, [r2, #8]
    6ef8:	4288      	cmp	r0, r1
    6efa:	d019      	beq.n	6f30 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    6efc:	ea57 0306 	orrs.w	r3, r7, r6
    6f00:	d118      	bne.n	6f34 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
    6f02:	f388 8811 	msr	BASEPRI, r8
    6f06:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
    6f0a:	f06f 000f 	mvn.w	r0, #15
    6f0e:	e00c      	b.n	6f2a <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
    6f10:	6891      	ldr	r1, [r2, #8]
    6f12:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    6f16:	6121      	str	r1, [r4, #16]
		mutex->lock_count++;
    6f18:	3301      	adds	r3, #1
    6f1a:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
    6f1c:	6893      	ldr	r3, [r2, #8]
    6f1e:	60a3      	str	r3, [r4, #8]
    6f20:	f388 8811 	msr	BASEPRI, r8
    6f24:	f3bf 8f6f 	isb	sy
		return 0;
    6f28:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
    6f2a:	b002      	add	sp, #8
    6f2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
    6f30:	6921      	ldr	r1, [r4, #16]
    6f32:	e7f0      	b.n	6f16 <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
    6f34:	f991 100e 	ldrsb.w	r1, [r1, #14]
    6f38:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
    6f3c:	4299      	cmp	r1, r3
    6f3e:	bfa8      	it	ge
    6f40:	4619      	movge	r1, r3
    6f42:	f06f 027e 	mvn.w	r2, #126	; 0x7e
    6f46:	4291      	cmp	r1, r2
    6f48:	bfb8      	it	lt
    6f4a:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    6f4c:	428b      	cmp	r3, r1
    6f4e:	dd2e      	ble.n	6fae <z_impl_k_mutex_lock+0xda>
		resched = adjust_owner_prio(mutex, new_prio);
    6f50:	f002 f993 	bl	927a <adjust_owner_prio.isra.0>
    6f54:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    6f56:	e9cd 7600 	strd	r7, r6, [sp]
    6f5a:	4819      	ldr	r0, [pc, #100]	; (6fc0 <z_impl_k_mutex_lock+0xec>)
    6f5c:	4622      	mov	r2, r4
    6f5e:	4641      	mov	r1, r8
    6f60:	f000 fba4 	bl	76ac <z_pend_curr>
	if (got_mutex == 0) {
    6f64:	2800      	cmp	r0, #0
    6f66:	d0e0      	beq.n	6f2a <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
    6f68:	f04f 0320 	mov.w	r3, #32
    6f6c:	f3ef 8611 	mrs	r6, BASEPRI
    6f70:	f383 8812 	msr	BASEPRI_MAX, r3
    6f74:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    6f78:	6823      	ldr	r3, [r4, #0]
    6f7a:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6f7c:	429c      	cmp	r4, r3
    6f7e:	d00a      	beq.n	6f96 <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    6f80:	b14b      	cbz	r3, 6f96 <z_impl_k_mutex_lock+0xc2>
    6f82:	f993 300e 	ldrsb.w	r3, [r3, #14]
    6f86:	4299      	cmp	r1, r3
    6f88:	bfa8      	it	ge
    6f8a:	4619      	movge	r1, r3
    6f8c:	f06f 037e 	mvn.w	r3, #126	; 0x7e
    6f90:	4299      	cmp	r1, r3
    6f92:	bfb8      	it	lt
    6f94:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    6f96:	68a0      	ldr	r0, [r4, #8]
    6f98:	f002 f96f 	bl	927a <adjust_owner_prio.isra.0>
    6f9c:	b900      	cbnz	r0, 6fa0 <z_impl_k_mutex_lock+0xcc>
	if (resched) {
    6f9e:	b145      	cbz	r5, 6fb2 <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
    6fa0:	4807      	ldr	r0, [pc, #28]	; (6fc0 <z_impl_k_mutex_lock+0xec>)
    6fa2:	4631      	mov	r1, r6
    6fa4:	f000 fa30 	bl	7408 <z_reschedule>
	return -EAGAIN;
    6fa8:	f06f 000a 	mvn.w	r0, #10
    6fac:	e7bd      	b.n	6f2a <z_impl_k_mutex_lock+0x56>
	bool resched = false;
    6fae:	2500      	movs	r5, #0
    6fb0:	e7d1      	b.n	6f56 <z_impl_k_mutex_lock+0x82>
	__asm__ volatile(
    6fb2:	f386 8811 	msr	BASEPRI, r6
    6fb6:	f3bf 8f6f 	isb	sy
    6fba:	e7f5      	b.n	6fa8 <z_impl_k_mutex_lock+0xd4>
    6fbc:	20001330 	.word	0x20001330
    6fc0:	200013aa 	.word	0x200013aa

00006fc4 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    6fc4:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
    6fc6:	6883      	ldr	r3, [r0, #8]
{
    6fc8:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
    6fca:	2b00      	cmp	r3, #0
    6fcc:	d032      	beq.n	7034 <z_impl_k_mutex_unlock+0x70>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    6fce:	4a1c      	ldr	r2, [pc, #112]	; (7040 <z_impl_k_mutex_unlock+0x7c>)
    6fd0:	6892      	ldr	r2, [r2, #8]
    6fd2:	4293      	cmp	r3, r2
    6fd4:	d131      	bne.n	703a <z_impl_k_mutex_unlock+0x76>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    6fd6:	7bda      	ldrb	r2, [r3, #15]
    6fd8:	3a01      	subs	r2, #1
    6fda:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
    6fdc:	68c3      	ldr	r3, [r0, #12]
    6fde:	2b01      	cmp	r3, #1
    6fe0:	d905      	bls.n	6fee <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
    6fe2:	3b01      	subs	r3, #1
    6fe4:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
    6fe6:	f000 fbef 	bl	77c8 <k_sched_unlock>

	return 0;
    6fea:	2000      	movs	r0, #0
}
    6fec:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
    6fee:	f04f 0320 	mov.w	r3, #32
    6ff2:	f3ef 8511 	mrs	r5, BASEPRI
    6ff6:	f383 8812 	msr	BASEPRI_MAX, r3
    6ffa:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    6ffe:	6901      	ldr	r1, [r0, #16]
    7000:	6880      	ldr	r0, [r0, #8]
    7002:	f002 f93a 	bl	927a <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    7006:	4620      	mov	r0, r4
    7008:	f002 fa9f 	bl	954a <z_unpend_first_thread>
	mutex->owner = new_owner;
    700c:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
    700e:	b158      	cbz	r0, 7028 <z_impl_k_mutex_unlock+0x64>
		mutex->owner_orig_prio = new_owner->base.prio;
    7010:	f990 200e 	ldrsb.w	r2, [r0, #14]
    7014:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    7016:	2200      	movs	r2, #0
    7018:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
    701a:	f002 fa3a 	bl	9492 <z_ready_thread>
		z_reschedule(&lock, key);
    701e:	4809      	ldr	r0, [pc, #36]	; (7044 <z_impl_k_mutex_unlock+0x80>)
    7020:	4629      	mov	r1, r5
    7022:	f000 f9f1 	bl	7408 <z_reschedule>
    7026:	e7de      	b.n	6fe6 <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
    7028:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    702a:	f385 8811 	msr	BASEPRI, r5
    702e:	f3bf 8f6f 	isb	sy
    7032:	e7d8      	b.n	6fe6 <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
    7034:	f06f 0015 	mvn.w	r0, #21
    7038:	e7d8      	b.n	6fec <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
    703a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    703e:	e7d5      	b.n	6fec <z_impl_k_mutex_unlock+0x28>
    7040:	20001330 	.word	0x20001330
    7044:	200013aa 	.word	0x200013aa

00007048 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
    7048:	b537      	push	{r0, r1, r2, r4, r5, lr}
    704a:	4611      	mov	r1, r2
	__asm__ volatile(
    704c:	f04f 0220 	mov.w	r2, #32
    7050:	f3ef 8511 	mrs	r5, BASEPRI
    7054:	f382 8812 	msr	BASEPRI_MAX, r2
    7058:	f3bf 8f6f 	isb	sy
    705c:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
    705e:	b19c      	cbz	r4, 7088 <z_impl_k_queue_get+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    7060:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    7062:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    7064:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    7068:	4294      	cmp	r4, r2
	list->head = node;
    706a:	6003      	str	r3, [r0, #0]
	list->tail = node;
    706c:	bf08      	it	eq
    706e:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
    7070:	2101      	movs	r1, #1
    7072:	4620      	mov	r0, r4
    7074:	f002 f970 	bl	9358 <z_queue_node_peek>
    7078:	4604      	mov	r4, r0
	__asm__ volatile(
    707a:	f385 8811 	msr	BASEPRI, r5
    707e:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
    7082:	4620      	mov	r0, r4
    7084:	b003      	add	sp, #12
    7086:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    7088:	ea51 0203 	orrs.w	r2, r1, r3
    708c:	d0f5      	beq.n	707a <z_impl_k_queue_get+0x32>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    708e:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
    7092:	e9cd 1300 	strd	r1, r3, [sp]
    7096:	4610      	mov	r0, r2
    7098:	4629      	mov	r1, r5
    709a:	f000 fb07 	bl	76ac <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
    709e:	2800      	cmp	r0, #0
    70a0:	d1ef      	bne.n	7082 <z_impl_k_queue_get+0x3a>
    70a2:	4b02      	ldr	r3, [pc, #8]	; (70ac <z_impl_k_queue_get+0x64>)
    70a4:	689b      	ldr	r3, [r3, #8]
    70a6:	695c      	ldr	r4, [r3, #20]
    70a8:	e7eb      	b.n	7082 <z_impl_k_queue_get+0x3a>
    70aa:	bf00      	nop
    70ac:	20001330 	.word	0x20001330

000070b0 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    70b0:	b538      	push	{r3, r4, r5, lr}
    70b2:	4604      	mov	r4, r0
	__asm__ volatile(
    70b4:	f04f 0320 	mov.w	r3, #32
    70b8:	f3ef 8511 	mrs	r5, BASEPRI
    70bc:	f383 8812 	msr	BASEPRI_MAX, r3
    70c0:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    70c4:	f002 fa41 	bl	954a <z_unpend_first_thread>

	if (thread != NULL) {
    70c8:	b148      	cbz	r0, 70de <z_impl_k_sem_give+0x2e>
    70ca:	2200      	movs	r2, #0
    70cc:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    70ce:	f002 f9e0 	bl	9492 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    70d2:	4629      	mov	r1, r5
    70d4:	4805      	ldr	r0, [pc, #20]	; (70ec <z_impl_k_sem_give+0x3c>)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    70d6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
    70da:	f000 b995 	b.w	7408 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    70de:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    70e2:	429a      	cmp	r2, r3
    70e4:	bf18      	it	ne
    70e6:	3301      	addne	r3, #1
    70e8:	60a3      	str	r3, [r4, #8]
}
    70ea:	e7f2      	b.n	70d2 <z_impl_k_sem_give+0x22>
    70ec:	200013aa 	.word	0x200013aa

000070f0 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    70f0:	b513      	push	{r0, r1, r4, lr}
    70f2:	f04f 0420 	mov.w	r4, #32
    70f6:	f3ef 8111 	mrs	r1, BASEPRI
    70fa:	f384 8812 	msr	BASEPRI_MAX, r4
    70fe:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    7102:	6884      	ldr	r4, [r0, #8]
    7104:	b144      	cbz	r4, 7118 <z_impl_k_sem_take+0x28>
		sem->count--;
    7106:	3c01      	subs	r4, #1
    7108:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
    710a:	f381 8811 	msr	BASEPRI, r1
    710e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
    7112:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    7114:	b002      	add	sp, #8
    7116:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    7118:	ea52 0403 	orrs.w	r4, r2, r3
    711c:	d106      	bne.n	712c <z_impl_k_sem_take+0x3c>
    711e:	f381 8811 	msr	BASEPRI, r1
    7122:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
    7126:	f06f 000f 	mvn.w	r0, #15
    712a:	e7f3      	b.n	7114 <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    712c:	e9cd 2300 	strd	r2, r3, [sp]
    7130:	4602      	mov	r2, r0
    7132:	4802      	ldr	r0, [pc, #8]	; (713c <z_impl_k_sem_take+0x4c>)
    7134:	f000 faba 	bl	76ac <z_pend_curr>
	return ret;
    7138:	e7ec      	b.n	7114 <z_impl_k_sem_take+0x24>
    713a:	bf00      	nop
    713c:	200013aa 	.word	0x200013aa

00007140 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
    7140:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return list->head;
    7144:	4e47      	ldr	r6, [pc, #284]	; (7264 <work_queue_main+0x124>)
    7146:	b085      	sub	sp, #20
    7148:	4604      	mov	r4, r0
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
    714a:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    714e:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	__asm__ volatile(
    7152:	f04f 0320 	mov.w	r3, #32
    7156:	f3ef 8711 	mrs	r7, BASEPRI
    715a:	f383 8812 	msr	BASEPRI_MAX, r3
    715e:	f3bf 8f6f 	isb	sy
    7162:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    7166:	b98d      	cbnz	r5, 718c <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
    7168:	2102      	movs	r1, #2
    716a:	f104 0098 	add.w	r0, r4, #152	; 0x98
    716e:	f002 f916 	bl	939e <flag_test_and_clear>
    7172:	2800      	cmp	r0, #0
    7174:	d135      	bne.n	71e2 <work_queue_main+0xa2>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
    7176:	2300      	movs	r3, #0
    7178:	e9cd 8900 	strd	r8, r9, [sp]
    717c:	9302      	str	r3, [sp, #8]
    717e:	f104 0288 	add.w	r2, r4, #136	; 0x88
    7182:	4639      	mov	r1, r7
    7184:	4838      	ldr	r0, [pc, #224]	; (7268 <work_queue_main+0x128>)
    7186:	f000 fc51 	bl	7a2c <z_sched_wait>
			continue;
    718a:	e7e2      	b.n	7152 <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    718c:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	return node->next;
    7190:	682b      	ldr	r3, [r5, #0]
	list->head = node;
    7192:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    7196:	4295      	cmp	r5, r2
    7198:	d101      	bne.n	719e <work_queue_main+0x5e>
	list->tail = node;
    719a:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	*flagp |= BIT(bit);
    719e:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    71a2:	f043 0302 	orr.w	r3, r3, #2
    71a6:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*flagp &= ~BIT(bit);
    71aa:	68eb      	ldr	r3, [r5, #12]
    71ac:	f023 0304 	bic.w	r3, r3, #4
    71b0:	f043 0301 	orr.w	r3, r3, #1
    71b4:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
    71b6:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
    71b8:	f387 8811 	msr	BASEPRI, r7
    71bc:	f3bf 8f6f 	isb	sy
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
		handler(work);
    71c0:	4628      	mov	r0, r5
    71c2:	4798      	blx	r3
	__asm__ volatile(
    71c4:	f04f 0320 	mov.w	r3, #32
    71c8:	f3ef 8b11 	mrs	fp, BASEPRI
    71cc:	f383 8812 	msr	BASEPRI_MAX, r3
    71d0:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
    71d4:	68eb      	ldr	r3, [r5, #12]
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    71d6:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
    71d8:	f023 0201 	bic.w	r2, r3, #1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    71dc:	d40b      	bmi.n	71f6 <work_queue_main+0xb6>
	*flagp &= ~BIT(bit);
    71de:	60ea      	str	r2, [r5, #12]
    71e0:	e00e      	b.n	7200 <work_queue_main+0xc0>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
    71e2:	f104 0590 	add.w	r5, r4, #144	; 0x90
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
    71e6:	2200      	movs	r2, #0
    71e8:	2101      	movs	r1, #1
    71ea:	4628      	mov	r0, r5
    71ec:	f002 f9d5 	bl	959a <z_sched_wake>
    71f0:	2800      	cmp	r0, #0
    71f2:	d1f8      	bne.n	71e6 <work_queue_main+0xa6>
    71f4:	e7bf      	b.n	7176 <work_queue_main+0x36>
	return list->head;
    71f6:	6830      	ldr	r0, [r6, #0]
	*flagp &= ~BIT(bit);
    71f8:	f023 0303 	bic.w	r3, r3, #3
    71fc:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    71fe:	b970      	cbnz	r0, 721e <work_queue_main+0xde>
	*flagp &= ~BIT(bit);
    7200:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    7204:	f023 0302 	bic.w	r3, r3, #2
    7208:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	__asm__ volatile(
    720c:	f38b 8811 	msr	BASEPRI, fp
    7210:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
    7214:	05d8      	lsls	r0, r3, #23
    7216:	d49c      	bmi.n	7152 <work_queue_main+0x12>
	z_impl_k_yield();
    7218:	f000 fafe 	bl	7818 <z_impl_k_yield>
}
    721c:	e799      	b.n	7152 <work_queue_main+0x12>
	return node->next;
    721e:	2700      	movs	r7, #0
    7220:	f8d0 a000 	ldr.w	sl, [r0]
	parent->next = child;
    7224:	463b      	mov	r3, r7
		if (wc->work == work) {
    7226:	6842      	ldr	r2, [r0, #4]
    7228:	4295      	cmp	r5, r2
			sys_slist_remove(&pending_cancels, prev, &wc->node);
    722a:	4601      	mov	r1, r0
		if (wc->work == work) {
    722c:	d10c      	bne.n	7248 <work_queue_main+0x108>
	return node->next;
    722e:	6801      	ldr	r1, [r0, #0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
    7230:	b997      	cbnz	r7, 7258 <work_queue_main+0x118>
    7232:	6872      	ldr	r2, [r6, #4]
	list->head = node;
    7234:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
    7236:	4282      	cmp	r2, r0
    7238:	d100      	bne.n	723c <work_queue_main+0xfc>
	list->tail = node;
    723a:	6071      	str	r1, [r6, #4]
	parent->next = child;
    723c:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
    7240:	f7ff ff36 	bl	70b0 <z_impl_k_sem_give>
}
    7244:	4639      	mov	r1, r7
    7246:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    7248:	f1ba 0f00 	cmp.w	sl, #0
    724c:	d0d8      	beq.n	7200 <work_queue_main+0xc0>
	return node->next;
    724e:	4650      	mov	r0, sl
    7250:	460f      	mov	r7, r1
    7252:	f8da a000 	ldr.w	sl, [sl]
    7256:	e7e6      	b.n	7226 <work_queue_main+0xe6>
	return list->tail;
    7258:	6872      	ldr	r2, [r6, #4]
	parent->next = child;
    725a:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
    725c:	4290      	cmp	r0, r2
	list->tail = node;
    725e:	bf08      	it	eq
    7260:	6077      	streq	r7, [r6, #4]
}
    7262:	e7eb      	b.n	723c <work_queue_main+0xfc>
    7264:	20001358 	.word	0x20001358
    7268:	200013aa 	.word	0x200013aa

0000726c <submit_to_queue_locked>:
{
    726c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
    726e:	68c3      	ldr	r3, [r0, #12]
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    7270:	079a      	lsls	r2, r3, #30
{
    7272:	4604      	mov	r4, r0
    7274:	460e      	mov	r6, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    7276:	f3c3 0540 	ubfx	r5, r3, #1, #1
    727a:	d41f      	bmi.n	72bc <submit_to_queue_locked+0x50>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
    727c:	075f      	lsls	r7, r3, #29
    727e:	d41f      	bmi.n	72c0 <submit_to_queue_locked+0x54>
		if (*queuep == NULL) {
    7280:	680a      	ldr	r2, [r1, #0]
    7282:	b90a      	cbnz	r2, 7288 <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
    7284:	6882      	ldr	r2, [r0, #8]
    7286:	600a      	str	r2, [r1, #0]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
    7288:	07d8      	lsls	r0, r3, #31
			*queuep = work->queue;
    728a:	bf44      	itt	mi
    728c:	68a3      	ldrmi	r3, [r4, #8]
    728e:	6033      	strmi	r3, [r6, #0]
		int rc = queue_submit_locked(*queuep, work);
    7290:	6837      	ldr	r7, [r6, #0]
			ret = 2;
    7292:	bf4c      	ite	mi
    7294:	2502      	movmi	r5, #2
		ret = 1;
    7296:	2501      	movpl	r5, #1
	if (queue == NULL) {
    7298:	b37f      	cbz	r7, 72fa <submit_to_queue_locked+0x8e>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    729a:	4b1b      	ldr	r3, [pc, #108]	; (7308 <submit_to_queue_locked+0x9c>)
    729c:	689b      	ldr	r3, [r3, #8]
    729e:	42bb      	cmp	r3, r7
    72a0:	d111      	bne.n	72c6 <submit_to_queue_locked+0x5a>
    72a2:	f001 ffd8 	bl	9256 <k_is_in_isr>
    72a6:	f080 0001 	eor.w	r0, r0, #1
    72aa:	b2c0      	uxtb	r0, r0
	return (*flagp & BIT(bit)) != 0U;
    72ac:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
    72b0:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
    72b2:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
    72b6:	d523      	bpl.n	7300 <submit_to_queue_locked+0x94>
	} else if (draining && !chained) {
    72b8:	b13a      	cbz	r2, 72ca <submit_to_queue_locked+0x5e>
    72ba:	b940      	cbnz	r0, 72ce <submit_to_queue_locked+0x62>
		ret = -EBUSY;
    72bc:	f06f 050f 	mvn.w	r5, #15
		*queuep = NULL;
    72c0:	2300      	movs	r3, #0
    72c2:	6033      	str	r3, [r6, #0]
	return ret;
    72c4:	e013      	b.n	72ee <submit_to_queue_locked+0x82>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    72c6:	2000      	movs	r0, #0
    72c8:	e7f0      	b.n	72ac <submit_to_queue_locked+0x40>
	} else if (plugged && !draining) {
    72ca:	071b      	lsls	r3, r3, #28
    72cc:	d4f6      	bmi.n	72bc <submit_to_queue_locked+0x50>
	parent->next = child;
    72ce:	2300      	movs	r3, #0
    72d0:	6023      	str	r3, [r4, #0]
	return list->tail;
    72d2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
Z_GENLIST_APPEND(slist, snode)
    72d6:	b963      	cbnz	r3, 72f2 <submit_to_queue_locked+0x86>
	list->head = node;
    72d8:	e9c7 4420 	strd	r4, r4, [r7, #128]	; 0x80
		(void)notify_queue_locked(queue);
    72dc:	4638      	mov	r0, r7
    72de:	f002 f869 	bl	93b4 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
    72e2:	68e3      	ldr	r3, [r4, #12]
    72e4:	f043 0304 	orr.w	r3, r3, #4
    72e8:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
    72ea:	6833      	ldr	r3, [r6, #0]
    72ec:	60a3      	str	r3, [r4, #8]
}
    72ee:	4628      	mov	r0, r5
    72f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
    72f2:	601c      	str	r4, [r3, #0]
	list->tail = node;
    72f4:	f8c7 4084 	str.w	r4, [r7, #132]	; 0x84
}
    72f8:	e7f0      	b.n	72dc <submit_to_queue_locked+0x70>
		return -EINVAL;
    72fa:	f06f 0515 	mvn.w	r5, #21
    72fe:	e7df      	b.n	72c0 <submit_to_queue_locked+0x54>
		ret = -ENODEV;
    7300:	f06f 0512 	mvn.w	r5, #18
    7304:	e7dc      	b.n	72c0 <submit_to_queue_locked+0x54>
    7306:	bf00      	nop
    7308:	20001330 	.word	0x20001330

0000730c <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
    730c:	b5f0      	push	{r4, r5, r6, r7, lr}
    730e:	b089      	sub	sp, #36	; 0x24
    7310:	4604      	mov	r4, r0
	list->head = NULL;
    7312:	2000      	movs	r0, #0
	list->tail = NULL;
    7314:	e9c4 0020 	strd	r0, r0, [r4, #128]	; 0x80
    7318:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    731a:	f104 0088 	add.w	r0, r4, #136	; 0x88
	list->tail = (sys_dnode_t *)list;
    731e:	e9c4 0022 	strd	r0, r0, [r4, #136]	; 0x88
    7322:	f104 0090 	add.w	r0, r4, #144	; 0x90
    7326:	e9c4 0024 	strd	r0, r0, [r4, #144]	; 0x90

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
    732a:	b31d      	cbz	r5, 7374 <k_work_queue_start+0x68>
    732c:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
    732e:	2800      	cmp	r0, #0
    7330:	f240 1001 	movw	r0, #257	; 0x101
    7334:	bf08      	it	eq
    7336:	2001      	moveq	r0, #1
	*flagp = flags;
    7338:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    733c:	2000      	movs	r0, #0
    733e:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    7342:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    7346:	e9cd 3003 	strd	r3, r0, [sp, #12]
    734a:	e9cd 0001 	strd	r0, r0, [sp, #4]
    734e:	e9cd 6706 	strd	r6, r7, [sp, #24]
    7352:	4b09      	ldr	r3, [pc, #36]	; (7378 <k_work_queue_start+0x6c>)
    7354:	9400      	str	r4, [sp, #0]
    7356:	4620      	mov	r0, r4
    7358:	f7ff fd1e 	bl	6d98 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
    735c:	b125      	cbz	r5, 7368 <k_work_queue_start+0x5c>
    735e:	6829      	ldr	r1, [r5, #0]
    7360:	b111      	cbz	r1, 7368 <k_work_queue_start+0x5c>
	return z_impl_k_thread_name_set(thread, str);
    7362:	4620      	mov	r0, r4
    7364:	f001 ff7d 	bl	9262 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
    7368:	4620      	mov	r0, r4
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
    736a:	b009      	add	sp, #36	; 0x24
    736c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    7370:	f001 bf7a 	b.w	9268 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
    7374:	2001      	movs	r0, #1
    7376:	e7df      	b.n	7338 <k_work_queue_start+0x2c>
    7378:	00007141 	.word	0x00007141

0000737c <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    737c:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    737e:	4c08      	ldr	r4, [pc, #32]	; (73a0 <z_reset_time_slice+0x24>)
    7380:	6823      	ldr	r3, [r4, #0]
    7382:	b15b      	cbz	r3, 739c <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    7384:	f7fd fdfa 	bl	4f7c <sys_clock_elapsed>
    7388:	4603      	mov	r3, r0
    738a:	6820      	ldr	r0, [r4, #0]
    738c:	4a05      	ldr	r2, [pc, #20]	; (73a4 <z_reset_time_slice+0x28>)
    738e:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
	}
}
    7390:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    7394:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    7396:	2100      	movs	r1, #0
    7398:	f002 b942 	b.w	9620 <z_set_timeout_expiry>
}
    739c:	bd10      	pop	{r4, pc}
    739e:	bf00      	nop
    73a0:	20001368 	.word	0x20001368
    73a4:	20001330 	.word	0x20001330

000073a8 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
    73a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    73aa:	4604      	mov	r4, r0
    73ac:	460d      	mov	r5, r1
	__asm__ volatile(
    73ae:	f04f 0320 	mov.w	r3, #32
    73b2:	f3ef 8611 	mrs	r6, BASEPRI
    73b6:	f383 8812 	msr	BASEPRI_MAX, r3
    73ba:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    73be:	4b0f      	ldr	r3, [pc, #60]	; (73fc <k_sched_time_slice_set+0x54>)
    73c0:	2100      	movs	r1, #0
			return (uint32_t)((t * to_hz + off) / from_hz);
    73c2:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    73c6:	f240 30e7 	movw	r0, #999	; 0x3e7
    73ca:	6119      	str	r1, [r3, #16]
    73cc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    73d0:	2300      	movs	r3, #0
    73d2:	fbe4 0107 	umlal	r0, r1, r4, r7
    73d6:	f7f9 fe93 	bl	1100 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    73da:	2c00      	cmp	r4, #0
    73dc:	4b08      	ldr	r3, [pc, #32]	; (7400 <k_sched_time_slice_set+0x58>)
    73de:	dc09      	bgt.n	73f4 <k_sched_time_slice_set+0x4c>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
    73e0:	6018      	str	r0, [r3, #0]
		}
		slice_max_prio = prio;
    73e2:	4b08      	ldr	r3, [pc, #32]	; (7404 <k_sched_time_slice_set+0x5c>)
    73e4:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
    73e6:	f7ff ffc9 	bl	737c <z_reset_time_slice>
	__asm__ volatile(
    73ea:	f386 8811 	msr	BASEPRI, r6
    73ee:	f3bf 8f6f 	isb	sy
	}
}
    73f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			slice_time = MAX(2, slice_time);
    73f4:	2802      	cmp	r0, #2
    73f6:	bfb8      	it	lt
    73f8:	2002      	movlt	r0, #2
    73fa:	e7f1      	b.n	73e0 <k_sched_time_slice_set+0x38>
    73fc:	20001330 	.word	0x20001330
    7400:	20001368 	.word	0x20001368
    7404:	20001364 	.word	0x20001364

00007408 <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
    7408:	b949      	cbnz	r1, 741e <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    740a:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
    740e:	b930      	cbnz	r0, 741e <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
    7410:	4b05      	ldr	r3, [pc, #20]	; (7428 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
    7412:	69da      	ldr	r2, [r3, #28]
    7414:	689b      	ldr	r3, [r3, #8]
    7416:	429a      	cmp	r2, r3
    7418:	d001      	beq.n	741e <z_reschedule+0x16>
	ret = arch_swap(key);
    741a:	f7fb bf35 	b.w	3288 <arch_swap>
    741e:	f381 8811 	msr	BASEPRI, r1
    7422:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
    7426:	4770      	bx	lr
    7428:	20001330 	.word	0x20001330

0000742c <k_sched_lock>:
	__asm__ volatile(
    742c:	f04f 0320 	mov.w	r3, #32
    7430:	f3ef 8111 	mrs	r1, BASEPRI
    7434:	f383 8812 	msr	BASEPRI_MAX, r3
    7438:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
    743c:	4b04      	ldr	r3, [pc, #16]	; (7450 <k_sched_lock+0x24>)
    743e:	689a      	ldr	r2, [r3, #8]
    7440:	7bd3      	ldrb	r3, [r2, #15]
    7442:	3b01      	subs	r3, #1
    7444:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    7446:	f381 8811 	msr	BASEPRI, r1
    744a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
    744e:	4770      	bx	lr
    7450:	20001330 	.word	0x20001330

00007454 <update_cache>:
{
    7454:	b538      	push	{r3, r4, r5, lr}
    7456:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
    7458:	480c      	ldr	r0, [pc, #48]	; (748c <update_cache+0x38>)
    745a:	4d0d      	ldr	r5, [pc, #52]	; (7490 <update_cache+0x3c>)
    745c:	f002 f813 	bl	9486 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    7460:	4604      	mov	r4, r0
    7462:	b900      	cbnz	r0, 7466 <update_cache+0x12>
    7464:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
    7466:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
    7468:	b94a      	cbnz	r2, 747e <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
    746a:	7b5a      	ldrb	r2, [r3, #13]
    746c:	06d2      	lsls	r2, r2, #27
    746e:	d106      	bne.n	747e <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    7470:	69a2      	ldr	r2, [r4, #24]
    7472:	b922      	cbnz	r2, 747e <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
    7474:	89da      	ldrh	r2, [r3, #14]
    7476:	2a7f      	cmp	r2, #127	; 0x7f
    7478:	d901      	bls.n	747e <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
    747a:	61eb      	str	r3, [r5, #28]
}
    747c:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
    747e:	429c      	cmp	r4, r3
    7480:	d001      	beq.n	7486 <update_cache+0x32>
			z_reset_time_slice();
    7482:	f7ff ff7b 	bl	737c <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    7486:	61ec      	str	r4, [r5, #28]
}
    7488:	e7f8      	b.n	747c <update_cache+0x28>
    748a:	bf00      	nop
    748c:	20001350 	.word	0x20001350
    7490:	20001330 	.word	0x20001330

00007494 <move_thread_to_end_of_prio_q>:
{
    7494:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
    7496:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
    749a:	7b43      	ldrb	r3, [r0, #13]
    749c:	2a00      	cmp	r2, #0
{
    749e:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
    74a0:	da04      	bge.n	74ac <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    74a2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    74a6:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    74a8:	f001 ffb1 	bl	940e <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    74ac:	7b4b      	ldrb	r3, [r1, #13]
	return list->head == list;
    74ae:	4a15      	ldr	r2, [pc, #84]	; (7504 <move_thread_to_end_of_prio_q+0x70>)
    74b0:	f063 037f 	orn	r3, r3, #127	; 0x7f
    74b4:	734b      	strb	r3, [r1, #13]
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
    74b6:	e9d2 3408 	ldrd	r3, r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    74ba:	f102 0520 	add.w	r5, r2, #32
    74be:	42ab      	cmp	r3, r5
    74c0:	d01b      	beq.n	74fa <move_thread_to_end_of_prio_q+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    74c2:	b1d3      	cbz	r3, 74fa <move_thread_to_end_of_prio_q+0x66>
	int32_t b1 = thread_1->base.prio;
    74c4:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
    74c8:	f993 000e 	ldrsb.w	r0, [r3, #14]
	if (b1 != b2) {
    74cc:	4286      	cmp	r6, r0
    74ce:	d00f      	beq.n	74f0 <move_thread_to_end_of_prio_q+0x5c>
		return b2 - b1;
    74d0:	1b80      	subs	r0, r0, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
    74d2:	2800      	cmp	r0, #0
    74d4:	dd0c      	ble.n	74f0 <move_thread_to_end_of_prio_q+0x5c>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
    74d6:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
    74d8:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
    74dc:	6001      	str	r1, [r0, #0]
	successor->prev = node;
    74de:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
    74e0:	6890      	ldr	r0, [r2, #8]
    74e2:	1a43      	subs	r3, r0, r1
    74e4:	4258      	negs	r0, r3
}
    74e6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
    74ea:	4158      	adcs	r0, r3
    74ec:	f7ff bfb2 	b.w	7454 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    74f0:	42a3      	cmp	r3, r4
    74f2:	d002      	beq.n	74fa <move_thread_to_end_of_prio_q+0x66>
    74f4:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    74f6:	2b00      	cmp	r3, #0
    74f8:	d1e6      	bne.n	74c8 <move_thread_to_end_of_prio_q+0x34>
	node->prev = tail;
    74fa:	e9c1 5400 	strd	r5, r4, [r1]
	tail->next = node;
    74fe:	6021      	str	r1, [r4, #0]
	list->tail = node;
    7500:	6251      	str	r1, [r2, #36]	; 0x24
}
    7502:	e7ed      	b.n	74e0 <move_thread_to_end_of_prio_q+0x4c>
    7504:	20001330 	.word	0x20001330

00007508 <z_time_slice>:
{
    7508:	b538      	push	{r3, r4, r5, lr}
    750a:	4601      	mov	r1, r0
	__asm__ volatile(
    750c:	f04f 0320 	mov.w	r3, #32
    7510:	f3ef 8411 	mrs	r4, BASEPRI
    7514:	f383 8812 	msr	BASEPRI_MAX, r3
    7518:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
    751c:	4b15      	ldr	r3, [pc, #84]	; (7574 <z_time_slice+0x6c>)
    751e:	4a16      	ldr	r2, [pc, #88]	; (7578 <z_time_slice+0x70>)
    7520:	6898      	ldr	r0, [r3, #8]
    7522:	6815      	ldr	r5, [r2, #0]
    7524:	42a8      	cmp	r0, r5
    7526:	d106      	bne.n	7536 <z_time_slice+0x2e>
			z_reset_time_slice();
    7528:	f7ff ff28 	bl	737c <z_reset_time_slice>
	__asm__ volatile(
    752c:	f384 8811 	msr	BASEPRI, r4
    7530:	f3bf 8f6f 	isb	sy
}
    7534:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
    7536:	2500      	movs	r5, #0
    7538:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
    753a:	4a10      	ldr	r2, [pc, #64]	; (757c <z_time_slice+0x74>)
    753c:	6812      	ldr	r2, [r2, #0]
    753e:	b1ba      	cbz	r2, 7570 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
    7540:	89c2      	ldrh	r2, [r0, #14]
    7542:	2a7f      	cmp	r2, #127	; 0x7f
    7544:	d814      	bhi.n	7570 <z_time_slice+0x68>
		&& !z_is_thread_prevented_from_running(thread)
    7546:	7b42      	ldrb	r2, [r0, #13]
    7548:	06d2      	lsls	r2, r2, #27
    754a:	d111      	bne.n	7570 <z_time_slice+0x68>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    754c:	4a0c      	ldr	r2, [pc, #48]	; (7580 <z_time_slice+0x78>)
    754e:	f990 500e 	ldrsb.w	r5, [r0, #14]
    7552:	6812      	ldr	r2, [r2, #0]
    7554:	4295      	cmp	r5, r2
    7556:	db0b      	blt.n	7570 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
    7558:	4a0a      	ldr	r2, [pc, #40]	; (7584 <z_time_slice+0x7c>)
    755a:	4290      	cmp	r0, r2
    755c:	d008      	beq.n	7570 <z_time_slice+0x68>
		if (ticks >= _current_cpu->slice_ticks) {
    755e:	691a      	ldr	r2, [r3, #16]
    7560:	428a      	cmp	r2, r1
    7562:	dc02      	bgt.n	756a <z_time_slice+0x62>
			move_thread_to_end_of_prio_q(_current);
    7564:	f7ff ff96 	bl	7494 <move_thread_to_end_of_prio_q>
    7568:	e7de      	b.n	7528 <z_time_slice+0x20>
			_current_cpu->slice_ticks -= ticks;
    756a:	1a52      	subs	r2, r2, r1
		_current_cpu->slice_ticks = 0;
    756c:	611a      	str	r2, [r3, #16]
    756e:	e7dd      	b.n	752c <z_time_slice+0x24>
    7570:	2200      	movs	r2, #0
    7572:	e7fb      	b.n	756c <z_time_slice+0x64>
    7574:	20001330 	.word	0x20001330
    7578:	20001360 	.word	0x20001360
    757c:	20001368 	.word	0x20001368
    7580:	20001364 	.word	0x20001364
    7584:	20000418 	.word	0x20000418

00007588 <ready_thread>:
{
    7588:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    758a:	f990 200d 	ldrsb.w	r2, [r0, #13]
    758e:	7b43      	ldrb	r3, [r0, #13]
    7590:	2a00      	cmp	r2, #0
    7592:	db2a      	blt.n	75ea <ready_thread+0x62>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    7594:	06da      	lsls	r2, r3, #27
    7596:	d128      	bne.n	75ea <ready_thread+0x62>
    7598:	6982      	ldr	r2, [r0, #24]
    759a:	bb32      	cbnz	r2, 75ea <ready_thread+0x62>
	return list->head == list;
    759c:	4a14      	ldr	r2, [pc, #80]	; (75f0 <ready_thread+0x68>)
	thread->base.thread_state |= _THREAD_QUEUED;
    759e:	f063 037f 	orn	r3, r3, #127	; 0x7f
    75a2:	7343      	strb	r3, [r0, #13]
	return (node == list->tail) ? NULL : node->next;
    75a4:	e9d2 3408 	ldrd	r3, r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    75a8:	f102 0520 	add.w	r5, r2, #32
    75ac:	42ab      	cmp	r3, r5
    75ae:	d017      	beq.n	75e0 <ready_thread+0x58>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    75b0:	b1b3      	cbz	r3, 75e0 <ready_thread+0x58>
	int32_t b1 = thread_1->base.prio;
    75b2:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
    75b6:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
    75ba:	428e      	cmp	r6, r1
    75bc:	d00b      	beq.n	75d6 <ready_thread+0x4e>
		return b2 - b1;
    75be:	1b89      	subs	r1, r1, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
    75c0:	2900      	cmp	r1, #0
    75c2:	dd08      	ble.n	75d6 <ready_thread+0x4e>
	sys_dnode_t *const prev = successor->prev;
    75c4:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    75c6:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
    75ca:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    75cc:	6058      	str	r0, [r3, #4]
}
    75ce:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
    75d0:	2000      	movs	r0, #0
    75d2:	f7ff bf3f 	b.w	7454 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    75d6:	42a3      	cmp	r3, r4
    75d8:	d002      	beq.n	75e0 <ready_thread+0x58>
    75da:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    75dc:	2b00      	cmp	r3, #0
    75de:	d1ea      	bne.n	75b6 <ready_thread+0x2e>
	node->prev = tail;
    75e0:	e9c0 5400 	strd	r5, r4, [r0]
	tail->next = node;
    75e4:	6020      	str	r0, [r4, #0]
	list->tail = node;
    75e6:	6250      	str	r0, [r2, #36]	; 0x24
}
    75e8:	e7f1      	b.n	75ce <ready_thread+0x46>
}
    75ea:	bc70      	pop	{r4, r5, r6}
    75ec:	4770      	bx	lr
    75ee:	bf00      	nop
    75f0:	20001330 	.word	0x20001330

000075f4 <z_sched_start>:
{
    75f4:	b510      	push	{r4, lr}
	__asm__ volatile(
    75f6:	f04f 0220 	mov.w	r2, #32
    75fa:	f3ef 8411 	mrs	r4, BASEPRI
    75fe:	f382 8812 	msr	BASEPRI_MAX, r2
    7602:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    7606:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
    7608:	0751      	lsls	r1, r2, #29
    760a:	d404      	bmi.n	7616 <z_sched_start+0x22>
	__asm__ volatile(
    760c:	f384 8811 	msr	BASEPRI, r4
    7610:	f3bf 8f6f 	isb	sy
}
    7614:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    7616:	f022 0204 	bic.w	r2, r2, #4
    761a:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
    761c:	f7ff ffb4 	bl	7588 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    7620:	4621      	mov	r1, r4
    7622:	4802      	ldr	r0, [pc, #8]	; (762c <z_sched_start+0x38>)
}
    7624:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
    7628:	f7ff beee 	b.w	7408 <z_reschedule>
    762c:	200013aa 	.word	0x200013aa

00007630 <unready_thread>:
{
    7630:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
    7632:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
    7636:	7b43      	ldrb	r3, [r0, #13]
    7638:	2a00      	cmp	r2, #0
{
    763a:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
    763c:	da04      	bge.n	7648 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    763e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    7642:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    7644:	f001 fee3 	bl	940e <sys_dlist_remove>
	update_cache(thread == _current);
    7648:	4b04      	ldr	r3, [pc, #16]	; (765c <unready_thread+0x2c>)
    764a:	6898      	ldr	r0, [r3, #8]
    764c:	1a43      	subs	r3, r0, r1
    764e:	4258      	negs	r0, r3
    7650:	4158      	adcs	r0, r3
}
    7652:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
    7656:	f7ff befd 	b.w	7454 <update_cache>
    765a:	bf00      	nop
    765c:	20001330 	.word	0x20001330

00007660 <pend>:
{
    7660:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7664:	4606      	mov	r6, r0
    7666:	4615      	mov	r5, r2
    7668:	461c      	mov	r4, r3
	__asm__ volatile(
    766a:	f04f 0320 	mov.w	r3, #32
    766e:	f3ef 8711 	mrs	r7, BASEPRI
    7672:	f383 8812 	msr	BASEPRI_MAX, r3
    7676:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
    767a:	f001 ff3c 	bl	94f6 <add_to_waitq_locked>
	__asm__ volatile(
    767e:	f387 8811 	msr	BASEPRI, r7
    7682:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    7686:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
    768a:	bf08      	it	eq
    768c:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
    7690:	d008      	beq.n	76a4 <pend+0x44>
    7692:	462a      	mov	r2, r5
    7694:	4623      	mov	r3, r4
    7696:	f106 0018 	add.w	r0, r6, #24
    769a:	4903      	ldr	r1, [pc, #12]	; (76a8 <pend+0x48>)
}
    769c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    76a0:	f000 ba3c 	b.w	7b1c <z_add_timeout>
    76a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    76a8:	000094b3 	.word	0x000094b3

000076ac <z_pend_curr>:
{
    76ac:	b510      	push	{r4, lr}
	pending_current = _current;
    76ae:	4b07      	ldr	r3, [pc, #28]	; (76cc <z_pend_curr+0x20>)
    76b0:	6898      	ldr	r0, [r3, #8]
    76b2:	4b07      	ldr	r3, [pc, #28]	; (76d0 <z_pend_curr+0x24>)
{
    76b4:	460c      	mov	r4, r1
	pending_current = _current;
    76b6:	6018      	str	r0, [r3, #0]
{
    76b8:	4611      	mov	r1, r2
	pend(_current, wait_q, timeout);
    76ba:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    76be:	f7ff ffcf 	bl	7660 <pend>
    76c2:	4620      	mov	r0, r4
}
    76c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    76c8:	f7fb bdde 	b.w	3288 <arch_swap>
    76cc:	20001330 	.word	0x20001330
    76d0:	20001360 	.word	0x20001360

000076d4 <z_set_prio>:
{
    76d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    76d6:	4604      	mov	r4, r0
	__asm__ volatile(
    76d8:	f04f 0320 	mov.w	r3, #32
    76dc:	f3ef 8611 	mrs	r6, BASEPRI
    76e0:	f383 8812 	msr	BASEPRI_MAX, r3
    76e4:	f3bf 8f6f 	isb	sy
	uint8_t state = thread->base.thread_state;
    76e8:	7b43      	ldrb	r3, [r0, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    76ea:	06da      	lsls	r2, r3, #27
				thread->base.prio = prio;
    76ec:	b249      	sxtb	r1, r1
    76ee:	d133      	bne.n	7758 <z_set_prio+0x84>
		if (need_sched) {
    76f0:	6982      	ldr	r2, [r0, #24]
    76f2:	bb8a      	cbnz	r2, 7758 <z_set_prio+0x84>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    76f4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    76f8:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    76fa:	f001 fe88 	bl	940e <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    76fe:	7b43      	ldrb	r3, [r0, #13]
	return list->head == list;
    7700:	4a17      	ldr	r2, [pc, #92]	; (7760 <z_set_prio+0x8c>)
				thread->base.prio = prio;
    7702:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
    7704:	f063 037f 	orn	r3, r3, #127	; 0x7f
    7708:	7343      	strb	r3, [r0, #13]
    770a:	4610      	mov	r0, r2
    770c:	f850 3f20 	ldr.w	r3, [r0, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7710:	4283      	cmp	r3, r0
    7712:	d01b      	beq.n	774c <z_set_prio+0x78>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    7714:	b1d3      	cbz	r3, 774c <z_set_prio+0x78>
	return (node == list->tail) ? NULL : node->next;
    7716:	6a57      	ldr	r7, [r2, #36]	; 0x24
	int32_t b2 = thread_2->base.prio;
    7718:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
    771c:	42a9      	cmp	r1, r5
    771e:	d010      	beq.n	7742 <z_set_prio+0x6e>
		return b2 - b1;
    7720:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
    7722:	2d00      	cmp	r5, #0
    7724:	dd0d      	ble.n	7742 <z_set_prio+0x6e>
	sys_dnode_t *const prev = successor->prev;
    7726:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    7728:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
    772c:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    772e:	605c      	str	r4, [r3, #4]
			update_cache(1);
    7730:	2001      	movs	r0, #1
    7732:	f7ff fe8f 	bl	7454 <update_cache>
    7736:	2001      	movs	r0, #1
	__asm__ volatile(
    7738:	f386 8811 	msr	BASEPRI, r6
    773c:	f3bf 8f6f 	isb	sy
}
    7740:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    7742:	42bb      	cmp	r3, r7
    7744:	d002      	beq.n	774c <z_set_prio+0x78>
    7746:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    7748:	2b00      	cmp	r3, #0
    774a:	d1e5      	bne.n	7718 <z_set_prio+0x44>
	sys_dnode_t *const tail = list->tail;
    774c:	6a53      	ldr	r3, [r2, #36]	; 0x24
	node->prev = tail;
    774e:	e9c4 0300 	strd	r0, r3, [r4]
	tail->next = node;
    7752:	601c      	str	r4, [r3, #0]
	list->tail = node;
    7754:	6254      	str	r4, [r2, #36]	; 0x24
}
    7756:	e7eb      	b.n	7730 <z_set_prio+0x5c>
			thread->base.prio = prio;
    7758:	73a1      	strb	r1, [r4, #14]
    775a:	2000      	movs	r0, #0
    775c:	e7ec      	b.n	7738 <z_set_prio+0x64>
    775e:	bf00      	nop
    7760:	20001330 	.word	0x20001330

00007764 <z_impl_k_thread_suspend>:
{
    7764:	b570      	push	{r4, r5, r6, lr}
    7766:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    7768:	3018      	adds	r0, #24
    776a:	f001 ff33 	bl	95d4 <z_abort_timeout>
	__asm__ volatile(
    776e:	f04f 0320 	mov.w	r3, #32
    7772:	f3ef 8611 	mrs	r6, BASEPRI
    7776:	f383 8812 	msr	BASEPRI_MAX, r3
    777a:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    777e:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
    7782:	7b63      	ldrb	r3, [r4, #13]
    7784:	2a00      	cmp	r2, #0
    7786:	da05      	bge.n	7794 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    7788:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    778c:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    778e:	4620      	mov	r0, r4
    7790:	f001 fe3d 	bl	940e <sys_dlist_remove>
		update_cache(thread == _current);
    7794:	4d0b      	ldr	r5, [pc, #44]	; (77c4 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
    7796:	7b63      	ldrb	r3, [r4, #13]
    7798:	68a8      	ldr	r0, [r5, #8]
    779a:	f043 0310 	orr.w	r3, r3, #16
    779e:	7363      	strb	r3, [r4, #13]
    77a0:	1b03      	subs	r3, r0, r4
    77a2:	4258      	negs	r0, r3
    77a4:	4158      	adcs	r0, r3
    77a6:	f7ff fe55 	bl	7454 <update_cache>
	__asm__ volatile(
    77aa:	f386 8811 	msr	BASEPRI, r6
    77ae:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
    77b2:	68ab      	ldr	r3, [r5, #8]
    77b4:	42a3      	cmp	r3, r4
    77b6:	d103      	bne.n	77c0 <z_impl_k_thread_suspend+0x5c>
}
    77b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
    77bc:	f001 be59 	b.w	9472 <z_reschedule_unlocked>
}
    77c0:	bd70      	pop	{r4, r5, r6, pc}
    77c2:	bf00      	nop
    77c4:	20001330 	.word	0x20001330

000077c8 <k_sched_unlock>:
{
    77c8:	b510      	push	{r4, lr}
	__asm__ volatile(
    77ca:	f04f 0320 	mov.w	r3, #32
    77ce:	f3ef 8411 	mrs	r4, BASEPRI
    77d2:	f383 8812 	msr	BASEPRI_MAX, r3
    77d6:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
    77da:	4b08      	ldr	r3, [pc, #32]	; (77fc <k_sched_unlock+0x34>)
    77dc:	689a      	ldr	r2, [r3, #8]
    77de:	7bd3      	ldrb	r3, [r2, #15]
    77e0:	3301      	adds	r3, #1
    77e2:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    77e4:	2000      	movs	r0, #0
    77e6:	f7ff fe35 	bl	7454 <update_cache>
	__asm__ volatile(
    77ea:	f384 8811 	msr	BASEPRI, r4
    77ee:	f3bf 8f6f 	isb	sy
}
    77f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
    77f6:	f001 be3c 	b.w	9472 <z_reschedule_unlocked>
    77fa:	bf00      	nop
    77fc:	20001330 	.word	0x20001330

00007800 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    7800:	4b04      	ldr	r3, [pc, #16]	; (7814 <z_sched_init+0x14>)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    7802:	2100      	movs	r1, #0
    7804:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
    7808:	e9c3 2208 	strd	r2, r2, [r3, #32]
    780c:	4608      	mov	r0, r1
    780e:	f7ff bdcb 	b.w	73a8 <k_sched_time_slice_set>
    7812:	bf00      	nop
    7814:	20001330 	.word	0x20001330

00007818 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
    7818:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    781a:	f04f 0320 	mov.w	r3, #32
    781e:	f3ef 8511 	mrs	r5, BASEPRI
    7822:	f383 8812 	msr	BASEPRI_MAX, r3
    7826:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
    782a:	491a      	ldr	r1, [pc, #104]	; (7894 <z_impl_k_yield+0x7c>)
    782c:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    782e:	7b43      	ldrb	r3, [r0, #13]
    7830:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    7834:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    7836:	f001 fdea 	bl	940e <sys_dlist_remove>
	}
	queue_thread(_current);
    783a:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
    783c:	7b5a      	ldrb	r2, [r3, #13]
	return list->head == list;
    783e:	4608      	mov	r0, r1
    7840:	f062 027f 	orn	r2, r2, #127	; 0x7f
    7844:	735a      	strb	r2, [r3, #13]
    7846:	f850 2f20 	ldr.w	r2, [r0, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    784a:	4282      	cmp	r2, r0
    784c:	d01c      	beq.n	7888 <z_impl_k_yield+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    784e:	b1da      	cbz	r2, 7888 <z_impl_k_yield+0x70>
	return (node == list->tail) ? NULL : node->next;
    7850:	6a4f      	ldr	r7, [r1, #36]	; 0x24
	int32_t b1 = thread_1->base.prio;
    7852:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
    7856:	f992 400e 	ldrsb.w	r4, [r2, #14]
	if (b1 != b2) {
    785a:	42a6      	cmp	r6, r4
    785c:	d00f      	beq.n	787e <z_impl_k_yield+0x66>
		return b2 - b1;
    785e:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
    7860:	2c00      	cmp	r4, #0
    7862:	dd0c      	ble.n	787e <z_impl_k_yield+0x66>
	sys_dnode_t *const prev = successor->prev;
    7864:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    7866:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
    786a:	600b      	str	r3, [r1, #0]
	successor->prev = node;
    786c:	6053      	str	r3, [r2, #4]
	update_cache(1);
    786e:	2001      	movs	r0, #1
    7870:	f7ff fdf0 	bl	7454 <update_cache>
    7874:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
    7876:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    787a:	f7fb bd05 	b.w	3288 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
    787e:	42ba      	cmp	r2, r7
    7880:	d002      	beq.n	7888 <z_impl_k_yield+0x70>
    7882:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    7884:	2a00      	cmp	r2, #0
    7886:	d1e6      	bne.n	7856 <z_impl_k_yield+0x3e>
	sys_dnode_t *const tail = list->tail;
    7888:	6a4a      	ldr	r2, [r1, #36]	; 0x24
	node->prev = tail;
    788a:	e9c3 0200 	strd	r0, r2, [r3]
	tail->next = node;
    788e:	6013      	str	r3, [r2, #0]
	list->tail = node;
    7890:	624b      	str	r3, [r1, #36]	; 0x24
}
    7892:	e7ec      	b.n	786e <z_impl_k_yield+0x56>
    7894:	20001330 	.word	0x20001330

00007898 <z_tick_sleep>:
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
    7898:	ea50 0301 	orrs.w	r3, r0, r1
{
    789c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    78a0:	4605      	mov	r5, r0
    78a2:	460e      	mov	r6, r1
	if (ticks == 0) {
    78a4:	d103      	bne.n	78ae <z_tick_sleep+0x16>
	z_impl_k_yield();
    78a6:	f7ff ffb7 	bl	7818 <z_impl_k_yield>
	if (ticks > 0) {
		return ticks;
	}
#endif

	return 0;
    78aa:	2000      	movs	r0, #0
    78ac:	e033      	b.n	7916 <z_tick_sleep+0x7e>
	if (Z_TICK_ABS(ticks) <= 0) {
    78ae:	f06f 0401 	mvn.w	r4, #1
    78b2:	1a24      	subs	r4, r4, r0
    78b4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    78b8:	eb63 0301 	sbc.w	r3, r3, r1
    78bc:	2c01      	cmp	r4, #1
    78be:	f173 0300 	sbcs.w	r3, r3, #0
    78c2:	da02      	bge.n	78ca <z_tick_sleep+0x32>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    78c4:	f001 fec6 	bl	9654 <sys_clock_tick_get_32>
    78c8:	1944      	adds	r4, r0, r5
    78ca:	f04f 0320 	mov.w	r3, #32
    78ce:	f3ef 8811 	mrs	r8, BASEPRI
    78d2:	f383 8812 	msr	BASEPRI_MAX, r3
    78d6:	f3bf 8f6f 	isb	sy
	pending_current = _current;
    78da:	4f10      	ldr	r7, [pc, #64]	; (791c <z_tick_sleep+0x84>)
    78dc:	4b10      	ldr	r3, [pc, #64]	; (7920 <z_tick_sleep+0x88>)
    78de:	68b8      	ldr	r0, [r7, #8]
    78e0:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
    78e2:	f7ff fea5 	bl	7630 <unready_thread>
	z_add_thread_timeout(_current, timeout);
    78e6:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    78e8:	490e      	ldr	r1, [pc, #56]	; (7924 <z_tick_sleep+0x8c>)
    78ea:	462a      	mov	r2, r5
    78ec:	4633      	mov	r3, r6
    78ee:	3018      	adds	r0, #24
    78f0:	f000 f914 	bl	7b1c <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    78f4:	68ba      	ldr	r2, [r7, #8]
    78f6:	7b53      	ldrb	r3, [r2, #13]
    78f8:	f043 0310 	orr.w	r3, r3, #16
    78fc:	7353      	strb	r3, [r2, #13]
    78fe:	4640      	mov	r0, r8
    7900:	f7fb fcc2 	bl	3288 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    7904:	f001 fea6 	bl	9654 <sys_clock_tick_get_32>
    7908:	1a20      	subs	r0, r4, r0
    790a:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
    790e:	2801      	cmp	r0, #1
    7910:	f173 0300 	sbcs.w	r3, r3, #0
    7914:	dbc9      	blt.n	78aa <z_tick_sleep+0x12>
}
    7916:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    791a:	bf00      	nop
    791c:	20001330 	.word	0x20001330
    7920:	20001360 	.word	0x20001360
    7924:	000094b3 	.word	0x000094b3

00007928 <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    7928:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    792c:	bf08      	it	eq
    792e:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
    7932:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    7934:	d106      	bne.n	7944 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
    7936:	4b08      	ldr	r3, [pc, #32]	; (7958 <z_impl_k_sleep+0x30>)
    7938:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    793a:	f7ff ff13 	bl	7764 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
    793e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
    7942:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
    7944:	f7ff ffa8 	bl	7898 <z_tick_sleep>
			return (t * to_hz + off) / from_hz;
    7948:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    794c:	fb80 0303 	smull	r0, r3, r0, r3
    7950:	0bc0      	lsrs	r0, r0, #15
    7952:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
    7956:	e7f4      	b.n	7942 <z_impl_k_sleep+0x1a>
    7958:	20001330 	.word	0x20001330

0000795c <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    795c:	4b01      	ldr	r3, [pc, #4]	; (7964 <z_impl_z_current_get+0x8>)
    795e:	6898      	ldr	r0, [r3, #8]
    7960:	4770      	bx	lr
    7962:	bf00      	nop
    7964:	20001330 	.word	0x20001330

00007968 <z_impl_k_is_preempt_thread>:
    7968:	f3ef 8305 	mrs	r3, IPSR
#include <syscalls/z_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
	return !arch_is_in_isr() && is_preempt(_current);
    796c:	b93b      	cbnz	r3, 797e <z_impl_k_is_preempt_thread+0x16>
    796e:	4b05      	ldr	r3, [pc, #20]	; (7984 <z_impl_k_is_preempt_thread+0x1c>)
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    7970:	689b      	ldr	r3, [r3, #8]
	return !arch_is_in_isr() && is_preempt(_current);
    7972:	89d8      	ldrh	r0, [r3, #14]
    7974:	287f      	cmp	r0, #127	; 0x7f
    7976:	bf8c      	ite	hi
    7978:	2000      	movhi	r0, #0
    797a:	2001      	movls	r0, #1
    797c:	4770      	bx	lr
    797e:	2000      	movs	r0, #0
}
    7980:	4770      	bx	lr
    7982:	bf00      	nop
    7984:	20001330 	.word	0x20001330

00007988 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    7988:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    798c:	4604      	mov	r4, r0
    798e:	f04f 0320 	mov.w	r3, #32
    7992:	f3ef 8611 	mrs	r6, BASEPRI
    7996:	f383 8812 	msr	BASEPRI_MAX, r3
    799a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    799e:	7b43      	ldrb	r3, [r0, #13]
    79a0:	071a      	lsls	r2, r3, #28
    79a2:	d505      	bpl.n	79b0 <z_thread_abort+0x28>
	__asm__ volatile(
    79a4:	f386 8811 	msr	BASEPRI, r6
    79a8:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    79ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
    79b0:	f023 0220 	bic.w	r2, r3, #32
    79b4:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
    79b8:	09d2      	lsrs	r2, r2, #7
    79ba:	d120      	bne.n	79fe <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    79bc:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
    79be:	68a3      	ldr	r3, [r4, #8]
    79c0:	b113      	cbz	r3, 79c8 <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
    79c2:	4620      	mov	r0, r4
    79c4:	f001 fd2b 	bl	941e <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
    79c8:	f104 0018 	add.w	r0, r4, #24
    79cc:	f001 fe02 	bl	95d4 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    79d0:	f104 0758 	add.w	r7, r4, #88	; 0x58
    79d4:	f04f 0800 	mov.w	r8, #0
	return list->head == list;
    79d8:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
    79da:	42bd      	cmp	r5, r7
    79dc:	d000      	beq.n	79e0 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    79de:	b9b5      	cbnz	r5, 7a0e <z_thread_abort+0x86>
		update_cache(1);
    79e0:	2001      	movs	r0, #1
    79e2:	f7ff fd37 	bl	7454 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
    79e6:	4b10      	ldr	r3, [pc, #64]	; (7a28 <z_thread_abort+0xa0>)
    79e8:	689b      	ldr	r3, [r3, #8]
    79ea:	42a3      	cmp	r3, r4
    79ec:	d1da      	bne.n	79a4 <z_thread_abort+0x1c>
    79ee:	f3ef 8305 	mrs	r3, IPSR
    79f2:	2b00      	cmp	r3, #0
    79f4:	d1d6      	bne.n	79a4 <z_thread_abort+0x1c>
    79f6:	4630      	mov	r0, r6
    79f8:	f7fb fc46 	bl	3288 <arch_swap>
	return ret;
    79fc:	e7d2      	b.n	79a4 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    79fe:	f003 035f 	and.w	r3, r3, #95	; 0x5f
    7a02:	f043 0308 	orr.w	r3, r3, #8
    7a06:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    7a08:	f001 fd01 	bl	940e <sys_dlist_remove>
}
    7a0c:	e7d7      	b.n	79be <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
    7a0e:	4628      	mov	r0, r5
    7a10:	f001 fd05 	bl	941e <unpend_thread_no_timeout>
    7a14:	f105 0018 	add.w	r0, r5, #24
    7a18:	f001 fddc 	bl	95d4 <z_abort_timeout>
    7a1c:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
		ready_thread(thread);
    7a20:	4628      	mov	r0, r5
    7a22:	f7ff fdb1 	bl	7588 <ready_thread>
    7a26:	e7d7      	b.n	79d8 <z_thread_abort+0x50>
    7a28:	20001330 	.word	0x20001330

00007a2c <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
    7a2c:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
    7a2e:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
    7a32:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
    7a34:	e9cd 6700 	strd	r6, r7, [sp]
    7a38:	f7ff fe38 	bl	76ac <z_pend_curr>

	if (data != NULL) {
    7a3c:	b11c      	cbz	r4, 7a46 <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
    7a3e:	4b03      	ldr	r3, [pc, #12]	; (7a4c <z_sched_wait+0x20>)
    7a40:	689b      	ldr	r3, [r3, #8]
    7a42:	695b      	ldr	r3, [r3, #20]
    7a44:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
    7a46:	b002      	add	sp, #8
    7a48:	bdd0      	pop	{r4, r6, r7, pc}
    7a4a:	bf00      	nop
    7a4c:	20001330 	.word	0x20001330

00007a50 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    7a50:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
    7a52:	4806      	ldr	r0, [pc, #24]	; (7a6c <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
    7a54:	4a06      	ldr	r2, [pc, #24]	; (7a70 <z_data_copy+0x20>)
    7a56:	4907      	ldr	r1, [pc, #28]	; (7a74 <z_data_copy+0x24>)
    7a58:	1a12      	subs	r2, r2, r0
    7a5a:	f000 ff2d 	bl	88b8 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    7a5e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
    7a62:	4a05      	ldr	r2, [pc, #20]	; (7a78 <z_data_copy+0x28>)
    7a64:	4905      	ldr	r1, [pc, #20]	; (7a7c <z_data_copy+0x2c>)
    7a66:	4806      	ldr	r0, [pc, #24]	; (7a80 <z_data_copy+0x30>)
    7a68:	f000 bf26 	b.w	88b8 <memcpy>
    7a6c:	20000000 	.word	0x20000000
    7a70:	200002d8 	.word	0x200002d8
    7a74:	00009d54 	.word	0x00009d54
    7a78:	00000000 	.word	0x00000000
    7a7c:	00009d54 	.word	0x00009d54
    7a80:	20000000 	.word	0x20000000

00007a84 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    7a84:	4b03      	ldr	r3, [pc, #12]	; (7a94 <elapsed+0x10>)
    7a86:	681b      	ldr	r3, [r3, #0]
    7a88:	b90b      	cbnz	r3, 7a8e <elapsed+0xa>
    7a8a:	f7fd ba77 	b.w	4f7c <sys_clock_elapsed>
}
    7a8e:	2000      	movs	r0, #0
    7a90:	4770      	bx	lr
    7a92:	bf00      	nop
    7a94:	2000136c 	.word	0x2000136c

00007a98 <next_timeout>:
	return list->head == list;
    7a98:	4b11      	ldr	r3, [pc, #68]	; (7ae0 <next_timeout+0x48>)

static int32_t next_timeout(void)
{
    7a9a:	b510      	push	{r4, lr}
    7a9c:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7a9e:	429c      	cmp	r4, r3
    7aa0:	bf08      	it	eq
    7aa2:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    7aa4:	f7ff ffee 	bl	7a84 <elapsed>
    7aa8:	4603      	mov	r3, r0
	int32_t ret = to == NULL ? MAX_WAIT
    7aaa:	b16c      	cbz	r4, 7ac8 <next_timeout+0x30>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    7aac:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
    7ab0:	1ac0      	subs	r0, r0, r3
    7ab2:	eb62 73e3 	sbc.w	r3, r2, r3, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
    7ab6:	2801      	cmp	r0, #1
    7ab8:	f173 0200 	sbcs.w	r2, r3, #0
    7abc:	db0d      	blt.n	7ada <next_timeout+0x42>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    7abe:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
    7ac2:	f173 0300 	sbcs.w	r3, r3, #0
    7ac6:	db01      	blt.n	7acc <next_timeout+0x34>
	int32_t ret = to == NULL ? MAX_WAIT
    7ac8:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    7acc:	4b05      	ldr	r3, [pc, #20]	; (7ae4 <next_timeout+0x4c>)
    7ace:	691b      	ldr	r3, [r3, #16]
    7ad0:	b113      	cbz	r3, 7ad8 <next_timeout+0x40>
    7ad2:	4298      	cmp	r0, r3
    7ad4:	bfa8      	it	ge
    7ad6:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    7ad8:	bd10      	pop	{r4, pc}
	int32_t ret = to == NULL ? MAX_WAIT
    7ada:	2000      	movs	r0, #0
    7adc:	e7f6      	b.n	7acc <next_timeout+0x34>
    7ade:	bf00      	nop
    7ae0:	20000190 	.word	0x20000190
    7ae4:	20001330 	.word	0x20001330

00007ae8 <remove_timeout>:
{
    7ae8:	b530      	push	{r4, r5, lr}
	return (node == list->tail) ? NULL : node->next;
    7aea:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    7aec:	b168      	cbz	r0, 7b0a <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
    7aee:	4a0a      	ldr	r2, [pc, #40]	; (7b18 <remove_timeout+0x30>)
    7af0:	6852      	ldr	r2, [r2, #4]
    7af2:	4290      	cmp	r0, r2
    7af4:	d009      	beq.n	7b0a <remove_timeout+0x22>
	if (next(t) != NULL) {
    7af6:	b143      	cbz	r3, 7b0a <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
    7af8:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
    7afc:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
    7b00:	1912      	adds	r2, r2, r4
    7b02:	eb41 0105 	adc.w	r1, r1, r5
    7b06:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    7b0a:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
    7b0c:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    7b0e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    7b10:	2300      	movs	r3, #0
	node->prev = NULL;
    7b12:	e9c0 3300 	strd	r3, r3, [r0]
}
    7b16:	bd30      	pop	{r4, r5, pc}
    7b18:	20000190 	.word	0x20000190

00007b1c <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    7b1c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    7b20:	bf08      	it	eq
    7b22:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
    7b26:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7b28:	4604      	mov	r4, r0
    7b2a:	461f      	mov	r7, r3
    7b2c:	4615      	mov	r5, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    7b2e:	d067      	beq.n	7c00 <z_add_timeout+0xe4>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    7b30:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
    7b32:	f04f 0320 	mov.w	r3, #32
    7b36:	f3ef 8611 	mrs	r6, BASEPRI
    7b3a:	f383 8812 	msr	BASEPRI_MAX, r3
    7b3e:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    7b42:	f06f 0201 	mvn.w	r2, #1
    7b46:	1b53      	subs	r3, r2, r5
    7b48:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    7b4c:	eb6c 0307 	sbc.w	r3, ip, r7
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    7b50:	2b00      	cmp	r3, #0
    7b52:	db1b      	blt.n	7b8c <z_add_timeout+0x70>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    7b54:	4b2b      	ldr	r3, [pc, #172]	; (7c04 <z_add_timeout+0xe8>)
    7b56:	e9d3 1300 	ldrd	r1, r3, [r3]
    7b5a:	1a52      	subs	r2, r2, r1
    7b5c:	eb6c 0303 	sbc.w	r3, ip, r3
    7b60:	1b55      	subs	r5, r2, r5

			to->dticks = MAX(1, ticks);
    7b62:	eb63 0307 	sbc.w	r3, r3, r7
    7b66:	2d01      	cmp	r5, #1
    7b68:	f173 0200 	sbcs.w	r2, r3, #0
    7b6c:	bfbc      	itt	lt
    7b6e:	2501      	movlt	r5, #1
    7b70:	2300      	movlt	r3, #0
    7b72:	e9c0 5304 	strd	r5, r3, [r0, #16]
	return list->head == list;
    7b76:	4824      	ldr	r0, [pc, #144]	; (7c08 <z_add_timeout+0xec>)
	sys_dnode_t *const tail = list->tail;
    7b78:	e9d0 3c00 	ldrd	r3, ip, [r0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7b7c:	4283      	cmp	r3, r0
    7b7e:	d118      	bne.n	7bb2 <z_add_timeout+0x96>
	node->prev = tail;
    7b80:	e9c4 0c00 	strd	r0, ip, [r4]
	tail->next = node;
    7b84:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
    7b88:	6044      	str	r4, [r0, #4]
}
    7b8a:	e026      	b.n	7bda <z_add_timeout+0xbe>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    7b8c:	f7ff ff7a 	bl	7a84 <elapsed>
    7b90:	3501      	adds	r5, #1
    7b92:	f147 0700 	adc.w	r7, r7, #0
    7b96:	182d      	adds	r5, r5, r0
    7b98:	eb47 77e0 	adc.w	r7, r7, r0, asr #31
    7b9c:	e9c4 5704 	strd	r5, r7, [r4, #16]
    7ba0:	e7e9      	b.n	7b76 <z_add_timeout+0x5a>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
    7ba2:	1a52      	subs	r2, r2, r1
    7ba4:	eb65 0507 	sbc.w	r5, r5, r7
	return (node == list->tail) ? NULL : node->next;
    7ba8:	459c      	cmp	ip, r3
    7baa:	e9c4 2504 	strd	r2, r5, [r4, #16]
    7bae:	d0e7      	beq.n	7b80 <z_add_timeout+0x64>
    7bb0:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
    7bb2:	2b00      	cmp	r3, #0
    7bb4:	d0e4      	beq.n	7b80 <z_add_timeout+0x64>
			if (t->dticks > to->dticks) {
    7bb6:	e9d3 1704 	ldrd	r1, r7, [r3, #16]
    7bba:	e9d4 2504 	ldrd	r2, r5, [r4, #16]
    7bbe:	428a      	cmp	r2, r1
    7bc0:	eb75 0e07 	sbcs.w	lr, r5, r7
    7bc4:	daed      	bge.n	7ba2 <z_add_timeout+0x86>
				t->dticks -= to->dticks;
    7bc6:	1a8a      	subs	r2, r1, r2
    7bc8:	eb67 0505 	sbc.w	r5, r7, r5
    7bcc:	e9c3 2504 	strd	r2, r5, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
    7bd0:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    7bd2:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
    7bd6:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    7bd8:	605c      	str	r4, [r3, #4]
	return list->head == list;
    7bda:	6803      	ldr	r3, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7bdc:	4283      	cmp	r3, r0
    7bde:	d00b      	beq.n	7bf8 <z_add_timeout+0xdc>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    7be0:	429c      	cmp	r4, r3
    7be2:	d109      	bne.n	7bf8 <z_add_timeout+0xdc>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    7be4:	f7ff ff58 	bl	7a98 <next_timeout>

			if (next_time == 0 ||
    7be8:	b118      	cbz	r0, 7bf2 <z_add_timeout+0xd6>
			    _current_cpu->slice_ticks != next_time) {
    7bea:	4b08      	ldr	r3, [pc, #32]	; (7c0c <z_add_timeout+0xf0>)
			if (next_time == 0 ||
    7bec:	691b      	ldr	r3, [r3, #16]
    7bee:	4283      	cmp	r3, r0
    7bf0:	d002      	beq.n	7bf8 <z_add_timeout+0xdc>
				sys_clock_set_timeout(next_time, false);
    7bf2:	2100      	movs	r1, #0
    7bf4:	f7fd f990 	bl	4f18 <sys_clock_set_timeout>
	__asm__ volatile(
    7bf8:	f386 8811 	msr	BASEPRI, r6
    7bfc:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    7c00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7c02:	bf00      	nop
    7c04:	20000518 	.word	0x20000518
    7c08:	20000190 	.word	0x20000190
    7c0c:	20001330 	.word	0x20001330

00007c10 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
    7c10:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    7c14:	4605      	mov	r5, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    7c16:	f7ff fc77 	bl	7508 <z_time_slice>
	__asm__ volatile(
    7c1a:	f04f 0320 	mov.w	r3, #32
    7c1e:	f3ef 8411 	mrs	r4, BASEPRI
    7c22:	f383 8812 	msr	BASEPRI_MAX, r3
    7c26:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    7c2a:	4e24      	ldr	r6, [pc, #144]	; (7cbc <sys_clock_announce+0xac>)
	return list->head == list;
    7c2c:	f8df 8090 	ldr.w	r8, [pc, #144]	; 7cc0 <sys_clock_announce+0xb0>
    7c30:	6035      	str	r5, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    7c32:	4d24      	ldr	r5, [pc, #144]	; (7cc4 <sys_clock_announce+0xb4>)
    7c34:	f8d8 0000 	ldr.w	r0, [r8]
	while (first() != NULL && first()->dticks <= announce_remaining) {
    7c38:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7c3a:	4540      	cmp	r0, r8
		curr_tick += dt;
    7c3c:	e9d5 1e00 	ldrd	r1, lr, [r5]
    7c40:	ea4f 77e2 	mov.w	r7, r2, asr #31
    7c44:	d00b      	beq.n	7c5e <sys_clock_announce+0x4e>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    7c46:	b150      	cbz	r0, 7c5e <sys_clock_announce+0x4e>
    7c48:	e9d0 3c04 	ldrd	r3, ip, [r0, #16]
    7c4c:	429a      	cmp	r2, r3
    7c4e:	eb77 090c 	sbcs.w	r9, r7, ip
    7c52:	da16      	bge.n	7c82 <sys_clock_announce+0x72>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    7c54:	1a9b      	subs	r3, r3, r2
    7c56:	eb6c 0c07 	sbc.w	ip, ip, r7
    7c5a:	e9c0 3c04 	strd	r3, ip, [r0, #16]
	}

	curr_tick += announce_remaining;
    7c5e:	1852      	adds	r2, r2, r1
    7c60:	eb4e 0707 	adc.w	r7, lr, r7
    7c64:	e9c5 2700 	strd	r2, r7, [r5]
	announce_remaining = 0;
    7c68:	2500      	movs	r5, #0
    7c6a:	6035      	str	r5, [r6, #0]

	sys_clock_set_timeout(next_timeout(), false);
    7c6c:	f7ff ff14 	bl	7a98 <next_timeout>
    7c70:	4629      	mov	r1, r5
    7c72:	f7fd f951 	bl	4f18 <sys_clock_set_timeout>
	__asm__ volatile(
    7c76:	f384 8811 	msr	BASEPRI, r4
    7c7a:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    7c7e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
    7c82:	1859      	adds	r1, r3, r1
    7c84:	eb4e 77e3 	adc.w	r7, lr, r3, asr #31
		announce_remaining -= dt;
    7c88:	1ad3      	subs	r3, r2, r3
    7c8a:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
    7c8c:	2200      	movs	r2, #0
    7c8e:	2300      	movs	r3, #0
    7c90:	e9c0 2304 	strd	r2, r3, [r0, #16]
		curr_tick += dt;
    7c94:	e9c5 1700 	strd	r1, r7, [r5]
		remove_timeout(t);
    7c98:	f7ff ff26 	bl	7ae8 <remove_timeout>
    7c9c:	f384 8811 	msr	BASEPRI, r4
    7ca0:	f3bf 8f6f 	isb	sy
		t->fn(t);
    7ca4:	6883      	ldr	r3, [r0, #8]
    7ca6:	4798      	blx	r3
	__asm__ volatile(
    7ca8:	f04f 0320 	mov.w	r3, #32
    7cac:	f3ef 8411 	mrs	r4, BASEPRI
    7cb0:	f383 8812 	msr	BASEPRI_MAX, r3
    7cb4:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    7cb8:	e7bc      	b.n	7c34 <sys_clock_announce+0x24>
    7cba:	bf00      	nop
    7cbc:	2000136c 	.word	0x2000136c
    7cc0:	20000190 	.word	0x20000190
    7cc4:	20000518 	.word	0x20000518

00007cc8 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    7cc8:	b510      	push	{r4, lr}
    7cca:	f04f 0320 	mov.w	r3, #32
    7cce:	f3ef 8411 	mrs	r4, BASEPRI
    7cd2:	f383 8812 	msr	BASEPRI_MAX, r3
    7cd6:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
    7cda:	f7fd f94f 	bl	4f7c <sys_clock_elapsed>
    7cde:	4a05      	ldr	r2, [pc, #20]	; (7cf4 <sys_clock_tick_get+0x2c>)
    7ce0:	e9d2 3100 	ldrd	r3, r1, [r2]
    7ce4:	18c0      	adds	r0, r0, r3
    7ce6:	f141 0100 	adc.w	r1, r1, #0
	__asm__ volatile(
    7cea:	f384 8811 	msr	BASEPRI, r4
    7cee:	f3bf 8f6f 	isb	sy
	}
	return t;
}
    7cf2:	bd10      	pop	{r4, pc}
    7cf4:	20000518 	.word	0x20000518

00007cf8 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
    7cf8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    7cfa:	4606      	mov	r6, r0
    7cfc:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
    7cfe:	f001 faaa 	bl	9256 <k_is_in_isr>
    7d02:	b978      	cbnz	r0, 7d24 <z_thread_aligned_alloc+0x2c>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
    7d04:	4b0b      	ldr	r3, [pc, #44]	; (7d34 <z_thread_aligned_alloc+0x3c>)
    7d06:	689b      	ldr	r3, [r3, #8]
    7d08:	6f1c      	ldr	r4, [r3, #112]	; 0x70
	}

	if (heap != NULL) {
    7d0a:	b17c      	cbz	r4, 7d2c <z_thread_aligned_alloc+0x34>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
    7d0c:	1d2a      	adds	r2, r5, #4
    7d0e:	d209      	bcs.n	7d24 <z_thread_aligned_alloc+0x2c>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
    7d10:	2000      	movs	r0, #0
    7d12:	2100      	movs	r1, #0
    7d14:	e9cd 0100 	strd	r0, r1, [sp]
    7d18:	f046 0104 	orr.w	r1, r6, #4
    7d1c:	4620      	mov	r0, r4
    7d1e:	f001 fcdb 	bl	96d8 <k_heap_aligned_alloc>
	if (mem == NULL) {
    7d22:	b908      	cbnz	r0, 7d28 <z_thread_aligned_alloc+0x30>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
    7d24:	2400      	movs	r4, #0
	}

	return ret;
    7d26:	e001      	b.n	7d2c <z_thread_aligned_alloc+0x34>
	*heap_ref = heap;
    7d28:	6004      	str	r4, [r0, #0]
	mem = ++heap_ref;
    7d2a:	1d04      	adds	r4, r0, #4
}
    7d2c:	4620      	mov	r0, r4
    7d2e:	b002      	add	sp, #8
    7d30:	bd70      	pop	{r4, r5, r6, pc}
    7d32:	bf00      	nop
    7d34:	20001330 	.word	0x20001330

00007d38 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    7d38:	4a02      	ldr	r2, [pc, #8]	; (7d44 <boot_banner+0xc>)
    7d3a:	4903      	ldr	r1, [pc, #12]	; (7d48 <boot_banner+0x10>)
    7d3c:	4803      	ldr	r0, [pc, #12]	; (7d4c <boot_banner+0x14>)
    7d3e:	f000 b854 	b.w	7dea <printk>
    7d42:	bf00      	nop
    7d44:	00009d47 	.word	0x00009d47
    7d48:	00009d06 	.word	0x00009d06
    7d4c:	00009d21 	.word	0x00009d21

00007d50 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
    7d50:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
    7d52:	4c06      	ldr	r4, [pc, #24]	; (7d6c <statics_init+0x1c>)
    7d54:	4d06      	ldr	r5, [pc, #24]	; (7d70 <statics_init+0x20>)
    7d56:	42ac      	cmp	r4, r5
    7d58:	d301      	bcc.n	7d5e <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
    7d5a:	2000      	movs	r0, #0
    7d5c:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    7d5e:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
    7d62:	4620      	mov	r0, r4
    7d64:	f001 fcb0 	bl	96c8 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
    7d68:	3414      	adds	r4, #20
    7d6a:	e7f4      	b.n	7d56 <statics_init+0x6>
    7d6c:	200001c8 	.word	0x200001c8
    7d70:	200001c8 	.word	0x200001c8

00007d74 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
    7d74:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
    7d76:	4b09      	ldr	r3, [pc, #36]	; (7d9c <k_sys_work_q_init+0x28>)
    7d78:	9302      	str	r3, [sp, #8]
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
    7d7a:	ab02      	add	r3, sp, #8
	struct k_work_queue_config cfg = {
    7d7c:	2400      	movs	r4, #0
	k_work_queue_start(&k_sys_work_q,
    7d7e:	9300      	str	r3, [sp, #0]
    7d80:	4907      	ldr	r1, [pc, #28]	; (7da0 <k_sys_work_q_init+0x2c>)
    7d82:	4808      	ldr	r0, [pc, #32]	; (7da4 <k_sys_work_q_init+0x30>)
	struct k_work_queue_config cfg = {
    7d84:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
    7d88:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7d8c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    7d90:	f7ff fabc 	bl	730c <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
    7d94:	4620      	mov	r0, r4
    7d96:	b004      	add	sp, #16
    7d98:	bd10      	pop	{r4, pc}
    7d9a:	bf00      	nop
    7d9c:	00009d48 	.word	0x00009d48
    7da0:	200029a0 	.word	0x200029a0
    7da4:	20000520 	.word	0x20000520

00007da8 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
    7da8:	4770      	bx	lr

00007daa <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
    7daa:	4603      	mov	r3, r0
    7dac:	b158      	cbz	r0, 7dc6 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    7dae:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    7db0:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
    7db4:	2a01      	cmp	r2, #1
    7db6:	d003      	beq.n	7dc0 <sys_notify_validate+0x16>
    7db8:	2a03      	cmp	r2, #3
    7dba:	d104      	bne.n	7dc6 <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
    7dbc:	6802      	ldr	r2, [r0, #0]
    7dbe:	b112      	cbz	r2, 7dc6 <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
    7dc0:	2000      	movs	r0, #0
    7dc2:	6098      	str	r0, [r3, #8]
    7dc4:	4770      	bx	lr
		return -EINVAL;
    7dc6:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
    7dca:	4770      	bx	lr

00007dcc <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    7dcc:	6842      	ldr	r2, [r0, #4]
	uint32_t method = sys_notify_get_method(notify);

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
    7dce:	6081      	str	r1, [r0, #8]
	return method & SYS_NOTIFY_METHOD_MASK;
    7dd0:	f002 0203 	and.w	r2, r2, #3
	switch (method) {
    7dd4:	2a03      	cmp	r2, #3
    7dd6:	f04f 0200 	mov.w	r2, #0
{
    7dda:	4603      	mov	r3, r0
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
    7ddc:	bf0c      	ite	eq
    7dde:	6800      	ldreq	r0, [r0, #0]
	sys_notify_generic_callback rv = NULL;
    7de0:	4610      	movne	r0, r2
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
    7de2:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
    7de4:	4770      	bx	lr

00007de6 <arch_printk_char_out>:
}
    7de6:	2000      	movs	r0, #0
    7de8:	4770      	bx	lr

00007dea <printk>:
 *
 * @return N/A
 */

void printk(const char *fmt, ...)
{
    7dea:	b40f      	push	{r0, r1, r2, r3}
    7dec:	b507      	push	{r0, r1, r2, lr}
    7dee:	a904      	add	r1, sp, #16
    7df0:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
    7df4:	9101      	str	r1, [sp, #4]

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
    7df6:	f7f9 fb4b 	bl	1490 <vprintk>
	}
	va_end(ap);
}
    7dfa:	b003      	add	sp, #12
    7dfc:	f85d eb04 	ldr.w	lr, [sp], #4
    7e00:	b004      	add	sp, #16
    7e02:	4770      	bx	lr

00007e04 <sys_slist_find_and_remove>:
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    7e04:	b510      	push	{r4, lr}
    7e06:	4603      	mov	r3, r0
	return list->head;
    7e08:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    7e0a:	2200      	movs	r2, #0
    7e0c:	b158      	cbz	r0, 7e26 <sys_slist_find_and_remove+0x22>
    7e0e:	4288      	cmp	r0, r1
    7e10:	d10f      	bne.n	7e32 <sys_slist_find_and_remove+0x2e>
	return node->next;
    7e12:	6808      	ldr	r0, [r1, #0]
	return list->tail;
    7e14:	685c      	ldr	r4, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
    7e16:	b93a      	cbnz	r2, 7e28 <sys_slist_find_and_remove+0x24>
    7e18:	42a1      	cmp	r1, r4
	list->head = node;
    7e1a:	6018      	str	r0, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
    7e1c:	d100      	bne.n	7e20 <sys_slist_find_and_remove+0x1c>
	list->tail = node;
    7e1e:	6058      	str	r0, [r3, #4]
	parent->next = child;
    7e20:	2300      	movs	r3, #0
    7e22:	600b      	str	r3, [r1, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    7e24:	2001      	movs	r0, #1
    7e26:	bd10      	pop	{r4, pc}
Z_GENLIST_REMOVE(slist, snode)
    7e28:	42a1      	cmp	r1, r4
	parent->next = child;
    7e2a:	6010      	str	r0, [r2, #0]
	list->tail = node;
    7e2c:	bf08      	it	eq
    7e2e:	605a      	streq	r2, [r3, #4]
}
    7e30:	e7f6      	b.n	7e20 <sys_slist_find_and_remove+0x1c>
	return node->next;
    7e32:	4602      	mov	r2, r0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    7e34:	6800      	ldr	r0, [r0, #0]
    7e36:	e7e9      	b.n	7e0c <sys_slist_find_and_remove+0x8>

00007e38 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    7e38:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
    7e3a:	f013 0307 	ands.w	r3, r3, #7
    7e3e:	d105      	bne.n	7e4c <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
    7e40:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
    7e42:	2b00      	cmp	r3, #0
    7e44:	bf0c      	ite	eq
    7e46:	2000      	moveq	r0, #0
    7e48:	2003      	movne	r0, #3
    7e4a:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
    7e4c:	2b02      	cmp	r3, #2
    7e4e:	d105      	bne.n	7e5c <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
    7e50:	8b43      	ldrh	r3, [r0, #26]
		evt = EVT_STOP;
    7e52:	2b00      	cmp	r3, #0
    7e54:	bf14      	ite	ne
    7e56:	2000      	movne	r0, #0
    7e58:	2004      	moveq	r0, #4
    7e5a:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
    7e5c:	2b01      	cmp	r3, #1
    7e5e:	d105      	bne.n	7e6c <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
    7e60:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
    7e62:	2b00      	cmp	r3, #0
    7e64:	bf0c      	ite	eq
    7e66:	2000      	moveq	r0, #0
    7e68:	2005      	movne	r0, #5
    7e6a:	4770      	bx	lr
	int evt = EVT_NOP;
    7e6c:	2000      	movs	r0, #0
}
    7e6e:	4770      	bx	lr

00007e70 <notify_one>:
{
    7e70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7e74:	460d      	mov	r5, r1
    7e76:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    7e78:	4619      	mov	r1, r3
    7e7a:	1d28      	adds	r0, r5, #4
{
    7e7c:	4690      	mov	r8, r2
    7e7e:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    7e80:	f7ff ffa4 	bl	7dcc <sys_notify_finalize>
	if (cb) {
    7e84:	4604      	mov	r4, r0
    7e86:	b138      	cbz	r0, 7e98 <notify_one+0x28>
		cb(mgr, cli, state, res);
    7e88:	4633      	mov	r3, r6
    7e8a:	4642      	mov	r2, r8
    7e8c:	4629      	mov	r1, r5
    7e8e:	4638      	mov	r0, r7
    7e90:	46a4      	mov	ip, r4
}
    7e92:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
    7e96:	4760      	bx	ip
}
    7e98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007e9c <transition_complete>:
{
    7e9c:	b410      	push	{r4}
	__asm__ volatile(
    7e9e:	f04f 0420 	mov.w	r4, #32
    7ea2:	f3ef 8211 	mrs	r2, BASEPRI
    7ea6:	f384 8812 	msr	BASEPRI_MAX, r4
    7eaa:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
    7eae:	6141      	str	r1, [r0, #20]
}
    7eb0:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
    7eb2:	2101      	movs	r1, #1
    7eb4:	f7f9 bafa 	b.w	14ac <process_event>

00007eb8 <validate_args>:
{
    7eb8:	b510      	push	{r4, lr}
    7eba:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
    7ebc:	b140      	cbz	r0, 7ed0 <validate_args+0x18>
    7ebe:	b139      	cbz	r1, 7ed0 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
    7ec0:	1d08      	adds	r0, r1, #4
    7ec2:	f7ff ff72 	bl	7daa <sys_notify_validate>
	if ((rv == 0)
    7ec6:	b928      	cbnz	r0, 7ed4 <validate_args+0x1c>
	    && ((cli->notify.flags
    7ec8:	68a3      	ldr	r3, [r4, #8]
    7eca:	f033 0303 	bics.w	r3, r3, #3
    7ece:	d001      	beq.n	7ed4 <validate_args+0x1c>
		rv = -EINVAL;
    7ed0:	f06f 0015 	mvn.w	r0, #21
}
    7ed4:	bd10      	pop	{r4, pc}

00007ed6 <onoff_manager_init>:
{
    7ed6:	b538      	push	{r3, r4, r5, lr}
    7ed8:	460c      	mov	r4, r1
	if ((mgr == NULL)
    7eda:	4605      	mov	r5, r0
    7edc:	b158      	cbz	r0, 7ef6 <onoff_manager_init+0x20>
	    || (transitions == NULL)
    7ede:	b151      	cbz	r1, 7ef6 <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
    7ee0:	680b      	ldr	r3, [r1, #0]
    7ee2:	b143      	cbz	r3, 7ef6 <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
    7ee4:	684b      	ldr	r3, [r1, #4]
    7ee6:	b133      	cbz	r3, 7ef6 <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
    7ee8:	221c      	movs	r2, #28
    7eea:	2100      	movs	r1, #0
    7eec:	f000 fcef 	bl	88ce <memset>
    7ef0:	612c      	str	r4, [r5, #16]
	return 0;
    7ef2:	2000      	movs	r0, #0
}
    7ef4:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    7ef6:	f06f 0015 	mvn.w	r0, #21
    7efa:	e7fb      	b.n	7ef4 <onoff_manager_init+0x1e>

00007efc <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
    7efc:	b570      	push	{r4, r5, r6, lr}
    7efe:	4604      	mov	r4, r0
    7f00:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
    7f02:	f7ff ffd9 	bl	7eb8 <validate_args>

	if (rv < 0) {
    7f06:	1e05      	subs	r5, r0, #0
    7f08:	db31      	blt.n	7f6e <onoff_request+0x72>
    7f0a:	f04f 0320 	mov.w	r3, #32
    7f0e:	f3ef 8111 	mrs	r1, BASEPRI
    7f12:	f383 8812 	msr	BASEPRI_MAX, r3
    7f16:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
    7f1a:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    7f1c:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
    7f1e:	f64f 75ff 	movw	r5, #65535	; 0xffff
    7f22:	42ab      	cmp	r3, r5
    7f24:	f000 0207 	and.w	r2, r0, #7
    7f28:	d02e      	beq.n	7f88 <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
    7f2a:	2a02      	cmp	r2, #2
    7f2c:	d10e      	bne.n	7f4c <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
    7f2e:	3301      	adds	r3, #1
    7f30:	8363      	strh	r3, [r4, #26]
	rv = state;
    7f32:	4615      	mov	r5, r2
		notify = true;
    7f34:	2301      	movs	r3, #1
	__asm__ volatile(
    7f36:	f381 8811 	msr	BASEPRI, r1
    7f3a:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
    7f3e:	b1b3      	cbz	r3, 7f6e <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
    7f40:	2300      	movs	r3, #0
    7f42:	4631      	mov	r1, r6
    7f44:	4620      	mov	r0, r4
    7f46:	f7ff ff93 	bl	7e70 <notify_one>
    7f4a:	e010      	b.n	7f6e <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
    7f4c:	0783      	lsls	r3, r0, #30
    7f4e:	d001      	beq.n	7f54 <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
    7f50:	2a06      	cmp	r2, #6
    7f52:	d10e      	bne.n	7f72 <onoff_request+0x76>
	parent->next = child;
    7f54:	2300      	movs	r3, #0
    7f56:	6033      	str	r3, [r6, #0]
	return list->tail;
    7f58:	6863      	ldr	r3, [r4, #4]
Z_GENLIST_APPEND(slist, snode)
    7f5a:	b993      	cbnz	r3, 7f82 <onoff_request+0x86>
	list->head = node;
    7f5c:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
    7f60:	4615      	mov	r5, r2
    7f62:	b962      	cbnz	r2, 7f7e <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
    7f64:	460a      	mov	r2, r1
    7f66:	4620      	mov	r0, r4
    7f68:	2102      	movs	r1, #2
    7f6a:	f7f9 fa9f 	bl	14ac <process_event>
		}
	}

	return rv;
}
    7f6e:	4628      	mov	r0, r5
    7f70:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
    7f72:	2a05      	cmp	r2, #5
    7f74:	bf0c      	ite	eq
    7f76:	f06f 0585 	mvneq.w	r5, #133	; 0x85
    7f7a:	f06f 0504 	mvnne.w	r5, #4
    7f7e:	2300      	movs	r3, #0
    7f80:	e7d9      	b.n	7f36 <onoff_request+0x3a>
	parent->next = child;
    7f82:	601e      	str	r6, [r3, #0]
	list->tail = node;
    7f84:	6066      	str	r6, [r4, #4]
}
    7f86:	e7eb      	b.n	7f60 <onoff_request+0x64>
		rv = -EAGAIN;
    7f88:	f06f 050a 	mvn.w	r5, #10
    7f8c:	e7f7      	b.n	7f7e <onoff_request+0x82>

00007f8e <onoff_release>:

int onoff_release(struct onoff_manager *mgr)
{
    7f8e:	b510      	push	{r4, lr}
	__asm__ volatile(
    7f90:	f04f 0320 	mov.w	r3, #32
    7f94:	f3ef 8211 	mrs	r2, BASEPRI
    7f98:	f383 8812 	msr	BASEPRI_MAX, r3
    7f9c:	f3bf 8f6f 	isb	sy
	bool stop = false;      /* trigger a stop transition */

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    7fa0:	8b04      	ldrh	r4, [r0, #24]
    7fa2:	f004 0407 	and.w	r4, r4, #7
	int rv = state;

	if (state != ONOFF_STATE_ON) {
    7fa6:	2c02      	cmp	r4, #2
    7fa8:	d00a      	beq.n	7fc0 <onoff_release+0x32>
		if (state == ONOFF_STATE_ERROR) {
			rv = -EIO;
		} else {
			rv = -ENOTSUP;
    7faa:	2c01      	cmp	r4, #1
    7fac:	bf0c      	ite	eq
    7fae:	f06f 0004 	mvneq.w	r0, #4
    7fb2:	f06f 0085 	mvnne.w	r0, #133	; 0x85
	__asm__ volatile(
    7fb6:	f382 8811 	msr	BASEPRI, r2
    7fba:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);
	}

	return rv;
    7fbe:	e008      	b.n	7fd2 <onoff_release+0x44>
	mgr->refs -= 1U;
    7fc0:	8b43      	ldrh	r3, [r0, #26]
    7fc2:	3b01      	subs	r3, #1
    7fc4:	b29b      	uxth	r3, r3
    7fc6:	8343      	strh	r3, [r0, #26]
	if (stop) {
    7fc8:	b923      	cbnz	r3, 7fd4 <onoff_release+0x46>
		process_event(mgr, EVT_RECHECK, key);
    7fca:	4621      	mov	r1, r4
    7fcc:	f7f9 fa6e 	bl	14ac <process_event>
	int rv = state;
    7fd0:	4620      	mov	r0, r4
}
    7fd2:	bd10      	pop	{r4, pc}
	int rv = state;
    7fd4:	4620      	mov	r0, r4
    7fd6:	e7ee      	b.n	7fb6 <onoff_release+0x28>

00007fd8 <onoff_cancel>:
	return rv;
}

int onoff_cancel(struct onoff_manager *mgr,
		 struct onoff_client *cli)
{
    7fd8:	b538      	push	{r3, r4, r5, lr}
	if ((mgr == NULL) || (cli == NULL)) {
    7fda:	b1b0      	cbz	r0, 800a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa>
    7fdc:	b1a9      	cbz	r1, 800a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa>
	__asm__ volatile(
    7fde:	f04f 0220 	mov.w	r2, #32
    7fe2:	f3ef 8511 	mrs	r5, BASEPRI
    7fe6:	f382 8812 	msr	BASEPRI_MAX, r2
    7fea:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	int rv = -EALREADY;
	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    7fee:	8b04      	ldrh	r4, [r0, #24]

	if (sys_slist_find_and_remove(&mgr->clients, &cli->node)) {
    7ff0:	f7ff ff08 	bl	7e04 <sys_slist_find_and_remove>
    7ff4:	b130      	cbz	r0, 8004 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4>
		__ASSERT_NO_MSG((state == ONOFF_STATE_TO_ON)
				|| (state == ONOFF_STATE_TO_OFF)
				|| (state == ONOFF_STATE_RESETTING));
		rv = state;
    7ff6:	f004 0007 	and.w	r0, r4, #7
	__asm__ volatile(
    7ffa:	f385 8811 	msr	BASEPRI, r5
    7ffe:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&mgr->lock, key);

	return rv;
}
    8002:	bd38      	pop	{r3, r4, r5, pc}
	int rv = -EALREADY;
    8004:	f06f 0077 	mvn.w	r0, #119	; 0x77
    8008:	e7f7      	b.n	7ffa <onoff_cancel+0x22>
		return -EINVAL;
    800a:	f06f 0015 	mvn.w	r0, #21
    800e:	e7f8      	b.n	8002 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2>

00008010 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    8010:	4604      	mov	r4, r0
    8012:	b508      	push	{r3, lr}
    8014:	4608      	mov	r0, r1
    8016:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    8018:	461a      	mov	r2, r3
    801a:	47a0      	blx	r4
	return z_impl_z_current_get();
    801c:	f7ff fc9e 	bl	795c <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
    8020:	f7fb fb1a 	bl	3658 <z_impl_k_thread_abort>

00008024 <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
    8024:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
    8028:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
    802a:	0840      	lsrs	r0, r0, #1
    802c:	4770      	bx	lr

0000802e <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    802e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8030:	4603      	mov	r3, r0
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
    8032:	f7ff fff7 	bl	8024 <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
    8036:	fab0 f080 	clz	r0, r0
    803a:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
    803e:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
	void *cmem = &buf[c];
    8042:	00ca      	lsls	r2, r1, #3
    8044:	f8dc 6010 	ldr.w	r6, [ip, #16]
		((uint16_t *)cmem)[f] = val;
    8048:	1d17      	adds	r7, r2, #4
{
    804a:	460c      	mov	r4, r1
    804c:	3206      	adds	r2, #6
    804e:	b28d      	uxth	r5, r1
	if (b->next == 0U) {
    8050:	b956      	cbnz	r6, 8068 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
    8052:	2101      	movs	r1, #1
    8054:	fa01 f000 	lsl.w	r0, r1, r0
    8058:	68d9      	ldr	r1, [r3, #12]
    805a:	4301      	orrs	r1, r0
    805c:	60d9      	str	r1, [r3, #12]
		b->next = c;
    805e:	f8cc 4010 	str.w	r4, [ip, #16]
    8062:	53dd      	strh	r5, [r3, r7]
    8064:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
    8066:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
    8068:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
    806a:	3104      	adds	r1, #4
    806c:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
    806e:	53d8      	strh	r0, [r3, r7]
    8070:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    8074:	529e      	strh	r6, [r3, r2]
    8076:	80c5      	strh	r5, [r0, #6]
    8078:	525d      	strh	r5, [r3, r1]
    807a:	e7f4      	b.n	8066 <free_list_add+0x38>

0000807c <free_list_remove_bidx>:
{
    807c:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
    807e:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    8082:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
    8084:	4299      	cmp	r1, r3
    8086:	f102 0104 	add.w	r1, r2, #4
    808a:	d10a      	bne.n	80a2 <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
    808c:	2301      	movs	r3, #1
    808e:	fa03 f202 	lsl.w	r2, r3, r2
    8092:	68c3      	ldr	r3, [r0, #12]
    8094:	ea23 0302 	bic.w	r3, r3, r2
    8098:	60c3      	str	r3, [r0, #12]
		b->next = 0;
    809a:	2300      	movs	r3, #0
    809c:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
    80a0:	bd10      	pop	{r4, pc}
    80a2:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
    80a4:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
    80a8:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
    80ac:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
    80b0:	80cb      	strh	r3, [r1, #6]
    80b2:	8082      	strh	r2, [r0, #4]
}
    80b4:	e7f4      	b.n	80a0 <free_list_remove_bidx+0x24>

000080b6 <free_list_remove>:
{
    80b6:	b508      	push	{r3, lr}
    80b8:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
    80ba:	f7ff ffb3 	bl	8024 <chunk_size>
	return 31 - __builtin_clz(usable_sz);
    80be:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
    80c2:	f1c2 021f 	rsb	r2, r2, #31
    80c6:	4618      	mov	r0, r3
}
    80c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		free_list_remove_bidx(h, c, bidx);
    80cc:	f7ff bfd6 	b.w	807c <free_list_remove_bidx>

000080d0 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
    80d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    80d4:	fab1 f581 	clz	r5, r1
    80d8:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
    80dc:	eb00 0789 	add.w	r7, r0, r9, lsl #2
{
    80e0:	4603      	mov	r3, r0
	if (b->next) {
    80e2:	693a      	ldr	r2, [r7, #16]
{
    80e4:	460e      	mov	r6, r1
	if (b->next) {
    80e6:	b1c2      	cbz	r2, 811a <alloc_chunk+0x4a>
    80e8:	f04f 0803 	mov.w	r8, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
    80ec:	693c      	ldr	r4, [r7, #16]
			if (chunk_size(h, c) >= sz) {
    80ee:	4618      	mov	r0, r3
    80f0:	4621      	mov	r1, r4
    80f2:	f7ff ff97 	bl	8024 <chunk_size>
    80f6:	42b0      	cmp	r0, r6
    80f8:	d306      	bcc.n	8108 <alloc_chunk+0x38>
				free_list_remove_bidx(h, c, bi);
    80fa:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
    80fc:	4618      	mov	r0, r3
    80fe:	f7ff ffbd 	bl	807c <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
    8102:	4620      	mov	r0, r4
    8104:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
    8108:	eb03 00c4 	add.w	r0, r3, r4, lsl #3
		} while (--i && b->next != first);
    810c:	f1b8 0801 	subs.w	r8, r8, #1
    8110:	88c0      	ldrh	r0, [r0, #6]
			b->next = next_free_chunk(h, c);
    8112:	6138      	str	r0, [r7, #16]
		} while (--i && b->next != first);
    8114:	d001      	beq.n	811a <alloc_chunk+0x4a>
    8116:	4282      	cmp	r2, r0
    8118:	d1e8      	bne.n	80ec <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
    811a:	f1c5 0220 	rsb	r2, r5, #32
    811e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    8122:	4094      	lsls	r4, r2
    8124:	68da      	ldr	r2, [r3, #12]
	if (bmask != 0U) {
    8126:	4014      	ands	r4, r2
    8128:	d0eb      	beq.n	8102 <alloc_chunk+0x32>
		int minbucket = __builtin_ctz(bmask);
    812a:	fa94 f2a4 	rbit	r2, r4
    812e:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
    8132:	1d11      	adds	r1, r2, #4
    8134:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
    8138:	4621      	mov	r1, r4
    813a:	e7df      	b.n	80fc <alloc_chunk+0x2c>

0000813c <merge_chunks>:
{
    813c:	b538      	push	{r3, r4, r5, lr}
    813e:	4603      	mov	r3, r0
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    8140:	f7ff ff70 	bl	8024 <chunk_size>
{
    8144:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    8146:	4604      	mov	r4, r0
    8148:	4611      	mov	r1, r2
    814a:	4618      	mov	r0, r3
    814c:	f7ff ff6a 	bl	8024 <chunk_size>
		((uint16_t *)cmem)[f] = val;
    8150:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
    8154:	4404      	add	r4, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    8156:	0060      	lsls	r0, r4, #1
		((uint16_t *)cmem)[f] = val;
    8158:	8068      	strh	r0, [r5, #2]
	return c + chunk_size(h, c);
    815a:	4618      	mov	r0, r3
    815c:	f7ff ff62 	bl	8024 <chunk_size>
	void *cmem = &buf[c];
    8160:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
    8162:	f823 4031 	strh.w	r4, [r3, r1, lsl #3]
}
    8166:	bd38      	pop	{r3, r4, r5, pc}

00008168 <split_chunks>:
{
    8168:	b538      	push	{r3, r4, r5, lr}
    816a:	4603      	mov	r3, r0
	chunksz_t sz0 = chunk_size(h, lc);
    816c:	f7ff ff5a 	bl	8024 <chunk_size>
{
    8170:	460c      	mov	r4, r1
	chunksz_t rsz = sz0 - lsz;
    8172:	1aa5      	subs	r5, r4, r2
	chunksz_t lsz = rc - lc;
    8174:	1a51      	subs	r1, r2, r1
    8176:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunksz_t rsz = sz0 - lsz;
    817a:	4405      	add	r5, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    817c:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
    817e:	8060      	strh	r0, [r4, #2]
    8180:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    8184:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
    8186:	8044      	strh	r4, [r0, #2]
    8188:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
    818c:	4618      	mov	r0, r3
    818e:	4611      	mov	r1, r2
    8190:	f7ff ff48 	bl	8024 <chunk_size>
	void *cmem = &buf[c];
    8194:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
    8196:	f823 5031 	strh.w	r5, [r3, r1, lsl #3]
}
    819a:	bd38      	pop	{r3, r4, r5, pc}

0000819c <free_chunk>:
{
    819c:	b538      	push	{r3, r4, r5, lr}
    819e:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
    81a0:	f7ff ff40 	bl	8024 <chunk_size>
    81a4:	460c      	mov	r4, r1
    81a6:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
    81a8:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    81ac:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
    81ae:	07da      	lsls	r2, r3, #31
    81b0:	d40a      	bmi.n	81c8 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
    81b2:	4628      	mov	r0, r5
    81b4:	f7ff ff7f 	bl	80b6 <free_list_remove>
	return c + chunk_size(h, c);
    81b8:	4621      	mov	r1, r4
    81ba:	4628      	mov	r0, r5
    81bc:	f7ff ff32 	bl	8024 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
    81c0:	1822      	adds	r2, r4, r0
    81c2:	4628      	mov	r0, r5
    81c4:	f7ff ffba 	bl	813c <merge_chunks>
		return ((uint16_t *)cmem)[f];
    81c8:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
    81cc:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
    81ce:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    81d2:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
    81d4:	07db      	lsls	r3, r3, #31
    81d6:	d40c      	bmi.n	81f2 <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
    81d8:	4628      	mov	r0, r5
    81da:	f7ff ff6c 	bl	80b6 <free_list_remove>
		return ((uint16_t *)cmem)[f];
    81de:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
    81e2:	4622      	mov	r2, r4
    81e4:	1a61      	subs	r1, r4, r1
    81e6:	4628      	mov	r0, r5
    81e8:	f7ff ffa8 	bl	813c <merge_chunks>
    81ec:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
    81f0:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
    81f2:	4621      	mov	r1, r4
    81f4:	4628      	mov	r0, r5
}
    81f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
    81fa:	f7ff bf18 	b.w	802e <free_list_add>

000081fe <sys_heap_free>:
	if (mem == NULL) {
    81fe:	b161      	cbz	r1, 821a <sys_heap_free+0x1c>
    8200:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    8202:	3904      	subs	r1, #4
    8204:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
    8206:	f021 0307 	bic.w	r3, r1, #7
    820a:	4403      	add	r3, r0
	free_chunk(h, c);
    820c:	08c9      	lsrs	r1, r1, #3
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
    820e:	885a      	ldrh	r2, [r3, #2]
    8210:	f022 0201 	bic.w	r2, r2, #1
    8214:	805a      	strh	r2, [r3, #2]
    8216:	f7ff bfc1 	b.w	819c <free_chunk>
}
    821a:	4770      	bx	lr

0000821c <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
    821c:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
    821e:	6805      	ldr	r5, [r0, #0]

	if (bytes == 0U || size_too_big(h, bytes)) {
    8220:	b909      	cbnz	r1, 8226 <sys_heap_alloc+0xa>
		return NULL;
    8222:	2000      	movs	r0, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return chunk_mem(h, c);
}
    8224:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
    8226:	68ab      	ldr	r3, [r5, #8]
    8228:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
    822c:	d9f9      	bls.n	8222 <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    822e:	310b      	adds	r1, #11
    8230:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
    8232:	4621      	mov	r1, r4
    8234:	4628      	mov	r0, r5
    8236:	f7ff ff4b 	bl	80d0 <alloc_chunk>
	if (c == 0U) {
    823a:	4606      	mov	r6, r0
    823c:	2800      	cmp	r0, #0
    823e:	d0f0      	beq.n	8222 <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
    8240:	4601      	mov	r1, r0
    8242:	4628      	mov	r0, r5
    8244:	f7ff feee 	bl	8024 <chunk_size>
    8248:	42a0      	cmp	r0, r4
    824a:	d907      	bls.n	825c <sys_heap_alloc+0x40>
		split_chunks(h, c, c + chunk_sz);
    824c:	1932      	adds	r2, r6, r4
    824e:	4628      	mov	r0, r5
    8250:	f7ff ff8a 	bl	8168 <split_chunks>
		free_list_add(h, c + chunk_sz);
    8254:	4611      	mov	r1, r2
    8256:	4628      	mov	r0, r5
    8258:	f7ff fee9 	bl	802e <free_list_add>
	void *cmem = &buf[c];
    825c:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
    8260:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    8262:	8853      	ldrh	r3, [r2, #2]
    8264:	f043 0301 	orr.w	r3, r3, #1
    8268:	8053      	strh	r3, [r2, #2]
    826a:	3004      	adds	r0, #4
	return chunk_mem(h, c);
    826c:	e7da      	b.n	8224 <sys_heap_alloc+0x8>

0000826e <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
    826e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8272:	4614      	mov	r4, r2
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
    8274:	424a      	negs	r2, r1
    8276:	ea02 0701 	and.w	r7, r2, r1
	if (align != rew) {
    827a:	ea31 0202 	bics.w	r2, r1, r2
{
    827e:	4603      	mov	r3, r0
	if (align != rew) {
    8280:	d00a      	beq.n	8298 <sys_heap_aligned_alloc+0x2a>
		return false;
    8282:	2f04      	cmp	r7, #4
    8284:	463a      	mov	r2, r7
    8286:	46b9      	mov	r9, r7
    8288:	bf28      	it	cs
    828a:	2204      	movcs	r2, #4
		align -= rew;
    828c:	1bcf      	subs	r7, r1, r7
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
    828e:	b974      	cbnz	r4, 82ae <sys_heap_aligned_alloc+0x40>
		return NULL;
    8290:	2500      	movs	r5, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return mem;
}
    8292:	4628      	mov	r0, r5
    8294:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
    8298:	2904      	cmp	r1, #4
    829a:	d804      	bhi.n	82a6 <sys_heap_aligned_alloc+0x38>
			return sys_heap_alloc(heap, bytes);
    829c:	4621      	mov	r1, r4
}
    829e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
    82a2:	f7ff bfbb 	b.w	821c <sys_heap_alloc>
		rew = 0;
    82a6:	f04f 0900 	mov.w	r9, #0
		gap = chunk_header_bytes(h);
    82aa:	2204      	movs	r2, #4
    82ac:	e7ef      	b.n	828e <sys_heap_aligned_alloc+0x20>
	struct z_heap *h = heap->heap;
    82ae:	681e      	ldr	r6, [r3, #0]
	if (bytes == 0 || size_too_big(h, bytes)) {
    82b0:	68b3      	ldr	r3, [r6, #8]
    82b2:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
    82b6:	d9eb      	bls.n	8290 <sys_heap_aligned_alloc+0x22>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    82b8:	f104 010b 	add.w	r1, r4, #11
    82bc:	4439      	add	r1, r7
    82be:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
    82c0:	08c9      	lsrs	r1, r1, #3
    82c2:	4630      	mov	r0, r6
    82c4:	f7ff ff04 	bl	80d0 <alloc_chunk>
	if (c0 == 0) {
    82c8:	4680      	mov	r8, r0
    82ca:	2800      	cmp	r0, #0
    82cc:	d0e0      	beq.n	8290 <sys_heap_aligned_alloc+0x22>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
    82ce:	f109 0504 	add.w	r5, r9, #4
    82d2:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
    82d6:	1e7b      	subs	r3, r7, #1
    82d8:	4435      	add	r5, r6
    82da:	441d      	add	r5, r3
    82dc:	427f      	negs	r7, r7
    82de:	403d      	ands	r5, r7
    82e0:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    82e4:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    82e6:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    82e8:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    82ea:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    82ec:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
    82f0:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
    82f2:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    82f6:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
    82fa:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
    82fe:	d208      	bcs.n	8312 <sys_heap_aligned_alloc+0xa4>
		split_chunks(h, c0, c);
    8300:	4601      	mov	r1, r0
    8302:	463a      	mov	r2, r7
    8304:	4630      	mov	r0, r6
    8306:	f7ff ff2f 	bl	8168 <split_chunks>
		free_list_add(h, c0);
    830a:	4641      	mov	r1, r8
    830c:	4630      	mov	r0, r6
    830e:	f7ff fe8e 	bl	802e <free_list_add>
	return c + chunk_size(h, c);
    8312:	4639      	mov	r1, r7
    8314:	4630      	mov	r0, r6
    8316:	f7ff fe85 	bl	8024 <chunk_size>
    831a:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
    831c:	4284      	cmp	r4, r0
    831e:	d207      	bcs.n	8330 <sys_heap_aligned_alloc+0xc2>
		split_chunks(h, c, c_end);
    8320:	4630      	mov	r0, r6
    8322:	4622      	mov	r2, r4
    8324:	f7ff ff20 	bl	8168 <split_chunks>
		free_list_add(h, c_end);
    8328:	4621      	mov	r1, r4
    832a:	4630      	mov	r0, r6
    832c:	f7ff fe7f 	bl	802e <free_list_add>
	void *cmem = &buf[c];
    8330:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    8334:	8873      	ldrh	r3, [r6, #2]
    8336:	f043 0301 	orr.w	r3, r3, #1
    833a:	8073      	strh	r3, [r6, #2]
    833c:	e7a9      	b.n	8292 <sys_heap_aligned_alloc+0x24>

0000833e <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
    833e:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    8340:	1dcb      	adds	r3, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    8342:	4411      	add	r1, r2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    8344:	f023 0307 	bic.w	r3, r3, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    8348:	f021 0107 	bic.w	r1, r1, #7
{
    834c:	b4f0      	push	{r4, r5, r6, r7}
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    834e:	1acd      	subs	r5, r1, r3
    8350:	08ea      	lsrs	r2, r5, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
    8352:	6003      	str	r3, [r0, #0]
	return 31 - __builtin_clz(usable_sz);
    8354:	fab2 f082 	clz	r0, r2
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
    8358:	f1c0 0424 	rsb	r4, r0, #36	; 0x24
    835c:	00a4      	lsls	r4, r4, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    835e:	3407      	adds	r4, #7
	h->avail_buckets = 0;
    8360:	2600      	movs	r6, #0
    8362:	08e1      	lsrs	r1, r4, #3
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    8364:	f1c0 0020 	rsb	r0, r0, #32
    8368:	f103 0410 	add.w	r4, r3, #16
	h->end_chunk = heap_sz;
    836c:	609a      	str	r2, [r3, #8]
	h->avail_buckets = 0;
    836e:	60de      	str	r6, [r3, #12]
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    8370:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    8374:	4284      	cmp	r4, r0
    8376:	d118      	bne.n	83aa <sys_heap_init+0x6c>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    8378:	0048      	lsls	r0, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    837a:	f040 0001 	orr.w	r0, r0, #1
    837e:	8058      	strh	r0, [r3, #2]
		((uint16_t *)cmem)[f] = val;
    8380:	eb03 04c1 	add.w	r4, r3, r1, lsl #3
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    8384:	1a50      	subs	r0, r2, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    8386:	0047      	lsls	r7, r0, #1
		((uint16_t *)cmem)[f] = val;
    8388:	801e      	strh	r6, [r3, #0]
    838a:	8067      	strh	r7, [r4, #2]
    838c:	195c      	adds	r4, r3, r5
    838e:	f823 1031 	strh.w	r1, [r3, r1, lsl #3]
	void *cmem = &buf[c];
    8392:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
		((uint16_t *)cmem)[f] = val;
    8396:	8066      	strh	r6, [r4, #2]
    8398:	5358      	strh	r0, [r3, r5]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    839a:	8850      	ldrh	r0, [r2, #2]
    839c:	f040 0001 	orr.w	r0, r0, #1
    83a0:	8050      	strh	r0, [r2, #2]
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
    83a2:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
    83a4:	4618      	mov	r0, r3
    83a6:	f7ff be42 	b.w	802e <free_list_add>
		h->buckets[i].next = 0;
    83aa:	f844 6b04 	str.w	r6, [r4], #4
	for (int i = 0; i < nb_buckets; i++) {
    83ae:	e7e1      	b.n	8374 <sys_heap_init+0x36>

000083b0 <encode_uint>:
{
    83b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    83b4:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
    83b6:	78d3      	ldrb	r3, [r2, #3]
	switch (specifier) {
    83b8:	2b6f      	cmp	r3, #111	; 0x6f
{
    83ba:	4680      	mov	r8, r0
    83bc:	460f      	mov	r7, r1
    83be:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    83c0:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
    83c4:	d029      	beq.n	841a <encode_uint+0x6a>
    83c6:	d824      	bhi.n	8412 <encode_uint+0x62>
		return 16;
    83c8:	2b58      	cmp	r3, #88	; 0x58
    83ca:	bf14      	ite	ne
    83cc:	260a      	movne	r6, #10
    83ce:	2610      	moveq	r6, #16
	char *bp = bps + (bpe - bps);
    83d0:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
    83d4:	4632      	mov	r2, r6
    83d6:	2300      	movs	r3, #0
    83d8:	4640      	mov	r0, r8
    83da:	4639      	mov	r1, r7
    83dc:	f7f8 fe90 	bl	1100 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    83e0:	2a09      	cmp	r2, #9
    83e2:	b2d4      	uxtb	r4, r2
    83e4:	d81e      	bhi.n	8424 <encode_uint+0x74>
    83e6:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
    83e8:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
    83ea:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
    83ec:	f177 0300 	sbcs.w	r3, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
    83f0:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
    83f4:	d301      	bcc.n	83fa <encode_uint+0x4a>
    83f6:	45d1      	cmp	r9, sl
    83f8:	d811      	bhi.n	841e <encode_uint+0x6e>
	if (conv->flag_hash) {
    83fa:	782b      	ldrb	r3, [r5, #0]
    83fc:	069b      	lsls	r3, r3, #26
    83fe:	d505      	bpl.n	840c <encode_uint+0x5c>
		if (radix == 8) {
    8400:	2e08      	cmp	r6, #8
    8402:	d115      	bne.n	8430 <encode_uint+0x80>
			conv->altform_0 = true;
    8404:	78ab      	ldrb	r3, [r5, #2]
    8406:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
    840a:	70ab      	strb	r3, [r5, #2]
}
    840c:	4648      	mov	r0, r9
    840e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
    8412:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
    8416:	2b70      	cmp	r3, #112	; 0x70
    8418:	e7d7      	b.n	83ca <encode_uint+0x1a>
	switch (specifier) {
    841a:	2608      	movs	r6, #8
    841c:	e7d8      	b.n	83d0 <encode_uint+0x20>
		value /= radix;
    841e:	4680      	mov	r8, r0
    8420:	460f      	mov	r7, r1
    8422:	e7d7      	b.n	83d4 <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    8424:	f1bb 0f19 	cmp.w	fp, #25
    8428:	bf94      	ite	ls
    842a:	3437      	addls	r4, #55	; 0x37
    842c:	3457      	addhi	r4, #87	; 0x57
    842e:	e7db      	b.n	83e8 <encode_uint+0x38>
		} else if (radix == 16) {
    8430:	2e10      	cmp	r6, #16
    8432:	d1eb      	bne.n	840c <encode_uint+0x5c>
			conv->altform_0c = true;
    8434:	78ab      	ldrb	r3, [r5, #2]
    8436:	f043 0310 	orr.w	r3, r3, #16
    843a:	e7e6      	b.n	840a <encode_uint+0x5a>

0000843c <outs>:
{
    843c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8440:	4607      	mov	r7, r0
    8442:	4688      	mov	r8, r1
    8444:	4615      	mov	r5, r2
    8446:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    8448:	4614      	mov	r4, r2
    844a:	42b4      	cmp	r4, r6
    844c:	eba4 0005 	sub.w	r0, r4, r5
    8450:	d302      	bcc.n	8458 <outs+0x1c>
    8452:	b93e      	cbnz	r6, 8464 <outs+0x28>
    8454:	7823      	ldrb	r3, [r4, #0]
    8456:	b12b      	cbz	r3, 8464 <outs+0x28>
		int rc = out((int)*sp++, ctx);
    8458:	f814 0b01 	ldrb.w	r0, [r4], #1
    845c:	4641      	mov	r1, r8
    845e:	47b8      	blx	r7
		if (rc < 0) {
    8460:	2800      	cmp	r0, #0
    8462:	daf2      	bge.n	844a <outs+0xe>
}
    8464:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00008468 <ring_buf_get_rewind_threshold>:
 * rewinding earlier.
 */
uint32_t __weak ring_buf_get_rewind_threshold(void)
{
	return RING_BUFFER_MAX_SIZE;
}
    8468:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    846c:	4770      	bx	lr

0000846e <ring_buf_is_empty>:
{
	return buf_size * (threshold / buf_size);
}

int ring_buf_is_empty(struct ring_buf *buf)
{
    846e:	b570      	push	{r4, r5, r6, lr}
	uint32_t tail = buf->tail;
	uint32_t head = buf->head;
    8470:	e9d0 5400 	ldrd	r5, r4, [r0]

	if (tail < head) {
    8474:	42ac      	cmp	r4, r5
    8476:	d206      	bcs.n	8486 <ring_buf_is_empty+0x18>
		tail += get_rewind_value(buf->size,
    8478:	6906      	ldr	r6, [r0, #16]
    847a:	f7ff fff5 	bl	8468 <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
    847e:	fbb0 f0f6 	udiv	r0, r0, r6
		tail += get_rewind_value(buf->size,
    8482:	fb06 4400 	mla	r4, r6, r0, r4
					 ring_buf_get_rewind_threshold());
	}

	return (head == tail);
}
    8486:	1b63      	subs	r3, r4, r5
    8488:	4258      	negs	r0, r3
    848a:	4158      	adcs	r0, r3
    848c:	bd70      	pop	{r4, r5, r6, pc}

0000848e <ring_buf_put_claim>:

	return 0;
}

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
    848e:	b5f0      	push	{r4, r5, r6, r7, lr}
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    8490:	6985      	ldr	r5, [r0, #24]
	uint32_t space, trail_size, allocated, tmp_trail_mod;

	tmp_trail_mod = mod(buf, buf->misc.byte_mode.tmp_tail);
    8492:	6886      	ldr	r6, [r0, #8]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    8494:	6907      	ldr	r7, [r0, #16]
{
    8496:	4604      	mov	r4, r0
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    8498:	b185      	cbz	r5, 84bc <ring_buf_put_claim+0x2e>
    849a:	4035      	ands	r5, r6
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
    849c:	6823      	ldr	r3, [r4, #0]
    849e:	443b      	add	r3, r7
    84a0:	1b98      	subs	r0, r3, r6
	trail_size = buf->size - tmp_trail_mod;

	/* Limit requested size to available size. */
	size = MIN(size, space);
    84a2:	4290      	cmp	r0, r2
    84a4:	bf28      	it	cs
    84a6:	4610      	movcs	r0, r2
	trail_size = buf->size - tmp_trail_mod;
    84a8:	1b7f      	subs	r7, r7, r5

	trail_size = buf->size - (tmp_trail_mod);

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
	*data = &buf->buf.buf8[tmp_trail_mod];
    84aa:	6963      	ldr	r3, [r4, #20]
	allocated = MIN(trail_size, size);
    84ac:	42b8      	cmp	r0, r7
    84ae:	bf28      	it	cs
    84b0:	4638      	movcs	r0, r7
	*data = &buf->buf.buf8[tmp_trail_mod];
    84b2:	442b      	add	r3, r5

	buf->misc.byte_mode.tmp_tail =
		buf->misc.byte_mode.tmp_tail + allocated;
    84b4:	4406      	add	r6, r0
	*data = &buf->buf.buf8[tmp_trail_mod];
    84b6:	600b      	str	r3, [r1, #0]
	buf->misc.byte_mode.tmp_tail =
    84b8:	60a6      	str	r6, [r4, #8]

	return allocated;
}
    84ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    84bc:	fbb6 f5f7 	udiv	r5, r6, r7
    84c0:	fb07 6515 	mls	r5, r7, r5, r6
    84c4:	e7ea      	b.n	849c <ring_buf_put_claim+0xe>

000084c6 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
    84c6:	b570      	push	{r4, r5, r6, lr}
    84c8:	4605      	mov	r5, r0
    84ca:	460c      	mov	r4, r1
	uint32_t rew;
	uint32_t threshold = ring_buf_get_rewind_threshold();
    84cc:	f7ff ffcc 	bl	8468 <ring_buf_get_rewind_threshold>

	if ((buf->tail + size) > (buf->head + buf->size)) {
    84d0:	686e      	ldr	r6, [r5, #4]
    84d2:	692a      	ldr	r2, [r5, #16]
    84d4:	682b      	ldr	r3, [r5, #0]
    84d6:	1931      	adds	r1, r6, r4
    84d8:	4413      	add	r3, r2
    84da:	4299      	cmp	r1, r3
    84dc:	d80a      	bhi.n	84f4 <ring_buf_put_finish+0x2e>
		return -EINVAL;
	}

	/* Check if indexes shall be rewind. */
	if (buf->tail > threshold) {
    84de:	4286      	cmp	r6, r0
		rew = get_rewind_value(buf->size, threshold);
	} else {
		rew = 0;
    84e0:	bf92      	itee	ls
    84e2:	2300      	movls	r3, #0
	return buf_size * (threshold / buf_size);
    84e4:	fbb0 f3f2 	udivhi	r3, r0, r2
    84e8:	4353      	mulhi	r3, r2
	}

	buf->tail += (size - rew);
    84ea:	1ac9      	subs	r1, r1, r3
	buf->misc.byte_mode.tmp_tail = buf->tail;
    84ec:	e9c5 1101 	strd	r1, r1, [r5, #4]

	return 0;
    84f0:	2000      	movs	r0, #0
}
    84f2:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
    84f4:	f06f 0015 	mvn.w	r0, #21
    84f8:	e7fb      	b.n	84f2 <ring_buf_put_finish+0x2c>

000084fa <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
    84fa:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    84fe:	4680      	mov	r8, r0
    8500:	460e      	mov	r6, r1
    8502:	4615      	mov	r5, r2
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
    8504:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
    8506:	462a      	mov	r2, r5
    8508:	a901      	add	r1, sp, #4
    850a:	4640      	mov	r0, r8
    850c:	f7ff ffbf 	bl	848e <ring_buf_put_claim>
		memcpy(dst, data, partial_size);
    8510:	4631      	mov	r1, r6
		partial_size = ring_buf_put_claim(buf, &dst, size);
    8512:	4604      	mov	r4, r0
		memcpy(dst, data, partial_size);
    8514:	4602      	mov	r2, r0
    8516:	9801      	ldr	r0, [sp, #4]
    8518:	f000 f9ce 	bl	88b8 <memcpy>
		total_size += partial_size;
		size -= partial_size;
		data += partial_size;
	} while (size && partial_size);
    851c:	1b2d      	subs	r5, r5, r4
		total_size += partial_size;
    851e:	4427      	add	r7, r4
		data += partial_size;
    8520:	4426      	add	r6, r4
	} while (size && partial_size);
    8522:	d001      	beq.n	8528 <ring_buf_put+0x2e>
    8524:	2c00      	cmp	r4, #0
    8526:	d1ee      	bne.n	8506 <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
    8528:	4639      	mov	r1, r7
    852a:	4640      	mov	r0, r8
    852c:	f7ff ffcb 	bl	84c6 <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
    8530:	4638      	mov	r0, r7
    8532:	b002      	add	sp, #8
    8534:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00008538 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
    8538:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t space, granted_size, trail_size, tmp_head_mod;
	uint32_t tail = buf->tail;

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
    853c:	68c3      	ldr	r3, [r0, #12]
	uint32_t tail = buf->tail;
    853e:	6846      	ldr	r6, [r0, #4]
	if (tail < buf->misc.byte_mode.tmp_head) {
    8540:	42b3      	cmp	r3, r6
{
    8542:	4604      	mov	r4, r0
    8544:	460f      	mov	r7, r1
    8546:	4690      	mov	r8, r2
	if (tail < buf->misc.byte_mode.tmp_head) {
    8548:	d906      	bls.n	8558 <ring_buf_get_claim+0x20>
		/* Locally, increment it to pre-rewind value */
		tail += get_rewind_value(buf->size,
    854a:	6905      	ldr	r5, [r0, #16]
    854c:	f7ff ff8c 	bl	8468 <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
    8550:	fbb0 f0f5 	udiv	r0, r0, r5
		tail += get_rewind_value(buf->size,
    8554:	fb05 6600 	mla	r6, r5, r0, r6
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    8558:	69a5      	ldr	r5, [r4, #24]
					 ring_buf_get_rewind_threshold());
	}

	tmp_head_mod = mod(buf, buf->misc.byte_mode.tmp_head);
    855a:	68e1      	ldr	r1, [r4, #12]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    855c:	6923      	ldr	r3, [r4, #16]
    855e:	b185      	cbz	r5, 8582 <ring_buf_get_claim+0x4a>
    8560:	400d      	ands	r5, r1
	space = tail - buf->misc.byte_mode.tmp_head;
    8562:	1a70      	subs	r0, r6, r1
	trail_size = buf->size - tmp_head_mod;

	/* Limit requested size to available size. */
	granted_size = MIN(size, space);
    8564:	4540      	cmp	r0, r8
    8566:	bf28      	it	cs
    8568:	4640      	movcs	r0, r8
    856a:	4606      	mov	r6, r0
	trail_size = buf->size - tmp_head_mod;
    856c:	1b58      	subs	r0, r3, r5

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);
    856e:	42b0      	cmp	r0, r6

	*data = &buf->buf.buf8[tmp_head_mod];
    8570:	6963      	ldr	r3, [r4, #20]
	granted_size = MIN(trail_size, granted_size);
    8572:	bf28      	it	cs
    8574:	4630      	movcs	r0, r6
	*data = &buf->buf.buf8[tmp_head_mod];
    8576:	442b      	add	r3, r5
	buf->misc.byte_mode.tmp_head += granted_size;
    8578:	4401      	add	r1, r0
	*data = &buf->buf.buf8[tmp_head_mod];
    857a:	603b      	str	r3, [r7, #0]
	buf->misc.byte_mode.tmp_head += granted_size;
    857c:	60e1      	str	r1, [r4, #12]

	return granted_size;
}
    857e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    8582:	fbb1 f5f3 	udiv	r5, r1, r3
    8586:	fb03 1515 	mls	r5, r3, r5, r1
    858a:	e7ea      	b.n	8562 <ring_buf_get_claim+0x2a>

0000858c <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
    858c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t tail = buf->tail;
    858e:	6846      	ldr	r6, [r0, #4]
	uint32_t rew;

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
    8590:	68c3      	ldr	r3, [r0, #12]
    8592:	42b3      	cmp	r3, r6
{
    8594:	4605      	mov	r5, r0
    8596:	460c      	mov	r4, r1
	if (tail < buf->misc.byte_mode.tmp_head) {
    8598:	d912      	bls.n	85c0 <ring_buf_get_finish+0x34>
		/* tail was rewinded. Locally, increment it to pre-rewind value */
		rew = get_rewind_value(buf->size,
    859a:	6907      	ldr	r7, [r0, #16]
    859c:	f7ff ff64 	bl	8468 <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
    85a0:	fbb0 f0f7 	udiv	r0, r0, r7
    85a4:	4378      	muls	r0, r7
				       ring_buf_get_rewind_threshold());
		tail += rew;
    85a6:	4406      	add	r6, r0
	} else {
		rew = 0;
	}

	if ((buf->head + size) > tail) {
    85a8:	6829      	ldr	r1, [r5, #0]
    85aa:	4421      	add	r1, r4
    85ac:	42b1      	cmp	r1, r6
		return -EINVAL;
	}

	/* Include potential rewinding. */
	buf->head += (size - rew);
    85ae:	bf9f      	itttt	ls
    85b0:	1a09      	subls	r1, r1, r0
    85b2:	6029      	strls	r1, [r5, #0]
	buf->misc.byte_mode.tmp_head = buf->head;
    85b4:	60e9      	strls	r1, [r5, #12]

	return 0;
    85b6:	2000      	movls	r0, #0
		return -EINVAL;
    85b8:	bf88      	it	hi
    85ba:	f06f 0015 	mvnhi.w	r0, #21
}
    85be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		rew = 0;
    85c0:	2000      	movs	r0, #0
    85c2:	e7f1      	b.n	85a8 <ring_buf_get_finish+0x1c>

000085c4 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
    85c4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    85c8:	4680      	mov	r8, r0
    85ca:	460d      	mov	r5, r1
    85cc:	4616      	mov	r6, r2
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
    85ce:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
    85d0:	4632      	mov	r2, r6
    85d2:	a901      	add	r1, sp, #4
    85d4:	4640      	mov	r0, r8
    85d6:	f7ff ffaf 	bl	8538 <ring_buf_get_claim>
    85da:	4604      	mov	r4, r0
		if (data) {
    85dc:	b12d      	cbz	r5, 85ea <ring_buf_get+0x26>
			memcpy(data, src, partial_size);
    85de:	4602      	mov	r2, r0
    85e0:	9901      	ldr	r1, [sp, #4]
    85e2:	4628      	mov	r0, r5
    85e4:	f000 f968 	bl	88b8 <memcpy>
			data += partial_size;
    85e8:	4425      	add	r5, r4
		}
		total_size += partial_size;
		size -= partial_size;
	} while (size && partial_size);
    85ea:	1b36      	subs	r6, r6, r4
		total_size += partial_size;
    85ec:	4427      	add	r7, r4
	} while (size && partial_size);
    85ee:	d001      	beq.n	85f4 <ring_buf_get+0x30>
    85f0:	2c00      	cmp	r4, #0
    85f2:	d1ed      	bne.n	85d0 <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
    85f4:	4639      	mov	r1, r7
    85f6:	4640      	mov	r0, r8
    85f8:	f7ff ffc8 	bl	858c <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
    85fc:	4638      	mov	r0, r7
    85fe:	b002      	add	sp, #8
    8600:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00008604 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    8604:	4770      	bx	lr

00008606 <usb_write>:
{
    8606:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    860a:	4606      	mov	r6, r0
    860c:	460f      	mov	r7, r1
    860e:	4690      	mov	r8, r2
    8610:	4699      	mov	r9, r3
    8612:	2504      	movs	r5, #4
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
    8614:	464b      	mov	r3, r9
    8616:	4642      	mov	r2, r8
    8618:	4639      	mov	r1, r7
    861a:	4630      	mov	r0, r6
    861c:	f7fb fdf0 	bl	4200 <usb_dc_ep_write>
		if (ret == -EAGAIN) {
    8620:	f110 0f0b 	cmn.w	r0, #11
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
    8624:	4604      	mov	r4, r0
		if (ret == -EAGAIN) {
    8626:	d103      	bne.n	8630 <usb_write+0x2a>
	z_impl_k_yield();
    8628:	f7ff f8f6 	bl	7818 <z_impl_k_yield>
	} while (ret == -EAGAIN && tries--);
    862c:	3d01      	subs	r5, #1
    862e:	d1f1      	bne.n	8614 <usb_write+0xe>
}
    8630:	4620      	mov	r0, r4
    8632:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00008636 <usb_get_dev_data_by_cfg>:
	return list->head;
    8636:	6800      	ldr	r0, [r0, #0]
struct usb_dev_data *usb_get_dev_data_by_cfg(sys_slist_t *list,
					     struct usb_cfg_data *cfg)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
    8638:	b158      	cbz	r0, 8652 <usb_get_dev_data_by_cfg+0x1c>
    863a:	3804      	subs	r0, #4
    863c:	b900      	cbnz	r0, 8640 <usb_get_dev_data_by_cfg+0xa>
    863e:	4770      	bx	lr
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg_cur = dev->config;
    8640:	6803      	ldr	r3, [r0, #0]

		if (cfg_cur == cfg) {
    8642:	685b      	ldr	r3, [r3, #4]
    8644:	428b      	cmp	r3, r1
    8646:	d004      	beq.n	8652 <usb_get_dev_data_by_cfg+0x1c>
Z_GENLIST_PEEK_NEXT(slist, snode)
    8648:	1d03      	adds	r3, r0, #4
    864a:	d001      	beq.n	8650 <usb_get_dev_data_by_cfg+0x1a>
	return node->next;
    864c:	6840      	ldr	r0, [r0, #4]
    864e:	e7f3      	b.n	8638 <usb_get_dev_data_by_cfg+0x2>
		}
	}

	LOG_DBG("Device data not found for cfg %p", cfg);

	return NULL;
    8650:	4618      	mov	r0, r3
}
    8652:	4770      	bx	lr

00008654 <usb_get_dev_data_by_iface>:
	return list->head;
    8654:	6800      	ldr	r0, [r0, #0]
struct usb_dev_data *usb_get_dev_data_by_iface(sys_slist_t *list,
					       uint8_t iface_num)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
    8656:	b168      	cbz	r0, 8674 <usb_get_dev_data_by_iface+0x20>
    8658:	3804      	subs	r0, #4
    865a:	b900      	cbnz	r0, 865e <usb_get_dev_data_by_iface+0xa>
    865c:	4770      	bx	lr
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config;
    865e:	6803      	ldr	r3, [r0, #0]
		const struct usb_if_descriptor *if_desc =
    8660:	685b      	ldr	r3, [r3, #4]
						cfg->interface_descriptor;

		if (if_desc->bInterfaceNumber == iface_num) {
    8662:	685b      	ldr	r3, [r3, #4]
    8664:	789b      	ldrb	r3, [r3, #2]
    8666:	428b      	cmp	r3, r1
    8668:	d004      	beq.n	8674 <usb_get_dev_data_by_iface+0x20>
Z_GENLIST_PEEK_NEXT(slist, snode)
    866a:	1d03      	adds	r3, r0, #4
    866c:	d001      	beq.n	8672 <usb_get_dev_data_by_iface+0x1e>
	return node->next;
    866e:	6840      	ldr	r0, [r0, #4]
    8670:	e7f1      	b.n	8656 <usb_get_dev_data_by_iface+0x2>
		}
	}

	LOG_DBG("Device data not found for iface number %u", iface_num);

	return NULL;
    8672:	4618      	mov	r0, r3
}
    8674:	4770      	bx	lr

00008676 <usb_get_dev_data_by_ep>:

struct usb_dev_data *usb_get_dev_data_by_ep(sys_slist_t *list, uint8_t ep)
{
    8676:	b530      	push	{r4, r5, lr}
	return list->head;
    8678:	6800      	ldr	r0, [r0, #0]
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
    867a:	b198      	cbz	r0, 86a4 <usb_get_dev_data_by_ep+0x2e>
    867c:	3804      	subs	r0, #4
    867e:	b188      	cbz	r0, 86a4 <usb_get_dev_data_by_ep+0x2e>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config;
    8680:	6803      	ldr	r3, [r0, #0]
    8682:	685b      	ldr	r3, [r3, #4]
		const struct usb_ep_cfg_data *ep_data = cfg->endpoint;
    8684:	6a1a      	ldr	r2, [r3, #32]

		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
    8686:	7f1d      	ldrb	r5, [r3, #28]
			if (ep_data[i].ep_addr == ep) {
    8688:	3a04      	subs	r2, #4
		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
    868a:	2300      	movs	r3, #0
    868c:	b2dc      	uxtb	r4, r3
    868e:	42a5      	cmp	r5, r4
    8690:	d803      	bhi.n	869a <usb_get_dev_data_by_ep+0x24>
Z_GENLIST_PEEK_NEXT(slist, snode)
    8692:	1d03      	adds	r3, r0, #4
    8694:	d007      	beq.n	86a6 <usb_get_dev_data_by_ep+0x30>
	return node->next;
    8696:	6840      	ldr	r0, [r0, #4]
    8698:	e7ef      	b.n	867a <usb_get_dev_data_by_ep+0x4>
			if (ep_data[i].ep_addr == ep) {
    869a:	3301      	adds	r3, #1
    869c:	f812 4033 	ldrb.w	r4, [r2, r3, lsl #3]
    86a0:	428c      	cmp	r4, r1
    86a2:	d1f3      	bne.n	868c <usb_get_dev_data_by_ep+0x16>
	}

	LOG_DBG("Device data not found for ep %u", ep);

	return NULL;
}
    86a4:	bd30      	pop	{r4, r5, pc}
	return NULL;
    86a6:	4618      	mov	r0, r3
    86a8:	e7fc      	b.n	86a4 <usb_get_dev_data_by_ep+0x2e>

000086aa <usb_transfer_is_busy>:
{
    86aa:	b508      	push	{r3, lr}
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);
    86ac:	f7fa f8d0 	bl	2850 <usb_ep_get_transfer>
	if (trans && trans->status == -EBUSY) {
    86b0:	b128      	cbz	r0, 86be <usb_transfer_is_busy+0x14>
    86b2:	6840      	ldr	r0, [r0, #4]
    86b4:	f110 0f10 	cmn.w	r0, #16
    86b8:	bf14      	ite	ne
    86ba:	2000      	movne	r0, #0
    86bc:	2001      	moveq	r0, #1
}
    86be:	bd08      	pop	{r3, pc}

000086c0 <cdc_interface_config>:
	desc->if1.bInterfaceNumber = bInterfaceNumber + 1;
    86c0:	1c4b      	adds	r3, r1, #1
    86c2:	b2db      	uxtb	r3, r3
	desc->if0.bInterfaceNumber = bInterfaceNumber;
    86c4:	7081      	strb	r1, [r0, #2]
	desc->if0_union.bControlInterface = bInterfaceNumber;
    86c6:	7681      	strb	r1, [r0, #26]
	desc->if1.bInterfaceNumber = bInterfaceNumber + 1;
    86c8:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
	desc->if0_union.bSubordinateInterface0 = bInterfaceNumber + 1;
    86cc:	76c3      	strb	r3, [r0, #27]
	desc->iad_cdc.bFirstInterface = bInterfaceNumber;
    86ce:	f800 1c06 	strb.w	r1, [r0, #-6]
}
    86d2:	4770      	bx	lr

000086d4 <cdc_acm_irq_callback_work_handler>:
	dev_data->cb(dev_data->common.dev, dev_data->cb_data);
    86d4:	e950 3102 	ldrd	r3, r1, [r0, #-8]
    86d8:	6f80      	ldr	r0, [r0, #120]	; 0x78
    86da:	4718      	bx	r3

000086dc <cdc_acm_irq_tx_disable>:
	dev_data->tx_irq_ena = false;
    86dc:	6903      	ldr	r3, [r0, #16]
    86de:	2200      	movs	r2, #0
    86e0:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
}
    86e4:	4770      	bx	lr

000086e6 <cdc_acm_irq_tx_ready>:
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    86e6:	6903      	ldr	r3, [r0, #16]
	if (dev_data->tx_irq_ena && dev_data->tx_ready) {
    86e8:	f893 002a 	ldrb.w	r0, [r3, #42]	; 0x2a
    86ec:	b108      	cbz	r0, 86f2 <cdc_acm_irq_tx_ready+0xc>
		return 1;
    86ee:	f893 0028 	ldrb.w	r0, [r3, #40]	; 0x28
}
    86f2:	4770      	bx	lr

000086f4 <cdc_acm_irq_rx_disable>:
	dev_data->rx_irq_ena = false;
    86f4:	6903      	ldr	r3, [r0, #16]
    86f6:	2200      	movs	r2, #0
    86f8:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
    86fc:	4770      	bx	lr

000086fe <cdc_acm_irq_rx_ready>:
	if (dev_data->rx_ready) {
    86fe:	6903      	ldr	r3, [r0, #16]
}
    8700:	f893 0029 	ldrb.w	r0, [r3, #41]	; 0x29
    8704:	4770      	bx	lr

00008706 <cdc_acm_irq_is_pending>:
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    8706:	6903      	ldr	r3, [r0, #16]
	if (dev_data->tx_ready && dev_data->tx_irq_ena) {
    8708:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    870c:	b112      	cbz	r2, 8714 <cdc_acm_irq_is_pending+0xe>
    870e:	f893 202a 	ldrb.w	r2, [r3, #42]	; 0x2a
    8712:	b92a      	cbnz	r2, 8720 <cdc_acm_irq_is_pending+0x1a>
	} else if (dev_data->rx_ready && dev_data->rx_irq_ena) {
    8714:	f893 0029 	ldrb.w	r0, [r3, #41]	; 0x29
    8718:	b118      	cbz	r0, 8722 <cdc_acm_irq_is_pending+0x1c>
		return 0;
    871a:	f893 002b 	ldrb.w	r0, [r3, #43]	; 0x2b
    871e:	4770      	bx	lr
		return 1;
    8720:	2001      	movs	r0, #1
}
    8722:	4770      	bx	lr

00008724 <cdc_acm_irq_update>:
}
    8724:	2001      	movs	r0, #1
    8726:	4770      	bx	lr

00008728 <cdc_acm_irq_callback_set>:
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    8728:	6903      	ldr	r3, [r0, #16]
	dev_data->cb_data = cb_data;
    872a:	e9c3 1200 	strd	r1, r2, [r3]
}
    872e:	4770      	bx	lr

00008730 <cdc_acm_line_ctrl_get>:
	switch (ctrl) {
    8730:	2902      	cmp	r1, #2
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    8732:	6903      	ldr	r3, [r0, #16]
	switch (ctrl) {
    8734:	d007      	beq.n	8746 <cdc_acm_line_ctrl_get+0x16>
    8736:	2904      	cmp	r1, #4
    8738:	d00a      	beq.n	8750 <cdc_acm_line_ctrl_get+0x20>
    873a:	2901      	cmp	r1, #1
    873c:	d10d      	bne.n	875a <cdc_acm_line_ctrl_get+0x2a>
		*val = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
    873e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
		*val = (dev_data->line_state &
    8740:	6013      	str	r3, [r2, #0]
		return 0;
    8742:	2000      	movs	r0, #0
    8744:	4770      	bx	lr
			SET_CONTROL_LINE_STATE_RTS) ? 1 : 0;
    8746:	f893 307b 	ldrb.w	r3, [r3, #123]	; 0x7b
    874a:	f3c3 0340 	ubfx	r3, r3, #1, #1
    874e:	e7f7      	b.n	8740 <cdc_acm_line_ctrl_get+0x10>
			SET_CONTROL_LINE_STATE_DTR) ? 1 : 0;
    8750:	f893 307b 	ldrb.w	r3, [r3, #123]	; 0x7b
    8754:	f003 0301 	and.w	r3, r3, #1
    8758:	e7f2      	b.n	8740 <cdc_acm_line_ctrl_get+0x10>
	switch (ctrl) {
    875a:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
    875e:	4770      	bx	lr

00008760 <cdc_acm_fifo_read>:
{
    8760:	b538      	push	{r3, r4, r5, lr}
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    8762:	6905      	ldr	r5, [r0, #16]
	len = ring_buf_get(dev_data->rx_ringbuf, rx_data, size);
    8764:	6ee8      	ldr	r0, [r5, #108]	; 0x6c
    8766:	f7ff ff2d 	bl	85c4 <ring_buf_get>
    876a:	4604      	mov	r4, r0
	if (ring_buf_is_empty(dev_data->rx_ringbuf)) {
    876c:	6ee8      	ldr	r0, [r5, #108]	; 0x6c
    876e:	f7ff fe7e 	bl	846e <ring_buf_is_empty>
    8772:	b110      	cbz	r0, 877a <cdc_acm_fifo_read+0x1a>
		dev_data->rx_ready = false;
    8774:	2300      	movs	r3, #0
    8776:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
}
    877a:	4620      	mov	r0, r4
    877c:	bd38      	pop	{r3, r4, r5, pc}

0000877e <cdc_acm_poll_in>:
{
    877e:	b508      	push	{r3, lr}
	int ret = cdc_acm_fifo_read(dev, c, 1);
    8780:	2201      	movs	r2, #1
    8782:	f7ff ffed 	bl	8760 <cdc_acm_fifo_read>
}
    8786:	3801      	subs	r0, #1
    8788:	bf18      	it	ne
    878a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    878e:	bd08      	pop	{r3, pc}

00008790 <cdc_acm_line_ctrl_set>:
	switch (ctrl) {
    8790:	2940      	cmp	r1, #64	; 0x40
{
    8792:	b508      	push	{r3, lr}
	struct cdc_acm_dev_data_t * const dev_data = DEV_DATA(dev);
    8794:	6903      	ldr	r3, [r0, #16]
	switch (ctrl) {
    8796:	d042      	beq.n	881e <cdc_acm_line_ctrl_set+0x8e>
    8798:	d813      	bhi.n	87c2 <cdc_acm_line_ctrl_set+0x32>
    879a:	2910      	cmp	r1, #16
    879c:	d032      	beq.n	8804 <cdc_acm_line_ctrl_set+0x74>
    879e:	d806      	bhi.n	87ae <cdc_acm_line_ctrl_set+0x1e>
    87a0:	2901      	cmp	r1, #1
    87a2:	d01e      	beq.n	87e2 <cdc_acm_line_ctrl_set+0x52>
    87a4:	2908      	cmp	r1, #8
    87a6:	d01f      	beq.n	87e8 <cdc_acm_line_ctrl_set+0x58>
    87a8:	f06f 0012 	mvn.w	r0, #18
}
    87ac:	bd08      	pop	{r3, pc}
	switch (ctrl) {
    87ae:	2920      	cmp	r1, #32
    87b0:	d1fa      	bne.n	87a8 <cdc_acm_line_ctrl_set+0x18>
		dev_data->serial_state &= ~SERIAL_STATE_BREAK;
    87b2:	f893 107c 	ldrb.w	r1, [r3, #124]	; 0x7c
    87b6:	f001 01fb 	and.w	r1, r1, #251	; 0xfb
		if (val) {
    87ba:	b342      	cbz	r2, 880e <cdc_acm_line_ctrl_set+0x7e>
			dev_data->serial_state |= SERIAL_STATE_BREAK;
    87bc:	f041 0104 	orr.w	r1, r1, #4
    87c0:	e025      	b.n	880e <cdc_acm_line_ctrl_set+0x7e>
	switch (ctrl) {
    87c2:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
    87c6:	d033      	beq.n	8830 <cdc_acm_line_ctrl_set+0xa0>
    87c8:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    87cc:	d039      	beq.n	8842 <cdc_acm_line_ctrl_set+0xb2>
    87ce:	2980      	cmp	r1, #128	; 0x80
    87d0:	d1ea      	bne.n	87a8 <cdc_acm_line_ctrl_set+0x18>
		dev_data->serial_state &= ~SERIAL_STATE_FRAMING;
    87d2:	f893 107c 	ldrb.w	r1, [r3, #124]	; 0x7c
    87d6:	f001 01ef 	and.w	r1, r1, #239	; 0xef
		if (val) {
    87da:	b1c2      	cbz	r2, 880e <cdc_acm_line_ctrl_set+0x7e>
			dev_data->serial_state |= SERIAL_STATE_FRAMING;
    87dc:	f041 0110 	orr.w	r1, r1, #16
    87e0:	e015      	b.n	880e <cdc_acm_line_ctrl_set+0x7e>
	dev_data->line_coding.dwDTERate = sys_cpu_to_le32(baudrate);
    87e2:	675a      	str	r2, [r3, #116]	; 0x74
		return 0;
    87e4:	2000      	movs	r0, #0
    87e6:	e7e1      	b.n	87ac <cdc_acm_line_ctrl_set+0x1c>
		dev_data->serial_state &= ~SERIAL_STATE_RX_CARRIER;
    87e8:	f893 107c 	ldrb.w	r1, [r3, #124]	; 0x7c
    87ec:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
		if (val) {
    87f0:	b92a      	cbnz	r2, 87fe <cdc_acm_line_ctrl_set+0x6e>
			dev_data->serial_state |= SERIAL_STATE_RX_CARRIER;
    87f2:	f883 107c 	strb.w	r1, [r3, #124]	; 0x7c
		cdc_acm_send_notification(dev, SERIAL_STATE_RX_CARRIER);
    87f6:	2101      	movs	r1, #1
		cdc_acm_send_notification(dev, dev_data->serial_state);
    87f8:	f7fa fb64 	bl	2ec4 <cdc_acm_send_notification.isra.0>
    87fc:	e7f2      	b.n	87e4 <cdc_acm_line_ctrl_set+0x54>
			dev_data->serial_state |= SERIAL_STATE_RX_CARRIER;
    87fe:	f041 0101 	orr.w	r1, r1, #1
    8802:	e7f6      	b.n	87f2 <cdc_acm_line_ctrl_set+0x62>
		dev_data->serial_state &= ~SERIAL_STATE_TX_CARRIER;
    8804:	f893 107c 	ldrb.w	r1, [r3, #124]	; 0x7c
    8808:	f001 01fd 	and.w	r1, r1, #253	; 0xfd
		if (val) {
    880c:	b922      	cbnz	r2, 8818 <cdc_acm_line_ctrl_set+0x88>
			dev_data->serial_state |= SERIAL_STATE_OVER_RUN;
    880e:	f883 107c 	strb.w	r1, [r3, #124]	; 0x7c
		cdc_acm_send_notification(dev, dev_data->serial_state);
    8812:	f893 107c 	ldrb.w	r1, [r3, #124]	; 0x7c
    8816:	e7ef      	b.n	87f8 <cdc_acm_line_ctrl_set+0x68>
			dev_data->serial_state |= SERIAL_STATE_TX_CARRIER;
    8818:	f041 0102 	orr.w	r1, r1, #2
    881c:	e7f7      	b.n	880e <cdc_acm_line_ctrl_set+0x7e>
		dev_data->serial_state &= ~SERIAL_STATE_RING_SIGNAL;
    881e:	f893 107c 	ldrb.w	r1, [r3, #124]	; 0x7c
    8822:	f001 01f7 	and.w	r1, r1, #247	; 0xf7
		if (val) {
    8826:	2a00      	cmp	r2, #0
    8828:	d0f1      	beq.n	880e <cdc_acm_line_ctrl_set+0x7e>
			dev_data->serial_state |= SERIAL_STATE_RING_SIGNAL;
    882a:	f041 0108 	orr.w	r1, r1, #8
    882e:	e7ee      	b.n	880e <cdc_acm_line_ctrl_set+0x7e>
		dev_data->serial_state &= ~SERIAL_STATE_PARITY;
    8830:	f893 107c 	ldrb.w	r1, [r3, #124]	; 0x7c
    8834:	f001 01df 	and.w	r1, r1, #223	; 0xdf
		if (val) {
    8838:	2a00      	cmp	r2, #0
    883a:	d0e8      	beq.n	880e <cdc_acm_line_ctrl_set+0x7e>
			dev_data->serial_state |= SERIAL_STATE_PARITY;
    883c:	f041 0120 	orr.w	r1, r1, #32
    8840:	e7e5      	b.n	880e <cdc_acm_line_ctrl_set+0x7e>
		dev_data->serial_state &= ~SERIAL_STATE_OVER_RUN;
    8842:	f893 107c 	ldrb.w	r1, [r3, #124]	; 0x7c
    8846:	f001 01bf 	and.w	r1, r1, #191	; 0xbf
		if (val) {
    884a:	2a00      	cmp	r2, #0
    884c:	d0df      	beq.n	880e <cdc_acm_line_ctrl_set+0x7e>
			dev_data->serial_state |= SERIAL_STATE_OVER_RUN;
    884e:	f041 0140 	orr.w	r1, r1, #64	; 0x40
    8852:	e7dc      	b.n	880e <cdc_acm_line_ctrl_set+0x7e>

00008854 <pm_policy_next_state>:
		}
	}

error:
	LOG_DBG("No suitable power state found for cpu: %d!", cpu);
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
    8854:	2200      	movs	r2, #0
    8856:	e9c0 2200 	strd	r2, r2, [r0]
    885a:	6082      	str	r2, [r0, #8]
}
    885c:	4770      	bx	lr

0000885e <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    885e:	f000 bcb6 	b.w	91ce <z_fatal_error>

00008862 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    8862:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
    8864:	6800      	ldr	r0, [r0, #0]
    8866:	f000 bcb2 	b.w	91ce <z_fatal_error>

0000886a <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    886a:	2100      	movs	r1, #0
    886c:	2001      	movs	r0, #1
    886e:	f7ff bff6 	b.w	885e <z_arm_fatal_error>

00008872 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    8872:	b508      	push	{r3, lr}
	handler();
    8874:	f7fa fce0 	bl	3238 <z_SysNmiOnReset>
	z_arm_int_exit();
}
    8878:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
    887c:	f7fa bdc0 	b.w	3400 <z_arm_exc_exit>

00008880 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    8880:	4603      	mov	r3, r0
	size_t n = 0;
    8882:	2000      	movs	r0, #0

	while (*s != '\0') {
    8884:	5c1a      	ldrb	r2, [r3, r0]
    8886:	b902      	cbnz	r2, 888a <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
    8888:	4770      	bx	lr
		n++;
    888a:	3001      	adds	r0, #1
    888c:	e7fa      	b.n	8884 <strlen+0x4>

0000888e <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    888e:	4603      	mov	r3, r0
	size_t n = 0;
    8890:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
    8892:	5c1a      	ldrb	r2, [r3, r0]
    8894:	b10a      	cbz	r2, 889a <strnlen+0xc>
    8896:	4288      	cmp	r0, r1
    8898:	d100      	bne.n	889c <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
    889a:	4770      	bx	lr
		n++;
    889c:	3001      	adds	r0, #1
    889e:	e7f8      	b.n	8892 <strnlen+0x4>

000088a0 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    88a0:	1e43      	subs	r3, r0, #1
    88a2:	3901      	subs	r1, #1
    88a4:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    88a8:	f811 0f01 	ldrb.w	r0, [r1, #1]!
    88ac:	4282      	cmp	r2, r0
    88ae:	d101      	bne.n	88b4 <strcmp+0x14>
    88b0:	2a00      	cmp	r2, #0
    88b2:	d1f7      	bne.n	88a4 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    88b4:	1a10      	subs	r0, r2, r0
    88b6:	4770      	bx	lr

000088b8 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
    88b8:	b510      	push	{r4, lr}
    88ba:	1e43      	subs	r3, r0, #1
    88bc:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
    88be:	4291      	cmp	r1, r2
    88c0:	d100      	bne.n	88c4 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    88c2:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
    88c4:	f811 4b01 	ldrb.w	r4, [r1], #1
    88c8:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
    88cc:	e7f7      	b.n	88be <memcpy+0x6>

000088ce <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    88ce:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    88d0:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
    88d2:	4603      	mov	r3, r0
	while (n > 0) {
    88d4:	4293      	cmp	r3, r2
    88d6:	d100      	bne.n	88da <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    88d8:	4770      	bx	lr
		*(d_byte++) = c_byte;
    88da:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    88de:	e7f9      	b.n	88d4 <memset+0x6>

000088e0 <_stdout_hook_default>:
}
    88e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    88e4:	4770      	bx	lr

000088e6 <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
    88e6:	b084      	sub	sp, #16
    88e8:	ab04      	add	r3, sp, #16
    88ea:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
    88ee:	f89d 3004 	ldrb.w	r3, [sp, #4]
    88f2:	2b06      	cmp	r3, #6
    88f4:	d108      	bne.n	8908 <pm_power_state_set+0x22>
    p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
    88f6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    88fa:	2201      	movs	r2, #1
    88fc:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
    8900:	f3bf 8f4f 	dsb	sy
        __WFE();
    8904:	bf20      	wfe
    while (true)
    8906:	e7fd      	b.n	8904 <pm_power_state_set+0x1e>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
    8908:	b004      	add	sp, #16
    890a:	4770      	bx	lr

0000890c <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
    890c:	b084      	sub	sp, #16
    890e:	ab04      	add	r3, sp, #16
    8910:	e903 0007 	stmdb	r3, {r0, r1, r2}
    8914:	2300      	movs	r3, #0
    8916:	f383 8811 	msr	BASEPRI, r3
    891a:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
    891e:	b004      	add	sp, #16
    8920:	4770      	bx	lr

00008922 <ep_ctx_reset>:
	ep_ctx->buf.data = ep_ctx->buf.block.data;
    8922:	6903      	ldr	r3, [r0, #16]
{
    8924:	b510      	push	{r4, lr}
	ep_ctx->buf.curr = ep_ctx->buf.data;
    8926:	e9c0 3305 	strd	r3, r3, [r0, #20]
	ep_ctx->buf.len  = 0U;
    892a:	2300      	movs	r3, #0
    892c:	60c3      	str	r3, [r0, #12]
	if (ep_ctx->write_in_progress) {
    892e:	7f83      	ldrb	r3, [r0, #30]
{
    8930:	4604      	mov	r4, r0
	if (ep_ctx->write_in_progress) {
    8932:	b113      	cbz	r3, 893a <ep_ctx_reset+0x18>
		nrfx_usbd_ep_abort(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    8934:	7a40      	ldrb	r0, [r0, #9]
    8936:	f000 fc31 	bl	919c <nrfx_usbd_ep_abort>
	ep_ctx->read_complete = true;
    893a:	2301      	movs	r3, #1
    893c:	7723      	strb	r3, [r4, #28]
	ep_ctx->read_pending = false;
    893e:	2300      	movs	r3, #0
    8940:	7763      	strb	r3, [r4, #29]
	ep_ctx->trans_zlp = false;
    8942:	77e3      	strb	r3, [r4, #31]
	ep_ctx->write_in_progress = false;
    8944:	77a3      	strb	r3, [r4, #30]
}
    8946:	bd10      	pop	{r4, pc}

00008948 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
    8948:	f7fe bac4 	b.w	6ed4 <z_impl_k_mutex_lock>

0000894c <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
    894c:	f7fe bb3a 	b.w	6fc4 <z_impl_k_mutex_unlock>

00008950 <usb_dc_ep_check_cap>:
	uint8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
    8950:	7803      	ldrb	r3, [r0, #0]
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
    8952:	7901      	ldrb	r1, [r0, #4]
	uint8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
    8954:	f003 020f 	and.w	r2, r3, #15
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
    8958:	b921      	cbnz	r1, 8964 <usb_dc_ep_check_cap+0x14>
    895a:	1e10      	subs	r0, r2, #0
    895c:	bf18      	it	ne
    895e:	2001      	movne	r0, #1
    8960:	4240      	negs	r0, r0
    8962:	4770      	bx	lr
	if (!NRF_USBD_EP_VALIDATE(ep_cfg->ep_addr)) {
    8964:	2a08      	cmp	r2, #8
    8966:	d806      	bhi.n	8976 <usb_dc_ep_check_cap+0x26>
	if ((ep_cfg->ep_type == USB_DC_EP_ISOCHRONOUS) &&
    8968:	2901      	cmp	r1, #1
    896a:	d107      	bne.n	897c <usb_dc_ep_check_cap+0x2c>
    896c:	f083 0008 	eor.w	r0, r3, #8
    8970:	f340 00c0 	sbfx	r0, r0, #3, #1
    8974:	4770      	bx	lr
		return -1;
    8976:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    897a:	4770      	bx	lr
	return 0;
    897c:	2000      	movs	r0, #0
}
    897e:	4770      	bx	lr

00008980 <usb_dc_ep_read>:
{
    8980:	b570      	push	{r4, r5, r6, lr}
    8982:	4604      	mov	r4, r0
    8984:	460e      	mov	r6, r1
    8986:	4615      	mov	r5, r2
	ret = usb_dc_ep_read_wait(ep, data, max_data_len, read_bytes);
    8988:	f7fb fcb2 	bl	42f0 <usb_dc_ep_read_wait>
	if (ret) {
    898c:	b930      	cbnz	r0, 899c <usb_dc_ep_read+0x1c>
	if (!data && !max_data_len) {
    898e:	b906      	cbnz	r6, 8992 <usb_dc_ep_read+0x12>
    8990:	b125      	cbz	r5, 899c <usb_dc_ep_read+0x1c>
	ret = usb_dc_ep_read_continue(ep);
    8992:	4620      	mov	r0, r4
}
    8994:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = usb_dc_ep_read_continue(ep);
    8998:	f7fb bcf2 	b.w	4380 <usb_dc_ep_read_continue>
}
    899c:	bd70      	pop	{r4, r5, r6, pc}

0000899e <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
    899e:	6903      	ldr	r3, [r0, #16]
    89a0:	b2c9      	uxtb	r1, r1
    89a2:	220c      	movs	r2, #12
    89a4:	fb01 3302 	mla	r3, r1, r2, r3
    89a8:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
    89aa:	f000 0007 	and.w	r0, r0, #7
    89ae:	4770      	bx	lr

000089b0 <set_on_state>:
	__asm__ volatile(
    89b0:	f04f 0320 	mov.w	r3, #32
    89b4:	f3ef 8211 	mrs	r2, BASEPRI
    89b8:	f383 8812 	msr	BASEPRI_MAX, r3
    89bc:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
    89c0:	6803      	ldr	r3, [r0, #0]
    89c2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    89c6:	f043 0302 	orr.w	r3, r3, #2
    89ca:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
    89cc:	f382 8811 	msr	BASEPRI, r2
    89d0:	f3bf 8f6f 	isb	sy
}
    89d4:	4770      	bx	lr

000089d6 <stop>:
{
    89d6:	4603      	mov	r3, r0
    89d8:	b570      	push	{r4, r5, r6, lr}
	struct nrf_clock_control_data *data = dev->data;
    89da:	6900      	ldr	r0, [r0, #16]
	return &data->subsys[type];
    89dc:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
    89de:	f04f 0420 	mov.w	r4, #32
    89e2:	f3ef 8611 	mrs	r6, BASEPRI
    89e6:	f384 8812 	msr	BASEPRI_MAX, r4
    89ea:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    89ee:	250c      	movs	r5, #12
    89f0:	fb05 0401 	mla	r4, r5, r1, r0
    89f4:	6c24      	ldr	r4, [r4, #64]	; 0x40
	if ((current_ctx != 0) && (current_ctx != ctx)) {
    89f6:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
    89fa:	d001      	beq.n	8a00 <stop+0x2a>
    89fc:	42a2      	cmp	r2, r4
    89fe:	d110      	bne.n	8a22 <stop+0x4c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
    8a00:	fb05 0001 	mla	r0, r5, r1, r0
    8a04:	2201      	movs	r2, #1
    8a06:	6402      	str	r2, [r0, #64]	; 0x40
	int err = 0;
    8a08:	2000      	movs	r0, #0
	__asm__ volatile(
    8a0a:	f386 8811 	msr	BASEPRI, r6
    8a0e:	f3bf 8f6f 	isb	sy
	if (err < 0) {
    8a12:	b928      	cbnz	r0, 8a20 <stop+0x4a>
	get_sub_config(dev, type)->stop();
    8a14:	685b      	ldr	r3, [r3, #4]
    8a16:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
    8a1a:	684b      	ldr	r3, [r1, #4]
    8a1c:	4798      	blx	r3
	return 0;
    8a1e:	2000      	movs	r0, #0
}
    8a20:	bd70      	pop	{r4, r5, r6, pc}
		err = -EPERM;
    8a22:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8a26:	e7f0      	b.n	8a0a <stop+0x34>

00008a28 <api_stop>:
	return stop(dev, subsys, CTX_API);
    8a28:	2280      	movs	r2, #128	; 0x80
    8a2a:	f7ff bfd4 	b.w	89d6 <stop>

00008a2e <async_start>:
{
    8a2e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8a30:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
    8a32:	6904      	ldr	r4, [r0, #16]
{
    8a34:	4605      	mov	r5, r0
    8a36:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
    8a38:	f04f 0020 	mov.w	r0, #32
    8a3c:	f3ef 8c11 	mrs	ip, BASEPRI
    8a40:	f380 8812 	msr	BASEPRI_MAX, r0
    8a44:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    8a48:	260c      	movs	r6, #12
    8a4a:	fb06 4601 	mla	r6, r6, r1, r4
    8a4e:	6c30      	ldr	r0, [r6, #64]	; 0x40
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
    8a50:	f000 0e07 	and.w	lr, r0, #7
    8a54:	f1be 0f01 	cmp.w	lr, #1
    8a58:	d111      	bne.n	8a7e <async_start+0x50>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
    8a5a:	6437      	str	r7, [r6, #64]	; 0x40
	int err = 0;
    8a5c:	2600      	movs	r6, #0
	__asm__ volatile(
    8a5e:	f38c 8811 	msr	BASEPRI, ip
    8a62:	f3bf 8f6f 	isb	sy
	if (err < 0) {
    8a66:	b946      	cbnz	r6, 8a7a <async_start+0x4c>
	subdata->cb = cb;
    8a68:	200c      	movs	r0, #12
    8a6a:	fb00 4401 	mla	r4, r0, r1, r4
	subdata->user_data = user_data;
    8a6e:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
    8a72:	686b      	ldr	r3, [r5, #4]
    8a74:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
    8a78:	4798      	blx	r3
}
    8a7a:	4630      	mov	r0, r6
    8a7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
    8a7e:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
		err = -EALREADY;
    8a82:	4287      	cmp	r7, r0
    8a84:	bf14      	ite	ne
    8a86:	f04f 36ff 	movne.w	r6, #4294967295	; 0xffffffff
    8a8a:	f06f 0677 	mvneq.w	r6, #119	; 0x77
    8a8e:	e7e6      	b.n	8a5e <async_start+0x30>

00008a90 <api_start>:
{
    8a90:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
    8a92:	2480      	movs	r4, #128	; 0x80
    8a94:	9400      	str	r4, [sp, #0]
    8a96:	f7ff ffca 	bl	8a2e <async_start>
}
    8a9a:	b002      	add	sp, #8
    8a9c:	bd10      	pop	{r4, pc}

00008a9e <onoff_started_callback>:
	return &data->mgr[type];
    8a9e:	6900      	ldr	r0, [r0, #16]
{
    8aa0:	b410      	push	{r4}
	return &data->mgr[type];
    8aa2:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
    8aa4:	241c      	movs	r4, #28
    8aa6:	fb03 0004 	mla	r0, r3, r4, r0
    8aaa:	2100      	movs	r1, #0
}
    8aac:	bc10      	pop	{r4}
	notify(mgr, 0);
    8aae:	4710      	bx	r2

00008ab0 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
    8ab0:	2000      	movs	r0, #0
    8ab2:	f000 ba1f 	b.w	8ef4 <nrfx_clock_start>

00008ab6 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    8ab6:	2000      	movs	r0, #0
    8ab8:	f7fc bbee 	b.w	5298 <nrfx_clock_stop>

00008abc <blocking_start_callback>:
{
    8abc:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
    8abe:	f7fe baf7 	b.w	70b0 <z_impl_k_sem_give>

00008ac2 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8ac2:	6843      	ldr	r3, [r0, #4]
    8ac4:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
    8ac6:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
    8aca:	600b      	str	r3, [r1, #0]
}
    8acc:	2000      	movs	r0, #0
    8ace:	4770      	bx	lr

00008ad0 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8ad0:	6843      	ldr	r3, [r0, #4]
    8ad2:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
    8ad4:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
    8ad8:	4042      	eors	r2, r0
    8ada:	400a      	ands	r2, r1
    8adc:	4042      	eors	r2, r0
    p_reg->OUT = value;
    8ade:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
    8ae2:	2000      	movs	r0, #0
    8ae4:	4770      	bx	lr

00008ae6 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8ae6:	6843      	ldr	r3, [r0, #4]
    8ae8:	685b      	ldr	r3, [r3, #4]
}
    8aea:	2000      	movs	r0, #0
    p_reg->OUTSET = set_mask;
    8aec:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
    8af0:	4770      	bx	lr

00008af2 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8af2:	6843      	ldr	r3, [r0, #4]
    8af4:	685b      	ldr	r3, [r3, #4]
}
    8af6:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
    8af8:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
    8afc:	4770      	bx	lr

00008afe <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8afe:	6843      	ldr	r3, [r0, #4]
    8b00:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
    8b02:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value ^ mask);
    8b06:	404b      	eors	r3, r1
    p_reg->OUT = value;
    8b08:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
    8b0c:	2000      	movs	r0, #0
    8b0e:	4770      	bx	lr

00008b10 <gpio_nrfx_manage_callback>:
	return port->data;
    8b10:	6903      	ldr	r3, [r0, #16]
	return list->head;
    8b12:	6858      	ldr	r0, [r3, #4]
{
    8b14:	b530      	push	{r4, r5, lr}
	if (!sys_slist_is_empty(callbacks)) {
    8b16:	b158      	cbz	r0, 8b30 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    8b18:	2400      	movs	r4, #0
    8b1a:	4281      	cmp	r1, r0
    8b1c:	d112      	bne.n	8b44 <gpio_nrfx_manage_callback+0x34>
	return node->next;
    8b1e:	6808      	ldr	r0, [r1, #0]
	return list->tail;
    8b20:	689d      	ldr	r5, [r3, #8]
Z_GENLIST_REMOVE(slist, snode)
    8b22:	b954      	cbnz	r4, 8b3a <gpio_nrfx_manage_callback+0x2a>
    8b24:	428d      	cmp	r5, r1
	list->head = node;
    8b26:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
    8b28:	d100      	bne.n	8b2c <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
    8b2a:	6098      	str	r0, [r3, #8]
	parent->next = child;
    8b2c:	2000      	movs	r0, #0
    8b2e:	6008      	str	r0, [r1, #0]
	if (set) {
    8b30:	b96a      	cbnz	r2, 8b4e <gpio_nrfx_manage_callback+0x3e>
	return 0;
    8b32:	2000      	movs	r0, #0
}
    8b34:	bd30      	pop	{r4, r5, pc}
    8b36:	4628      	mov	r0, r5
    8b38:	e7ef      	b.n	8b1a <gpio_nrfx_manage_callback+0xa>
Z_GENLIST_REMOVE(slist, snode)
    8b3a:	428d      	cmp	r5, r1
	parent->next = child;
    8b3c:	6020      	str	r0, [r4, #0]
	list->tail = node;
    8b3e:	bf08      	it	eq
    8b40:	609c      	streq	r4, [r3, #8]
}
    8b42:	e7f3      	b.n	8b2c <gpio_nrfx_manage_callback+0x1c>
	return node->next;
    8b44:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    8b46:	4604      	mov	r4, r0
    8b48:	2d00      	cmp	r5, #0
    8b4a:	d1f4      	bne.n	8b36 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
    8b4c:	b13a      	cbz	r2, 8b5e <gpio_nrfx_manage_callback+0x4e>
Z_GENLIST_PREPEND(slist, snode)
    8b4e:	6898      	ldr	r0, [r3, #8]
	parent->next = child;
    8b50:	685a      	ldr	r2, [r3, #4]
    8b52:	600a      	str	r2, [r1, #0]
	list->head = node;
    8b54:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
    8b56:	2800      	cmp	r0, #0
    8b58:	d1eb      	bne.n	8b32 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
    8b5a:	6099      	str	r1, [r3, #8]
}
    8b5c:	e7ea      	b.n	8b34 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
    8b5e:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    8b62:	e7e7      	b.n	8b34 <gpio_nrfx_manage_callback+0x24>

00008b64 <z_impl_hwinfo_get_device_id>:
struct nrf_uid {
	uint32_t id[2];
};

ssize_t z_impl_hwinfo_get_device_id(uint8_t *buffer, size_t length)
{
    8b64:	b573      	push	{r0, r1, r4, r5, r6, lr}
NRF_STATIC_INLINE uint32_t nrf_ficr_deviceid_get(NRF_FICR_Type const * p_reg, uint32_t reg_id)
{
#if defined(FICR_INFO_DEVICEID_DEVICEID_Msk)
    return p_reg->INFO.DEVICEID[reg_id];
#else
    return p_reg->DEVICEID[reg_id];
    8b66:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
    8b6a:	2908      	cmp	r1, #8
    8b6c:	6e66      	ldr	r6, [r4, #100]	; 0x64
    8b6e:	6e65      	ldr	r5, [r4, #100]	; 0x64
    8b70:	6e62      	ldr	r2, [r4, #100]	; 0x64
    8b72:	6e63      	ldr	r3, [r4, #100]	; 0x64
	struct nrf_uid dev_id;

	dev_id.id[0] = sys_cpu_to_be32(nrf_ficr_deviceid_get(NRF_FICR, 1));
    8b74:	ea4f 2515 	mov.w	r5, r5, lsr #8
    8b78:	ea4f 6303 	mov.w	r3, r3, lsl #24
    8b7c:	ea43 6316 	orr.w	r3, r3, r6, lsr #24
    8b80:	f405 457f 	and.w	r5, r5, #65280	; 0xff00
    8b84:	ea4f 2202 	mov.w	r2, r2, lsl #8
    8b88:	ea43 0305 	orr.w	r3, r3, r5
    8b8c:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    8b90:	ea43 0302 	orr.w	r3, r3, r2
    8b94:	9300      	str	r3, [sp, #0]
    8b96:	6e26      	ldr	r6, [r4, #96]	; 0x60
    8b98:	6e25      	ldr	r5, [r4, #96]	; 0x60
    8b9a:	6e22      	ldr	r2, [r4, #96]	; 0x60
    8b9c:	6e23      	ldr	r3, [r4, #96]	; 0x60
	dev_id.id[1] = sys_cpu_to_be32(nrf_ficr_deviceid_get(NRF_FICR, 0));
    8b9e:	ea4f 2415 	mov.w	r4, r5, lsr #8
    8ba2:	ea4f 6303 	mov.w	r3, r3, lsl #24
    8ba6:	ea43 6316 	orr.w	r3, r3, r6, lsr #24
    8baa:	f404 447f 	and.w	r4, r4, #65280	; 0xff00
    8bae:	ea43 0304 	orr.w	r3, r3, r4
    8bb2:	ea4f 2402 	mov.w	r4, r2, lsl #8
    8bb6:	bf28      	it	cs
    8bb8:	2108      	movcs	r1, #8
    8bba:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
    8bbe:	4323      	orrs	r3, r4

	if (length > sizeof(dev_id.id)) {
		length = sizeof(dev_id.id);
	}

	memcpy(buffer, dev_id.id, length);
    8bc0:	460a      	mov	r2, r1
    8bc2:	460c      	mov	r4, r1
    8bc4:	4669      	mov	r1, sp
	dev_id.id[1] = sys_cpu_to_be32(nrf_ficr_deviceid_get(NRF_FICR, 0));
    8bc6:	9301      	str	r3, [sp, #4]
	memcpy(buffer, dev_id.id, length);
    8bc8:	f7ff fe76 	bl	88b8 <memcpy>

	return length;
}
    8bcc:	4620      	mov	r0, r4
    8bce:	b002      	add	sp, #8
    8bd0:	bd70      	pop	{r4, r5, r6, pc}

00008bd2 <uarte_nrfx_config_get>:
	*cfg = get_dev_data(dev)->uart_config;
    8bd2:	6902      	ldr	r2, [r0, #16]
{
    8bd4:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
    8bd6:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
    8bda:	e883 0003 	stmia.w	r3, {r0, r1}
}
    8bde:	2000      	movs	r0, #0
    8be0:	4770      	bx	lr

00008be2 <uarte_nrfx_err_check>:
	return config->uarte_regs;
    8be2:	6843      	ldr	r3, [r0, #4]
    8be4:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    8be6:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
    8bea:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
    8bee:	4770      	bx	lr

00008bf0 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
    8bf0:	6843      	ldr	r3, [r0, #4]
	return dev->data;
    8bf2:	6902      	ldr	r2, [r0, #16]
	return config->uarte_regs;
    8bf4:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8bf6:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    8bfa:	b148      	cbz	r0, 8c10 <uarte_nrfx_poll_in+0x20>
	*c = data->rx_data;
    8bfc:	7d52      	ldrb	r2, [r2, #21]
    8bfe:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    8c00:	2000      	movs	r0, #0
    8c02:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    8c06:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8c0a:	2201      	movs	r2, #1
    8c0c:	601a      	str	r2, [r3, #0]
	return 0;
    8c0e:	4770      	bx	lr
		return -1;
    8c10:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    8c14:	4770      	bx	lr

00008c16 <uarte_nrfx_fifo_read>:
	if (size > 0 && nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    8c16:	2a00      	cmp	r2, #0
{
    8c18:	b510      	push	{r4, lr}
    8c1a:	4604      	mov	r4, r0
	if (size > 0 && nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    8c1c:	dd0f      	ble.n	8c3e <uarte_nrfx_fifo_read+0x28>
	return config->uarte_regs;
    8c1e:	6843      	ldr	r3, [r0, #4]
    8c20:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8c22:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (size > 0 && nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    8c26:	b148      	cbz	r0, 8c3c <uarte_nrfx_fifo_read+0x26>
	return dev->data;
    8c28:	6922      	ldr	r2, [r4, #16]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    8c2a:	2000      	movs	r0, #0
    8c2c:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    8c30:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
		rx_data[num_rx++] = (uint8_t)data->rx_data;
    8c34:	7d52      	ldrb	r2, [r2, #21]
    8c36:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8c38:	2001      	movs	r0, #1
    8c3a:	6018      	str	r0, [r3, #0]
}
    8c3c:	bd10      	pop	{r4, pc}
	int num_rx = 0;
    8c3e:	2000      	movs	r0, #0
    8c40:	e7fc      	b.n	8c3c <uarte_nrfx_fifo_read+0x26>

00008c42 <uarte_nrfx_irq_tx_enable>:
	return config->uarte_regs;
    8c42:	6843      	ldr	r3, [r0, #4]
	return dev->data;
    8c44:	6901      	ldr	r1, [r0, #16]
	return config->uarte_regs;
    8c46:	681a      	ldr	r2, [r3, #0]
	__asm__ volatile(
    8c48:	f04f 0020 	mov.w	r0, #32
    8c4c:	f3ef 8311 	mrs	r3, BASEPRI
    8c50:	f380 8812 	msr	BASEPRI_MAX, r0
    8c54:	f3bf 8f6f 	isb	sy
	data->int_driven->disable_tx_irq = false;
    8c58:	68c9      	ldr	r1, [r1, #12]
    8c5a:	2000      	movs	r0, #0
    8c5c:	7388      	strb	r0, [r1, #14]
    p_reg->INTENSET = mask;
    8c5e:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
    8c62:	f8c2 1304 	str.w	r1, [r2, #772]	; 0x304
	__asm__ volatile(
    8c66:	f383 8811 	msr	BASEPRI, r3
    8c6a:	f3bf 8f6f 	isb	sy
}
    8c6e:	4770      	bx	lr

00008c70 <uarte_nrfx_irq_tx_disable>:
	data->int_driven->disable_tx_irq = true;
    8c70:	6903      	ldr	r3, [r0, #16]
    8c72:	68db      	ldr	r3, [r3, #12]
    8c74:	2201      	movs	r2, #1
    8c76:	739a      	strb	r2, [r3, #14]
}
    8c78:	4770      	bx	lr

00008c7a <uarte_nrfx_irq_tx_ready_complete>:
	bool ready = !data->int_driven->disable_tx_irq &&
    8c7a:	6903      	ldr	r3, [r0, #16]
    8c7c:	68db      	ldr	r3, [r3, #12]
    8c7e:	7b9a      	ldrb	r2, [r3, #14]
		     nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) &&
    8c80:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    8c84:	b962      	cbnz	r2, 8ca0 <uarte_nrfx_irq_tx_ready_complete+0x26>
	return config->uarte_regs;
    8c86:	6842      	ldr	r2, [r0, #4]
    8c88:	6812      	ldr	r2, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8c8a:	f8d2 0158 	ldr.w	r0, [r2, #344]	; 0x158
	bool ready = !data->int_driven->disable_tx_irq &&
    8c8e:	b140      	cbz	r0, 8ca2 <uarte_nrfx_irq_tx_ready_complete+0x28>
    return p_reg->INTENSET & mask;
    8c90:	f8d2 0304 	ldr.w	r0, [r2, #772]	; 0x304
	if (ready) {
    8c94:	f410 0080 	ands.w	r0, r0, #4194304	; 0x400000
    8c98:	d003      	beq.n	8ca2 <uarte_nrfx_irq_tx_ready_complete+0x28>
		data->int_driven->fifo_fill_lock = 0;
    8c9a:	6119      	str	r1, [r3, #16]
		     nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) &&
    8c9c:	2001      	movs	r0, #1
    8c9e:	4770      	bx	lr
    8ca0:	2000      	movs	r0, #0
}
    8ca2:	4770      	bx	lr

00008ca4 <uarte_nrfx_irq_rx_ready>:
	return config->uarte_regs;
    8ca4:	6843      	ldr	r3, [r0, #4]
    8ca6:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8ca8:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
    8cac:	3800      	subs	r0, #0
    8cae:	bf18      	it	ne
    8cb0:	2001      	movne	r0, #1
    8cb2:	4770      	bx	lr

00008cb4 <uarte_nrfx_irq_rx_enable>:
	return config->uarte_regs;
    8cb4:	6843      	ldr	r3, [r0, #4]
    8cb6:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    8cb8:	2210      	movs	r2, #16
    8cba:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    8cbe:	4770      	bx	lr

00008cc0 <uarte_nrfx_irq_rx_disable>:
	return config->uarte_regs;
    8cc0:	6843      	ldr	r3, [r0, #4]
    8cc2:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    8cc4:	2210      	movs	r2, #16
    8cc6:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
    8cca:	4770      	bx	lr

00008ccc <uarte_nrfx_irq_err_enable>:
	return config->uarte_regs;
    8ccc:	6843      	ldr	r3, [r0, #4]
    8cce:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    8cd0:	f44f 7200 	mov.w	r2, #512	; 0x200
    8cd4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    8cd8:	4770      	bx	lr

00008cda <uarte_nrfx_irq_err_disable>:
	return config->uarte_regs;
    8cda:	6843      	ldr	r3, [r0, #4]
    8cdc:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    8cde:	f44f 7200 	mov.w	r2, #512	; 0x200
    8ce2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
    8ce6:	4770      	bx	lr

00008ce8 <uarte_nrfx_irq_update>:
}
    8ce8:	2001      	movs	r0, #1
    8cea:	4770      	bx	lr

00008cec <uarte_nrfx_irq_callback_set>:
	data->int_driven->cb = cb;
    8cec:	6903      	ldr	r3, [r0, #16]
    8cee:	68db      	ldr	r3, [r3, #12]
	data->int_driven->cb_data = cb_data;
    8cf0:	e9c3 1200 	strd	r1, r2, [r3]
}
    8cf4:	4770      	bx	lr

00008cf6 <uarte_nrfx_irq_is_pending>:
{
    8cf6:	b538      	push	{r3, r4, r5, lr}
	return config->uarte_regs;
    8cf8:	6843      	ldr	r3, [r0, #4]
    8cfa:	681d      	ldr	r5, [r3, #0]
    return p_reg->INTENSET & mask;
    8cfc:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
		||
    8d00:	025b      	lsls	r3, r3, #9
{
    8d02:	4604      	mov	r4, r0
		||
    8d04:	d405      	bmi.n	8d12 <uarte_nrfx_irq_is_pending+0x1c>
    8d06:	f8d5 0304 	ldr.w	r0, [r5, #772]	; 0x304
    8d0a:	f010 0010 	ands.w	r0, r0, #16
    8d0e:	d106      	bne.n	8d1e <uarte_nrfx_irq_is_pending+0x28>
}
    8d10:	bd38      	pop	{r3, r4, r5, pc}
		 uarte_nrfx_irq_tx_ready_complete(dev))
    8d12:	f7ff ffb2 	bl	8c7a <uarte_nrfx_irq_tx_ready_complete>
					    NRF_UARTE_INT_TXSTOPPED_MASK) &&
    8d16:	2800      	cmp	r0, #0
    8d18:	d0f5      	beq.n	8d06 <uarte_nrfx_irq_is_pending+0x10>
		||
    8d1a:	2001      	movs	r0, #1
    8d1c:	e7f8      	b.n	8d10 <uarte_nrfx_irq_is_pending+0x1a>
		 uarte_nrfx_irq_rx_ready(dev)));
    8d1e:	4620      	mov	r0, r4
    8d20:	f7ff ffc0 	bl	8ca4 <uarte_nrfx_irq_rx_ready>
					    NRF_UARTE_INT_ENDRX_MASK) &&
    8d24:	3800      	subs	r0, #0
    8d26:	bf18      	it	ne
    8d28:	2001      	movne	r0, #1
    8d2a:	e7f1      	b.n	8d10 <uarte_nrfx_irq_is_pending+0x1a>

00008d2c <nrf_gpio_cfg_input>:
{
    8d2c:	b507      	push	{r0, r1, r2, lr}
    8d2e:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    8d30:	a801      	add	r0, sp, #4
    8d32:	f7fb fe7d 	bl	4a30 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    8d36:	9b01      	ldr	r3, [sp, #4]
    8d38:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    8d3c:	0089      	lsls	r1, r1, #2
    reg->PIN_CNF[pin_number] = cnf;
    8d3e:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
}
    8d42:	b003      	add	sp, #12
    8d44:	f85d fb04 	ldr.w	pc, [sp], #4

00008d48 <tx_start.isra.0>:
	return config->uarte_regs;
    8d48:	6803      	ldr	r3, [r0, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    8d4a:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    8d4e:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    8d52:	2200      	movs	r2, #0
    8d54:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    8d58:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    8d5c:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
    8d60:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
    8d64:	6842      	ldr	r2, [r0, #4]
    8d66:	06d2      	lsls	r2, r2, #27
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    8d68:	bf41      	itttt	mi
    8d6a:	2208      	movmi	r2, #8
    8d6c:	f8c3 2500 	strmi.w	r2, [r3, #1280]	; 0x500
    p_reg->INTENSET = mask;
    8d70:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
    8d74:	f8c3 2304 	strmi.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8d78:	2201      	movs	r2, #1
    8d7a:	609a      	str	r2, [r3, #8]
}
    8d7c:	4770      	bx	lr

00008d7e <is_tx_ready.isra.0>:
	return config->uarte_regs;
    8d7e:	6802      	ldr	r2, [r0, #0]
static bool is_tx_ready(const struct device *dev)
    8d80:	4603      	mov	r3, r0
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8d82:	f8d2 0158 	ldr.w	r0, [r2, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
    8d86:	b940      	cbnz	r0, 8d9a <is_tx_ready.isra.0+0x1c>
	bool ppi_endtx = get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX;
    8d88:	685b      	ldr	r3, [r3, #4]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
    8d8a:	079b      	lsls	r3, r3, #30
    8d8c:	d406      	bmi.n	8d9c <is_tx_ready.isra.0+0x1e>
    8d8e:	f8d2 0120 	ldr.w	r0, [r2, #288]	; 0x120
    8d92:	3800      	subs	r0, #0
    8d94:	bf18      	it	ne
    8d96:	2001      	movne	r0, #1
    8d98:	4770      	bx	lr
    8d9a:	2001      	movs	r0, #1
}
    8d9c:	4770      	bx	lr

00008d9e <uarte_nrfx_fifo_fill>:
{
    8d9e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return dev->data;
    8da0:	6906      	ldr	r6, [r0, #16]
	len = MIN(len, data->int_driven->tx_buff_size);
    8da2:	68f3      	ldr	r3, [r6, #12]
    8da4:	899c      	ldrh	r4, [r3, #12]
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    8da6:	f3bf 8f5b 	dmb	ish
    8daa:	4294      	cmp	r4, r2
    8dac:	bfa8      	it	ge
    8dae:	4614      	movge	r4, r2
{
    8db0:	4605      	mov	r5, r0
    8db2:	3310      	adds	r3, #16
    8db4:	2201      	movs	r2, #1
    8db6:	e853 0f00 	ldrex	r0, [r3]
    8dba:	2800      	cmp	r0, #0
    8dbc:	d103      	bne.n	8dc6 <uarte_nrfx_fifo_fill+0x28>
    8dbe:	e843 2700 	strex	r7, r2, [r3]
    8dc2:	2f00      	cmp	r7, #0
    8dc4:	d1f7      	bne.n	8db6 <uarte_nrfx_fifo_fill+0x18>
    8dc6:	f3bf 8f5b 	dmb	ish
    8dca:	bf0c      	ite	eq
    8dcc:	4613      	moveq	r3, r2
    8dce:	2300      	movne	r3, #0
	if (!atomic_cas(&data->int_driven->fifo_fill_lock, 0, 1)) {
    8dd0:	d01d      	beq.n	8e0e <uarte_nrfx_fifo_fill+0x70>
		return 0;
    8dd2:	461c      	mov	r4, r3
}
    8dd4:	4620      	mov	r0, r4
    8dd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		data->int_driven->tx_buffer[i] = tx_data[i];
    8dd8:	68f2      	ldr	r2, [r6, #12]
    8dda:	5cc8      	ldrb	r0, [r1, r3]
    8ddc:	6892      	ldr	r2, [r2, #8]
    8dde:	54d0      	strb	r0, [r2, r3]
	for (int i = 0; i < len; i++) {
    8de0:	3301      	adds	r3, #1
    8de2:	42a3      	cmp	r3, r4
    8de4:	dbf8      	blt.n	8dd8 <uarte_nrfx_fifo_fill+0x3a>
	__asm__ volatile(
    8de6:	f04f 0320 	mov.w	r3, #32
    8dea:	f3ef 8711 	mrs	r7, BASEPRI
    8dee:	f383 8812 	msr	BASEPRI_MAX, r3
    8df2:	f3bf 8f6f 	isb	sy
	if (!is_tx_ready(dev)) {
    8df6:	6868      	ldr	r0, [r5, #4]
    8df8:	f7ff ffc1 	bl	8d7e <is_tx_ready.isra.0>
    8dfc:	68f3      	ldr	r3, [r6, #12]
    8dfe:	b940      	cbnz	r0, 8e12 <uarte_nrfx_fifo_fill+0x74>
		data->int_driven->fifo_fill_lock = 0;
    8e00:	6118      	str	r0, [r3, #16]
		len = 0;
    8e02:	4604      	mov	r4, r0
	__asm__ volatile(
    8e04:	f387 8811 	msr	BASEPRI, r7
    8e08:	f3bf 8f6f 	isb	sy
	return len;
    8e0c:	e7e2      	b.n	8dd4 <uarte_nrfx_fifo_fill+0x36>
	for (int i = 0; i < len; i++) {
    8e0e:	2300      	movs	r3, #0
    8e10:	e7e7      	b.n	8de2 <uarte_nrfx_fifo_fill+0x44>
		tx_start(dev, data->int_driven->tx_buffer, len);
    8e12:	6899      	ldr	r1, [r3, #8]
    8e14:	6868      	ldr	r0, [r5, #4]
    8e16:	4622      	mov	r2, r4
    8e18:	f7ff ff96 	bl	8d48 <tx_start.isra.0>
    8e1c:	e7f2      	b.n	8e04 <uarte_nrfx_fifo_fill+0x66>

00008e1e <uarte_nrfx_isr_int>:
	return config->uarte_regs;
    8e1e:	6843      	ldr	r3, [r0, #4]
    8e20:	681b      	ldr	r3, [r3, #0]
    return p_reg->INTENSET & mask;
    8e22:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
    8e26:	05d1      	lsls	r1, r2, #23
{
    8e28:	b410      	push	{r4}
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
    8e2a:	d518      	bpl.n	8e5e <uarte_nrfx_isr_int+0x40>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8e2c:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    8e30:	b1aa      	cbz	r2, 8e5e <uarte_nrfx_isr_int+0x40>
	__asm__ volatile(
    8e32:	f04f 0120 	mov.w	r1, #32
    8e36:	f3ef 8211 	mrs	r2, BASEPRI
    8e3a:	f381 8812 	msr	BASEPRI_MAX, r1
    8e3e:	f3bf 8f6f 	isb	sy
    8e42:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
    8e46:	b131      	cbz	r1, 8e56 <uarte_nrfx_isr_int+0x38>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    8e48:	2100      	movs	r1, #0
    8e4a:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
    8e4e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8e52:	2101      	movs	r1, #1
    8e54:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
    8e56:	f382 8811 	msr	BASEPRI, r2
    8e5a:	f3bf 8f6f 	isb	sy
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
    8e5e:	6842      	ldr	r2, [r0, #4]
    8e60:	6852      	ldr	r2, [r2, #4]
    8e62:	06d2      	lsls	r2, r2, #27
    8e64:	d51a      	bpl.n	8e9c <uarte_nrfx_isr_int+0x7e>
	__asm__ volatile(
    8e66:	f04f 0220 	mov.w	r2, #32
    8e6a:	f3ef 8111 	mrs	r1, BASEPRI
    8e6e:	f382 8812 	msr	BASEPRI_MAX, r2
    8e72:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8e76:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
    8e7a:	b112      	cbz	r2, 8e82 <uarte_nrfx_isr_int+0x64>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
    8e7c:	2200      	movs	r2, #0
    8e7e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
		if (!data->int_driven || data->int_driven->fifo_fill_lock == 0)
    8e82:	6902      	ldr	r2, [r0, #16]
    8e84:	68d2      	ldr	r2, [r2, #12]
    8e86:	b10a      	cbz	r2, 8e8c <uarte_nrfx_isr_int+0x6e>
    8e88:	6912      	ldr	r2, [r2, #16]
    8e8a:	b91a      	cbnz	r2, 8e94 <uarte_nrfx_isr_int+0x76>
    p_reg->INTENCLR = mask;
    8e8c:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
    8e90:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	__asm__ volatile(
    8e94:	f381 8811 	msr	BASEPRI, r1
    8e98:	f3bf 8f6f 	isb	sy
	if (!data->int_driven) {
    8e9c:	6902      	ldr	r2, [r0, #16]
    8e9e:	68d2      	ldr	r2, [r2, #12]
    8ea0:	b15a      	cbz	r2, 8eba <uarte_nrfx_isr_int+0x9c>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8ea2:	f8d3 1158 	ldr.w	r1, [r3, #344]	; 0x158
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
    8ea6:	b151      	cbz	r1, 8ebe <uarte_nrfx_isr_int+0xa0>
		if (data->int_driven->disable_tx_irq) {
    8ea8:	7b94      	ldrb	r4, [r2, #14]
		data->int_driven->fifo_fill_lock = 0;
    8eaa:	2100      	movs	r1, #0
    8eac:	6111      	str	r1, [r2, #16]
		if (data->int_driven->disable_tx_irq) {
    8eae:	b134      	cbz	r4, 8ebe <uarte_nrfx_isr_int+0xa0>
    p_reg->INTENCLR = mask;
    8eb0:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
    8eb4:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
			data->int_driven->disable_tx_irq = false;
    8eb8:	7391      	strb	r1, [r2, #14]
}
    8eba:	bc10      	pop	{r4}
    8ebc:	4770      	bx	lr
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8ebe:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
    8ec2:	b121      	cbz	r1, 8ece <uarte_nrfx_isr_int+0xb0>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    8ec4:	2100      	movs	r1, #0
    8ec6:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
    8eca:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
	if (data->int_driven->cb) {
    8ece:	6813      	ldr	r3, [r2, #0]
    8ed0:	2b00      	cmp	r3, #0
    8ed2:	d0f2      	beq.n	8eba <uarte_nrfx_isr_int+0x9c>
		data->int_driven->cb(dev, data->int_driven->cb_data);
    8ed4:	6851      	ldr	r1, [r2, #4]
}
    8ed6:	bc10      	pop	{r4}
		data->int_driven->cb(dev, data->int_driven->cb_data);
    8ed8:	4718      	bx	r3

00008eda <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
    8eda:	4770      	bx	lr

00008edc <nrf52_errata_136>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    8edc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
    8ee0:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
}
    8ee4:	f1a0 0308 	sub.w	r3, r0, #8
    8ee8:	4258      	negs	r0, r3
    8eea:	4158      	adcs	r0, r3
    8eec:	4770      	bx	lr

00008eee <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
    8eee:	4700      	bx	r0

00008ef0 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
    8ef0:	f000 bbb4 	b.w	965c <z_impl_k_busy_wait>

00008ef4 <nrfx_clock_start>:
    switch (domain)
    8ef4:	b110      	cbz	r0, 8efc <nrfx_clock_start+0x8>
    8ef6:	2801      	cmp	r0, #1
    8ef8:	d01d      	beq.n	8f36 <nrfx_clock_start+0x42>
    8efa:	4770      	bx	lr
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    8efc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8f00:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    8f04:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
    8f08:	03c9      	lsls	r1, r1, #15
    8f0a:	d512      	bpl.n	8f32 <nrfx_clock_start+0x3e>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    8f0c:	f002 0203 	and.w	r2, r2, #3
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
    8f10:	2a01      	cmp	r2, #1
    8f12:	d10e      	bne.n	8f32 <nrfx_clock_start+0x3e>
    p_reg->LFCLKSRC = (uint32_t)(source);
    8f14:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    8f18:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8f1c:	2200      	movs	r2, #0
    8f1e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    8f22:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    p_reg->INTENSET = mask;
    8f26:	2202      	movs	r2, #2
    8f28:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8f2c:	2201      	movs	r2, #1
    8f2e:	609a      	str	r2, [r3, #8]
}
    8f30:	4770      	bx	lr
    p_reg->LFCLKSRC = (uint32_t)(source);
    8f32:	2200      	movs	r2, #0
    8f34:	e7ee      	b.n	8f14 <nrfx_clock_start+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    8f36:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8f3a:	2200      	movs	r2, #0
    8f3c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    8f40:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
    8f44:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8f48:	6018      	str	r0, [r3, #0]
}
    8f4a:	4770      	bx	lr

00008f4c <nrf_gpio_reconfigure>:
{
    8f4c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8f4e:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    8f50:	a801      	add	r0, sp, #4
{
    8f52:	e9dd 4608 	ldrd	r4, r6, [sp, #32]
    8f56:	4617      	mov	r7, r2
    8f58:	461d      	mov	r5, r3
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    8f5a:	f7fc fa0d 	bl	5378 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
    8f5e:	9b01      	ldr	r3, [sp, #4]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
    8f60:	2f00      	cmp	r7, #0
    8f62:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    8f66:	bf14      	ite	ne
    8f68:	2302      	movne	r3, #2
    8f6a:	2300      	moveq	r3, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
    8f6c:	2900      	cmp	r1, #0
    8f6e:	bf18      	it	ne
    8f70:	f043 0301 	orrne.w	r3, r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
    8f74:	2d00      	cmp	r5, #0
    8f76:	bf14      	ite	ne
    8f78:	f04f 0c0c 	movne.w	ip, #12
    8f7c:	f04f 0c00 	moveq.w	ip, #0
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
    8f80:	2c00      	cmp	r4, #0
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
    8f82:	ea43 030c 	orr.w	r3, r3, ip
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
    8f86:	bf14      	ite	ne
    8f88:	f44f 6ce0 	movne.w	ip, #1792	; 0x700
    8f8c:	f04f 0c00 	moveq.w	ip, #0
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
    8f90:	2e00      	cmp	r6, #0
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
    8f92:	ea43 030c 	orr.w	r3, r3, ip
    uint32_t cnf = reg->PIN_CNF[pin_number];
    8f96:	f8d0 2700 	ldr.w	r2, [r0, #1792]	; 0x700
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
    8f9a:	bf14      	ite	ne
    8f9c:	f44f 3c40 	movne.w	ip, #196608	; 0x30000
    8fa0:	f04f 0c00 	moveq.w	ip, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
    8fa4:	ea43 030c 	orr.w	r3, r3, ip
    cnf &= ~to_update;
    8fa8:	ea22 0303 	bic.w	r3, r2, r3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    8fac:	b101      	cbz	r1, 8fb0 <nrf_gpio_reconfigure+0x64>
    8fae:	7809      	ldrb	r1, [r1, #0]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
    8fb0:	b10f      	cbz	r7, 8fb6 <nrf_gpio_reconfigure+0x6a>
    8fb2:	783f      	ldrb	r7, [r7, #0]
    8fb4:	007f      	lsls	r7, r7, #1
    8fb6:	4319      	orrs	r1, r3
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    8fb8:	b10d      	cbz	r5, 8fbe <nrf_gpio_reconfigure+0x72>
    8fba:	782d      	ldrb	r5, [r5, #0]
    8fbc:	00ad      	lsls	r5, r5, #2
    8fbe:	4339      	orrs	r1, r7
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
    8fc0:	b10c      	cbz	r4, 8fc6 <nrf_gpio_reconfigure+0x7a>
    8fc2:	7822      	ldrb	r2, [r4, #0]
    8fc4:	0214      	lsls	r4, r2, #8
    8fc6:	430d      	orrs	r5, r1
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
    8fc8:	b10e      	cbz	r6, 8fce <nrf_gpio_reconfigure+0x82>
    8fca:	7836      	ldrb	r6, [r6, #0]
    8fcc:	0436      	lsls	r6, r6, #16
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    8fce:	432c      	orrs	r4, r5
    8fd0:	4334      	orrs	r4, r6
    reg->PIN_CNF[pin_number] = cnf;
    8fd2:	f8c0 4700 	str.w	r4, [r0, #1792]	; 0x700
}
    8fd6:	b003      	add	sp, #12
    8fd8:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008fda <nrf_gpio_cfg_sense_set>:
{
    8fda:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
    8fdc:	f10d 030f 	add.w	r3, sp, #15
    8fe0:	9301      	str	r3, [sp, #4]
    8fe2:	2300      	movs	r3, #0
{
    8fe4:	f88d 100f 	strb.w	r1, [sp, #15]
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
    8fe8:	9300      	str	r3, [sp, #0]
    8fea:	461a      	mov	r2, r3
    8fec:	4619      	mov	r1, r3
    8fee:	f7ff ffad 	bl	8f4c <nrf_gpio_reconfigure>
}
    8ff2:	b005      	add	sp, #20
    8ff4:	f85d fb04 	ldr.w	pc, [sp], #4

00008ff8 <nrf_power_event_get_and_clear.constprop.0>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8ff8:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
    8ffc:	681a      	ldr	r2, [r3, #0]
    8ffe:	2a00      	cmp	r2, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    9000:	bf1f      	itttt	ne
    9002:	2200      	movne	r2, #0
    9004:	601a      	strne	r2, [r3, #0]
    9006:	681b      	ldrne	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    9008:	2001      	movne	r0, #1
    900a:	bf08      	it	eq
    900c:	2000      	moveq	r0, #0
}
    900e:	4770      	bx	lr

00009010 <nrfx_power_usbevt_enable>:
    p_reg->INTENSET = mask;
    9010:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    9014:	f44f 7260 	mov.w	r2, #896	; 0x380
    9018:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    901c:	4770      	bx	lr

0000901e <nrfx_power_usbevt_disable>:
    p_reg->INTENCLR = mask;
    901e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    9022:	f44f 7260 	mov.w	r2, #896	; 0x380
    9026:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
    902a:	4770      	bx	lr

0000902c <nrfx_power_clock_irq_handler>:
 * a library with nrfx is created. In such case, forcing a linker to use this
 * function instead of another one defined as weak will require additional
 * actions, and might be even impossible.
 */
void nrfx_power_clock_irq_handler(void)
{
    902c:	b508      	push	{r3, lr}
    nrfx_power_irq_handler();
    902e:	f7fc fd53 	bl	5ad8 <nrfx_power_irq_handler>
    nrfx_clock_irq_handler();
}
    9032:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_irq_handler();
    9036:	f7fc b96b 	b.w	5310 <nrfx_clock_irq_handler>

0000903a <nrf52_errata_166>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    903a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
    903e:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
}
    9042:	f1a0 0308 	sub.w	r3, r0, #8
    9046:	4258      	negs	r0, r3
    9048:	4158      	adcs	r0, r3
    904a:	4770      	bx	lr

0000904c <nrfx_usbd_consumer>:
{
    904c:	b530      	push	{r4, r5, lr}
    size_t size = p_transfer->size;
    904e:	684c      	ldr	r4, [r1, #4]
    if (size < data_size)
    9050:	680d      	ldr	r5, [r1, #0]
    9052:	42a3      	cmp	r3, r4
        p_next->p_data = p_transfer->p_data;
    9054:	bf97      	itett	ls
    9056:	e9c0 5300 	strdls	r5, r3, [r0]
        p_next->size = 0;
    905a:	2100      	movhi	r1, #0
        size -= data_size;
    905c:	1ae4      	subls	r4, r4, r3
        p_transfer->p_data.addr += data_size;
    905e:	18ed      	addls	r5, r5, r3
        p_next->p_data = p_transfer->p_data;
    9060:	bf8e      	itee	hi
    9062:	e9c0 5100 	strdhi	r5, r1, [r0]
        p_transfer->size = size;
    9066:	604c      	strls	r4, [r1, #4]
        p_transfer->p_data.addr += data_size;
    9068:	600d      	strls	r5, [r1, #0]
    return (ep_size == data_size) && (size != 0);
    906a:	429a      	cmp	r2, r3
    906c:	d103      	bne.n	9076 <nrfx_usbd_consumer+0x2a>
    906e:	1e20      	subs	r0, r4, #0
    9070:	bf18      	it	ne
    9072:	2001      	movne	r0, #1
}
    9074:	bd30      	pop	{r4, r5, pc}
    return (ep_size == data_size) && (size != 0);
    9076:	2000      	movs	r0, #0
    9078:	e7fc      	b.n	9074 <nrfx_usbd_consumer+0x28>

0000907a <nrfx_usbd_feeder_ram>:
    size_t tx_size = p_transfer->size;
    907a:	684b      	ldr	r3, [r1, #4]
{
    907c:	b510      	push	{r4, lr}
    907e:	429a      	cmp	r2, r3
    p_next->p_data = p_transfer->p_data;
    9080:	680c      	ldr	r4, [r1, #0]
    9082:	bf28      	it	cs
    9084:	461a      	movcs	r2, r3
    p_next->size = tx_size;
    9086:	e9c0 4200 	strd	r4, r2, [r0]
    p_transfer->size -= tx_size;
    908a:	1a98      	subs	r0, r3, r2
    p_transfer->p_data.addr += tx_size;
    908c:	680b      	ldr	r3, [r1, #0]
    p_transfer->size -= tx_size;
    908e:	6048      	str	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
    9090:	441a      	add	r2, r3
}
    9092:	3800      	subs	r0, #0
    p_transfer->p_data.addr += tx_size;
    9094:	600a      	str	r2, [r1, #0]
}
    9096:	bf18      	it	ne
    9098:	2001      	movne	r0, #1
    909a:	bd10      	pop	{r4, pc}

0000909c <nrfx_usbd_feeder_ram_zlp>:
{
    909c:	b530      	push	{r4, r5, lr}
    size_t tx_size = p_transfer->size;
    909e:	684c      	ldr	r4, [r1, #4]
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
    90a0:	680b      	ldr	r3, [r1, #0]
    90a2:	42a2      	cmp	r2, r4
    90a4:	bf28      	it	cs
    90a6:	4622      	movcs	r2, r4
    90a8:	2a00      	cmp	r2, #0
    90aa:	bf14      	ite	ne
    90ac:	461d      	movne	r5, r3
    90ae:	2500      	moveq	r5, #0
    p_next->size = tx_size;
    90b0:	e9c0 5200 	strd	r5, r2, [r0]
    p_transfer->size -= tx_size;
    90b4:	eba4 0402 	sub.w	r4, r4, r2
    p_transfer->p_data.addr += tx_size;
    90b8:	441a      	add	r2, r3
    p_transfer->size -= tx_size;
    90ba:	604c      	str	r4, [r1, #4]
    p_transfer->p_data.addr += tx_size;
    90bc:	600a      	str	r2, [r1, #0]
}
    90be:	bf14      	ite	ne
    90c0:	2001      	movne	r0, #1
    90c2:	2000      	moveq	r0, #0
    90c4:	bd30      	pop	{r4, r5, pc}

000090c6 <ep2bit>:
    return NRFX_USBD_EP_BITPOS(ep);
    90c6:	b243      	sxtb	r3, r0
    90c8:	2b00      	cmp	r3, #0
    90ca:	bfb4      	ite	lt
    90cc:	2000      	movlt	r0, #0
    90ce:	2010      	movge	r0, #16
    90d0:	f003 030f 	and.w	r3, r3, #15
}
    90d4:	4418      	add	r0, r3
    90d6:	4770      	bx	lr

000090d8 <ev_started_handler>:
}
    90d8:	4770      	bx	lr

000090da <nrf_usbd_epin_dma_handler>:
{
    90da:	b508      	push	{r3, lr}
    90dc:	4601      	mov	r1, r0
    usbd_dma_pending_clear();
    90de:	f7fc fd73 	bl	5bc8 <usbd_dma_pending_clear>
    usbd_ep_state_t * p_state = ep_state_access(ep);
    90e2:	4608      	mov	r0, r1
    90e4:	f7fc fd62 	bl	5bac <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    90e8:	7b83      	ldrb	r3, [r0, #14]
    90ea:	2b03      	cmp	r3, #3
    90ec:	d10a      	bne.n	9104 <nrf_usbd_epin_dma_handler+0x2a>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    90ee:	4608      	mov	r0, r1
    90f0:	f7ff ffe9 	bl	90c6 <ep2bit>
    90f4:	2301      	movs	r3, #1
    90f6:	fa03 f000 	lsl.w	r0, r3, r0
    90fa:	43c0      	mvns	r0, r0
}
    90fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    9100:	f7fc be72 	b.w	5de8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
    9104:	6803      	ldr	r3, [r0, #0]
    9106:	2b00      	cmp	r3, #0
    9108:	d0f1      	beq.n	90ee <nrf_usbd_epin_dma_handler+0x14>
}
    910a:	bd08      	pop	{r3, pc}

0000910c <ev_dma_epin7_handler>:
static void ev_dma_epin7_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN7 ); }
    910c:	2087      	movs	r0, #135	; 0x87
    910e:	f7ff bfe4 	b.w	90da <nrf_usbd_epin_dma_handler>

00009112 <ev_dma_epin6_handler>:
static void ev_dma_epin6_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN6 ); }
    9112:	2086      	movs	r0, #134	; 0x86
    9114:	f7ff bfe1 	b.w	90da <nrf_usbd_epin_dma_handler>

00009118 <ev_dma_epin5_handler>:
static void ev_dma_epin5_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN5 ); }
    9118:	2085      	movs	r0, #133	; 0x85
    911a:	f7ff bfde 	b.w	90da <nrf_usbd_epin_dma_handler>

0000911e <ev_dma_epin4_handler>:
static void ev_dma_epin4_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN4 ); }
    911e:	2084      	movs	r0, #132	; 0x84
    9120:	f7ff bfdb 	b.w	90da <nrf_usbd_epin_dma_handler>

00009124 <ev_dma_epin3_handler>:
static void ev_dma_epin3_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN3 ); }
    9124:	2083      	movs	r0, #131	; 0x83
    9126:	f7ff bfd8 	b.w	90da <nrf_usbd_epin_dma_handler>

0000912a <ev_dma_epin2_handler>:
static void ev_dma_epin2_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN2 ); }
    912a:	2082      	movs	r0, #130	; 0x82
    912c:	f7ff bfd5 	b.w	90da <nrf_usbd_epin_dma_handler>

00009130 <ev_dma_epin1_handler>:
static void ev_dma_epin1_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN1 ); }
    9130:	2081      	movs	r0, #129	; 0x81
    9132:	f7ff bfd2 	b.w	90da <nrf_usbd_epin_dma_handler>

00009136 <ev_dma_epin0_handler>:
static void ev_dma_epin0_handler(void)  { nrf_usbd_ep0in_dma_handler(); }
    9136:	f7fc be67 	b.w	5e08 <nrf_usbd_ep0in_dma_handler>

0000913a <nrfx_usbd_ep_max_packet_size_set>:
{
    913a:	b508      	push	{r3, lr}
    usbd_ep_state_t * p_state = ep_state_access(ep);
    913c:	f7fc fd36 	bl	5bac <ep_state_access>
    p_state->max_packet_size = size;
    9140:	8181      	strh	r1, [r0, #12]
}
    9142:	bd08      	pop	{r3, pc}

00009144 <nrfx_usbd_ep_status_get>:
{
    9144:	b508      	push	{r3, lr}
    usbd_ep_state_t const * p_state = ep_state_access(ep);
    9146:	f7fc fd31 	bl	5bac <ep_state_access>
	__asm__ volatile(
    914a:	f04f 0220 	mov.w	r2, #32
    914e:	f3ef 8311 	mrs	r3, BASEPRI
    9152:	f382 8812 	msr	BASEPRI_MAX, r2
    9156:	f3bf 8f6f 	isb	sy
    *p_size = p_state->transfer_cnt;
    915a:	6882      	ldr	r2, [r0, #8]
    915c:	600a      	str	r2, [r1, #0]
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
    915e:	6802      	ldr	r2, [r0, #0]
    9160:	b92a      	cbnz	r2, 916e <nrfx_usbd_ep_status_get+0x2a>
    9162:	7b80      	ldrb	r0, [r0, #14]
	__asm__ volatile(
    9164:	f383 8811 	msr	BASEPRI, r3
    9168:	f3bf 8f6f 	isb	sy
}
    916c:	bd08      	pop	{r3, pc}
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
    916e:	2004      	movs	r0, #4
    9170:	e7f8      	b.n	9164 <nrfx_usbd_ep_status_get+0x20>

00009172 <ev_dma_epout7_handler>:
static void ev_dma_epout7_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT7); }
    9172:	2007      	movs	r0, #7
    9174:	f7fd b980 	b.w	6478 <nrf_usbd_epout_dma_handler>

00009178 <ev_dma_epout6_handler>:
static void ev_dma_epout6_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT6); }
    9178:	2006      	movs	r0, #6
    917a:	f7fd b97d 	b.w	6478 <nrf_usbd_epout_dma_handler>

0000917e <ev_dma_epout5_handler>:
static void ev_dma_epout5_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT5); }
    917e:	2005      	movs	r0, #5
    9180:	f7fd b97a 	b.w	6478 <nrf_usbd_epout_dma_handler>

00009184 <ev_dma_epout4_handler>:
static void ev_dma_epout4_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT4); }
    9184:	2004      	movs	r0, #4
    9186:	f7fd b977 	b.w	6478 <nrf_usbd_epout_dma_handler>

0000918a <ev_dma_epout3_handler>:
static void ev_dma_epout3_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT3); }
    918a:	2003      	movs	r0, #3
    918c:	f7fd b974 	b.w	6478 <nrf_usbd_epout_dma_handler>

00009190 <ev_dma_epout2_handler>:
static void ev_dma_epout2_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT2); }
    9190:	2002      	movs	r0, #2
    9192:	f7fd b971 	b.w	6478 <nrf_usbd_epout_dma_handler>

00009196 <ev_dma_epout1_handler>:
static void ev_dma_epout1_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT1); }
    9196:	2001      	movs	r0, #1
    9198:	f7fd b96e 	b.w	6478 <nrf_usbd_epout_dma_handler>

0000919c <nrfx_usbd_ep_abort>:
    usbd_ep_abort(ep);
    919c:	f7fd ba62 	b.w	6664 <usbd_ep_abort>

000091a0 <z_device_state_init>:
}
    91a0:	4770      	bx	lr

000091a2 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    91a2:	b138      	cbz	r0, 91b4 <z_device_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    91a4:	68c3      	ldr	r3, [r0, #12]
    91a6:	8818      	ldrh	r0, [r3, #0]
    91a8:	f3c0 0008 	ubfx	r0, r0, #0, #9
    91ac:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
    91b0:	4258      	negs	r0, r3
    91b2:	4158      	adcs	r0, r3
}
    91b4:	4770      	bx	lr

000091b6 <arch_system_halt>:
	__asm__ volatile(
    91b6:	f04f 0220 	mov.w	r2, #32
    91ba:	f3ef 8311 	mrs	r3, BASEPRI
    91be:	f382 8812 	msr	BASEPRI_MAX, r2
    91c2:	f3bf 8f6f 	isb	sy
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
    91c6:	e7fe      	b.n	91c6 <arch_system_halt+0x10>

000091c8 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    91c8:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
    91ca:	f7ff fff4 	bl	91b6 <arch_system_halt>

000091ce <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    91ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    91d0:	4605      	mov	r5, r0
    91d2:	460e      	mov	r6, r1
    91d4:	f04f 0320 	mov.w	r3, #32
    91d8:	f3ef 8711 	mrs	r7, BASEPRI
    91dc:	f383 8812 	msr	BASEPRI_MAX, r3
    91e0:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
    91e4:	f7fe fbba 	bl	795c <z_impl_z_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    91e8:	4631      	mov	r1, r6
    91ea:	4604      	mov	r4, r0
    91ec:	4628      	mov	r0, r5
    91ee:	f7ff ffeb 	bl	91c8 <k_sys_fatal_error_handler>
	__asm__ volatile(
    91f2:	f387 8811 	msr	BASEPRI, r7
    91f6:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
    91fa:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    91fc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    9200:	f7fa ba2a 	b.w	3658 <z_impl_k_thread_abort>

00009204 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    9204:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9206:	4604      	mov	r4, r0
    9208:	460d      	mov	r5, r1
	__asm__ volatile(
    920a:	f04f 0320 	mov.w	r3, #32
    920e:	f3ef 8611 	mrs	r6, BASEPRI
    9212:	f383 8812 	msr	BASEPRI_MAX, r3
    9216:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
    921a:	6947      	ldr	r7, [r0, #20]
    921c:	b977      	cbnz	r7, 923c <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    921e:	f000 f994 	bl	954a <z_unpend_first_thread>

		if (pending_thread != NULL) {
    9222:	b158      	cbz	r0, 923c <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    9224:	682a      	ldr	r2, [r5, #0]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    9226:	6142      	str	r2, [r0, #20]
    9228:	6787      	str	r7, [r0, #120]	; 0x78
			z_ready_thread(pending_thread);
    922a:	f000 f932 	bl	9492 <z_ready_thread>
			z_reschedule(&slab->lock, key);
    922e:	4631      	mov	r1, r6
    9230:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
    9234:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
    9238:	f7fe b8e6 	b.w	7408 <z_reschedule>
	**(char ***) mem = slab->free_list;
    923c:	682b      	ldr	r3, [r5, #0]
    923e:	6962      	ldr	r2, [r4, #20]
    9240:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
    9242:	682b      	ldr	r3, [r5, #0]
    9244:	6163      	str	r3, [r4, #20]
	slab->num_used--;
    9246:	69a3      	ldr	r3, [r4, #24]
    9248:	3b01      	subs	r3, #1
    924a:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    924c:	f386 8811 	msr	BASEPRI, r6
    9250:	f3bf 8f6f 	isb	sy
}
    9254:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00009256 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    9256:	f3ef 8005 	mrs	r0, IPSR
}
    925a:	3800      	subs	r0, #0
    925c:	bf18      	it	ne
    925e:	2001      	movne	r0, #1
    9260:	4770      	bx	lr

00009262 <z_impl_k_thread_name_set>:
}
    9262:	f06f 0057 	mvn.w	r0, #87	; 0x57
    9266:	4770      	bx	lr

00009268 <z_impl_k_thread_start>:
	z_sched_start(thread);
    9268:	f7fe b9c4 	b.w	75f4 <z_sched_start>

0000926c <z_pm_save_idle_exit>:
{
    926c:	b508      	push	{r3, lr}
	pm_system_resume();
    926e:	f7f9 feb7 	bl	2fe0 <pm_system_resume>
}
    9272:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
    9276:	f7ff be30 	b.w	8eda <sys_clock_idle_exit>

0000927a <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
    927a:	f990 300e 	ldrsb.w	r3, [r0, #14]
    927e:	428b      	cmp	r3, r1
    9280:	d001      	beq.n	9286 <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
    9282:	f7fe ba27 	b.w	76d4 <z_set_prio>
}
    9286:	2000      	movs	r0, #0
    9288:	4770      	bx	lr

0000928a <z_impl_k_mutex_init>:
{
    928a:	4603      	mov	r3, r0
	mutex->owner = NULL;
    928c:	2000      	movs	r0, #0
	mutex->lock_count = 0U;
    928e:	e9c3 0002 	strd	r0, r0, [r3, #8]
	list->tail = (sys_dnode_t *)list;
    9292:	e9c3 3300 	strd	r3, r3, [r3]
}
    9296:	4770      	bx	lr

00009298 <queue_insert>:
{
    9298:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    929c:	4699      	mov	r9, r3
    929e:	4604      	mov	r4, r0
    92a0:	f89d 3020 	ldrb.w	r3, [sp, #32]
    92a4:	460d      	mov	r5, r1
    92a6:	4690      	mov	r8, r2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    92a8:	f100 0708 	add.w	r7, r0, #8
	__asm__ volatile(
    92ac:	f04f 0220 	mov.w	r2, #32
    92b0:	f3ef 8611 	mrs	r6, BASEPRI
    92b4:	f382 8812 	msr	BASEPRI_MAX, r2
    92b8:	f3bf 8f6f 	isb	sy
	if (is_append) {
    92bc:	b103      	cbz	r3, 92c0 <queue_insert+0x28>
	return list->tail;
    92be:	6845      	ldr	r5, [r0, #4]
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
    92c0:	4638      	mov	r0, r7
    92c2:	f000 f942 	bl	954a <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
    92c6:	b158      	cbz	r0, 92e0 <queue_insert+0x48>
    92c8:	2400      	movs	r4, #0
    92ca:	6784      	str	r4, [r0, #120]	; 0x78
    92cc:	f8c0 8014 	str.w	r8, [r0, #20]
	z_ready_thread(thread);
    92d0:	f000 f8df 	bl	9492 <z_ready_thread>
	z_reschedule(&queue->lock, key);
    92d4:	4638      	mov	r0, r7
    92d6:	4631      	mov	r1, r6
    92d8:	f7fe f896 	bl	7408 <z_reschedule>
	return 0;
    92dc:	2000      	movs	r0, #0
    92de:	e00c      	b.n	92fa <queue_insert+0x62>
	if (alloc) {
    92e0:	f1b9 0f00 	cmp.w	r9, #0
    92e4:	d01c      	beq.n	9320 <queue_insert+0x88>
	return z_thread_aligned_alloc(0, size);
    92e6:	2108      	movs	r1, #8
    92e8:	f7fe fd06 	bl	7cf8 <z_thread_aligned_alloc>
		if (anode == NULL) {
    92ec:	b938      	cbnz	r0, 92fe <queue_insert+0x66>
	__asm__ volatile(
    92ee:	f386 8811 	msr	BASEPRI, r6
    92f2:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
    92f6:	f06f 000b 	mvn.w	r0, #11
}
    92fa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
    92fe:	2301      	movs	r3, #1
		anode->data = data;
    9300:	f8c0 8004 	str.w	r8, [r0, #4]
    9304:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    9306:	6803      	ldr	r3, [r0, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
    9308:	f003 0203 	and.w	r2, r3, #3
Z_GENLIST_INSERT(sflist, sfnode)
    930c:	b965      	cbnz	r5, 9328 <queue_insert+0x90>
	parent->next_and_flags = cur_flags | (unative_t)child;
    930e:	6823      	ldr	r3, [r4, #0]
    9310:	4313      	orrs	r3, r2
    9312:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
    9314:	6863      	ldr	r3, [r4, #4]
	list->head = node;
    9316:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
    9318:	2b00      	cmp	r3, #0
    931a:	d1db      	bne.n	92d4 <queue_insert+0x3c>
	list->tail = node;
    931c:	6060      	str	r0, [r4, #4]
}
    931e:	e7d9      	b.n	92d4 <queue_insert+0x3c>
	node->next_and_flags = flags;
    9320:	f8c8 9000 	str.w	r9, [r8]
}
    9324:	4640      	mov	r0, r8
    9326:	e7ee      	b.n	9306 <queue_insert+0x6e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    9328:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
    932a:	f033 0303 	bics.w	r3, r3, #3
    932e:	d10b      	bne.n	9348 <queue_insert+0xb0>
	parent->next_and_flags = cur_flags | (unative_t)child;
    9330:	6002      	str	r2, [r0, #0]
	return list->tail;
    9332:	6862      	ldr	r2, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
    9334:	b912      	cbnz	r2, 933c <queue_insert+0xa4>
	list->head = node;
    9336:	e9c4 0000 	strd	r0, r0, [r4]
}
    933a:	e7cb      	b.n	92d4 <queue_insert+0x3c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    933c:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
    933e:	f003 0303 	and.w	r3, r3, #3
    9342:	4303      	orrs	r3, r0
    9344:	6013      	str	r3, [r2, #0]
    9346:	e7e9      	b.n	931c <queue_insert+0x84>
    9348:	4313      	orrs	r3, r2
    934a:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    934c:	682b      	ldr	r3, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
    934e:	f003 0303 	and.w	r3, r3, #3
    9352:	4318      	orrs	r0, r3
    9354:	6028      	str	r0, [r5, #0]
}
    9356:	e7bd      	b.n	92d4 <queue_insert+0x3c>

00009358 <z_queue_node_peek>:
{
    9358:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
    935a:	4604      	mov	r4, r0
    935c:	b130      	cbz	r0, 936c <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    935e:	6802      	ldr	r2, [r0, #0]
    9360:	0793      	lsls	r3, r2, #30
    9362:	d003      	beq.n	936c <z_queue_node_peek+0x14>
		ret = anode->data;
    9364:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
    9366:	b109      	cbz	r1, 936c <z_queue_node_peek+0x14>
			k_free(anode);
    9368:	f000 f9a7 	bl	96ba <k_free>
}
    936c:	4620      	mov	r0, r4
    936e:	bd10      	pop	{r4, pc}

00009370 <k_queue_append>:
{
    9370:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, true);
    9372:	2301      	movs	r3, #1
    9374:	9300      	str	r3, [sp, #0]
    9376:	2300      	movs	r3, #0
{
    9378:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
    937a:	4619      	mov	r1, r3
    937c:	f7ff ff8c 	bl	9298 <queue_insert>
}
    9380:	b003      	add	sp, #12
    9382:	f85d fb04 	ldr.w	pc, [sp], #4

00009386 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
    9386:	b13a      	cbz	r2, 9398 <z_impl_k_sem_init+0x12>
    9388:	428a      	cmp	r2, r1
    938a:	d305      	bcc.n	9398 <z_impl_k_sem_init+0x12>
	sem->limit = limit;
    938c:	e9c0 1202 	strd	r1, r2, [r0, #8]
    9390:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
    9394:	2000      	movs	r0, #0
    9396:	4770      	bx	lr
		return -EINVAL;
    9398:	f06f 0015 	mvn.w	r0, #21
}
    939c:	4770      	bx	lr

0000939e <flag_test_and_clear>:
	return (*flagp & BIT(bit)) != 0U;
    939e:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
    93a0:	2301      	movs	r3, #1
    93a2:	408b      	lsls	r3, r1
    93a4:	ea22 0303 	bic.w	r3, r2, r3
    93a8:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
    93aa:	fa22 f001 	lsr.w	r0, r2, r1
}
    93ae:	f000 0001 	and.w	r0, r0, #1
    93b2:	4770      	bx	lr

000093b4 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
    93b4:	b120      	cbz	r0, 93c0 <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
    93b6:	2200      	movs	r2, #0
    93b8:	4611      	mov	r1, r2
    93ba:	3088      	adds	r0, #136	; 0x88
    93bc:	f000 b8ed 	b.w	959a <z_sched_wake>
}
    93c0:	4770      	bx	lr

000093c2 <k_work_init>:
{
    93c2:	b538      	push	{r3, r4, r5, lr}
    93c4:	4604      	mov	r4, r0
    93c6:	460d      	mov	r5, r1
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    93c8:	2210      	movs	r2, #16
    93ca:	2100      	movs	r1, #0
    93cc:	f7ff fa7f 	bl	88ce <memset>
    93d0:	6065      	str	r5, [r4, #4]
}
    93d2:	bd38      	pop	{r3, r4, r5, pc}

000093d4 <k_work_submit_to_queue>:
{
    93d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    93d6:	9001      	str	r0, [sp, #4]
    93d8:	4608      	mov	r0, r1
	__asm__ volatile(
    93da:	f04f 0320 	mov.w	r3, #32
    93de:	f3ef 8511 	mrs	r5, BASEPRI
    93e2:	f383 8812 	msr	BASEPRI_MAX, r3
    93e6:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
    93ea:	a901      	add	r1, sp, #4
    93ec:	f7fd ff3e 	bl	726c <submit_to_queue_locked>
    93f0:	4604      	mov	r4, r0
	__asm__ volatile(
    93f2:	f385 8811 	msr	BASEPRI, r5
    93f6:	f3bf 8f6f 	isb	sy
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
    93fa:	2800      	cmp	r0, #0
    93fc:	dd04      	ble.n	9408 <k_work_submit_to_queue+0x34>
	return z_impl_k_is_preempt_thread();
    93fe:	f7fe fab3 	bl	7968 <z_impl_k_is_preempt_thread>
    9402:	b108      	cbz	r0, 9408 <k_work_submit_to_queue+0x34>
	z_impl_k_yield();
    9404:	f7fe fa08 	bl	7818 <z_impl_k_yield>
}
    9408:	4620      	mov	r0, r4
    940a:	b003      	add	sp, #12
    940c:	bd30      	pop	{r4, r5, pc}

0000940e <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
    940e:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
    9412:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    9414:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    9416:	2300      	movs	r3, #0
	node->prev = NULL;
    9418:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
    941c:	4770      	bx	lr

0000941e <unpend_thread_no_timeout>:
{
    941e:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
    9420:	f7ff fff5 	bl	940e <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    9424:	7b43      	ldrb	r3, [r0, #13]
    9426:	f023 0302 	bic.w	r3, r3, #2
    942a:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
    942c:	2300      	movs	r3, #0
    942e:	6083      	str	r3, [r0, #8]
}
    9430:	bd08      	pop	{r3, pc}

00009432 <z_unpend_thread>:
{
    9432:	b510      	push	{r4, lr}
	__asm__ volatile(
    9434:	f04f 0320 	mov.w	r3, #32
    9438:	f3ef 8411 	mrs	r4, BASEPRI
    943c:	f383 8812 	msr	BASEPRI_MAX, r3
    9440:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
    9444:	f7ff ffeb 	bl	941e <unpend_thread_no_timeout>
	__asm__ volatile(
    9448:	f384 8811 	msr	BASEPRI, r4
    944c:	f3bf 8f6f 	isb	sy
}
    9450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    9454:	3018      	adds	r0, #24
    9456:	f000 b8bd 	b.w	95d4 <z_abort_timeout>

0000945a <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    945a:	4603      	mov	r3, r0
    945c:	b920      	cbnz	r0, 9468 <z_reschedule_irqlock+0xe>
    945e:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
    9462:	b90a      	cbnz	r2, 9468 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
    9464:	f7f9 bf10 	b.w	3288 <arch_swap>
    9468:	f383 8811 	msr	BASEPRI, r3
    946c:	f3bf 8f6f 	isb	sy
}
    9470:	4770      	bx	lr

00009472 <z_reschedule_unlocked>:
	__asm__ volatile(
    9472:	f04f 0320 	mov.w	r3, #32
    9476:	f3ef 8011 	mrs	r0, BASEPRI
    947a:	f383 8812 	msr	BASEPRI_MAX, r3
    947e:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    9482:	f7ff bfea 	b.w	945a <z_reschedule_irqlock>

00009486 <z_priq_dumb_best>:
{
    9486:	4603      	mov	r3, r0
	return list->head == list;
    9488:	6800      	ldr	r0, [r0, #0]
}
    948a:	4283      	cmp	r3, r0
    948c:	bf08      	it	eq
    948e:	2000      	moveq	r0, #0
    9490:	4770      	bx	lr

00009492 <z_ready_thread>:
{
    9492:	b510      	push	{r4, lr}
    9494:	f04f 0320 	mov.w	r3, #32
    9498:	f3ef 8411 	mrs	r4, BASEPRI
    949c:	f383 8812 	msr	BASEPRI_MAX, r3
    94a0:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
    94a4:	f7fe f870 	bl	7588 <ready_thread>
	__asm__ volatile(
    94a8:	f384 8811 	msr	BASEPRI, r4
    94ac:	f3bf 8f6f 	isb	sy
}
    94b0:	bd10      	pop	{r4, pc}

000094b2 <z_thread_timeout>:
{
    94b2:	b510      	push	{r4, lr}
    94b4:	4601      	mov	r1, r0
	__asm__ volatile(
    94b6:	f04f 0320 	mov.w	r3, #32
    94ba:	f3ef 8411 	mrs	r4, BASEPRI
    94be:	f383 8812 	msr	BASEPRI_MAX, r3
    94c2:	f3bf 8f6f 	isb	sy
		if (!killed) {
    94c6:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
    94ca:	f013 0f28 	tst.w	r3, #40	; 0x28
    94ce:	d10d      	bne.n	94ec <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
    94d0:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
    94d4:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
    94d6:	b10b      	cbz	r3, 94dc <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
    94d8:	f7ff ffa1 	bl	941e <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    94dc:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
    94e0:	f023 0314 	bic.w	r3, r3, #20
    94e4:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
    94e8:	f7fe f84e 	bl	7588 <ready_thread>
	__asm__ volatile(
    94ec:	f384 8811 	msr	BASEPRI, r4
    94f0:	f3bf 8f6f 	isb	sy
}
    94f4:	bd10      	pop	{r4, pc}

000094f6 <add_to_waitq_locked>:
{
    94f6:	b538      	push	{r3, r4, r5, lr}
    94f8:	4604      	mov	r4, r0
    94fa:	460d      	mov	r5, r1
	unready_thread(thread);
    94fc:	f7fe f898 	bl	7630 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    9500:	7b63      	ldrb	r3, [r4, #13]
    9502:	f043 0302 	orr.w	r3, r3, #2
    9506:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
    9508:	b195      	cbz	r5, 9530 <add_to_waitq_locked+0x3a>
    950a:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
    950c:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    950e:	429d      	cmp	r5, r3
    9510:	d015      	beq.n	953e <add_to_waitq_locked+0x48>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    9512:	b1a3      	cbz	r3, 953e <add_to_waitq_locked+0x48>
	int32_t b1 = thread_1->base.prio;
    9514:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
    9518:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
    951c:	4291      	cmp	r1, r2
    951e:	d008      	beq.n	9532 <add_to_waitq_locked+0x3c>
		return b2 - b1;
    9520:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
    9522:	2a00      	cmp	r2, #0
    9524:	dd05      	ble.n	9532 <add_to_waitq_locked+0x3c>
	sys_dnode_t *const prev = successor->prev;
    9526:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    9528:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
    952c:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    952e:	605c      	str	r4, [r3, #4]
}
    9530:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
    9532:	686a      	ldr	r2, [r5, #4]
    9534:	4293      	cmp	r3, r2
    9536:	d002      	beq.n	953e <add_to_waitq_locked+0x48>
    9538:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    953a:	2b00      	cmp	r3, #0
    953c:	d1ec      	bne.n	9518 <add_to_waitq_locked+0x22>
	sys_dnode_t *const tail = list->tail;
    953e:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
    9540:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
    9544:	601c      	str	r4, [r3, #0]
	list->tail = node;
    9546:	606c      	str	r4, [r5, #4]
}
    9548:	e7f2      	b.n	9530 <add_to_waitq_locked+0x3a>

0000954a <z_unpend_first_thread>:
{
    954a:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    954c:	f04f 0320 	mov.w	r3, #32
    9550:	f3ef 8511 	mrs	r5, BASEPRI
    9554:	f383 8812 	msr	BASEPRI_MAX, r3
    9558:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
    955c:	f7ff ff93 	bl	9486 <z_priq_dumb_best>
		if (thread != NULL) {
    9560:	4604      	mov	r4, r0
    9562:	b120      	cbz	r0, 956e <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
    9564:	f7ff ff5b 	bl	941e <unpend_thread_no_timeout>
    9568:	3018      	adds	r0, #24
    956a:	f000 f833 	bl	95d4 <z_abort_timeout>
	__asm__ volatile(
    956e:	f385 8811 	msr	BASEPRI, r5
    9572:	f3bf 8f6f 	isb	sy
}
    9576:	4620      	mov	r0, r4
    9578:	bd38      	pop	{r3, r4, r5, pc}

0000957a <z_unpend_all>:
{
    957a:	b538      	push	{r3, r4, r5, lr}
    957c:	4605      	mov	r5, r0
	int need_sched = 0;
    957e:	2000      	movs	r0, #0
	return list->head == list;
    9580:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    9582:	42a5      	cmp	r5, r4
    9584:	d000      	beq.n	9588 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    9586:	b904      	cbnz	r4, 958a <z_unpend_all+0x10>
}
    9588:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
    958a:	4620      	mov	r0, r4
    958c:	f7ff ff51 	bl	9432 <z_unpend_thread>
		z_ready_thread(thread);
    9590:	4620      	mov	r0, r4
    9592:	f7ff ff7e 	bl	9492 <z_ready_thread>
		need_sched = 1;
    9596:	2001      	movs	r0, #1
    9598:	e7f2      	b.n	9580 <z_unpend_all+0x6>

0000959a <z_sched_wake>:
{
    959a:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    959c:	f04f 0320 	mov.w	r3, #32
    95a0:	f3ef 8511 	mrs	r5, BASEPRI
    95a4:	f383 8812 	msr	BASEPRI_MAX, r3
    95a8:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
    95ac:	f7ff ff6b 	bl	9486 <z_priq_dumb_best>
		if (thread != NULL) {
    95b0:	4604      	mov	r4, r0
    95b2:	b150      	cbz	r0, 95ca <z_sched_wake+0x30>
    95b4:	6781      	str	r1, [r0, #120]	; 0x78
	thread->base.swap_data = data;
    95b6:	6142      	str	r2, [r0, #20]
			unpend_thread_no_timeout(thread);
    95b8:	f7ff ff31 	bl	941e <unpend_thread_no_timeout>
    95bc:	3018      	adds	r0, #24
    95be:	f000 f809 	bl	95d4 <z_abort_timeout>
			ready_thread(thread);
    95c2:	4620      	mov	r0, r4
    95c4:	f7fd ffe0 	bl	7588 <ready_thread>
			ret = true;
    95c8:	2001      	movs	r0, #1
	__asm__ volatile(
    95ca:	f385 8811 	msr	BASEPRI, r5
    95ce:	f3bf 8f6f 	isb	sy
}
    95d2:	bd38      	pop	{r3, r4, r5, pc}

000095d4 <z_abort_timeout>:
{
    95d4:	b510      	push	{r4, lr}
	__asm__ volatile(
    95d6:	f04f 0220 	mov.w	r2, #32
    95da:	f3ef 8411 	mrs	r4, BASEPRI
    95de:	f382 8812 	msr	BASEPRI_MAX, r2
    95e2:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
    95e6:	6803      	ldr	r3, [r0, #0]
    95e8:	b13b      	cbz	r3, 95fa <z_abort_timeout+0x26>
			remove_timeout(to);
    95ea:	f7fe fa7d 	bl	7ae8 <remove_timeout>
			ret = 0;
    95ee:	2000      	movs	r0, #0
	__asm__ volatile(
    95f0:	f384 8811 	msr	BASEPRI, r4
    95f4:	f3bf 8f6f 	isb	sy
}
    95f8:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
    95fa:	f06f 0015 	mvn.w	r0, #21
    95fe:	e7f7      	b.n	95f0 <z_abort_timeout+0x1c>

00009600 <z_get_next_timeout_expiry>:
{
    9600:	b510      	push	{r4, lr}
	__asm__ volatile(
    9602:	f04f 0320 	mov.w	r3, #32
    9606:	f3ef 8411 	mrs	r4, BASEPRI
    960a:	f383 8812 	msr	BASEPRI_MAX, r3
    960e:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
    9612:	f7fe fa41 	bl	7a98 <next_timeout>
	__asm__ volatile(
    9616:	f384 8811 	msr	BASEPRI, r4
    961a:	f3bf 8f6f 	isb	sy
}
    961e:	bd10      	pop	{r4, pc}

00009620 <z_set_timeout_expiry>:
{
    9620:	b570      	push	{r4, r5, r6, lr}
    9622:	4604      	mov	r4, r0
    9624:	460d      	mov	r5, r1
	__asm__ volatile(
    9626:	f04f 0320 	mov.w	r3, #32
    962a:	f3ef 8611 	mrs	r6, BASEPRI
    962e:	f383 8812 	msr	BASEPRI_MAX, r3
    9632:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
    9636:	f7fe fa2f 	bl	7a98 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    963a:	2801      	cmp	r0, #1
    963c:	dd05      	ble.n	964a <z_set_timeout_expiry+0x2a>
    963e:	42a0      	cmp	r0, r4
    9640:	db03      	blt.n	964a <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    9642:	4629      	mov	r1, r5
    9644:	4620      	mov	r0, r4
    9646:	f7fb fc67 	bl	4f18 <sys_clock_set_timeout>
	__asm__ volatile(
    964a:	f386 8811 	msr	BASEPRI, r6
    964e:	f3bf 8f6f 	isb	sy
}
    9652:	bd70      	pop	{r4, r5, r6, pc}

00009654 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    9654:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    9656:	f7fe fb37 	bl	7cc8 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    965a:	bd08      	pop	{r3, pc}

0000965c <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    965c:	b108      	cbz	r0, 9662 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    965e:	f7fa b909 	b.w	3874 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    9662:	4770      	bx	lr

00009664 <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    9664:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    9668:	bf08      	it	eq
    966a:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
    966e:	b538      	push	{r3, r4, r5, lr}
    9670:	4605      	mov	r5, r0
    9672:	460c      	mov	r4, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    9674:	d01d      	beq.n	96b2 <sys_clock_timeout_end_calc+0x4e>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    9676:	ea51 0300 	orrs.w	r3, r1, r0
    967a:	d103      	bne.n	9684 <sys_clock_timeout_end_calc+0x20>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
    967c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
    9680:	f7fe bb22 	b.w	7cc8 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
    9684:	f06f 0301 	mvn.w	r3, #1
    9688:	1a18      	subs	r0, r3, r0
    968a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    968e:	eb63 0101 	sbc.w	r1, r3, r1
    9692:	2900      	cmp	r1, #0
    9694:	da0c      	bge.n	96b0 <sys_clock_timeout_end_calc+0x4c>
		return sys_clock_tick_get() + MAX(1, dt);
    9696:	f7fe fb17 	bl	7cc8 <sys_clock_tick_get>
    969a:	2d01      	cmp	r5, #1
    969c:	4622      	mov	r2, r4
    969e:	f174 0400 	sbcs.w	r4, r4, #0
    96a2:	462b      	mov	r3, r5
    96a4:	bfbc      	itt	lt
    96a6:	2301      	movlt	r3, #1
    96a8:	2200      	movlt	r2, #0
    96aa:	1818      	adds	r0, r3, r0
    96ac:	eb41 0102 	adc.w	r1, r1, r2
}
    96b0:	bd38      	pop	{r3, r4, r5, pc}
		return UINT64_MAX;
    96b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    96b6:	4601      	mov	r1, r0
    96b8:	e7fa      	b.n	96b0 <sys_clock_timeout_end_calc+0x4c>

000096ba <k_free>:
	if (ptr != NULL) {
    96ba:	b120      	cbz	r0, 96c6 <k_free+0xc>
		k_heap_free(*heap_ref, ptr);
    96bc:	1f01      	subs	r1, r0, #4
    96be:	f850 0c04 	ldr.w	r0, [r0, #-4]
    96c2:	f000 b84a 	b.w	975a <k_heap_free>
}
    96c6:	4770      	bx	lr

000096c8 <k_heap_init>:
{
    96c8:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
    96ca:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
    96ce:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
    96d2:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
    96d4:	f7fe be33 	b.w	833e <sys_heap_init>

000096d8 <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
    96d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    96dc:	b085      	sub	sp, #20
    96de:	4606      	mov	r6, r0
    96e0:	4688      	mov	r8, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
    96e2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
{
    96e6:	4691      	mov	r9, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
    96e8:	f7ff ffbc 	bl	9664 <sys_clock_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    96ec:	f106 0a14 	add.w	sl, r6, #20
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
    96f0:	4605      	mov	r5, r0
    96f2:	460f      	mov	r7, r1
	__asm__ volatile(
    96f4:	f04f 0320 	mov.w	r3, #32
    96f8:	f3ef 8411 	mrs	r4, BASEPRI
    96fc:	f383 8812 	msr	BASEPRI_MAX, r3
    9700:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
    9704:	f106 0b0c 	add.w	fp, r6, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
    9708:	464a      	mov	r2, r9
    970a:	4641      	mov	r1, r8
    970c:	4630      	mov	r0, r6
    970e:	f7fe fdae 	bl	826e <sys_heap_aligned_alloc>
    9712:	9003      	str	r0, [sp, #12]
		now = sys_clock_tick_get();
    9714:	f7fe fad8 	bl	7cc8 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
    9718:	9b03      	ldr	r3, [sp, #12]
    971a:	b13b      	cbz	r3, 972c <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
    971c:	f384 8811 	msr	BASEPRI, r4
    9720:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
    9724:	4618      	mov	r0, r3
    9726:	b005      	add	sp, #20
    9728:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
    972c:	1a28      	subs	r0, r5, r0
    972e:	eb67 0101 	sbc.w	r1, r7, r1
    9732:	2801      	cmp	r0, #1
    9734:	f171 0200 	sbcs.w	r2, r1, #0
    9738:	dbf0      	blt.n	971c <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
    973a:	e9cd 0100 	strd	r0, r1, [sp]
    973e:	465a      	mov	r2, fp
    9740:	4621      	mov	r1, r4
    9742:	4650      	mov	r0, sl
    9744:	f7fd ffb2 	bl	76ac <z_pend_curr>
	__asm__ volatile(
    9748:	f04f 0320 	mov.w	r3, #32
    974c:	f3ef 8411 	mrs	r4, BASEPRI
    9750:	f383 8812 	msr	BASEPRI_MAX, r3
    9754:	f3bf 8f6f 	isb	sy
    9758:	e7d6      	b.n	9708 <k_heap_aligned_alloc+0x30>

0000975a <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
    975a:	b538      	push	{r3, r4, r5, lr}
    975c:	4604      	mov	r4, r0
    975e:	f04f 0320 	mov.w	r3, #32
    9762:	f3ef 8511 	mrs	r5, BASEPRI
    9766:	f383 8812 	msr	BASEPRI_MAX, r3
    976a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
    976e:	f7fe fd46 	bl	81fe <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
    9772:	f104 000c 	add.w	r0, r4, #12
    9776:	f7ff ff00 	bl	957a <z_unpend_all>
    977a:	b130      	cbz	r0, 978a <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
    977c:	4629      	mov	r1, r5
    977e:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
    9782:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
    9786:	f7fd be3f 	b.w	7408 <z_reschedule>
	__asm__ volatile(
    978a:	f385 8811 	msr	BASEPRI, r5
    978e:	f3bf 8f6f 	isb	sy
}
    9792:	bd38      	pop	{r3, r4, r5, pc}

00009794 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
    9794:	f7fb bc2c 	b.w	4ff0 <SystemInit>

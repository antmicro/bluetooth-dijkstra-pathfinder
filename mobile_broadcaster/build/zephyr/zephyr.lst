
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   0:	40 3b 00 20 69 29 00 00 c9 fa 00 00 3d 29 00 00     @;. i)......=)..
  10:	3d 29 00 00 3d 29 00 00 3d 29 00 00 00 00 00 00     =)..=)..=)......
	...
  2c:	51 26 00 00 3d 29 00 00 00 00 00 00 fd 25 00 00     Q&..=).......%..
  3c:	3d 29 00 00                                         =)..

00000040 <_irq_vector_table>:
  40:	01 27 00 00 6f 17 01 00 01 27 00 00 01 27 00 00     .'..o....'...'..
  50:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..
  60:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..
  70:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..
  80:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..
  90:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..
  a0:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..
  b0:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..
  c0:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..
  d0:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..
  e0:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..
  f0:	01 27 00 00 01 27 00 00 01 27 00 00 01 27 00 00     .'...'...'...'..

Disassembly of section text:

00000100 <__aeabi_uldivmod>:
     100:	b953      	cbnz	r3, 118 <__aeabi_uldivmod+0x18>
     102:	b94a      	cbnz	r2, 118 <__aeabi_uldivmod+0x18>
     104:	2900      	cmp	r1, #0
     106:	bf08      	it	eq
     108:	2800      	cmpeq	r0, #0
     10a:	bf1c      	itt	ne
     10c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
     110:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     114:	f000 b80c 	b.w	130 <__aeabi_idiv0>
     118:	f1ad 0c08 	sub.w	ip, sp, #8
     11c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     120:	f000 f808 	bl	134 <__udivmoddi4>
     124:	f8dd e004 	ldr.w	lr, [sp, #4]
     128:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     12c:	b004      	add	sp, #16
     12e:	4770      	bx	lr

00000130 <__aeabi_idiv0>:
     130:	4770      	bx	lr
     132:	bf00      	nop

00000134 <__udivmoddi4>:
     134:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     138:	4607      	mov	r7, r0
     13a:	468c      	mov	ip, r1
     13c:	4608      	mov	r0, r1
     13e:	9e09      	ldr	r6, [sp, #36]	; 0x24
     140:	4615      	mov	r5, r2
     142:	463c      	mov	r4, r7
     144:	4619      	mov	r1, r3
     146:	2b00      	cmp	r3, #0
     148:	f040 80c6 	bne.w	2d8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x58>
     14c:	4282      	cmp	r2, r0
     14e:	fab2 f782 	clz	r7, r2
     152:	d946      	bls.n	1e2 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x22>
     154:	b14f      	cbz	r7, 16a <CONFIG_IDLE_STACK_SIZE+0x2a>
     156:	f1c7 0e20 	rsb	lr, r7, #32
     15a:	fa24 fe0e 	lsr.w	lr, r4, lr
     15e:	fa00 f307 	lsl.w	r3, r0, r7
     162:	40bd      	lsls	r5, r7
     164:	ea4e 0c03 	orr.w	ip, lr, r3
     168:	40bc      	lsls	r4, r7
     16a:	ea4f 4815 	mov.w	r8, r5, lsr #16
     16e:	fa1f fe85 	uxth.w	lr, r5
     172:	fbbc f9f8 	udiv	r9, ip, r8
     176:	0c22      	lsrs	r2, r4, #16
     178:	fb08 c319 	mls	r3, r8, r9, ip
     17c:	fb09 fa0e 	mul.w	sl, r9, lr
     180:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
     184:	459a      	cmp	sl, r3
     186:	d928      	bls.n	1da <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x1a>
     188:	18eb      	adds	r3, r5, r3
     18a:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
     18e:	d204      	bcs.n	19a <CONFIG_IDLE_STACK_SIZE+0x5a>
     190:	459a      	cmp	sl, r3
     192:	d902      	bls.n	19a <CONFIG_IDLE_STACK_SIZE+0x5a>
     194:	f1a9 0002 	sub.w	r0, r9, #2
     198:	442b      	add	r3, r5
     19a:	eba3 030a 	sub.w	r3, r3, sl
     19e:	b2a4      	uxth	r4, r4
     1a0:	fbb3 f2f8 	udiv	r2, r3, r8
     1a4:	fb08 3312 	mls	r3, r8, r2, r3
     1a8:	fb02 fe0e 	mul.w	lr, r2, lr
     1ac:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     1b0:	45a6      	cmp	lr, r4
     1b2:	d914      	bls.n	1de <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x1e>
     1b4:	192c      	adds	r4, r5, r4
     1b6:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
     1ba:	d203      	bcs.n	1c4 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x4>
     1bc:	45a6      	cmp	lr, r4
     1be:	d901      	bls.n	1c4 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x4>
     1c0:	1e93      	subs	r3, r2, #2
     1c2:	442c      	add	r4, r5
     1c4:	eba4 040e 	sub.w	r4, r4, lr
     1c8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     1cc:	b11e      	cbz	r6, 1d6 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x16>
     1ce:	40fc      	lsrs	r4, r7
     1d0:	2300      	movs	r3, #0
     1d2:	6034      	str	r4, [r6, #0]
     1d4:	6073      	str	r3, [r6, #4]
     1d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     1da:	4648      	mov	r0, r9
     1dc:	e7dd      	b.n	19a <CONFIG_IDLE_STACK_SIZE+0x5a>
     1de:	4613      	mov	r3, r2
     1e0:	e7f0      	b.n	1c4 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x4>
     1e2:	b902      	cbnz	r2, 1e6 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x26>
     1e4:	deff      	udf	#255	; 0xff
     1e6:	bb87      	cbnz	r7, 24a <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x8a>
     1e8:	1a83      	subs	r3, r0, r2
     1ea:	2101      	movs	r1, #1
     1ec:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     1f0:	b2aa      	uxth	r2, r5
     1f2:	fbb3 fcfe 	udiv	ip, r3, lr
     1f6:	0c20      	lsrs	r0, r4, #16
     1f8:	fb0e 331c 	mls	r3, lr, ip, r3
     1fc:	fb0c f802 	mul.w	r8, ip, r2
     200:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
     204:	4598      	cmp	r8, r3
     206:	d963      	bls.n	2d0 <CONFIG_BT_HCI_TX_STACK_SIZE+0x50>
     208:	18eb      	adds	r3, r5, r3
     20a:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
     20e:	d204      	bcs.n	21a <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x5a>
     210:	4598      	cmp	r8, r3
     212:	d902      	bls.n	21a <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x5a>
     214:	f1ac 0002 	sub.w	r0, ip, #2
     218:	442b      	add	r3, r5
     21a:	eba3 0308 	sub.w	r3, r3, r8
     21e:	b2a4      	uxth	r4, r4
     220:	fbb3 fcfe 	udiv	ip, r3, lr
     224:	fb0e 331c 	mls	r3, lr, ip, r3
     228:	fb0c f202 	mul.w	r2, ip, r2
     22c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     230:	42a2      	cmp	r2, r4
     232:	d94f      	bls.n	2d4 <CONFIG_BT_HCI_TX_STACK_SIZE+0x54>
     234:	192c      	adds	r4, r5, r4
     236:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
     23a:	d204      	bcs.n	246 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x86>
     23c:	42a2      	cmp	r2, r4
     23e:	d902      	bls.n	246 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x86>
     240:	f1ac 0302 	sub.w	r3, ip, #2
     244:	442c      	add	r4, r5
     246:	1aa4      	subs	r4, r4, r2
     248:	e7be      	b.n	1c8 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x8>
     24a:	f1c7 0c20 	rsb	ip, r7, #32
     24e:	fa20 f80c 	lsr.w	r8, r0, ip
     252:	fa00 f307 	lsl.w	r3, r0, r7
     256:	fa24 fc0c 	lsr.w	ip, r4, ip
     25a:	40bd      	lsls	r5, r7
     25c:	ea4c 0203 	orr.w	r2, ip, r3
     260:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     264:	b2ab      	uxth	r3, r5
     266:	fbb8 fcfe 	udiv	ip, r8, lr
     26a:	0c11      	lsrs	r1, r2, #16
     26c:	fb0e 801c 	mls	r0, lr, ip, r8
     270:	fb0c f903 	mul.w	r9, ip, r3
     274:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
     278:	4581      	cmp	r9, r0
     27a:	fa04 f407 	lsl.w	r4, r4, r7
     27e:	d923      	bls.n	2c8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x48>
     280:	1828      	adds	r0, r5, r0
     282:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
     286:	d204      	bcs.n	292 <CONFIG_BT_HCI_TX_STACK_SIZE+0x12>
     288:	4581      	cmp	r9, r0
     28a:	d902      	bls.n	292 <CONFIG_BT_HCI_TX_STACK_SIZE+0x12>
     28c:	f1ac 0102 	sub.w	r1, ip, #2
     290:	4428      	add	r0, r5
     292:	eba0 0009 	sub.w	r0, r0, r9
     296:	b292      	uxth	r2, r2
     298:	fbb0 fcfe 	udiv	ip, r0, lr
     29c:	fb0e 001c 	mls	r0, lr, ip, r0
     2a0:	fb0c f803 	mul.w	r8, ip, r3
     2a4:	ea42 4300 	orr.w	r3, r2, r0, lsl #16
     2a8:	4598      	cmp	r8, r3
     2aa:	d90f      	bls.n	2cc <CONFIG_BT_HCI_TX_STACK_SIZE+0x4c>
     2ac:	18eb      	adds	r3, r5, r3
     2ae:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
     2b2:	d204      	bcs.n	2be <CONFIG_BT_HCI_TX_STACK_SIZE+0x3e>
     2b4:	4598      	cmp	r8, r3
     2b6:	d902      	bls.n	2be <CONFIG_BT_HCI_TX_STACK_SIZE+0x3e>
     2b8:	f1ac 0202 	sub.w	r2, ip, #2
     2bc:	442b      	add	r3, r5
     2be:	eba3 0308 	sub.w	r3, r3, r8
     2c2:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
     2c6:	e791      	b.n	1ec <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x2c>
     2c8:	4661      	mov	r1, ip
     2ca:	e7e2      	b.n	292 <CONFIG_BT_HCI_TX_STACK_SIZE+0x12>
     2cc:	4662      	mov	r2, ip
     2ce:	e7f6      	b.n	2be <CONFIG_BT_HCI_TX_STACK_SIZE+0x3e>
     2d0:	4660      	mov	r0, ip
     2d2:	e7a2      	b.n	21a <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x5a>
     2d4:	4663      	mov	r3, ip
     2d6:	e7b6      	b.n	246 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x86>
     2d8:	4283      	cmp	r3, r0
     2da:	d905      	bls.n	2e8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x68>
     2dc:	b10e      	cbz	r6, 2e2 <CONFIG_BT_HCI_TX_STACK_SIZE+0x62>
     2de:	e9c6 7000 	strd	r7, r0, [r6]
     2e2:	2100      	movs	r1, #0
     2e4:	4608      	mov	r0, r1
     2e6:	e776      	b.n	1d6 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x16>
     2e8:	fab3 f183 	clz	r1, r3
     2ec:	b981      	cbnz	r1, 310 <CONFIG_BT_HCI_TX_STACK_SIZE+0x90>
     2ee:	4283      	cmp	r3, r0
     2f0:	d301      	bcc.n	2f6 <CONFIG_BT_HCI_TX_STACK_SIZE+0x76>
     2f2:	42ba      	cmp	r2, r7
     2f4:	d80a      	bhi.n	30c <CONFIG_BT_HCI_TX_STACK_SIZE+0x8c>
     2f6:	1abc      	subs	r4, r7, r2
     2f8:	eb60 0303 	sbc.w	r3, r0, r3
     2fc:	2001      	movs	r0, #1
     2fe:	469c      	mov	ip, r3
     300:	2e00      	cmp	r6, #0
     302:	d068      	beq.n	3d6 <CONFIG_BT_HCI_TX_STACK_SIZE+0x156>
     304:	e9c6 4c00 	strd	r4, ip, [r6]
     308:	2100      	movs	r1, #0
     30a:	e764      	b.n	1d6 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x16>
     30c:	4608      	mov	r0, r1
     30e:	e7f7      	b.n	300 <CONFIG_BT_HCI_TX_STACK_SIZE+0x80>
     310:	f1c1 0c20 	rsb	ip, r1, #32
     314:	408b      	lsls	r3, r1
     316:	fa22 f40c 	lsr.w	r4, r2, ip
     31a:	431c      	orrs	r4, r3
     31c:	fa02 f501 	lsl.w	r5, r2, r1
     320:	fa00 f301 	lsl.w	r3, r0, r1
     324:	fa27 f20c 	lsr.w	r2, r7, ip
     328:	fa20 fb0c 	lsr.w	fp, r0, ip
     32c:	ea4f 4914 	mov.w	r9, r4, lsr #16
     330:	4313      	orrs	r3, r2
     332:	fbbb f8f9 	udiv	r8, fp, r9
     336:	fa1f fe84 	uxth.w	lr, r4
     33a:	fb09 bb18 	mls	fp, r9, r8, fp
     33e:	0c1a      	lsrs	r2, r3, #16
     340:	fb08 fa0e 	mul.w	sl, r8, lr
     344:	ea42 420b 	orr.w	r2, r2, fp, lsl #16
     348:	4592      	cmp	sl, r2
     34a:	fa07 f701 	lsl.w	r7, r7, r1
     34e:	d93e      	bls.n	3ce <CONFIG_BT_HCI_TX_STACK_SIZE+0x14e>
     350:	18a2      	adds	r2, r4, r2
     352:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
     356:	d204      	bcs.n	362 <CONFIG_BT_HCI_TX_STACK_SIZE+0xe2>
     358:	4592      	cmp	sl, r2
     35a:	d902      	bls.n	362 <CONFIG_BT_HCI_TX_STACK_SIZE+0xe2>
     35c:	f1a8 0002 	sub.w	r0, r8, #2
     360:	4422      	add	r2, r4
     362:	eba2 020a 	sub.w	r2, r2, sl
     366:	b29b      	uxth	r3, r3
     368:	fbb2 f8f9 	udiv	r8, r2, r9
     36c:	fb09 2218 	mls	r2, r9, r8, r2
     370:	fb08 fe0e 	mul.w	lr, r8, lr
     374:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
     378:	4596      	cmp	lr, r2
     37a:	d92a      	bls.n	3d2 <CONFIG_BT_HCI_TX_STACK_SIZE+0x152>
     37c:	18a2      	adds	r2, r4, r2
     37e:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
     382:	d204      	bcs.n	38e <CONFIG_BT_HCI_TX_STACK_SIZE+0x10e>
     384:	4596      	cmp	lr, r2
     386:	d902      	bls.n	38e <CONFIG_BT_HCI_TX_STACK_SIZE+0x10e>
     388:	f1a8 0302 	sub.w	r3, r8, #2
     38c:	4422      	add	r2, r4
     38e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     392:	fba0 9305 	umull	r9, r3, r0, r5
     396:	eba2 020e 	sub.w	r2, r2, lr
     39a:	429a      	cmp	r2, r3
     39c:	46ce      	mov	lr, r9
     39e:	4698      	mov	r8, r3
     3a0:	d302      	bcc.n	3a8 <CONFIG_BT_HCI_TX_STACK_SIZE+0x128>
     3a2:	d106      	bne.n	3b2 <CONFIG_BT_HCI_TX_STACK_SIZE+0x132>
     3a4:	454f      	cmp	r7, r9
     3a6:	d204      	bcs.n	3b2 <CONFIG_BT_HCI_TX_STACK_SIZE+0x132>
     3a8:	ebb9 0e05 	subs.w	lr, r9, r5
     3ac:	eb63 0804 	sbc.w	r8, r3, r4
     3b0:	3801      	subs	r0, #1
     3b2:	b186      	cbz	r6, 3d6 <CONFIG_BT_HCI_TX_STACK_SIZE+0x156>
     3b4:	ebb7 030e 	subs.w	r3, r7, lr
     3b8:	eb62 0708 	sbc.w	r7, r2, r8
     3bc:	fa07 fc0c 	lsl.w	ip, r7, ip
     3c0:	40cb      	lsrs	r3, r1
     3c2:	ea4c 0303 	orr.w	r3, ip, r3
     3c6:	40cf      	lsrs	r7, r1
     3c8:	e9c6 3700 	strd	r3, r7, [r6]
     3cc:	e79c      	b.n	308 <CONFIG_BT_HCI_TX_STACK_SIZE+0x88>
     3ce:	4640      	mov	r0, r8
     3d0:	e7c7      	b.n	362 <CONFIG_BT_HCI_TX_STACK_SIZE+0xe2>
     3d2:	4643      	mov	r3, r8
     3d4:	e7db      	b.n	38e <CONFIG_BT_HCI_TX_STACK_SIZE+0x10e>
     3d6:	4631      	mov	r1, r6
     3d8:	e6fd      	b.n	1d6 <CONFIG_BT_CTLR_RX_PRIO_STACK_SIZE+0x16>
     3da:	0000      	movs	r0, r0
     3dc:	0000      	movs	r0, r0
	...

000003e0 <ticker_cb>:
}

static void ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
		      uint32_t remainder, uint16_t lazy, uint8_t force,
		      void *param)
{
     3e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     3e4:	461d      	mov	r5, r3
     3e6:	b08a      	sub	sp, #40	; 0x28

	DEBUG_RADIO_PREPARE_A(1);

	lll = &adv->lll;

	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
     3e8:	f64f 73ff 	movw	r3, #65535	; 0xffff
     3ec:	429d      	cmp	r5, r3
{
     3ee:	9c11      	ldr	r4, [sp, #68]	; 0x44
     3f0:	4680      	mov	r8, r0
     3f2:	460e      	mov	r6, r1
     3f4:	4617      	mov	r7, r2
	if (IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) ||
     3f6:	d035      	beq.n	464 <CONFIG_BT_RX_STACK_SIZE+0x64>
	return hdr->ref;
}

static inline uint8_t ull_ref_inc(struct ull_hdr *hdr)
{
	return ++hdr->ref;
     3f8:	7823      	ldrb	r3, [r4, #0]
     3fa:	3301      	adds	r3, #1
     3fc:	b2db      	uxtb	r3, r3
     3fe:	7023      	strb	r3, [r4, #0]
	    (lazy != TICKER_LAZY_MUST_EXPIRE)) {
		/* Increment prepare reference count */
		ref = ull_ref_inc(&adv->ull);
		LL_ASSERT(ref);
     400:	b963      	cbnz	r3, 41c <CONFIG_BT_RX_STACK_SIZE+0x1c>
     402:	4a43      	ldr	r2, [pc, #268]	; (510 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x9c>)
     404:	4943      	ldr	r1, [pc, #268]	; (514 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa0>)
     406:	4844      	ldr	r0, [pc, #272]	; (518 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa4>)
     408:	f640 037d 	movw	r3, #2173	; 0x87d
     40c:	f00f f85b 	bl	f4c6 <printk>
     410:	4040      	eors	r0, r0
     412:	f380 8811 	msr	BASEPRI, r0
     416:	f04f 0003 	mov.w	r0, #3
     41a:	df02      	svc	2

		/* Append timing parameters */
		p.ticks_at_expire = ticks_at_expire;
     41c:	493f      	ldr	r1, [pc, #252]	; (51c <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa8>)
		p.remainder = remainder;
		p.lazy = lazy;
		p.force = force;
     41e:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
     422:	728b      	strb	r3, [r1, #10]
	lll = &adv->lll;
     424:	f104 031c 	add.w	r3, r4, #28
		p.param = lll;
     428:	60cb      	str	r3, [r1, #12]
		mfy.param = &p;
     42a:	4b3d      	ldr	r3, [pc, #244]	; (520 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xac>)
		p.lazy = lazy;
     42c:	810d      	strh	r5, [r1, #8]

		/* Kick LLL prepare */
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
     42e:	2200      	movs	r2, #0
		p.remainder = remainder;
     430:	e9c1 8700 	strd	r8, r7, [r1]
		mfy.param = &p;
     434:	6099      	str	r1, [r3, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
     436:	2001      	movs	r0, #1
     438:	4611      	mov	r1, r2
     43a:	f003 fdbf 	bl	3fbc <mayfly_enqueue>
				     TICKER_USER_ID_LLL, 0, &mfy);
		LL_ASSERT(!ret);
     43e:	b160      	cbz	r0, 45a <CONFIG_BT_RX_STACK_SIZE+0x5a>
     440:	4a33      	ldr	r2, [pc, #204]	; (510 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x9c>)
     442:	4938      	ldr	r1, [pc, #224]	; (524 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xb0>)
     444:	4834      	ldr	r0, [pc, #208]	; (518 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa4>)
     446:	f640 038a 	movw	r3, #2186	; 0x88a
     44a:	f00f f83c 	bl	f4c6 <printk>
     44e:	4040      	eors	r0, r0
     450:	f380 8811 	msr	BASEPRI, r0
     454:	f04f 0003 	mov.w	r0, #3
     458:	df02      	svc	2

#if defined(CONFIG_BT_CTLR_ADV_EXT) && (CONFIG_BT_CTLR_ADV_AUX_SET > 0)
		if (adv->lll.aux) {
     45a:	6c23      	ldr	r3, [r4, #64]	; 0x40
     45c:	b113      	cbz	r3, 464 <CONFIG_BT_RX_STACK_SIZE+0x64>
			ull_adv_aux_offset_get(adv);
     45e:	4620      	mov	r0, r4
     460:	f007 fa94 	bl	798c <ull_adv_aux_offset_get>
	lll_rand_isr_get(&random_delay, sizeof(random_delay));
     464:	2104      	movs	r1, #4
     466:	a809      	add	r0, sp, #36	; 0x24
     468:	f011 f992 	bl	11790 <lll_rand_isr_get>
	random_delay %= ticks_delay_window;
     46c:	9b09      	ldr	r3, [sp, #36]	; 0x24
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
     46e:	9406      	str	r4, [sp, #24]
	random_delay %= ticks_delay_window;
     470:	f240 1247 	movw	r2, #327	; 0x147
     474:	fbb3 f1f2 	udiv	r1, r3, r2
     478:	fb02 3311 	mls	r3, r2, r1, r3
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
     47c:	4a2a      	ldr	r2, [pc, #168]	; (528 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xb4>)
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
     47e:	492b      	ldr	r1, [pc, #172]	; (52c <CONFIG_BT_HCI_ECC_STACK_SIZE+0xb8>)
     480:	9105      	str	r1, [sp, #20]
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
     482:	1aa2      	subs	r2, r4, r2
     484:	09d2      	lsrs	r2, r2, #7
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
     486:	2000      	movs	r0, #0
			    TICKER_ID_ADV_BASE + ull_adv_handle_get(adv),
     488:	3202      	adds	r2, #2
	random_delay += (ticks_delay_window_offset + 1);
     48a:	3301      	adds	r3, #1
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
     48c:	e9cd 0003 	strd	r0, r0, [sp, #12]
     490:	e9cd 0001 	strd	r0, r0, [sp, #4]
     494:	9000      	str	r0, [sp, #0]
     496:	b2d2      	uxtb	r2, r2
     498:	2101      	movs	r1, #1
	random_delay += (ticks_delay_window_offset + 1);
     49a:	9309      	str	r3, [sp, #36]	; 0x24
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
     49c:	f010 fbc0 	bl	10c20 <ticker_update>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
     4a0:	f030 0302 	bics.w	r3, r0, #2
     4a4:	d00c      	beq.n	4c0 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x4c>
     4a6:	4a1a      	ldr	r2, [pc, #104]	; (510 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x9c>)
     4a8:	4921      	ldr	r1, [pc, #132]	; (530 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xbc>)
     4aa:	481b      	ldr	r0, [pc, #108]	; (518 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xa4>)
     4ac:	f240 7324 	movw	r3, #1828	; 0x724
     4b0:	f00f f809 	bl	f4c6 <printk>
     4b4:	4040      	eors	r0, r0
     4b6:	f380 8811 	msr	BASEPRI, r0
     4ba:	f04f 0003 	mov.w	r0, #3
     4be:	df02      	svc	2
	{
		/* Apply random delay in range [0..ULL_ADV_RANDOM_DELAY] */
		random_delay = ticker_update_rand(adv, ULL_ADV_RANDOM_DELAY, 0, 0);

#if defined(CONFIG_BT_CTLR_ADV_EXT)
		adv->event_counter += (lazy + 1);
     4c0:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70

		if (adv->ticks_remain_duration) {
     4c4:	6f67      	ldr	r7, [r4, #116]	; 0x74
		adv->event_counter += (lazy + 1);
     4c6:	442b      	add	r3, r5
     4c8:	3301      	adds	r3, #1
     4ca:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
		if (adv->ticks_remain_duration) {
     4ce:	b1b7      	cbz	r7, 4fe <CONFIG_BT_HCI_ECC_STACK_SIZE+0x8a>
			uint32_t ticks_interval =
				HAL_TICKER_US_TO_TICKS((uint64_t)adv->interval *
     4d0:	6e61      	ldr	r1, [r4, #100]	; 0x64
     4d2:	4818      	ldr	r0, [pc, #96]	; (534 <CONFIG_BT_HCI_ECC_STACK_SIZE+0xc0>)
     4d4:	f04f 0e91 	mov.w	lr, #145	; 0x91
     4d8:	fba1 0c00 	umull	r0, ip, r1, r0
     4dc:	a30a      	add	r3, pc, #40	; (adr r3, 508 <CONFIG_BT_HCI_ECC_STACK_SIZE+0x94>)
     4de:	e9d3 2300 	ldrd	r2, r3, [r3]
     4e2:	fb0e c101 	mla	r1, lr, r1, ip
     4e6:	f7ff fe0b 	bl	100 <__aeabi_uldivmod>
			uint32_t ticks_interval =
     4ea:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
						       ADV_INT_UNIT_US);
			uint32_t ticks_elapsed = ticks_interval * (lazy + 1) +
     4ee:	fb05 0500 	mla	r5, r5, r0, r0
     4f2:	4435      	add	r5, r6
						 ticks_drift;

			if (adv->ticks_remain_duration > ticks_elapsed) {
     4f4:	42af      	cmp	r7, r5
				adv->ticks_remain_duration -= ticks_elapsed;
     4f6:	bf86      	itte	hi
     4f8:	1b7d      	subhi	r5, r7, r5
     4fa:	6765      	strhi	r5, [r4, #116]	; 0x74
			} else {
				adv->ticks_remain_duration = ticks_interval;
     4fc:	6760      	strls	r0, [r4, #116]	; 0x74
		}
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	}

	DEBUG_RADIO_PREPARE_A(1);
}
     4fe:	b00a      	add	sp, #40	; 0x28
     500:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     504:	f3af 8000 	nop.w
     508:	1afd498d 	.word	0x1afd498d
     50c:	00000007 	.word	0x00000007
     510:	00013714 	.word	0x00013714
     514:	000137cc 	.word	0x000137cc
     518:	000133b6 	.word	0x000133b6
     51c:	20001ee8 	.word	0x20001ee8
     520:	200003b8 	.word	0x200003b8
     524:	0001366f 	.word	0x0001366f
     528:	20001e5c 	.word	0x20001e5c
     52c:	00006e31 	.word	0x00006e31
     530:	000137b3 	.word	0x000137b3
     534:	84e72a00 	.word	0x84e72a00

00000538 <ull_adv_done>:
{
     538:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	adv = CONTAINER_OF(done->param, struct ll_adv_set, ull);
     53a:	69c4      	ldr	r4, [r0, #28]
	if (adv->max_events && (adv->event_counter >= adv->max_events)) {
     53c:	f8b4 3072 	ldrh.w	r3, [r4, #114]	; 0x72
     540:	2b00      	cmp	r3, #0
     542:	d045      	beq.n	5d0 <__data_size+0x4a>
     544:	f8b4 2070 	ldrh.w	r2, [r4, #112]	; 0x70
     548:	429a      	cmp	r2, r3
     54a:	d341      	bcc.n	5d0 <__data_size+0x4a>
		adv->max_events = 0;
     54c:	2300      	movs	r3, #0
		rx_hdr = (void *)lll->node_rx_adv_term;
     54e:	6be5      	ldr	r5, [r4, #60]	; 0x3c
		adv->max_events = 0;
     550:	f8a4 3072 	strh.w	r3, [r4, #114]	; 0x72
		rx_hdr->rx_ftr.param_adv_term.status = BT_HCI_ERR_LIMIT_REACHED;
     554:	2343      	movs	r3, #67	; 0x43
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
     556:	4e30      	ldr	r6, [pc, #192]	; (618 <CONFIG_BT_COMPANY_ID+0x27>)
		rx_hdr->rx_ftr.param_adv_term.status = BT_HCI_ERR_ADV_TIMEOUT;
     558:	722b      	strb	r3, [r5, #8]
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
     55a:	1ba6      	subs	r6, r4, r6
     55c:	09f7      	lsrs	r7, r6, #7
	handle = ull_adv_handle_get(adv);
     55e:	f3c6 16c7 	ubfx	r6, r6, #7, #8
	LL_ASSERT(handle < BT_CTLR_ADV_SET);
     562:	b166      	cbz	r6, 57e <ull_adv_done+0x46>
     564:	4a2d      	ldr	r2, [pc, #180]	; (61c <CONFIG_BT_COMPANY_ID+0x2b>)
     566:	492e      	ldr	r1, [pc, #184]	; (620 <CONFIG_BT_COMPANY_ID+0x2f>)
     568:	482e      	ldr	r0, [pc, #184]	; (624 <CONFIG_BT_COMPANY_ID+0x33>)
     56a:	f240 7387 	movw	r3, #1927	; 0x787
     56e:	f00e ffaa 	bl	f4c6 <printk>
     572:	4040      	eors	r0, r0
     574:	f380 8811 	msr	BASEPRI, r0
     578:	f04f 0003 	mov.w	r0, #3
     57c:	df02      	svc	2
	rx_hdr->type = NODE_RX_TYPE_EXT_ADV_TERMINATE;
     57e:	2312      	movs	r3, #18
     580:	712b      	strb	r3, [r5, #4]
	lll_aux = lll->aux;
     582:	6c20      	ldr	r0, [r4, #64]	; 0x40
	rx_hdr->handle = handle;
     584:	80ee      	strh	r6, [r5, #6]
	rx_hdr->rx_ftr.param_adv_term.conn_handle = 0xffff;
     586:	f64f 73ff 	movw	r3, #65535	; 0xffff
     58a:	816b      	strh	r3, [r5, #10]
	rx_hdr->rx_ftr.param_adv_term.num_events = adv->event_counter;
     58c:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
     590:	726b      	strb	r3, [r5, #9]
	if (lll_aux) {
     592:	2800      	cmp	r0, #0
     594:	d034      	beq.n	600 <CONFIG_BT_COMPANY_ID+0xf>
		aux_handle = ull_adv_aux_handle_get(aux);
     596:	6800      	ldr	r0, [r0, #0]
     598:	f007 f8ca 	bl	7730 <ull_adv_aux_handle_get>
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
     59c:	4b22      	ldr	r3, [pc, #136]	; (628 <CONFIG_BT_COMPANY_ID+0x37>)
     59e:	9400      	str	r4, [sp, #0]
				  (TICKER_ID_ADV_AUX_BASE + aux_handle),
     5a0:	1cc2      	adds	r2, r0, #3
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
     5a2:	b2d2      	uxtb	r2, r2
     5a4:	2101      	movs	r1, #1
     5a6:	2000      	movs	r0, #0
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
     5a8:	f004 fafe 	bl	4ba8 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
     5ac:	f030 0302 	bics.w	r3, r0, #2
     5b0:	d00c      	beq.n	5cc <__data_size+0x46>
     5b2:	4a1a      	ldr	r2, [pc, #104]	; (61c <CONFIG_BT_COMPANY_ID+0x2b>)
     5b4:	491d      	ldr	r1, [pc, #116]	; (62c <CONFIG_BT_COMPANY_ID+0x3b>)
     5b6:	481b      	ldr	r0, [pc, #108]	; (624 <CONFIG_BT_COMPANY_ID+0x33>)
     5b8:	f44f 63f4 	mov.w	r3, #1952	; 0x7a0
     5bc:	f00e ff83 	bl	f4c6 <printk>
     5c0:	4040      	eors	r0, r0
     5c2:	f380 8811 	msr	BASEPRI, r0
     5c6:	f04f 0003 	mov.w	r0, #3
     5ca:	df02      	svc	2
}
     5cc:	b003      	add	sp, #12
     5ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (adv->ticks_remain_duration &&
     5d0:	6f66      	ldr	r6, [r4, #116]	; 0x74
     5d2:	2e00      	cmp	r6, #0
     5d4:	d0fa      	beq.n	5cc <__data_size+0x46>
		    HAL_TICKER_US_TO_TICKS((uint64_t)adv->interval *
     5d6:	6e65      	ldr	r5, [r4, #100]	; 0x64
     5d8:	4815      	ldr	r0, [pc, #84]	; (630 <CONFIG_BT_COMPANY_ID+0x3f>)
     5da:	2791      	movs	r7, #145	; 0x91
     5dc:	fba5 0100 	umull	r0, r1, r5, r0
     5e0:	a30b      	add	r3, pc, #44	; (adr r3, 610 <CONFIG_BT_COMPANY_ID+0x1f>)
     5e2:	e9d3 2300 	ldrd	r2, r3, [r3]
     5e6:	fb07 1105 	mla	r1, r7, r5, r1
     5ea:	f7ff fd89 	bl	100 <__aeabi_uldivmod>
     5ee:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} else if (adv->ticks_remain_duration &&
     5f2:	4286      	cmp	r6, r0
     5f4:	d8ea      	bhi.n	5cc <__data_size+0x46>
		adv->ticks_remain_duration = 0;
     5f6:	2300      	movs	r3, #0
     5f8:	6763      	str	r3, [r4, #116]	; 0x74
		rx_hdr = (void *)lll->node_rx_adv_term;
     5fa:	6be5      	ldr	r5, [r4, #60]	; 0x3c
		rx_hdr->rx_ftr.param_adv_term.status = BT_HCI_ERR_ADV_TIMEOUT;
     5fc:	233c      	movs	r3, #60	; 0x3c
     5fe:	e7aa      	b.n	556 <ull_adv_done+0x1e>
				  (TICKER_ID_ADV_BASE + handle),
     600:	1cba      	adds	r2, r7, #2
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
     602:	4b0c      	ldr	r3, [pc, #48]	; (634 <CONFIG_BT_COMPANY_ID+0x43>)
     604:	9400      	str	r4, [sp, #0]
     606:	b2d2      	uxtb	r2, r2
     608:	2101      	movs	r1, #1
     60a:	e7cd      	b.n	5a8 <__data_size+0x22>
     60c:	f3af 8000 	nop.w
     610:	1afd498d 	.word	0x1afd498d
     614:	00000007 	.word	0x00000007
     618:	20001e5c 	.word	0x20001e5c
     61c:	00013714 	.word	0x00013714
     620:	0001381a 	.word	0x0001381a
     624:	000133b6 	.word	0x000133b6
     628:	00006dd1 	.word	0x00006dd1
     62c:	000137b3 	.word	0x000137b3
     630:	84e72a00 	.word	0x84e72a00
     634:	00006d91 	.word	0x00006d91

00000638 <ll_adv_enable>:
{
     638:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     63c:	4605      	mov	r5, r0
     63e:	b08f      	sub	sp, #60	; 0x3c
     640:	4616      	mov	r6, r2
     642:	461f      	mov	r7, r3
	if (!enable) {
     644:	b921      	cbnz	r1, 650 <ll_adv_enable+0x18>
}
     646:	b00f      	add	sp, #60	; 0x3c
     648:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return disable(handle);
     64c:	f006 bf60 	b.w	7510 <disable>
	if (!adv || adv->is_enabled) {
     650:	4c93      	ldr	r4, [pc, #588]	; (8a0 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xa0>)
     652:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
     656:	f002 0201 	and.w	r2, r2, #1
     65a:	4315      	orrs	r5, r2
     65c:	d036      	beq.n	6cc <ll_adv_enable+0x94>
				adv = ull_adv_is_enabled_get(handle);
     65e:	f006 ff49 	bl	74f4 <ull_adv_is_enabled_get>
				if (!adv) {
     662:	4604      	mov	r4, r0
     664:	b920      	cbnz	r0, 670 <ll_adv_enable+0x38>
					return BT_HCI_ERR_CMD_DISALLOWED;
     666:	250c      	movs	r5, #12
}
     668:	4628      	mov	r0, r5
     66a:	b00f      	add	sp, #60	; 0x3c
     66c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     670:	f890 2031 	ldrb.w	r2, [r0, #49]	; 0x31
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     674:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     678:	eb00 0282 	add.w	r2, r0, r2, lsl #2
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     67c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
				hci_err = adv_scan_pdu_addr_update(adv,
     680:	6b52      	ldr	r2, [r2, #52]	; 0x34
     682:	6a99      	ldr	r1, [r3, #40]	; 0x28
     684:	f010 fdb6 	bl	111f4 <adv_scan_pdu_addr_update>
				if (hci_err) {
     688:	4605      	mov	r5, r0
     68a:	2800      	cmp	r0, #0
     68c:	d1ec      	bne.n	668 <ll_adv_enable+0x30>
				if (!adv->lll.node_rx_adv_term) {
     68e:	6be5      	ldr	r5, [r4, #60]	; 0x3c
     690:	2d00      	cmp	r5, #0
     692:	d0e8      	beq.n	666 <ll_adv_enable+0x2e>
				if (*type == NODE_RX_TYPE_NONE) {
     694:	792b      	ldrb	r3, [r5, #4]
     696:	f003 02ff 	and.w	r2, r3, #255	; 0xff
     69a:	b993      	cbnz	r3, 6c2 <ll_adv_enable+0x8a>
					uint8_t max_ext_adv_evts)
{
	adv->event_counter = 0;
	adv->max_events = max_ext_adv_evts;
	adv->ticks_remain_duration =
		HAL_TICKER_US_TO_TICKS((uint64_t)duration * 10 * USEC_PER_MSEC);
     69c:	4881      	ldr	r0, [pc, #516]	; (8a4 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xa4>)
	adv->max_events = max_ext_adv_evts;
     69e:	f8a4 7072 	strh.w	r7, [r4, #114]	; 0x72
		HAL_TICKER_US_TO_TICKS((uint64_t)duration * 10 * USEC_PER_MSEC);
     6a2:	fba6 0100 	umull	r0, r1, r6, r0
     6a6:	f640 1718 	movw	r7, #2328	; 0x918
	adv->event_counter = 0;
     6aa:	f8a4 2070 	strh.w	r2, [r4, #112]	; 0x70
		HAL_TICKER_US_TO_TICKS((uint64_t)duration * 10 * USEC_PER_MSEC);
     6ae:	fb07 1106 	mla	r1, r7, r6, r1
     6b2:	a379      	add	r3, pc, #484	; (adr r3, 898 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x98>)
     6b4:	e9d3 2300 	ldrd	r2, r3, [r3]
     6b8:	f7ff fd22 	bl	100 <__aeabi_uldivmod>
     6bc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	adv->ticks_remain_duration =
     6c0:	6760      	str	r0, [r4, #116]	; 0x74
				if (*type != NODE_RX_TYPE_NONE) {
     6c2:	792b      	ldrb	r3, [r5, #4]
     6c4:	2b00      	cmp	r3, #0
     6c6:	d1ce      	bne.n	666 <ll_adv_enable+0x2e>
			return 0;
     6c8:	2500      	movs	r5, #0
     6ca:	e7cd      	b.n	668 <ll_adv_enable+0x30>
	ull_filter_adv_update(lll->filter_policy);
     6cc:	f894 0020 	ldrb.w	r0, [r4, #32]
	lll->rl_idx = FILTER_IDX_NONE;
     6d0:	23ff      	movs	r3, #255	; 0xff
     6d2:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	ull_filter_adv_update(lll->filter_policy);
     6d6:	0980      	lsrs	r0, r0, #6
     6d8:	f008 f856 	bl	8788 <ull_filter_adv_update>
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
     6dc:	f894 0078 	ldrb.w	r0, [r4, #120]	; 0x78
     6e0:	0743      	lsls	r3, r0, #29
     6e2:	d50d      	bpl.n	700 <ll_adv_enable+0xc8>
		lll->rl_idx = ull_filter_rl_find(adv->peer_addr_type,
     6e4:	462a      	mov	r2, r5
     6e6:	f104 0179 	add.w	r1, r4, #121	; 0x79
     6ea:	f3c0 00c0 	ubfx	r0, r0, #3, #1
     6ee:	f008 f9c1 	bl	8a74 <ull_filter_rl_find>
		if (lll->rl_idx != FILTER_IDX_NONE) {
     6f2:	28ff      	cmp	r0, #255	; 0xff
		lll->rl_idx = ull_filter_rl_find(adv->peer_addr_type,
     6f4:	f884 0022 	strb.w	r0, [r4, #34]	; 0x22
		if (lll->rl_idx != FILTER_IDX_NONE) {
     6f8:	d002      	beq.n	700 <ll_adv_enable+0xc8>
			ull_filter_rpa_update(false);
     6fa:	4628      	mov	r0, r5
     6fc:	f008 f888 	bl	8810 <ull_filter_rpa_update>
     700:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
	hci_err = adv_scan_pdu_addr_update(adv, pdu_adv, pdu_scan);
     704:	4866      	ldr	r0, [pc, #408]	; (8a0 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xa0>)
     706:	eb04 0383 	add.w	r3, r4, r3, lsl #2
     70a:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     70e:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
     712:	eb04 0383 	add.w	r3, r4, r3, lsl #2
     716:	4641      	mov	r1, r8
     718:	f8d3 9034 	ldr.w	r9, [r3, #52]	; 0x34
     71c:	464a      	mov	r2, r9
     71e:	f010 fd69 	bl	111f4 <adv_scan_pdu_addr_update>
	if (hci_err) {
     722:	4605      	mov	r5, r0
     724:	2800      	cmp	r0, #0
     726:	d19f      	bne.n	668 <ll_adv_enable+0x30>
		link_adv_term = ll_rx_link_alloc();
     728:	f005 fe80 	bl	642c <ll_rx_link_alloc>
		if (!link_adv_term) {
     72c:	4682      	mov	sl, r0
     72e:	b128      	cbz	r0, 73c <ll_adv_enable+0x104>
		node_rx_adv_term = ll_rx_alloc();
     730:	f005 fe88 	bl	6444 <ll_rx_alloc>
		if (!node_rx_adv_term) {
     734:	b920      	cbnz	r0, 740 <ll_adv_enable+0x108>
			ll_rx_link_release(link_adv_term);
     736:	4650      	mov	r0, sl
     738:	f005 fe7e 	bl	6438 <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
     73c:	2507      	movs	r5, #7
     73e:	e793      	b.n	668 <ll_adv_enable+0x30>
		node_rx_adv_term->hdr.type = NODE_RX_TYPE_NONE;
     740:	7105      	strb	r5, [r0, #4]
		node_rx_adv_term->hdr.link = (void *)link_adv_term;
     742:	f8c0 a000 	str.w	sl, [r0]
		adv->lll.node_rx_adv_term = (void *)node_rx_adv_term;
     746:	63e0      	str	r0, [r4, #60]	; 0x3c
		HAL_TICKER_US_TO_TICKS((uint64_t)duration * 10 * USEC_PER_MSEC);
     748:	4856      	ldr	r0, [pc, #344]	; (8a4 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xa4>)
	adv->max_events = max_ext_adv_evts;
     74a:	f8a4 7072 	strh.w	r7, [r4, #114]	; 0x72
		HAL_TICKER_US_TO_TICKS((uint64_t)duration * 10 * USEC_PER_MSEC);
     74e:	fba6 0100 	umull	r0, r1, r6, r0
     752:	f640 1718 	movw	r7, #2328	; 0x918
     756:	a350      	add	r3, pc, #320	; (adr r3, 898 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x98>)
     758:	e9d3 2300 	ldrd	r2, r3, [r3]
     75c:	fb07 1106 	mla	r1, r7, r6, r1
	adv->event_counter = 0;
     760:	f8a4 5070 	strh.w	r5, [r4, #112]	; 0x70
		HAL_TICKER_US_TO_TICKS((uint64_t)duration * 10 * USEC_PER_MSEC);
     764:	f7ff fccc 	bl	100 <__aeabi_uldivmod>
	uint8_t ch_map = lll->chan_map;
     768:	f894 3020 	ldrb.w	r3, [r4, #32]
	const uint8_t phy = lll->phy_p;
     76c:	f894 6021 	ldrb.w	r6, [r4, #33]	; 0x21
		HAL_TICKER_US_TO_TICKS((uint64_t)duration * 10 * USEC_PER_MSEC);
     770:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	adv->ticks_remain_duration =
     774:	6760      	str	r0, [r4, #116]	; 0x74
	uint8_t ch_map = lll->chan_map;
     776:	f3c3 0302 	ubfx	r3, r3, #0, #3
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     77a:	2101      	movs	r1, #1
     77c:	f10d 0033 	add.w	r0, sp, #51	; 0x33
	uint8_t ch_map = lll->chan_map;
     780:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
	const uint8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
     784:	f00f ffba 	bl	106fc <util_ones_count_get>
	const uint8_t phy = lll->phy_p;
     788:	f006 0607 	and.w	r6, r6, #7
	if (adv_chn_cnt == 0) {
     78c:	4602      	mov	r2, r0
     78e:	2800      	cmp	r0, #0
     790:	f43f af69 	beq.w	666 <ll_adv_enable+0x2e>
	uint16_t time_us = adv_time_get(pdu_adv, pdu_scan, adv_chn_cnt, phy,
     794:	4633      	mov	r3, r6
     796:	4649      	mov	r1, r9
     798:	4640      	mov	r0, r8
     79a:	f010 fc7c 	bl	11096 <adv_time_get.constprop.0>
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     79e:	4942      	ldr	r1, [pc, #264]	; (8a8 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xa8>)
	return hdr->ref--;
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->ref = 0U;
     7a0:	7025      	strb	r5, [r4, #0]
	adv->ull.ticks_prepare_to_start =
     7a2:	2331      	movs	r3, #49	; 0x31
	adv->ull.ticks_preempt_to_start =
     7a4:	e9c4 3502 	strd	r3, r5, [r4, #8]
	hdr->disabled_cb = hdr->disabled_param = NULL;
     7a8:	e9c4 5505 	strd	r5, r5, [r4, #20]
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     7ac:	a33a      	add	r3, pc, #232	; (adr r3, 898 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x98>)
     7ae:	e9d3 2300 	ldrd	r2, r3, [r3]
	adv->ull.ticks_active_to_start = 0;
     7b2:	6065      	str	r5, [r4, #4]
	adv->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     7b4:	fba0 0101 	umull	r0, r1, r0, r1
     7b8:	f7ff fca2 	bl	100 <__aeabi_uldivmod>
     7bc:	6120      	str	r0, [r4, #16]
	uint16_t interval = adv->interval;
     7be:	f8b4 9064 	ldrh.w	r9, [r4, #100]	; 0x64
	ticks_anchor = ticker_ticks_now_get();
     7c2:	f010 fa45 	bl	10c50 <ticker_ticks_now_get>
		if (lll->aux) {
     7c6:	6c26      	ldr	r6, [r4, #64]	; 0x40
		const uint32_t ticks_slot = adv->ull.ticks_slot +
     7c8:	f8d4 8010 	ldr.w	r8, [r4, #16]
	ticks_anchor = ticker_ticks_now_get();
     7cc:	4607      	mov	r7, r0
		if (lll->aux) {
     7ce:	2e00      	cmp	r6, #0
     7d0:	d05e      	beq.n	890 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x90>
			aux = HDR_LLL2ULL(lll_aux);
     7d2:	6836      	ldr	r6, [r6, #0]
			ticks_anchor_aux =
     7d4:	f108 0a02 	add.w	sl, r8, #2
     7d8:	4482      	add	sl, r0
			ticks_slot_overhead_aux = ull_adv_aux_evt_init(aux);
     7da:	4630      	mov	r0, r6
     7dc:	f000 f8c8 	bl	970 <ull_adv_aux_evt_init>
			aux->interval = adv->interval +
     7e0:	6e63      	ldr	r3, [r4, #100]	; 0x64
     7e2:	330f      	adds	r3, #15
			ticks_slot_overhead_aux = ull_adv_aux_evt_init(aux);
     7e4:	4602      	mov	r2, r0
			aux->interval = adv->interval +
     7e6:	8733      	strh	r3, [r6, #56]	; 0x38
			ret = ull_adv_aux_start(aux, ticks_anchor_aux,
     7e8:	4651      	mov	r1, sl
     7ea:	4630      	mov	r0, r6
     7ec:	f000 f8e8 	bl	9c0 <ull_adv_aux_start>
			if (ret) {
     7f0:	2800      	cmp	r0, #0
     7f2:	f47f af38 	bne.w	666 <ll_adv_enable+0x2e>
			aux_is_started = 1U;
     7f6:	2301      	movs	r3, #1
     7f8:	930b      	str	r3, [sp, #44]	; 0x2c
		ll_adv_ticker_ext[handle].ticks_slot_window =
     7fa:	4b2c      	ldr	r3, [pc, #176]	; (8ac <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xac>)
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     7fc:	482c      	ldr	r0, [pc, #176]	; (8b0 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xb0>)
			ULL_ADV_RANDOM_DELAY + ticks_slot;
     7fe:	f208 1247 	addw	r2, r8, #327	; 0x147
		ll_adv_ticker_ext[handle].ticks_slot_window =
     802:	601a      	str	r2, [r3, #0]
		ret = ticker_start_ext(
     804:	9309      	str	r3, [sp, #36]	; 0x24
     806:	4b2b      	ldr	r3, [pc, #172]	; (8b4 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xb4>)
     808:	e9cd 4306 	strd	r4, r3, [sp, #24]
     80c:	4b2a      	ldr	r3, [pc, #168]	; (8b8 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0xb8>)
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     80e:	f04f 0c91 	mov.w	ip, #145	; 0x91
		ret = ticker_start_ext(
     812:	e9cd 8304 	strd	r8, r3, [sp, #16]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     816:	fba9 0100 	umull	r0, r1, r9, r0
		ret = ticker_start_ext(
     81a:	f04f 0800 	mov.w	r8, #0
     81e:	f64f 73ff 	movw	r3, #65535	; 0xffff
     822:	e9cd 8302 	strd	r8, r3, [sp, #8]
		ret_cb = TICKER_STATUS_BUSY;
     826:	f04f 0b02 	mov.w	fp, #2
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     82a:	a31b      	add	r3, pc, #108	; (adr r3, 898 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x98>)
     82c:	e9d3 2300 	ldrd	r2, r3, [r3]
		ret = ticker_start_ext(
     830:	f10d 0a34 	add.w	sl, sp, #52	; 0x34
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     834:	fb0c 1109 	mla	r1, ip, r9, r1
		ret_cb = TICKER_STATUS_BUSY;
     838:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
		ret = ticker_start_ext(
     83c:	f8cd a020 	str.w	sl, [sp, #32]
				   HAL_TICKER_US_TO_TICKS((uint64_t)interval *
     840:	f7ff fc5e 	bl	100 <__aeabi_uldivmod>
		ret = ticker_start_ext(
     844:	2103      	movs	r1, #3
     846:	e9cd 8000 	strd	r8, r0, [sp]
     84a:	463b      	mov	r3, r7
     84c:	465a      	mov	r2, fp
     84e:	4640      	mov	r0, r8
     850:	f004 f8d4 	bl	49fc <ticker_start_ext>
	ret = ull_ticker_status_take(ret, &ret_cb);
     854:	4651      	mov	r1, sl
     856:	f005 fe79 	bl	654c <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     85a:	2800      	cmp	r0, #0
     85c:	f47f af03 	bne.w	666 <ll_adv_enable+0x2e>
	if (aux_is_started) {
     860:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
     862:	b12b      	cbz	r3, 870 <CONFIG_BT_BACKGROUND_SCAN_INTERVAL+0x70>
		aux->is_started = aux_is_started;
     864:	f896 304a 	ldrb.w	r3, [r6, #74]	; 0x4a
     868:	f043 0301 	orr.w	r3, r3, #1
     86c:	f886 304a 	strb.w	r3, [r6, #74]	; 0x4a
	adv->is_enabled = 1;
     870:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
     874:	f043 0301 	orr.w	r3, r3, #1
     878:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
     87c:	2000      	movs	r0, #0
     87e:	f007 fb2d 	bl	7edc <ull_scan_is_enabled_get>
     882:	2800      	cmp	r0, #0
     884:	f47f af20 	bne.w	6c8 <ll_adv_enable+0x90>
		ull_filter_adv_scan_state_cb(BIT(0));
     888:	2001      	movs	r0, #1
     88a:	f007 ff5d 	bl	8748 <ull_filter_adv_scan_state_cb>
     88e:	e6eb      	b.n	668 <ll_adv_enable+0x30>
	uint8_t aux_is_started = 0U;
     890:	960b      	str	r6, [sp, #44]	; 0x2c
     892:	e7b2      	b.n	7fa <ll_adv_enable+0x1c2>
     894:	f3af 8000 	nop.w
     898:	1afd498d 	.word	0x1afd498d
     89c:	00000007 	.word	0x00000007
     8a0:	20001e5c 	.word	0x20001e5c
     8a4:	4e72a000 	.word	0x4e72a000
     8a8:	3b9aca00 	.word	0x3b9aca00
     8ac:	20001edc 	.word	0x20001edc
     8b0:	84e72a00 	.word	0x84e72a00
     8b4:	00006209 	.word	0x00006209
     8b8:	000003e1 	.word	0x000003e1
     8bc:	00000000 	.word	0x00000000

000008c0 <ull_adv_time_update>:
{
     8c0:	b5f0      	push	{r4, r5, r6, r7, lr}
	chan_map = lll->chan_map;
     8c2:	f890 3020 	ldrb.w	r3, [r0, #32]
	phy = lll->phy_p;
     8c6:	f890 7021 	ldrb.w	r7, [r0, #33]	; 0x21
{
     8ca:	b08b      	sub	sp, #44	; 0x2c
     8cc:	460d      	mov	r5, r1
	chan_map = lll->chan_map;
     8ce:	f3c3 0302 	ubfx	r3, r3, #0, #3
{
     8d2:	4604      	mov	r4, r0
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
     8d4:	2101      	movs	r1, #1
     8d6:	f10d 0023 	add.w	r0, sp, #35	; 0x23
{
     8da:	4616      	mov	r6, r2
	chan_map = lll->chan_map;
     8dc:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
     8e0:	f00f ff0c 	bl	106fc <util_ones_count_get>
	phy = lll->phy_p;
     8e4:	f007 0707 	and.w	r7, r7, #7
	chan_cnt = util_ones_count_get(&chan_map, sizeof(chan_map));
     8e8:	4602      	mov	r2, r0
	time_us = adv_time_get(pdu, pdu_scan, chan_cnt, phy, phy_flags);
     8ea:	463b      	mov	r3, r7
     8ec:	4631      	mov	r1, r6
     8ee:	4628      	mov	r0, r5
     8f0:	f010 fbd1 	bl	11096 <adv_time_get.constprop.0>
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
     8f4:	491a      	ldr	r1, [pc, #104]	; (960 <ull_adv_time_update+0xa0>)
     8f6:	a318      	add	r3, pc, #96	; (adr r3, 958 <ull_adv_time_update+0x98>)
     8f8:	e9d3 2300 	ldrd	r2, r3, [r3]
     8fc:	fba0 0101 	umull	r0, r1, r0, r1
     900:	f7ff fbfe 	bl	100 <__aeabi_uldivmod>
	if (adv->ull.ticks_slot > time_ticks) {
     904:	6921      	ldr	r1, [r4, #16]
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
     906:	4605      	mov	r5, r0
	if (adv->ull.ticks_slot > time_ticks) {
     908:	428d      	cmp	r5, r1
     90a:	d21d      	bcs.n	948 <ull_adv_time_update+0x88>
		ticks_minus = adv->ull.ticks_slot - time_ticks;
     90c:	1b48      	subs	r0, r1, r5
		ticks_plus = 0U;
     90e:	2100      	movs	r1, #0
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
     910:	4a14      	ldr	r2, [pc, #80]	; (964 <ull_adv_time_update+0xa4>)
     912:	1aa2      	subs	r2, r4, r2
	ret_cb = TICKER_STATUS_BUSY;
     914:	2302      	movs	r3, #2
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
     916:	09d2      	lsrs	r2, r2, #7
	ret_cb = TICKER_STATUS_BUSY;
     918:	9309      	str	r3, [sp, #36]	; 0x24
			    (TICKER_ID_ADV_BASE +
     91a:	441a      	add	r2, r3
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
     91c:	4b12      	ldr	r3, [pc, #72]	; (968 <ull_adv_time_update+0xa8>)
     91e:	9305      	str	r3, [sp, #20]
     920:	ae09      	add	r6, sp, #36	; 0x24
     922:	2300      	movs	r3, #0
     924:	e9cd 1001 	strd	r1, r0, [sp, #4]
     928:	e9cd 3303 	strd	r3, r3, [sp, #12]
     92c:	2103      	movs	r1, #3
     92e:	9606      	str	r6, [sp, #24]
     930:	9300      	str	r3, [sp, #0]
     932:	b2d2      	uxtb	r2, r2
     934:	4618      	mov	r0, r3
     936:	f010 f973 	bl	10c20 <ticker_update>
	ret = ull_ticker_status_take(ret, &ret_cb);
     93a:	4631      	mov	r1, r6
     93c:	f005 fe06 	bl	654c <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     940:	b940      	cbnz	r0, 954 <ull_adv_time_update+0x94>
	adv->ull.ticks_slot = time_ticks;
     942:	6125      	str	r5, [r4, #16]
}
     944:	b00b      	add	sp, #44	; 0x2c
     946:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else if (adv->ull.ticks_slot < time_ticks) {
     948:	d902      	bls.n	950 <ull_adv_time_update+0x90>
		ticks_plus = time_ticks - adv->ull.ticks_slot;
     94a:	1a69      	subs	r1, r5, r1
		ticks_minus = 0U;
     94c:	2000      	movs	r0, #0
     94e:	e7df      	b.n	910 <ull_adv_time_update+0x50>
		return BT_HCI_ERR_SUCCESS;
     950:	2000      	movs	r0, #0
     952:	e7f7      	b.n	944 <ull_adv_time_update+0x84>
		return BT_HCI_ERR_CMD_DISALLOWED;
     954:	200c      	movs	r0, #12
     956:	e7f5      	b.n	944 <ull_adv_time_update+0x84>
     958:	1afd498d 	.word	0x1afd498d
     95c:	00000007 	.word	0x00000007
     960:	3b9aca00 	.word	0x3b9aca00
     964:	20001e5c 	.word	0x20001e5c
     968:	00006209 	.word	0x00006209
     96c:	00000000 	.word	0x00000000

00000970 <ull_adv_aux_evt_init>:
{
	return ull_adv_aux_handle_get((void *)lll->hdr.parent);
}

uint32_t ull_adv_aux_evt_init(struct ll_adv_aux_set *aux)
{
     970:	b538      	push	{r3, r4, r5, lr}
	struct pdu_adv *pdu;
	struct lll_adv *lll;
	uint32_t time_us;

	lll_aux = &aux->lll;
	lll = lll_aux->adv;
     972:	6a03      	ldr	r3, [r0, #32]
	lll_adv_pdu_enqueue(&lll->data, idx);
}

static inline struct pdu_adv *lll_adv_aux_data_peek(struct lll_adv_aux *lll)
{
	return (void *)lll->data.pdu[lll->data.last];
     974:	f890 102d 	ldrb.w	r1, [r0, #45]	; 0x2d
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     978:	7d5a      	ldrb	r2, [r3, #21]
	return (void *)lll->data.pdu[lll->data.last];
     97a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     97e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
	pdu = lll_adv_aux_data_peek(lll_aux);
	pdu_scan = lll_adv_scan_rsp_peek(lll);

	/* Calculate the PDU Tx Time and hence the radio event length */
	time_us = aux_time_get(aux, pdu, pdu_scan);
     982:	6b09      	ldr	r1, [r1, #48]	; 0x30
     984:	699a      	ldr	r2, [r3, #24]
{
     986:	4604      	mov	r4, r0
	time_us = aux_time_get(aux, pdu, pdu_scan);
     988:	f010 fd1e 	bl	113c8 <aux_time_get>
	aux->ull.ticks_active_to_start = 0;
	aux->ull.ticks_prepare_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	aux->ull.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	aux->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     98c:	490a      	ldr	r1, [pc, #40]	; (9b8 <ull_adv_aux_evt_init+0x48>)
	aux->ull.ticks_prepare_to_start =
     98e:	2500      	movs	r5, #0
     990:	2331      	movs	r3, #49	; 0x31
     992:	e9c4 5301 	strd	r5, r3, [r4, #4]
	aux->ull.ticks_preempt_to_start =
     996:	60e5      	str	r5, [r4, #12]
	aux->ull.ticks_slot = HAL_TICKER_US_TO_TICKS(time_us);
     998:	a305      	add	r3, pc, #20	; (adr r3, 9b0 <ull_adv_aux_evt_init+0x40>)
     99a:	e9d3 2300 	ldrd	r2, r3, [r3]
     99e:	fba0 0101 	umull	r0, r1, r0, r1
     9a2:	f7ff fbad 	bl	100 <__aeabi_uldivmod>
     9a6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
     9aa:	6120      	str	r0, [r4, #16]
	} else {
		ticks_slot_overhead = 0;
	}

	return ticks_slot_overhead;
}
     9ac:	4628      	mov	r0, r5
     9ae:	bd38      	pop	{r3, r4, r5, pc}
     9b0:	1afd498d 	.word	0x1afd498d
     9b4:	00000007 	.word	0x00000007
     9b8:	3b9aca00 	.word	0x3b9aca00
     9bc:	00000000 	.word	0x00000000

000009c0 <ull_adv_aux_start>:

uint32_t ull_adv_aux_start(struct ll_adv_aux_set *aux, uint32_t ticks_anchor,
			   uint32_t ticks_slot_overhead)
{
     9c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	hdr->ref = 0U;
     9c4:	2500      	movs	r5, #0
     9c6:	b08d      	sub	sp, #52	; 0x34
	hdr->disabled_cb = hdr->disabled_param = NULL;
     9c8:	e9c0 5505 	strd	r5, r5, [r0, #20]
	hdr->ref = 0U;
     9cc:	7005      	strb	r5, [r0, #0]
     9ce:	4604      	mov	r4, r0
     9d0:	4688      	mov	r8, r1
     9d2:	4617      	mov	r7, r2
	uint32_t volatile ret_cb;
	uint8_t aux_handle;
	uint32_t ret;

	ull_hdr_init(&aux->ull);
	aux_handle = ull_adv_aux_handle_get(aux);
     9d4:	f006 feac 	bl	7730 <ull_adv_aux_handle_get>

	ret_cb = TICKER_STATUS_BUSY;
     9d8:	2302      	movs	r3, #2
     9da:	930b      	str	r3, [sp, #44]	; 0x2c
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
     9dc:	4b16      	ldr	r3, [pc, #88]	; (a38 <ull_adv_aux_start+0x78>)
     9de:	e9cd 4306 	strd	r4, r3, [sp, #24]
     9e2:	f10d 092c 	add.w	r9, sp, #44	; 0x2c
     9e6:	4b15      	ldr	r3, [pc, #84]	; (a3c <ull_adv_aux_start+0x7c>)
     9e8:	9305      	str	r3, [sp, #20]
     9ea:	f8cd 9020 	str.w	r9, [sp, #32]
     9ee:	6922      	ldr	r2, [r4, #16]
     9f0:	9502      	str	r5, [sp, #8]
     9f2:	4417      	add	r7, r2
     9f4:	e9cd 5703 	strd	r5, r7, [sp, #12]
			   (TICKER_ID_ADV_AUX_BASE + aux_handle),
     9f8:	1cc6      	adds	r6, r0, #3
			   ticks_anchor, 0,
			   HAL_TICKER_US_TO_TICKS((uint64_t)aux->interval *
     9fa:	8f24      	ldrh	r4, [r4, #56]	; 0x38
     9fc:	4810      	ldr	r0, [pc, #64]	; (a40 <ull_adv_aux_start+0x80>)
     9fe:	2791      	movs	r7, #145	; 0x91
     a00:	fba4 0100 	umull	r0, r1, r4, r0
     a04:	a30a      	add	r3, pc, #40	; (adr r3, a30 <ull_adv_aux_start+0x70>)
     a06:	e9d3 2300 	ldrd	r2, r3, [r3]
     a0a:	fb07 1104 	mla	r1, r7, r4, r1
     a0e:	f7ff fb77 	bl	100 <__aeabi_uldivmod>
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
     a12:	b2f6      	uxtb	r6, r6
     a14:	e9cd 5000 	strd	r5, r0, [sp]
     a18:	4643      	mov	r3, r8
     a1a:	4632      	mov	r2, r6
     a1c:	2103      	movs	r1, #3
     a1e:	4628      	mov	r0, r5
     a20:	f010 f8e3 	bl	10bea <ticker_start>
						  ADV_INT_UNIT_US),
			   TICKER_NULL_REMAINDER, TICKER_NULL_LAZY,
			   (aux->ull.ticks_slot + ticks_slot_overhead),
			   ticker_cb, aux,
			   ull_ticker_status_give, (void *)&ret_cb);
	ret = ull_ticker_status_take(ret, &ret_cb);
     a24:	4649      	mov	r1, r9
     a26:	f005 fd91 	bl	654c <ull_ticker_status_take>

	return ret;
}
     a2a:	b00d      	add	sp, #52	; 0x34
     a2c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     a30:	1afd498d 	.word	0x1afd498d
     a34:	00000007 	.word	0x00000007
     a38:	00006209 	.word	0x00006209
     a3c:	00007649 	.word	0x00007649
     a40:	84e72a00 	.word	0x84e72a00
     a44:	00000000 	.word	0x00000000

00000a48 <ull_adv_aux_hdr_set_clear>:
{
     a48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     a4c:	b09b      	sub	sp, #108	; 0x6c
     a4e:	4683      	mov	fp, r0
     a50:	930b      	str	r3, [sp, #44]	; 0x2c
	LL_ASSERT(!(sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_ADVA) ||
     a52:	f240 2301 	movw	r3, #513	; 0x201
     a56:	438b      	bics	r3, r1
{
     a58:	910c      	str	r1, [sp, #48]	; 0x30
     a5a:	9215      	str	r2, [sp, #84]	; 0x54
	LL_ASSERT(!(sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_ADVA) ||
     a5c:	d10c      	bne.n	a78 <ull_adv_aux_hdr_set_clear+0x30>
     a5e:	4aa9      	ldr	r2, [pc, #676]	; (d04 <ull_adv_aux_hdr_set_clear+0x2bc>)
     a60:	49a9      	ldr	r1, [pc, #676]	; (d08 <ull_adv_aux_hdr_set_clear+0x2c0>)
     a62:	48aa      	ldr	r0, [pc, #680]	; (d0c <ull_adv_aux_hdr_set_clear+0x2c4>)
     a64:	f240 230f 	movw	r3, #527	; 0x20f
     a68:	f00e fd2d 	bl	f4c6 <printk>
     a6c:	4040      	eors	r0, r0
     a6e:	f380 8811 	msr	BASEPRI, r0
     a72:	f04f 0003 	mov.w	r0, #3
     a76:	df02      	svc	2
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
     a78:	f89b 3025 	ldrb.w	r3, [fp, #37]	; 0x25
     a7c:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
     a80:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
	if (pri_pdu_prev->type != PDU_ADV_TYPE_EXT_IND) {
     a84:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     a86:	f898 a000 	ldrb.w	sl, [r8]
     a8a:	f00a 0a0f 	and.w	sl, sl, #15
     a8e:	f403 7300 	and.w	r3, r3, #512	; 0x200
     a92:	f1ba 0f07 	cmp.w	sl, #7
     a96:	930e      	str	r3, [sp, #56]	; 0x38
     a98:	d014      	beq.n	ac4 <ull_adv_aux_hdr_set_clear+0x7c>
		if (sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_AD_DATA) {
     a9a:	b92b      	cbnz	r3, aa8 <ull_adv_aux_hdr_set_clear+0x60>
		return BT_HCI_ERR_CMD_DISALLOWED;
     a9c:	f04f 0a0c 	mov.w	sl, #12
}
     aa0:	4650      	mov	r0, sl
     aa2:	b01b      	add	sp, #108	; 0x6c
     aa4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				     uint8_t **const ad_data)
{
	uint8_t ad_len;

	/* pick the data length */
	ad_len = *((uint8_t *)value);
     aa8:	990b      	ldr	r1, [sp, #44]	; 0x2c
     aaa:	f811 4b01 	ldrb.w	r4, [r1], #1
	value = (uint8_t *)value + sizeof(ad_len);

	/* pick the reference to data */
	(void)memcpy(ad_data, value, sizeof(*ad_data));
     aae:	2204      	movs	r2, #4
     ab0:	a818      	add	r0, sp, #96	; 0x60
     ab2:	f00f f878 	bl	fba6 <memcpy>
			return ull_adv_data_set(adv, ad_len, ad_data);
     ab6:	9a18      	ldr	r2, [sp, #96]	; 0x60
     ab8:	4621      	mov	r1, r4
     aba:	4658      	mov	r0, fp
     abc:	f010 fbe0 	bl	11280 <ull_adv_data_set>
     ac0:	4682      	mov	sl, r0
     ac2:	e7ed      	b.n	aa0 <ull_adv_aux_hdr_set_clear+0x58>
	if (pri_com_hdr_prev->ext_hdr_len) {
     ac4:	f898 3002 	ldrb.w	r3, [r8, #2]
	if ((sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_AD_DATA) &&
     ac8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
	if (pri_com_hdr_prev->ext_hdr_len) {
     aca:	f013 093f 	ands.w	r9, r3, #63	; 0x3f
		pri_hdr_prev = *pri_hdr;
     ace:	bf18      	it	ne
     ad0:	f898 9003 	ldrbne.w	r9, [r8, #3]
	if ((sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_AD_DATA) &&
     ad4:	b112      	cbz	r2, adc <ull_adv_aux_hdr_set_clear+0x94>
     ad6:	09db      	lsrs	r3, r3, #7
     ad8:	f040 8286 	bne.w	fe8 <ull_adv_aux_hdr_set_clear+0x5a0>
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
     adc:	9925      	ldr	r1, [sp, #148]	; 0x94
     ade:	f10b 0024 	add.w	r0, fp, #36	; 0x24
     ae2:	f010 fecd 	bl	11880 <lll_adv_pdu_alloc>
	pri_pdu->type = pri_pdu_prev->type;
     ae6:	f898 2000 	ldrb.w	r2, [r8]
     aea:	7803      	ldrb	r3, [r0, #0]
     aec:	f002 020f 	and.w	r2, r2, #15
     af0:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
     af4:	4313      	orrs	r3, r2
     af6:	4602      	mov	r2, r0
     af8:	f10b 041c 	add.w	r4, fp, #28
     afc:	f802 3b02 	strb.w	r3, [r2], #2
	pri_com_hdr->adv_mode = pri_com_hdr_prev->adv_mode;
     b00:	f898 3002 	ldrb.w	r3, [r8, #2]
	pri_pdu->type = pri_pdu_prev->type;
     b04:	9212      	str	r2, [sp, #72]	; 0x48
	pri_com_hdr->adv_mode = pri_com_hdr_prev->adv_mode;
     b06:	7882      	ldrb	r2, [r0, #2]
     b08:	099b      	lsrs	r3, r3, #6
     b0a:	f363 1287 	bfi	r2, r3, #6, #2
	*(uint8_t *)pri_hdr = 0U;
     b0e:	2300      	movs	r3, #0
     b10:	70c3      	strb	r3, [r0, #3]
	pri_com_hdr->adv_mode = pri_com_hdr_prev->adv_mode;
     b12:	7082      	strb	r2, [r0, #2]
	lll_aux = lll->aux;
     b14:	f8db 2040 	ldr.w	r2, [fp, #64]	; 0x40
     b18:	920a      	str	r2, [sp, #40]	; 0x28
     b1a:	4605      	mov	r5, r0
	if (!lll_aux) {
     b1c:	2a00      	cmp	r2, #0
     b1e:	f040 80bc 	bne.w	c9a <ull_adv_aux_hdr_set_clear+0x252>
		aux = ull_adv_aux_acquire(lll);
     b22:	4620      	mov	r0, r4
     b24:	f006 fe38 	bl	7798 <ull_adv_aux_acquire>
		if (!aux) {
     b28:	9009      	str	r0, [sp, #36]	; 0x24
     b2a:	4603      	mov	r3, r0
     b2c:	2800      	cmp	r0, #0
     b2e:	d0b7      	beq.n	aa0 <ull_adv_aux_hdr_set_clear+0x58>
		lll_aux = &aux->lll;
     b30:	331c      	adds	r3, #28
     b32:	930a      	str	r3, [sp, #40]	; 0x28
		is_aux_new = 1U;
     b34:	2301      	movs	r3, #1
	return (void *)lll->data.pdu[lll->data.last];
     b36:	9a0a      	ldr	r2, [sp, #40]	; 0x28
     b38:	990a      	ldr	r1, [sp, #40]	; 0x28
     b3a:	7c52      	ldrb	r2, [r2, #17]
     b3c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
     b40:	f8d2 a014 	ldr.w	sl, [r2, #20]
	sec_com_hdr_prev = (void *)&sec_pdu_prev->adv_ext_ind;
     b44:	f10a 0202 	add.w	r2, sl, #2
     b48:	920d      	str	r2, [sp, #52]	; 0x34
	if (!is_aux_new) {
     b4a:	2b00      	cmp	r3, #0
     b4c:	f040 80a9 	bne.w	ca2 <ull_adv_aux_hdr_set_clear+0x25a>
		sec_hdr_prev = *sec_hdr;
     b50:	f89a 3003 	ldrb.w	r3, [sl, #3]
     b54:	930d      	str	r3, [sp, #52]	; 0x34
	return lll_adv_pdu_alloc(&lll->data, idx);
     b56:	9b0a      	ldr	r3, [sp, #40]	; 0x28
     b58:	f10d 015b 	add.w	r1, sp, #91	; 0x5b
     b5c:	f103 0010 	add.w	r0, r3, #16
     b60:	f010 fe8e 	bl	11880 <lll_adv_pdu_alloc>
	sec_pdu->tx_addr = sec_pdu_prev->tx_addr;
     b64:	f89a 1000 	ldrb.w	r1, [sl]
	sec_pdu->type = pri_pdu->type;
     b68:	782a      	ldrb	r2, [r5, #0]
	} else if (sec_hdr_prev.adv_addr) {
     b6a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
     b6c:	4604      	mov	r4, r0
	sec_pdu->type = pri_pdu->type;
     b6e:	f3c2 0203 	ubfx	r2, r2, #0, #4
	sec_pdu->tx_addr = sec_pdu_prev->tx_addr;
     b72:	f3c1 1080 	ubfx	r0, r1, #6, #1
	sec_pdu->type = pri_pdu->type;
     b76:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
     b7a:	f001 0180 	and.w	r1, r1, #128	; 0x80
     b7e:	430a      	orrs	r2, r1
     b80:	7022      	strb	r2, [r4, #0]
	sec_com_hdr->adv_mode = pri_com_hdr->adv_mode;
     b82:	78aa      	ldrb	r2, [r5, #2]
     b84:	78a1      	ldrb	r1, [r4, #2]
     b86:	0992      	lsrs	r2, r2, #6
     b88:	f362 1187 	bfi	r1, r2, #6, #2
	sec_dptr = sec_hdr->data;
     b8c:	1d22      	adds	r2, r4, #4
	sec_com_hdr->adv_mode = pri_com_hdr->adv_mode;
     b8e:	70a1      	strb	r1, [r4, #2]
	sec_dptr = sec_hdr->data;
     b90:	9217      	str	r2, [sp, #92]	; 0x5c
	*(uint8_t *)sec_hdr = 0U;
     b92:	2201      	movs	r2, #1
     b94:	70e2      	strb	r2, [r4, #3]
	} else if (pri_hdr_prev.adv_addr) {
     b96:	ea09 0002 	and.w	r0, r9, r2
	} else if (sec_hdr_prev.adv_addr) {
     b9a:	401a      	ands	r2, r3
     b9c:	9213      	str	r2, [sp, #76]	; 0x4c
	if (sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_ADVA) {
     b9e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
     ba0:	f012 0101 	ands.w	r1, r2, #1
     ba4:	f000 8088 	beq.w	cb8 <ull_adv_aux_hdr_set_clear+0x270>
		uint8_t own_addr_type = *(uint8_t *)value;
     ba8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
     baa:	f812 6b01 	ldrb.w	r6, [r2], #1
     bae:	920b      	str	r2, [sp, #44]	; 0x2c
		sec_pdu->tx_addr = own_addr_type & 0x1;
     bb0:	7822      	ldrb	r2, [r4, #0]
     bb2:	f366 1286 	bfi	r2, r6, #6, #1
     bb6:	7022      	strb	r2, [r4, #0]
	pri_pdu->tx_addr = 0U;
     bb8:	782a      	ldrb	r2, [r5, #0]
     bba:	f36f 1286 	bfc	r2, #6, #1
     bbe:	702a      	strb	r2, [r5, #0]
	if (pri_hdr_prev.adv_addr) {
     bc0:	2800      	cmp	r0, #0
     bc2:	f040 808c 	bne.w	cde <ull_adv_aux_hdr_set_clear+0x296>
	pri_dptr_prev = pri_hdr->data;
     bc6:	f108 0704 	add.w	r7, r8, #4
	if (sec_hdr_prev.adv_addr) {
     bca:	f003 0201 	and.w	r2, r3, #1
     bce:	2a00      	cmp	r2, #0
     bd0:	f040 8088 	bne.w	ce4 <ull_adv_aux_hdr_set_clear+0x29c>
	sec_dptr_prev = sec_hdr->data;
     bd4:	f10a 0604 	add.w	r6, sl, #4
	sec_dptr += BDADDR_SIZE;
     bd8:	9a17      	ldr	r2, [sp, #92]	; 0x5c
     bda:	1d90      	adds	r0, r2, #6
     bdc:	9017      	str	r0, [sp, #92]	; 0x5c
	} else if (!(sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_ADVA) &&
     bde:	f003 0002 	and.w	r0, r3, #2
     be2:	9014      	str	r0, [sp, #80]	; 0x50
	if (pri_hdr_prev.tgt_addr) {
     be4:	f019 0002 	ands.w	r0, r9, #2
     be8:	d07f      	beq.n	cea <ull_adv_aux_hdr_set_clear+0x2a2>
		sec_hdr->tgt_addr = 1U;
     bea:	78e1      	ldrb	r1, [r4, #3]
     bec:	f041 0102 	orr.w	r1, r1, #2
     bf0:	70e1      	strb	r1, [r4, #3]
		sec_pdu->rx_addr = pri_pdu_prev->rx_addr;
     bf2:	f898 1000 	ldrb.w	r1, [r8]
		sec_pdu->rx_addr = sec_pdu_prev->rx_addr;
     bf6:	f894 c000 	ldrb.w	ip, [r4]
     bfa:	09c9      	lsrs	r1, r1, #7
     bfc:	f361 1cc7 	bfi	ip, r1, #7, #1
		sec_dptr += BDADDR_SIZE;
     c00:	320c      	adds	r2, #12
		sec_pdu->rx_addr = sec_pdu_prev->rx_addr;
     c02:	f884 c000 	strb.w	ip, [r4]
		sec_dptr += BDADDR_SIZE;
     c06:	9217      	str	r2, [sp, #92]	; 0x5c
	pri_pdu->rx_addr = 0U;
     c08:	782a      	ldrb	r2, [r5, #0]
     c0a:	f36f 12c7 	bfc	r2, #7, #1
     c0e:	702a      	strb	r2, [r5, #0]
	if (pri_hdr_prev.tgt_addr) {
     c10:	b100      	cbz	r0, c14 <ull_adv_aux_hdr_set_clear+0x1cc>
		pri_dptr_prev += BDADDR_SIZE;
     c12:	3706      	adds	r7, #6
	if (sec_hdr_prev.tgt_addr) {
     c14:	f003 0202 	and.w	r2, r3, #2
     c18:	b102      	cbz	r2, c1c <ull_adv_aux_hdr_set_clear+0x1d4>
		sec_dptr_prev += BDADDR_SIZE;
     c1a:	3606      	adds	r6, #6
	if (pri_hdr_prev.adi) {
     c1c:	f019 0208 	ands.w	r2, r9, #8
     c20:	920f      	str	r2, [sp, #60]	; 0x3c
	pri_hdr->adi = 1;
     c22:	78ea      	ldrb	r2, [r5, #3]
     c24:	f042 0208 	orr.w	r2, r2, #8
     c28:	70ea      	strb	r2, [r5, #3]
		pri_dptr_prev += sizeof(struct pdu_adv_adi);
     c2a:	bf18      	it	ne
     c2c:	3702      	addne	r7, #2
	if (sec_hdr_prev.adi) {
     c2e:	f013 0208 	ands.w	r2, r3, #8
     c32:	9210      	str	r2, [sp, #64]	; 0x40
	sec_hdr->adi = 1;
     c34:	78e2      	ldrb	r2, [r4, #3]
     c36:	f042 0208 	orr.w	r2, r2, #8
     c3a:	70e2      	strb	r2, [r4, #3]
	sec_dptr += sizeof(struct pdu_adv_adi);
     c3c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
     c3e:	f102 0202 	add.w	r2, r2, #2
     c42:	9217      	str	r2, [sp, #92]	; 0x5c
		sec_dptr_prev += sizeof(struct pdu_adv_adi);
     c44:	bf18      	it	ne
     c46:	3602      	addne	r6, #2
	if (pri_hdr_prev.aux_ptr) {
     c48:	f019 0210 	ands.w	r2, r9, #16
     c4c:	9211      	str	r2, [sp, #68]	; 0x44
	pri_hdr->aux_ptr = 1;
     c4e:	78ea      	ldrb	r2, [r5, #3]
     c50:	f042 0210 	orr.w	r2, r2, #16
     c54:	70ea      	strb	r2, [r5, #3]
	} else if (!(sec_hdr_rem_fields & ULL_ADV_PDU_HDR_FIELD_AUX_PTR) &&
     c56:	f003 0210 	and.w	r2, r3, #16
     c5a:	920d      	str	r2, [sp, #52]	; 0x34
	if (sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_AUX_PTR) {
     c5c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		pri_dptr_prev += sizeof(struct pdu_adv_aux_ptr);
     c5e:	bf18      	it	ne
     c60:	3703      	addne	r7, #3
	if (sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_AUX_PTR) {
     c62:	06d1      	lsls	r1, r2, #27
	pri_dptr += sizeof(struct pdu_adv_aux_ptr);
     c64:	f105 0809 	add.w	r8, r5, #9
	if (sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_AUX_PTR) {
     c68:	d552      	bpl.n	d10 <ull_adv_aux_hdr_set_clear+0x2c8>
		sec_hdr->aux_ptr = 1;
     c6a:	78e2      	ldrb	r2, [r4, #3]
		*(uint8_t *)value = sizeof(struct pdu_adv_aux_ptr);
     c6c:	980b      	ldr	r0, [sp, #44]	; 0x2c
     c6e:	930c      	str	r3, [sp, #48]	; 0x30
		sec_hdr->aux_ptr = 1;
     c70:	f042 0210 	orr.w	r2, r2, #16
     c74:	70e2      	strb	r2, [r4, #3]
		*(uint8_t *)value = sizeof(struct pdu_adv_aux_ptr);
     c76:	2203      	movs	r2, #3
     c78:	f800 2b01 	strb.w	r2, [r0], #1
		(void)memcpy(value, &sec_dptr, sizeof(sec_dptr));
     c7c:	a917      	add	r1, sp, #92	; 0x5c
     c7e:	2204      	movs	r2, #4
     c80:	f00e ff91 	bl	fba6 <memcpy>
		value = (uint8_t *)value + sizeof(sec_dptr);
     c84:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
     c86:	3305      	adds	r3, #5
     c88:	930b      	str	r3, [sp, #44]	; 0x2c
     c8a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	if (sec_hdr_prev.aux_ptr) {
     c8c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
     c8e:	2a00      	cmp	r2, #0
     c90:	f000 818c 	beq.w	fac <ull_adv_aux_hdr_set_clear+0x564>
     c94:	2200      	movs	r2, #0
     c96:	920c      	str	r2, [sp, #48]	; 0x30
     c98:	e047      	b.n	d2a <ull_adv_aux_hdr_set_clear+0x2e2>
		aux = HDR_LLL2ULL(lll_aux);
     c9a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
     c9c:	6812      	ldr	r2, [r2, #0]
     c9e:	9209      	str	r2, [sp, #36]	; 0x24
		is_aux_new = 0U;
     ca0:	e749      	b.n	b36 <ull_adv_aux_hdr_set_clear+0xee>
		sec_pdu_prev->tx_addr = 0U;
     ca2:	f89a 3000 	ldrb.w	r3, [sl]
     ca6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
     caa:	f88a 3000 	strb.w	r3, [sl]
		sec_pdu_prev->len = PDU_AC_EXT_HEADER_SIZE_MIN;
     cae:	2301      	movs	r3, #1
     cb0:	f88a 3001 	strb.w	r3, [sl, #1]
		*(uint8_t *)&sec_hdr_prev = 0U;
     cb4:	2300      	movs	r3, #0
     cb6:	e74d      	b.n	b54 <ull_adv_aux_hdr_set_clear+0x10c>
	} else if (pri_hdr_prev.adv_addr) {
     cb8:	b140      	cbz	r0, ccc <ull_adv_aux_hdr_set_clear+0x284>
		sec_pdu->tx_addr = pri_pdu_prev->tx_addr;
     cba:	f898 2000 	ldrb.w	r2, [r8]
		sec_pdu->tx_addr = sec_pdu_prev->tx_addr;
     cbe:	7826      	ldrb	r6, [r4, #0]
     cc0:	f3c2 1280 	ubfx	r2, r2, #6, #1
     cc4:	f362 1686 	bfi	r6, r2, #6, #1
     cc8:	7026      	strb	r6, [r4, #0]
     cca:	e775      	b.n	bb8 <ull_adv_aux_hdr_set_clear+0x170>
	} else if (sec_hdr_prev.adv_addr) {
     ccc:	f003 0201 	and.w	r2, r3, #1
     cd0:	b912      	cbnz	r2, cd8 <ull_adv_aux_hdr_set_clear+0x290>
		return BT_HCI_ERR_UNSPECIFIED;
     cd2:	f04f 0a1f 	mov.w	sl, #31
     cd6:	e6e3      	b.n	aa0 <ull_adv_aux_hdr_set_clear+0x58>
		sec_pdu->tx_addr = sec_pdu_prev->tx_addr;
     cd8:	f89a 2000 	ldrb.w	r2, [sl]
     cdc:	e7ef      	b.n	cbe <ull_adv_aux_hdr_set_clear+0x276>
		pri_dptr_prev += BDADDR_SIZE;
     cde:	f108 070a 	add.w	r7, r8, #10
     ce2:	e772      	b.n	bca <ull_adv_aux_hdr_set_clear+0x182>
		sec_dptr_prev += BDADDR_SIZE;
     ce4:	f10a 060a 	add.w	r6, sl, #10
     ce8:	e776      	b.n	bd8 <ull_adv_aux_hdr_set_clear+0x190>
	} else if (!(sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_ADVA) &&
     cea:	2900      	cmp	r1, #0
     cec:	d18c      	bne.n	c08 <ull_adv_aux_hdr_set_clear+0x1c0>
     cee:	f003 0102 	and.w	r1, r3, #2
     cf2:	2900      	cmp	r1, #0
     cf4:	d088      	beq.n	c08 <ull_adv_aux_hdr_set_clear+0x1c0>
		sec_hdr->tgt_addr = 1U;
     cf6:	78e1      	ldrb	r1, [r4, #3]
     cf8:	f041 0102 	orr.w	r1, r1, #2
     cfc:	70e1      	strb	r1, [r4, #3]
		sec_pdu->rx_addr = sec_pdu_prev->rx_addr;
     cfe:	f89a 1000 	ldrb.w	r1, [sl]
     d02:	e778      	b.n	bf6 <ull_adv_aux_hdr_set_clear+0x1ae>
     d04:	00013825 	.word	0x00013825
     d08:	00013880 	.word	0x00013880
     d0c:	000133b6 	.word	0x000133b6
	} else if (!(sec_hdr_rem_fields & ULL_ADV_PDU_HDR_FIELD_AUX_PTR) &&
     d10:	9a15      	ldr	r2, [sp, #84]	; 0x54
     d12:	06d2      	lsls	r2, r2, #27
     d14:	d4ba      	bmi.n	c8c <ull_adv_aux_hdr_set_clear+0x244>
     d16:	f003 0210 	and.w	r2, r3, #16
     d1a:	2a00      	cmp	r2, #0
     d1c:	f000 8142 	beq.w	fa4 <ull_adv_aux_hdr_set_clear+0x55c>
		sec_hdr->aux_ptr = 1;
     d20:	78e2      	ldrb	r2, [r4, #3]
		aux_ptr = (void *)sec_dptr_prev;
     d22:	960c      	str	r6, [sp, #48]	; 0x30
		sec_hdr->aux_ptr = 1;
     d24:	f042 0210 	orr.w	r2, r2, #16
     d28:	70e2      	strb	r2, [r4, #3]
		sec_dptr_prev += sizeof(struct pdu_adv_aux_ptr);
     d2a:	3603      	adds	r6, #3
	if (sec_hdr->aux_ptr) {
     d2c:	78e2      	ldrb	r2, [r4, #3]
     d2e:	06d0      	lsls	r0, r2, #27
		sec_dptr += sizeof(struct pdu_adv_aux_ptr);
     d30:	bf42      	ittt	mi
     d32:	9a17      	ldrmi	r2, [sp, #92]	; 0x5c
     d34:	3203      	addmi	r2, #3
     d36:	9217      	strmi	r2, [sp, #92]	; 0x5c
	if (pri_hdr_prev.tx_pwr) {
     d38:	f019 0f40 	tst.w	r9, #64	; 0x40
     d3c:	d012      	beq.n	d64 <ull_adv_aux_hdr_set_clear+0x31c>
		if (lll->phy_p != PHY_CODED) {
     d3e:	f89b 2021 	ldrb.w	r2, [fp, #33]	; 0x21
     d42:	f002 0207 	and.w	r2, r2, #7
     d46:	2a04      	cmp	r2, #4
			pri_hdr->tx_pwr = 1;
     d48:	bf15      	itete	ne
     d4a:	78ea      	ldrbne	r2, [r5, #3]
			sec_hdr->tx_pwr = 1;
     d4c:	78e2      	ldrbeq	r2, [r4, #3]
			pri_hdr->tx_pwr = 1;
     d4e:	f042 0240 	orrne.w	r2, r2, #64	; 0x40
			sec_hdr->tx_pwr = 1;
     d52:	f042 0240 	orreq.w	r2, r2, #64	; 0x40
		pri_dptr_prev++;
     d56:	f107 0701 	add.w	r7, r7, #1
			pri_hdr->tx_pwr = 1;
     d5a:	bf1a      	itte	ne
     d5c:	70ea      	strbne	r2, [r5, #3]
			pri_dptr++;
     d5e:	f105 080a 	addne.w	r8, r5, #10
			sec_hdr->tx_pwr = 1;
     d62:	70e2      	strbeq	r2, [r4, #3]
	if (sec_hdr_prev.tx_pwr) {
     d64:	0659      	lsls	r1, r3, #25
		sec_hdr->tx_pwr = 1;
     d66:	bf42      	ittt	mi
     d68:	78e3      	ldrbmi	r3, [r4, #3]
     d6a:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
     d6e:	70e3      	strbmi	r3, [r4, #3]
	if (sec_hdr->tx_pwr) {
     d70:	78e3      	ldrb	r3, [r4, #3]
		sec_dptr_prev++;
     d72:	bf48      	it	mi
     d74:	3601      	addmi	r6, #1
	if (sec_hdr->tx_pwr) {
     d76:	065a      	lsls	r2, r3, #25
		sec_dptr++;
     d78:	bf48      	it	mi
     d7a:	9b17      	ldrmi	r3, [sp, #92]	; 0x5c

/* helper function to fill common ext adv payload header length */
static inline void
ull_adv_aux_hdr_len_fill(struct pdu_adv_com_ext_adv *com_hdr, uint8_t len)
{
	com_hdr->ext_hdr_len = len - PDU_AC_EXT_HEADER_SIZE_MIN;
     d7c:	78aa      	ldrb	r2, [r5, #2]
     d7e:	bf44      	itt	mi
     d80:	3301      	addmi	r3, #1
     d82:	9317      	strmi	r3, [sp, #92]	; 0x5c
	len = *dptr - (uint8_t *)com_hdr;
     d84:	9b12      	ldr	r3, [sp, #72]	; 0x48
     d86:	eba8 0303 	sub.w	r3, r8, r3
     d8a:	b2db      	uxtb	r3, r3
	if (len <= (PDU_AC_EXT_HEADER_SIZE_MIN +
     d8c:	2b02      	cmp	r3, #2
		len = PDU_AC_EXT_HEADER_SIZE_MIN;
     d8e:	bf98      	it	ls
     d90:	2301      	movls	r3, #1
	com_hdr->ext_hdr_len = len - PDU_AC_EXT_HEADER_SIZE_MIN;
     d92:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
     d96:	f361 0205 	bfi	r2, r1, #0, #6
	pri_pdu->len = pri_len;
     d9a:	706b      	strb	r3, [r5, #1]
	len = *dptr - (uint8_t *)com_hdr;
     d9c:	f10a 0302 	add.w	r3, sl, #2
	com_hdr->ext_hdr_len = len - PDU_AC_EXT_HEADER_SIZE_MIN;
     da0:	70aa      	strb	r2, [r5, #2]
	len = *dptr - (uint8_t *)com_hdr;
     da2:	eba6 0203 	sub.w	r2, r6, r3
     da6:	b2d2      	uxtb	r2, r2
		*dptr = (uint8_t *)com_hdr + len;
     da8:	bf98      	it	ls
     daa:	f105 0803 	addls.w	r8, r5, #3
	if (len <= (PDU_AC_EXT_HEADER_SIZE_MIN +
     dae:	2a02      	cmp	r2, #2
		*dptr = (uint8_t *)com_hdr + len;
     db0:	bf98      	it	ls
     db2:	f10a 0603 	addls.w	r6, sl, #3
	if (sec_len_prev > sec_pdu_prev->len) {
     db6:	f89a a001 	ldrb.w	sl, [sl, #1]
		len = PDU_AC_EXT_HEADER_SIZE_MIN;
     dba:	bf98      	it	ls
     dbc:	2201      	movls	r2, #1
     dbe:	4592      	cmp	sl, r2
     dc0:	d387      	bcc.n	cd2 <ull_adv_aux_hdr_set_clear+0x28a>
	len = *dptr - (uint8_t *)com_hdr;
     dc2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
	com_hdr->ext_hdr_len = len - PDU_AC_EXT_HEADER_SIZE_MIN;
     dc4:	78a0      	ldrb	r0, [r4, #2]
	sec_com_hdr = (void *)&sec_pdu->adv_ext_ind;
     dc6:	f104 0902 	add.w	r9, r4, #2
	len = *dptr - (uint8_t *)com_hdr;
     dca:	eba3 0309 	sub.w	r3, r3, r9
     dce:	fa5f f983 	uxtb.w	r9, r3
	if (len <= (PDU_AC_EXT_HEADER_SIZE_MIN +
     dd2:	f1b9 0f02 	cmp.w	r9, #2
		len = PDU_AC_EXT_HEADER_SIZE_MIN;
     dd6:	bf98      	it	ls
     dd8:	f04f 0901 	movls.w	r9, #1
	com_hdr->ext_hdr_len = len - PDU_AC_EXT_HEADER_SIZE_MIN;
     ddc:	f109 31ff 	add.w	r1, r9, #4294967295	; 0xffffffff
     de0:	f361 0005 	bfi	r0, r1, #0, #6
	if (sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_AD_DATA) {
     de4:	990e      	ldr	r1, [sp, #56]	; 0x38
		*dptr = (uint8_t *)com_hdr + len;
     de6:	bf9c      	itt	ls
     de8:	1ce3      	addls	r3, r4, #3
     dea:	9317      	strls	r3, [sp, #92]	; 0x5c
	sec_len = ull_adv_aux_hdr_len_calc(sec_com_hdr, &sec_dptr);
     dec:	fa1f f389 	uxth.w	r3, r9
	com_hdr->ext_hdr_len = len - PDU_AC_EXT_HEADER_SIZE_MIN;
     df0:	70a0      	strb	r0, [r4, #2]
	if (sec_hdr_add_fields & ULL_ADV_PDU_HDR_FIELD_AD_DATA) {
     df2:	2900      	cmp	r1, #0
     df4:	f000 80dc 	beq.w	fb0 <ull_adv_aux_hdr_set_clear+0x568>
	ad_len = *((uint8_t *)value);
     df8:	990b      	ldr	r1, [sp, #44]	; 0x2c
     dfa:	930e      	str	r3, [sp, #56]	; 0x38
     dfc:	f811 ab01 	ldrb.w	sl, [r1], #1
	(void)memcpy(ad_data, value, sizeof(*ad_data));
     e00:	2204      	movs	r2, #4
     e02:	a818      	add	r0, sp, #96	; 0x60
     e04:	f00e fecf 	bl	fba6 <memcpy>

	return ad_len;
     e08:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	sec_len += ad_len;
     e0a:	4453      	add	r3, sl
	if (sec_len > PDU_AC_PAYLOAD_SIZE_MAX) {
     e0c:	b29b      	uxth	r3, r3
     e0e:	2b5f      	cmp	r3, #95	; 0x5f
     e10:	f200 80ed 	bhi.w	fee <ull_adv_aux_hdr_set_clear+0x5a6>
	sec_pdu->len = sec_len;
     e14:	44d1      	add	r9, sl
     e16:	f884 9001 	strb.w	r9, [r4, #1]
	(void)memmove(sec_dptr, ad_data, ad_len);
     e1a:	4652      	mov	r2, sl
     e1c:	e9dd 0117 	ldrd	r0, r1, [sp, #92]	; 0x5c
     e20:	f00e fea9 	bl	fb76 <memmove>
	if (!sec_com_hdr->ext_hdr_len) {
     e24:	f894 a002 	ldrb.w	sl, [r4, #2]
     e28:	f01a 0a3f 	ands.w	sl, sl, #63	; 0x3f
     e2c:	f43f ae38 	beq.w	aa0 <ull_adv_aux_hdr_set_clear+0x58>
	if (pri_hdr->tx_pwr) {
     e30:	78eb      	ldrb	r3, [r5, #3]
     e32:	065b      	lsls	r3, r3, #25
     e34:	f140 80c2 	bpl.w	fbc <ull_adv_aux_hdr_set_clear+0x574>
		*--pri_dptr = *--pri_dptr_prev;
     e38:	f817 3c01 	ldrb.w	r3, [r7, #-1]
     e3c:	f808 3c01 	strb.w	r3, [r8, #-1]
     e40:	3f01      	subs	r7, #1
     e42:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
	if (pri_hdr_prev.aux_ptr) {
     e46:	9b11      	ldr	r3, [sp, #68]	; 0x44
     e48:	b103      	cbz	r3, e4c <ull_adv_aux_hdr_set_clear+0x404>
		pri_dptr_prev -= sizeof(struct pdu_adv_aux_ptr);
     e4a:	3f03      	subs	r7, #3
	ull_adv_aux_ptr_fill((void *)pri_dptr, 0U, lll->phy_s);
     e4c:	f89b 2021 	ldrb.w	r2, [fp, #33]	; 0x21
     e50:	2100      	movs	r1, #0
     e52:	f3c2 02c2 	ubfx	r2, r2, #3, #3
     e56:	f1a8 0003 	sub.w	r0, r8, #3
     e5a:	f010 faf5 	bl	11448 <ull_adv_aux_ptr_fill>
	if (sec_hdr_prev.aux_ptr) {
     e5e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
     e60:	b103      	cbz	r3, e64 <ull_adv_aux_hdr_set_clear+0x41c>
		sec_dptr_prev -= sizeof(struct pdu_adv_aux_ptr);
     e62:	3e03      	subs	r6, #3
	if (sec_hdr->aux_ptr) {
     e64:	78e3      	ldrb	r3, [r4, #3]
     e66:	06d8      	lsls	r0, r3, #27
		sec_dptr -= sizeof(struct pdu_adv_aux_ptr);
     e68:	bf42      	ittt	mi
     e6a:	9b17      	ldrmi	r3, [sp, #92]	; 0x5c
     e6c:	3b03      	submi	r3, #3
     e6e:	9317      	strmi	r3, [sp, #92]	; 0x5c
	if (aux_ptr) {
     e70:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     e72:	b123      	cbz	r3, e7e <ull_adv_aux_hdr_set_clear+0x436>
		(void)memmove(sec_dptr, aux_ptr, sizeof(*aux_ptr));
     e74:	9817      	ldr	r0, [sp, #92]	; 0x5c
     e76:	2203      	movs	r2, #3
     e78:	4619      	mov	r1, r3
     e7a:	f00e fe7c 	bl	fb76 <memmove>
	if (pri_hdr_prev.adi) {
     e7e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     e80:	b103      	cbz	r3, e84 <ull_adv_aux_hdr_set_clear+0x43c>
		pri_dptr_prev -= sizeof(struct pdu_adv_adi);
     e82:	3f02      	subs	r7, #2
	if (sec_hdr_prev.adi) {
     e84:	9b10      	ldr	r3, [sp, #64]	; 0x40
     e86:	b103      	cbz	r3, e8a <ull_adv_aux_hdr_set_clear+0x442>
		sec_dptr_prev -= sizeof(struct pdu_adv_adi);
     e88:	3e02      	subs	r6, #2
	sec_dptr -= sizeof(struct pdu_adv_adi);
     e8a:	9d17      	ldr	r5, [sp, #92]	; 0x5c
	pri_adi->sid = adv->sid;
     e8c:	f89b 006e 	ldrb.w	r0, [fp, #110]	; 0x6e
	sec_dptr -= sizeof(struct pdu_adv_adi);
     e90:	1eab      	subs	r3, r5, #2
     e92:	9317      	str	r3, [sp, #92]	; 0x5c
	pri_adi->sid = adv->sid;
     e94:	f818 3c04 	ldrb.w	r3, [r8, #-4]
     e98:	f000 000f 	and.w	r0, r0, #15
     e9c:	f360 1307 	bfi	r3, r0, #4, #4
     ea0:	f808 3c04 	strb.w	r3, [r8, #-4]
	sec_adi->sid = adv->sid;
     ea4:	f815 3c01 	ldrb.w	r3, [r5, #-1]
     ea8:	f360 1307 	bfi	r3, r0, #4, #4
     eac:	f805 3c01 	strb.w	r3, [r5, #-1]
	did = ull_adv_aux_did_next_unique_get(adv->sid);
     eb0:	f006 fc32 	bl	7718 <ull_adv_aux_did_next_unique_get>
	pri_adi->did = sys_cpu_to_le16(did);
     eb4:	f818 3c04 	ldrb.w	r3, [r8, #-4]
     eb8:	b2c2      	uxtb	r2, r0
     eba:	f023 030f 	bic.w	r3, r3, #15
     ebe:	f3c0 2003 	ubfx	r0, r0, #8, #4
     ec2:	4303      	orrs	r3, r0
     ec4:	f808 2c05 	strb.w	r2, [r8, #-5]
     ec8:	f808 3c04 	strb.w	r3, [r8, #-4]
	sec_adi->did = sys_cpu_to_le16(did);
     ecc:	f815 3c01 	ldrb.w	r3, [r5, #-1]
     ed0:	f805 2c02 	strb.w	r2, [r5, #-2]
     ed4:	f023 030f 	bic.w	r3, r3, #15
     ed8:	4318      	orrs	r0, r3
	if (adi) {
     eda:	9b24      	ldr	r3, [sp, #144]	; 0x90
	sec_adi->did = sys_cpu_to_le16(did);
     edc:	f805 0c01 	strb.w	r0, [r5, #-1]
	if (adi) {
     ee0:	b11b      	cbz	r3, eea <ull_adv_aux_hdr_set_clear+0x4a2>
		*adi = *pri_adi;
     ee2:	9a24      	ldr	r2, [sp, #144]	; 0x90
     ee4:	f838 3c05 	ldrh.w	r3, [r8, #-5]
     ee8:	8013      	strh	r3, [r2, #0]
	if (sec_hdr->tgt_addr) {
     eea:	78e3      	ldrb	r3, [r4, #3]
     eec:	0799      	lsls	r1, r3, #30
     eee:	d50a      	bpl.n	f06 <ull_adv_aux_hdr_set_clear+0x4be>
		if (sec_hdr_prev.tgt_addr) {
     ef0:	9b14      	ldr	r3, [sp, #80]	; 0x50
     ef2:	2b00      	cmp	r3, #0
     ef4:	d06f      	beq.n	fd6 <ull_adv_aux_hdr_set_clear+0x58e>
			sec_dptr_prev -= BDADDR_SIZE;
     ef6:	3e06      	subs	r6, #6
     ef8:	4631      	mov	r1, r6
		sec_dptr -= BDADDR_SIZE;
     efa:	9817      	ldr	r0, [sp, #92]	; 0x5c
		(void)memcpy(sec_dptr, bdaddr, BDADDR_SIZE);
     efc:	2206      	movs	r2, #6
		sec_dptr -= BDADDR_SIZE;
     efe:	3806      	subs	r0, #6
     f00:	9017      	str	r0, [sp, #92]	; 0x5c
		(void)memcpy(sec_dptr, bdaddr, BDADDR_SIZE);
     f02:	f00e fe50 	bl	fba6 <memcpy>
	if (sec_hdr->adv_addr) {
     f06:	78e3      	ldrb	r3, [r4, #3]
     f08:	07da      	lsls	r2, r3, #31
     f0a:	d509      	bpl.n	f20 <ull_adv_aux_hdr_set_clear+0x4d8>
		if (sec_hdr_prev.adv_addr) {
     f0c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     f0e:	2b00      	cmp	r3, #0
     f10:	d064      	beq.n	fdc <ull_adv_aux_hdr_set_clear+0x594>
			sec_dptr_prev -= BDADDR_SIZE;
     f12:	1fb1      	subs	r1, r6, #6
		sec_dptr -= BDADDR_SIZE;
     f14:	9817      	ldr	r0, [sp, #92]	; 0x5c
		(void)memcpy(sec_dptr, bdaddr, BDADDR_SIZE);
     f16:	2206      	movs	r2, #6
		sec_dptr -= BDADDR_SIZE;
     f18:	3806      	subs	r0, #6
     f1a:	9017      	str	r0, [sp, #92]	; 0x5c
		(void)memcpy(sec_dptr, bdaddr, BDADDR_SIZE);
     f1c:	f00e fe43 	bl	fba6 <memcpy>
	if (aux->is_started) {
     f20:	9b09      	ldr	r3, [sp, #36]	; 0x24
     f22:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
     f26:	07db      	lsls	r3, r3, #31
     f28:	d535      	bpl.n	f96 <ull_adv_aux_hdr_set_clear+0x54e>
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
     f2a:	f89b 0031 	ldrb.w	r0, [fp, #49]	; 0x31
     f2e:	eb0b 0080 	add.w	r0, fp, r0, lsl #2
	uint32_t ticks_plus;
	uint32_t time_ticks;
	uint32_t time_us;
	uint32_t ret;

	time_us = aux_time_get(aux, pdu, pdu_scan);
     f32:	4621      	mov	r1, r4
     f34:	6b42      	ldr	r2, [r0, #52]	; 0x34
     f36:	9809      	ldr	r0, [sp, #36]	; 0x24
     f38:	f010 fa46 	bl	113c8 <aux_time_get>
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
     f3c:	4930      	ldr	r1, [pc, #192]	; (1000 <ull_adv_aux_hdr_set_clear+0x5b8>)
     f3e:	a32e      	add	r3, pc, #184	; (adr r3, ff8 <ull_adv_aux_hdr_set_clear+0x5b0>)
     f40:	e9d3 2300 	ldrd	r2, r3, [r3]
     f44:	fba0 0101 	umull	r0, r1, r0, r1
     f48:	f7ff f8da 	bl	100 <__aeabi_uldivmod>
	if (aux->ull.ticks_slot > time_ticks) {
     f4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
     f4e:	691d      	ldr	r5, [r3, #16]
	time_ticks = HAL_TICKER_US_TO_TICKS(time_us);
     f50:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
	if (aux->ull.ticks_slot > time_ticks) {
     f54:	42ac      	cmp	r4, r5
     f56:	d243      	bcs.n	fe0 <ull_adv_aux_hdr_set_clear+0x598>
		ticks_minus = aux->ull.ticks_slot - time_ticks;
     f58:	1b2f      	subs	r7, r5, r4
		ticks_plus = 0U;
     f5a:	2500      	movs	r5, #0
		ticks_plus = time_ticks - aux->ull.ticks_slot;
	} else {
		return BT_HCI_ERR_SUCCESS;
	}

	ret_cb = TICKER_STATUS_BUSY;
     f5c:	2302      	movs	r3, #2
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
			    TICKER_USER_ID_THREAD,
			    (TICKER_ID_ADV_AUX_BASE +
			     ull_adv_aux_handle_get(aux)),
     f5e:	9809      	ldr	r0, [sp, #36]	; 0x24
	ret_cb = TICKER_STATUS_BUSY;
     f60:	9319      	str	r3, [sp, #100]	; 0x64
			     ull_adv_aux_handle_get(aux)),
     f62:	f006 fbe5 	bl	7730 <ull_adv_aux_handle_get>
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
     f66:	4b27      	ldr	r3, [pc, #156]	; (1004 <ull_adv_aux_hdr_set_clear+0x5bc>)
     f68:	9305      	str	r3, [sp, #20]
			    (TICKER_ID_ADV_AUX_BASE +
     f6a:	1cc2      	adds	r2, r0, #3
	ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
     f6c:	2300      	movs	r3, #0
     f6e:	ae19      	add	r6, sp, #100	; 0x64
     f70:	2103      	movs	r1, #3
     f72:	e9cd 3303 	strd	r3, r3, [sp, #12]
     f76:	e9cd 5701 	strd	r5, r7, [sp, #4]
     f7a:	9606      	str	r6, [sp, #24]
     f7c:	9300      	str	r3, [sp, #0]
     f7e:	b2d2      	uxtb	r2, r2
     f80:	4618      	mov	r0, r3
     f82:	f00f fe4d 	bl	10c20 <ticker_update>
			    0, 0, ticks_plus, ticks_minus, 0, 0,
			    ull_ticker_status_give, (void *)&ret_cb);
	ret = ull_ticker_status_take(ret, &ret_cb);
     f86:	4631      	mov	r1, r6
     f88:	f005 fae0 	bl	654c <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
     f8c:	2800      	cmp	r0, #0
     f8e:	f47f ad85 	bne.w	a9c <ull_adv_aux_hdr_set_clear+0x54>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	aux->ull.ticks_slot = time_ticks;
     f92:	9b09      	ldr	r3, [sp, #36]	; 0x24
     f94:	611c      	str	r4, [r3, #16]
	pdu->last = idx;
     f96:	9a0a      	ldr	r2, [sp, #40]	; 0x28
     f98:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
     f9c:	7453      	strb	r3, [r2, #17]
	return 0;
     f9e:	f04f 0a00 	mov.w	sl, #0
     fa2:	e57d      	b.n	aa0 <ull_adv_aux_hdr_set_clear+0x58>
		aux_ptr = NULL;
     fa4:	f003 0210 	and.w	r2, r3, #16
     fa8:	920c      	str	r2, [sp, #48]	; 0x30
     faa:	e6bf      	b.n	d2c <ull_adv_aux_hdr_set_clear+0x2e4>
     fac:	9a0d      	ldr	r2, [sp, #52]	; 0x34
     fae:	e7fb      	b.n	fa8 <ull_adv_aux_hdr_set_clear+0x560>
		ad_len = sec_pdu_prev->len - sec_len_prev;
     fb0:	ebaa 0a02 	sub.w	sl, sl, r2
     fb4:	fa5f fa8a 	uxtb.w	sl, sl
		ad_data = sec_dptr_prev;
     fb8:	9618      	str	r6, [sp, #96]	; 0x60
     fba:	e726      	b.n	e0a <ull_adv_aux_hdr_set_clear+0x3c2>
	} else if (sec_hdr->tx_pwr) {
     fbc:	78e3      	ldrb	r3, [r4, #3]
     fbe:	065d      	lsls	r5, r3, #25
     fc0:	f57f af41 	bpl.w	e46 <ull_adv_aux_hdr_set_clear+0x3fe>
		*--sec_dptr = *--sec_dptr_prev;
     fc4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
     fc6:	1e5a      	subs	r2, r3, #1
     fc8:	9217      	str	r2, [sp, #92]	; 0x5c
     fca:	f816 2c01 	ldrb.w	r2, [r6, #-1]
     fce:	f803 2c01 	strb.w	r2, [r3, #-1]
     fd2:	3e01      	subs	r6, #1
     fd4:	e737      	b.n	e46 <ull_adv_aux_hdr_set_clear+0x3fe>
			pri_dptr_prev -= BDADDR_SIZE;
     fd6:	3f06      	subs	r7, #6
			bdaddr = pri_dptr_prev;
     fd8:	4639      	mov	r1, r7
     fda:	e78e      	b.n	efa <ull_adv_aux_hdr_set_clear+0x4b2>
			pri_dptr_prev -= BDADDR_SIZE;
     fdc:	1fb9      	subs	r1, r7, #6
			bdaddr = pri_dptr_prev;
     fde:	e799      	b.n	f14 <ull_adv_aux_hdr_set_clear+0x4cc>
	} else if (aux->ull.ticks_slot < time_ticks) {
     fe0:	d9d9      	bls.n	f96 <ull_adv_aux_hdr_set_clear+0x54e>
		ticks_plus = time_ticks - aux->ull.ticks_slot;
     fe2:	1b65      	subs	r5, r4, r5
		ticks_minus = 0U;
     fe4:	2700      	movs	r7, #0
     fe6:	e7b9      	b.n	f5c <ull_adv_aux_hdr_set_clear+0x514>
		return BT_HCI_ERR_INVALID_PARAM;
     fe8:	f04f 0a12 	mov.w	sl, #18
     fec:	e558      	b.n	aa0 <ull_adv_aux_hdr_set_clear+0x58>
		return BT_HCI_ERR_PACKET_TOO_LONG;
     fee:	f04f 0a45 	mov.w	sl, #69	; 0x45
     ff2:	e555      	b.n	aa0 <ull_adv_aux_hdr_set_clear+0x58>
     ff4:	f3af 8000 	nop.w
     ff8:	1afd498d 	.word	0x1afd498d
     ffc:	00000007 	.word	0x00000007
    1000:	3b9aca00 	.word	0x3b9aca00
    1004:	00006209 	.word	0x00006209

00001008 <ull_adv_aux_lll_offset_fill>:
{
    1008:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (h->adv_addr) {
    100a:	78c3      	ldrb	r3, [r0, #3]
	offs = HAL_TICKER_TICKS_TO_US(ticks_offset) - start_us;
    100c:	4d20      	ldr	r5, [pc, #128]	; (1090 <ull_adv_aux_lll_offset_fill+0x88>)
{
    100e:	4604      	mov	r4, r0
	if (h->adv_addr) {
    1010:	07d8      	lsls	r0, r3, #31
		ptr += BDADDR_SIZE;
    1012:	bf48      	it	mi
    1014:	340a      	addmi	r4, #10
{
    1016:	4616      	mov	r6, r2
	ptr = h->data;
    1018:	bf58      	it	pl
    101a:	3404      	addpl	r4, #4
	offs = HAL_TICKER_TICKS_TO_US(ticks_offset) - start_us;
    101c:	fba1 0505 	umull	r0, r5, r1, r5
	if (h->tgt_addr) {
    1020:	079a      	lsls	r2, r3, #30
	offs = HAL_TICKER_TICKS_TO_US(ticks_offset) - start_us;
    1022:	f04f 0707 	mov.w	r7, #7
		ptr += BDADDR_SIZE;
    1026:	bf48      	it	mi
    1028:	3406      	addmi	r4, #6
	offs = HAL_TICKER_TICKS_TO_US(ticks_offset) - start_us;
    102a:	fb07 5101 	mla	r1, r7, r1, r5
	if (h->adi) {
    102e:	071b      	lsls	r3, r3, #28
	offs = HAL_TICKER_TICKS_TO_US(ticks_offset) - start_us;
    1030:	a315      	add	r3, pc, #84	; (adr r3, 1088 <ull_adv_aux_lll_offset_fill+0x80>)
    1032:	e9d3 2300 	ldrd	r2, r3, [r3]
		ptr += sizeof(struct pdu_adv_adi);
    1036:	bf48      	it	mi
    1038:	3402      	addmi	r4, #2
	offs = HAL_TICKER_TICKS_TO_US(ticks_offset) - start_us;
    103a:	f7ff f861 	bl	100 <__aeabi_uldivmod>
	offs = offs / OFFS_UNIT_30_US;
    103e:	221e      	movs	r2, #30
	offs = HAL_TICKER_TICKS_TO_US(ticks_offset) - start_us;
    1040:	1b80      	subs	r0, r0, r6
	offs = offs / OFFS_UNIT_30_US;
    1042:	fbb0 f2f2 	udiv	r2, r0, r2
	if (!!(offs >> OFFS_UNIT_BITS)) {
    1046:	0b55      	lsrs	r5, r2, #13
    1048:	78a3      	ldrb	r3, [r4, #2]
    104a:	7821      	ldrb	r1, [r4, #0]
    104c:	d00f      	beq.n	106e <ull_adv_aux_lll_offset_fill+0x66>
		aux_ptr->offs = offs / (OFFS_UNIT_300_US / OFFS_UNIT_30_US);
    104e:	f44f 7296 	mov.w	r2, #300	; 0x12c
    1052:	f023 031f 	bic.w	r3, r3, #31
    1056:	fbb0 f0f2 	udiv	r0, r0, r2
    105a:	7060      	strb	r0, [r4, #1]
    105c:	f3c0 2004 	ubfx	r0, r0, #8, #5
    1060:	4303      	orrs	r3, r0
    1062:	70a3      	strb	r3, [r4, #2]
		aux_ptr->offs_units = OFFS_UNIT_VALUE_300_US;
    1064:	f041 0380 	orr.w	r3, r1, #128	; 0x80
		aux_ptr->offs_units = OFFS_UNIT_VALUE_30_US;
    1068:	7023      	strb	r3, [r4, #0]
}
    106a:	4620      	mov	r0, r4
    106c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		aux_ptr->offs = offs;
    106e:	7062      	strb	r2, [r4, #1]
    1070:	f023 031f 	bic.w	r3, r3, #31
    1074:	f3c2 2204 	ubfx	r2, r2, #8, #5
    1078:	4313      	orrs	r3, r2
    107a:	70a3      	strb	r3, [r4, #2]
		aux_ptr->offs_units = OFFS_UNIT_VALUE_30_US;
    107c:	460b      	mov	r3, r1
    107e:	f365 13c7 	bfi	r3, r5, #7, #1
    1082:	e7f1      	b.n	1068 <ull_adv_aux_lll_offset_fill+0x60>
    1084:	f3af 8000 	nop.w
    1088:	3b9aca00 	.word	0x3b9aca00
    108c:	00000000 	.word	0x00000000
    1090:	1afd498d 	.word	0x1afd498d
    1094:	00000000 	.word	0x00000000

00001098 <ull_scan_enable>:
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((uint64_t)window *
						   SCAN_INT_UNIT_US);
}

uint8_t ull_scan_enable(struct ll_scan_set *scan)
{
    1098:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    109c:	4604      	mov	r4, r0
	uint32_t volatile ret_cb;
	uint32_t ticks_interval;
	uint32_t ticks_anchor;
	uint32_t ret;

	lll->init_addr_type = scan->own_addr_type;
    109e:	f890 0044 	ldrb.w	r0, [r0, #68]	; 0x44
    10a2:	f894 3020 	ldrb.w	r3, [r4, #32]
	lll->is_stop = 0U;

	ull_hdr_init(&scan->ull);
	lll_hdr_init(lll, scan);

	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
    10a6:	4e44      	ldr	r6, [pc, #272]	; (11b8 <ull_scan_enable+0x120>)
	lll->init_addr_type = scan->own_addr_type;
    10a8:	f3c0 0040 	ubfx	r0, r0, #1, #1
    10ac:	f360 1386 	bfi	r3, r0, #6, #1
{
    10b0:	b08d      	sub	sp, #52	; 0x34
	lll->init_addr_type = scan->own_addr_type;
    10b2:	f884 3020 	strb.w	r3, [r4, #32]
	(void)ll_addr_read(lll->init_addr_type, lll->init_addr);
    10b6:	f104 012e 	add.w	r1, r4, #46	; 0x2e
    10ba:	f00f fdcb 	bl	10c54 <ll_addr_read>
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
    10be:	8ea7      	ldrh	r7, [r4, #52]	; 0x34
	lll->chan = 0U;
    10c0:	f894 3020 	ldrb.w	r3, [r4, #32]

static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
    10c4:	61e4      	str	r4, [r4, #28]
    10c6:	2500      	movs	r5, #0
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
    10c8:	fba7 0106 	umull	r0, r1, r7, r6
    10cc:	f04f 0c91 	mov.w	ip, #145	; 0x91
	lll->chan = 0U;
    10d0:	f003 0379 	and.w	r3, r3, #121	; 0x79
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
    10d4:	fb0c 1107 	mla	r1, ip, r7, r1
	hdr->disabled_cb = hdr->disabled_param = NULL;
    10d8:	e9c4 5505 	strd	r5, r5, [r4, #20]
	lll->chan = 0U;
    10dc:	f884 3020 	strb.w	r3, [r4, #32]
	hdr->ref = 0U;
    10e0:	7025      	strb	r5, [r4, #0]
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
    10e2:	a333      	add	r3, pc, #204	; (adr r3, 11b0 <ull_scan_enable+0x118>)
    10e4:	e9d3 2300 	ldrd	r2, r3, [r3]
    10e8:	f7ff f80a 	bl	100 <__aeabi_uldivmod>
						SCAN_INT_UNIT_US);

	/* TODO: active_to_start feature port */
	scan->ull.ticks_active_to_start = 0U;
	scan->ull.ticks_prepare_to_start =
    10ec:	2331      	movs	r3, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	scan->ull.ticks_preempt_to_start =
    10ee:	e9c4 3502 	strd	r3, r5, [r4, #8]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	if ((lll->ticks_window +
    10f2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	scan->ull.ticks_active_to_start = 0U;
    10f4:	6065      	str	r5, [r4, #4]
	if ((lll->ticks_window +
    10f6:	3309      	adds	r3, #9
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) <
	    (ticks_interval -
    10f8:	f1a0 0231 	sub.w	r2, r0, #49	; 0x31
	if ((lll->ticks_window +
    10fc:	4293      	cmp	r3, r2
		} else {
			scan->ull.ticks_slot = ticks_interval -
				HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
		}

		lll->ticks_window = 0U;
    10fe:	bf28      	it	cs
    1100:	63a5      	strcs	r5, [r4, #56]	; 0x38
	return &ll_scan[handle];
}

uint8_t ull_scan_handle_get(struct ll_scan_set *scan)
{
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    1102:	4d2e      	ldr	r5, [pc, #184]	; (11bc <ull_scan_enable+0x124>)
		scan->ull.ticks_slot =
    1104:	bf34      	ite	cc
    1106:	6123      	strcc	r3, [r4, #16]
			scan->ull.ticks_slot = ticks_interval -
    1108:	6122      	strcs	r2, [r4, #16]
	ticks_interval = HAL_TICKER_US_TO_TICKS((uint64_t)lll->interval *
    110a:	4607      	mov	r7, r0
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    110c:	1b65      	subs	r5, r4, r5
	ticks_anchor = ticker_ticks_now_get();
    110e:	f00f fd9f 	bl	10c50 <ticker_ticks_now_get>
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    1112:	2348      	movs	r3, #72	; 0x48
    1114:	fbb5 f5f3 	udiv	r5, r5, r3
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    1118:	4b29      	ldr	r3, [pc, #164]	; (11c0 <ull_scan_enable+0x128>)
    111a:	e9cd 4306 	strd	r4, r3, [sp, #24]
    111e:	f10d 0b2c 	add.w	fp, sp, #44	; 0x2c
    1122:	4b28      	ldr	r3, [pc, #160]	; (11c4 <ull_scan_enable+0x12c>)
    1124:	f8cd b020 	str.w	fp, [sp, #32]
    1128:	9305      	str	r3, [sp, #20]
    112a:	6923      	ldr	r3, [r4, #16]
    112c:	9304      	str	r3, [sp, #16]
    112e:	f04f 0a00 	mov.w	sl, #0
    1132:	f8cd a00c 	str.w	sl, [sp, #12]
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
    1136:	f8b4 c034 	ldrh.w	ip, [r4, #52]	; 0x34
    113a:	46b1      	mov	r9, r6
	ticks_anchor = ticker_ticks_now_get();
    113c:	4680      	mov	r8, r0
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
    113e:	2191      	movs	r1, #145	; 0x91
    1140:	fbac 0909 	umull	r0, r9, ip, r9
    1144:	fb01 910c 	mla	r1, r1, ip, r9
    1148:	a319      	add	r3, pc, #100	; (adr r3, 11b0 <ull_scan_enable+0x118>)
    114a:	e9d3 2300 	ldrd	r2, r3, [r3]
	ret_cb = TICKER_STATUS_BUSY;
    114e:	2602      	movs	r6, #2
    1150:	960b      	str	r6, [sp, #44]	; 0x2c
			   HAL_TICKER_REMAINDER((uint64_t)lll->interval *
    1152:	f7fe ffd5 	bl	100 <__aeabi_uldivmod>
    1156:	4610      	mov	r0, r2
    1158:	4619      	mov	r1, r3
    115a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    115e:	2300      	movs	r3, #0
    1160:	f7fe ffce 	bl	100 <__aeabi_uldivmod>
			   TICKER_USER_ID_THREAD, TICKER_ID_SCAN_BASE + handle,
    1164:	3505      	adds	r5, #5
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    1166:	b2ed      	uxtb	r5, r5
    1168:	462a      	mov	r2, r5
    116a:	e9cd 7001 	strd	r7, r0, [sp, #4]
    116e:	4643      	mov	r3, r8
    1170:	2103      	movs	r1, #3
    1172:	f8cd a000 	str.w	sl, [sp]
    1176:	4650      	mov	r0, sl
    1178:	f00f fd37 	bl	10bea <ticker_start>
	ret = ull_ticker_status_take(ret, &ret_cb);
    117c:	4659      	mov	r1, fp
    117e:	f005 f9e5 	bl	654c <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
    1182:	4605      	mov	r5, r0
    1184:	b980      	cbnz	r0, 11a8 <ull_scan_enable+0x110>
	scan->is_enabled = 1U;
    1186:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    118a:	f043 0301 	orr.w	r3, r3, #1
    118e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	if (!ull_adv_is_enabled_get(0))
    1192:	f006 f9af 	bl	74f4 <ull_adv_is_enabled_get>
    1196:	4604      	mov	r4, r0
    1198:	b940      	cbnz	r0, 11ac <ull_scan_enable+0x114>
		ull_filter_adv_scan_state_cb(BIT(1));
    119a:	4630      	mov	r0, r6
    119c:	f007 fad4 	bl	8748 <ull_filter_adv_scan_state_cb>
	return 0;
    11a0:	4620      	mov	r0, r4
}
    11a2:	b00d      	add	sp, #52	; 0x34
    11a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
    11a8:	200c      	movs	r0, #12
    11aa:	e7fa      	b.n	11a2 <ull_scan_enable+0x10a>
	return 0;
    11ac:	4628      	mov	r0, r5
    11ae:	e7f8      	b.n	11a2 <ull_scan_enable+0x10a>
    11b0:	1afd498d 	.word	0x1afd498d
    11b4:	00000007 	.word	0x00000007
    11b8:	84e72a00 	.word	0x84e72a00
    11bc:	20001f80 	.word	0x20001f80
    11c0:	00006209 	.word	0x00006209
    11c4:	00007b25 	.word	0x00007b25

000011c8 <ll_scan_params_set>:
{
    11c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    11cc:	4605      	mov	r5, r0
	scan = ull_scan_is_disabled_get(SCAN_HANDLE_1M);
    11ce:	2000      	movs	r0, #0
{
    11d0:	4616      	mov	r6, r2
    11d2:	4698      	mov	r8, r3
	scan = ull_scan_is_disabled_get(SCAN_HANDLE_1M);
    11d4:	f006 fe90 	bl	7ef8 <ull_scan_is_disabled_get>
	if (!scan) {
    11d8:	4604      	mov	r4, r0
    11da:	b3a8      	cbz	r0, 1248 <ll_scan_params_set+0x80>
	phy  = type >> 1;
    11dc:	086b      	lsrs	r3, r5, #1
	if (phy & BT_HCI_LE_EXT_SCAN_PHY_CODED) {
    11de:	f013 0704 	ands.w	r7, r3, #4
    11e2:	d131      	bne.n	1248 <ll_scan_params_set+0x80>
	if (!interval) {
    11e4:	f890 2026 	ldrb.w	r2, [r0, #38]	; 0x26
    11e8:	b931      	cbnz	r1, 11f8 <ll_scan_params_set+0x30>
		lll->phy = 0U;
    11ea:	f367 0202 	bfi	r2, r7, #0, #3
    11ee:	f880 2026 	strb.w	r2, [r0, #38]	; 0x26
}
    11f2:	4638      	mov	r0, r7
    11f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	lll->phy = phy;
    11f8:	f363 0202 	bfi	r2, r3, #0, #3
	scan->own_addr_type = own_addr_type;
    11fc:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
	lll->phy = phy;
    1200:	f880 2026 	strb.w	r2, [r0, #38]	; 0x26
	scan->own_addr_type = own_addr_type;
    1204:	f368 0342 	bfi	r3, r8, #1, #2
    1208:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	lll->filter_policy = filter_policy;
    120c:	f89d 3018 	ldrb.w	r3, [sp, #24]
	lll->interval = interval;
    1210:	8681      	strh	r1, [r0, #52]	; 0x34
	lll->filter_policy = filter_policy;
    1212:	016d      	lsls	r5, r5, #5
    1214:	00db      	lsls	r3, r3, #3
    1216:	f003 0318 	and.w	r3, r3, #24
    121a:	f005 0520 	and.w	r5, r5, #32
    121e:	431d      	orrs	r5, r3
    1220:	f890 3020 	ldrb.w	r3, [r0, #32]
    1224:	f023 0338 	bic.w	r3, r3, #56	; 0x38
    1228:	431d      	orrs	r5, r3
    122a:	f880 5020 	strb.w	r5, [r0, #32]
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((uint64_t)window *
    122e:	480a      	ldr	r0, [pc, #40]	; (1258 <ll_scan_params_set+0x90>)
    1230:	2591      	movs	r5, #145	; 0x91
    1232:	fba6 0100 	umull	r0, r1, r6, r0
    1236:	a306      	add	r3, pc, #24	; (adr r3, 1250 <ll_scan_params_set+0x88>)
    1238:	e9d3 2300 	ldrd	r2, r3, [r3]
    123c:	fb05 1106 	mla	r1, r5, r6, r1
    1240:	f7fe ff5e 	bl	100 <__aeabi_uldivmod>
    1244:	63a0      	str	r0, [r4, #56]	; 0x38
	return 0;
    1246:	e7d4      	b.n	11f2 <ll_scan_params_set+0x2a>
		return BT_HCI_ERR_CMD_DISALLOWED;
    1248:	270c      	movs	r7, #12
    124a:	e7d2      	b.n	11f2 <ll_scan_params_set+0x2a>
    124c:	f3af 8000 	nop.w
    1250:	1afd498d 	.word	0x1afd498d
    1254:	00000007 	.word	0x00000007
    1258:	84e72a00 	.word	0x84e72a00
    125c:	00000000 	.word	0x00000000

00001260 <ull_scan_aux_setup>:

	return 0;
}

void ull_scan_aux_setup(memq_link_t *link, struct node_rx_hdr *rx)
{
    1260:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	is_scan_req = false;
	ftr = &rx->rx_ftr;

	sync_lll = NULL;

	switch (rx->type) {
    1264:	790b      	ldrb	r3, [r1, #4]
    1266:	2b08      	cmp	r3, #8
{
    1268:	b08d      	sub	sp, #52	; 0x34
    126a:	4683      	mov	fp, r0
    126c:	460d      	mov	r5, r1
	switch (rx->type) {
    126e:	f000 808e 	beq.w	138e <ull_scan_aux_setup+0x12e>
    1272:	2b09      	cmp	r3, #9
    1274:	f000 8091 	beq.w	139a <ull_scan_aux_setup+0x13a>
    1278:	2b06      	cmp	r3, #6
    127a:	f040 80f7 	bne.w	146c <ull_scan_aux_setup+0x20c>
	case NODE_RX_TYPE_EXT_1M_REPORT:
		lll_aux = NULL;
		aux = NULL;
		sync_iso = NULL;
		lll = ftr->param;
    127e:	688f      	ldr	r7, [r1, #8]
		scan = HDR_LLL2ULL(lll);
    1280:	f8d7 a000 	ldr.w	sl, [r7]
		sync = sync_create_get(scan);
		phy = BT_HCI_LE_EXT_SCAN_PHY_1M;
    1284:	f04f 0901 	mov.w	r9, #1
	is_scan_req = false;
    1288:	2300      	movs	r3, #0
	sync_lll = NULL;
    128a:	461a      	mov	r2, r3
		break;
	case NODE_RX_TYPE_EXT_CODED_REPORT:
		lll_aux = NULL;
		aux = NULL;
    128c:	461c      	mov	r4, r3
		lll_aux = NULL;
    128e:	461e      	mov	r6, r3
	}

	rx->link = link;
	ftr->extra = NULL;

	ftr->aux_w4next = 0;
    1290:	7ea9      	ldrb	r1, [r5, #26]
	rx->link = link;
    1292:	f8c5 b000 	str.w	fp, [r5]
	ftr->extra = NULL;
    1296:	2000      	movs	r0, #0
	ftr->aux_w4next = 0;
    1298:	f360 1104 	bfi	r1, r0, #4, #1
    129c:	76a9      	strb	r1, [r5, #26]

	pdu = (void *)((struct node_rx_pdu *)rx)->pdu;
	p = (void *)&pdu->adv_ext_ind;
	if (!p->ext_hdr_len) {
    129e:	7fa9      	ldrb	r1, [r5, #30]
	ftr->extra = NULL;
    12a0:	60e8      	str	r0, [r5, #12]
	if (!p->ext_hdr_len) {
    12a2:	0689      	lsls	r1, r1, #26
    12a4:	f000 81c8 	beq.w	1638 <ull_scan_aux_setup+0x3d8>

	/* Regard PDU as invalid if a RFU field is set, we do not know the
	 * size of this future field, hence will cause incorrect calculation of
	 * offset to ACAD field.
	 */
	if (h->rfu) {
    12a8:	f995 001f 	ldrsb.w	r0, [r5, #31]
    12ac:	7fe9      	ldrb	r1, [r5, #31]
    12ae:	2800      	cmp	r0, #0
    12b0:	f2c0 81c2 	blt.w	1638 <ull_scan_aux_setup+0x3d8>
		goto ull_scan_aux_rx_flush;
	}

	ptr = h->data;

	if (h->adv_addr) {
    12b4:	07c8      	lsls	r0, r1, #31
#endif /* !CONFIG_BT_CTLR_PRIVACY */

		}
#endif /* CONFIG_BT_CTLR_SYNC_PERIODIC */

		ptr += BDADDR_SIZE;
    12b6:	bf4c      	ite	mi
    12b8:	f105 0826 	addmi.w	r8, r5, #38	; 0x26
	ptr = h->data;
    12bc:	f105 0820 	addpl.w	r8, r5, #32
	}

	if (h->tgt_addr) {
    12c0:	0788      	lsls	r0, r1, #30
		ptr += BDADDR_SIZE;
    12c2:	bf48      	it	mi
    12c4:	f108 0806 	addmi.w	r8, r8, #6
	}

	if (h->cte_info) {
    12c8:	0748      	lsls	r0, r1, #29
		ptr += sizeof(struct pdu_cte_info);
    12ca:	bf48      	it	mi
    12cc:	f108 0801 	addmi.w	r8, r8, #1
	}

	adi = NULL;
	if (h->adi) {
    12d0:	0708      	lsls	r0, r1, #28
		adi = (void *)ptr;
		ptr += sizeof(*adi);
    12d2:	bf48      	it	mi
    12d4:	f108 0802 	addmi.w	r8, r8, #2
	}

	aux_ptr = NULL;
	if (h->aux_ptr) {
    12d8:	06c9      	lsls	r1, r1, #27
    12da:	f140 80ca 	bpl.w	1472 <ull_scan_aux_setup+0x212>

	/* Do not ULL schedule auxiliary PDU reception if no aux pointer
	 * or aux pointer is zero or scannable advertising has erroneous aux
	 * pointer being present or PHY in the aux pointer is invalid.
	 */
	if (!aux_ptr || !aux_ptr->offs || is_scan_req ||
    12de:	f1b8 0f00 	cmp.w	r8, #0
    12e2:	f000 80c6 	beq.w	1472 <ull_scan_aux_setup+0x212>
    12e6:	f898 1002 	ldrb.w	r1, [r8, #2]
    12ea:	f898 0001 	ldrb.w	r0, [r8, #1]
    12ee:	f001 0c1f 	and.w	ip, r1, #31
    12f2:	ea50 200c 	orrs.w	r0, r0, ip, lsl #8
    12f6:	f000 80bc 	beq.w	1472 <ull_scan_aux_setup+0x212>
    12fa:	2b00      	cmp	r3, #0
    12fc:	f040 80bc 	bne.w	1478 <ull_scan_aux_setup+0x218>
    1300:	295f      	cmp	r1, #95	; 0x5f
    1302:	f200 8199 	bhi.w	1638 <ull_scan_aux_setup+0x3d8>
		}

		goto ull_scan_aux_rx_flush;
	}

	if (!aux) {
    1306:	b9ec      	cbnz	r4, 1344 <ull_scan_aux_setup+0xe4>
	return 0;
}

static inline struct ll_scan_aux_set *aux_acquire(void)
{
	return mem_acquire(&scan_aux_free);
    1308:	4867      	ldr	r0, [pc, #412]	; (14a8 <ull_scan_aux_setup+0x248>)
    130a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    130e:	f00f f987 	bl	10620 <mem_acquire>
		if (!aux) {
    1312:	4604      	mov	r4, r0
    1314:	2800      	cmp	r0, #0
    1316:	f000 81d4 	beq.w	16c2 <ull_scan_aux_setup+0x462>
		aux->rx_head = aux->rx_last = NULL;
    131a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		lll_aux->is_chain_sched = 0U;
    131c:	f890 1020 	ldrb.w	r1, [r0, #32]
		aux->parent = lll ? (void *)lll : (void *)sync_lll;
    1320:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    1322:	7003      	strb	r3, [r0, #0]
		lll_aux->is_chain_sched = 0U;
    1324:	f363 11c7 	bfi	r1, r3, #7, #1
		aux->rx_head = aux->rx_last = NULL;
    1328:	e9c0 330b 	strd	r3, r3, [r0, #44]	; 0x2c
	hdr->disabled_cb = hdr->disabled_param = NULL;
    132c:	e9c0 3305 	strd	r3, r3, [r0, #20]
		aux->parent = lll ? (void *)lll : (void *)sync_lll;
    1330:	2f00      	cmp	r7, #0
    1332:	bf14      	ite	ne
    1334:	463b      	movne	r3, r7
    1336:	4613      	moveq	r3, r2
		lll_aux = &aux->lll;
    1338:	f100 061c 	add.w	r6, r0, #28
		lll_aux->is_chain_sched = 0U;
    133c:	f880 1020 	strb.w	r1, [r0, #32]
    1340:	61c0      	str	r0, [r0, #28]
		aux->parent = lll ? (void *)lll : (void *)sync_lll;
    1342:	6283      	str	r3, [r0, #40]	; 0x28
		if (aux->rx_last) {
    1344:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1346:	2b00      	cmp	r3, #0
    1348:	f000 80ac 	beq.w	14a4 <ull_scan_aux_setup+0x244>
			aux->rx_last->rx_ftr.extra = rx;
    134c:	60dd      	str	r5, [r3, #12]
		aux->rx_last = rx;
    134e:	6325      	str	r5, [r4, #48]	; 0x30
	lll_aux->chan = aux_ptr->chan_idx;
    1350:	f898 3000 	ldrb.w	r3, [r8]
    1354:	7931      	ldrb	r1, [r6, #4]
    1356:	f3c3 0305 	ubfx	r3, r3, #0, #6
    135a:	f363 0105 	bfi	r1, r3, #0, #6
	lll_aux->phy = BIT(aux_ptr->phy);
    135e:	f898 3002 	ldrb.w	r3, [r8, #2]
	lll_aux->chan = aux_ptr->chan_idx;
    1362:	7131      	strb	r1, [r6, #4]
	lll_aux->phy = BIT(aux_ptr->phy);
    1364:	0959      	lsrs	r1, r3, #5
    1366:	2301      	movs	r3, #1
    1368:	408b      	lsls	r3, r1
    136a:	7971      	ldrb	r1, [r6, #5]
    136c:	f363 0102 	bfi	r1, r3, #0, #3
    1370:	7171      	strb	r1, [r6, #5]
	ftr->aux_w4next = 1;
    1372:	7eab      	ldrb	r3, [r5, #26]
    1374:	f043 0310 	orr.w	r3, r3, #16
    1378:	76ab      	strb	r3, [r5, #26]
	if (ftr->aux_lll_sched) {
    137a:	f013 0308 	ands.w	r3, r3, #8
    137e:	f000 80a1 	beq.w	14c4 <ull_scan_aux_setup+0x264>
			lll->lll_aux = lll_aux;
    1382:	60fe      	str	r6, [r7, #12]
		lll_aux->state = 0U;
    1384:	7933      	ldrb	r3, [r6, #4]
    1386:	f36f 1386 	bfc	r3, #6, #1
    138a:	7133      	strb	r3, [r6, #4]
		return;
    138c:	e087      	b.n	149e <ull_scan_aux_setup+0x23e>
		lll = ftr->param;
    138e:	688f      	ldr	r7, [r1, #8]
		phy = BT_HCI_LE_EXT_SCAN_PHY_CODED;
    1390:	f04f 0904 	mov.w	r9, #4
		scan = HDR_LLL2ULL(lll);
    1394:	f8d7 a000 	ldr.w	sl, [r7]
		break;
    1398:	e776      	b.n	1288 <ull_scan_aux_setup+0x28>
		if (ull_scan_aux_is_valid_get(HDR_LLL2ULL(ftr->param))) {
    139a:	688e      	ldr	r6, [r1, #8]
    139c:	6834      	ldr	r4, [r6, #0]
    139e:	4620      	mov	r0, r4
    13a0:	f006 ff16 	bl	81d0 <ull_scan_aux_is_valid_get>
    13a4:	b178      	cbz	r0, 13c6 <ull_scan_aux_setup+0x166>
			lll = aux->parent;
    13a6:	6aa7      	ldr	r7, [r4, #40]	; 0x28
		if (lll) {
    13a8:	2f00      	cmp	r7, #0
    13aa:	d036      	beq.n	141a <ull_scan_aux_setup+0x1ba>
			scan = ull_scan_is_valid_get(scan);
    13ac:	6838      	ldr	r0, [r7, #0]
    13ae:	f006 fd8d 	bl	7ecc <ull_scan_is_valid_get>
		phy = lll_aux->phy;
    13b2:	f896 9005 	ldrb.w	r9, [r6, #5]
		if (scan) {
    13b6:	4682      	mov	sl, r0
		phy = lll_aux->phy;
    13b8:	f009 0907 	and.w	r9, r9, #7
		if (scan) {
    13bc:	2800      	cmp	r0, #0
    13be:	d135      	bne.n	142c <ull_scan_aux_setup+0x1cc>
    13c0:	4602      	mov	r2, r0
	is_scan_req = false;
    13c2:	4603      	mov	r3, r0
    13c4:	e764      	b.n	1290 <ull_scan_aux_setup+0x30>
		} else if (ull_scan_is_valid_get(HDR_LLL2ULL(ftr->param))) {
    13c6:	4620      	mov	r0, r4
    13c8:	f006 fd80 	bl	7ecc <ull_scan_is_valid_get>
    13cc:	f8d5 8008 	ldr.w	r8, [r5, #8]
			lll = ftr->param;
    13d0:	4647      	mov	r7, r8
		} else if (ull_scan_is_valid_get(HDR_LLL2ULL(ftr->param))) {
    13d2:	b1f8      	cbz	r0, 1414 <ull_scan_aux_setup+0x1b4>
			lll_aux = lll->lll_aux;
    13d4:	f8d8 600c 	ldr.w	r6, [r8, #12]
			LL_ASSERT(lll_aux);
    13d8:	b95e      	cbnz	r6, 13f2 <ull_scan_aux_setup+0x192>
    13da:	4a34      	ldr	r2, [pc, #208]	; (14ac <ull_scan_aux_setup+0x24c>)
    13dc:	4934      	ldr	r1, [pc, #208]	; (14b0 <ull_scan_aux_setup+0x250>)
    13de:	4835      	ldr	r0, [pc, #212]	; (14b4 <ull_scan_aux_setup+0x254>)
    13e0:	23a1      	movs	r3, #161	; 0xa1
    13e2:	f00e f870 	bl	f4c6 <printk>
    13e6:	4040      	eors	r0, r0
    13e8:	f380 8811 	msr	BASEPRI, r0
    13ec:	f04f 0003 	mov.w	r0, #3
    13f0:	df02      	svc	2
			aux = HDR_LLL2ULL(lll_aux);
    13f2:	6834      	ldr	r4, [r6, #0]
			LL_ASSERT(lll == aux->parent);
    13f4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    13f6:	4543      	cmp	r3, r8
    13f8:	d0d8      	beq.n	13ac <ull_scan_aux_setup+0x14c>
    13fa:	4a2c      	ldr	r2, [pc, #176]	; (14ac <ull_scan_aux_setup+0x24c>)
    13fc:	492e      	ldr	r1, [pc, #184]	; (14b8 <ull_scan_aux_setup+0x258>)
    13fe:	482d      	ldr	r0, [pc, #180]	; (14b4 <ull_scan_aux_setup+0x254>)
    1400:	23a4      	movs	r3, #164	; 0xa4
    1402:	f00e f860 	bl	f4c6 <printk>
    1406:	4040      	eors	r0, r0
    1408:	f380 8811 	msr	BASEPRI, r0
    140c:	f04f 0003 	mov.w	r0, #3
    1410:	df02      	svc	2
    1412:	e7cb      	b.n	13ac <ull_scan_aux_setup+0x14c>
			lll_aux = sync_lll->lll_aux;
    1414:	f8d8 603c 	ldr.w	r6, [r8, #60]	; 0x3c
			aux = HDR_LLL2ULL(lll_aux);
    1418:	6834      	ldr	r4, [r6, #0]
		phy = lll_aux->phy;
    141a:	f896 9005 	ldrb.w	r9, [r6, #5]
    141e:	463a      	mov	r2, r7
	is_scan_req = false;
    1420:	2700      	movs	r7, #0
		phy = lll_aux->phy;
    1422:	f009 0907 	and.w	r9, r9, #7
    1426:	463b      	mov	r3, r7
			scan = NULL;
    1428:	46ba      	mov	sl, r7
    142a:	e731      	b.n	1290 <ull_scan_aux_setup+0x30>
			switch (phy) {
    142c:	f1b9 0f02 	cmp.w	r9, #2
    1430:	d00b      	beq.n	144a <ull_scan_aux_setup+0x1ea>
    1432:	f1b9 0f04 	cmp.w	r9, #4
    1436:	d00a      	beq.n	144e <ull_scan_aux_setup+0x1ee>
    1438:	f1b9 0f01 	cmp.w	r9, #1
    143c:	d109      	bne.n	1452 <ull_scan_aux_setup+0x1f2>
				rx->type = NODE_RX_TYPE_EXT_1M_REPORT;
    143e:	2306      	movs	r3, #6
				rx->type = NODE_RX_TYPE_EXT_CODED_REPORT;
    1440:	712b      	strb	r3, [r5, #4]
			is_scan_req = !!ftr->scan_req;
    1442:	7eab      	ldrb	r3, [r5, #26]
    1444:	2200      	movs	r2, #0
    1446:	09db      	lsrs	r3, r3, #7
    1448:	e722      	b.n	1290 <ull_scan_aux_setup+0x30>
				rx->type = NODE_RX_TYPE_EXT_2M_REPORT;
    144a:	2307      	movs	r3, #7
    144c:	e7f8      	b.n	1440 <ull_scan_aux_setup+0x1e0>
				rx->type = NODE_RX_TYPE_EXT_CODED_REPORT;
    144e:	2308      	movs	r3, #8
    1450:	e7f6      	b.n	1440 <ull_scan_aux_setup+0x1e0>
				LL_ASSERT(0);
    1452:	23cc      	movs	r3, #204	; 0xcc
		LL_ASSERT(0);
    1454:	4a15      	ldr	r2, [pc, #84]	; (14ac <ull_scan_aux_setup+0x24c>)
    1456:	4919      	ldr	r1, [pc, #100]	; (14bc <ull_scan_aux_setup+0x25c>)
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    1458:	4816      	ldr	r0, [pc, #88]	; (14b4 <ull_scan_aux_setup+0x254>)
    145a:	f00e f834 	bl	f4c6 <printk>
    145e:	4040      	eors	r0, r0
    1460:	f380 8811 	msr	BASEPRI, r0
    1464:	f04f 0003 	mov.w	r0, #3
    1468:	df02      	svc	2
    146a:	e018      	b.n	149e <ull_scan_aux_setup+0x23e>
		LL_ASSERT(0);
    146c:	f44f 7383 	mov.w	r3, #262	; 0x106
    1470:	e7f0      	b.n	1454 <ull_scan_aux_setup+0x1f4>
		if (is_scan_req) {
    1472:	2b00      	cmp	r3, #0
    1474:	f000 80e0 	beq.w	1638 <ull_scan_aux_setup+0x3d8>
			LL_ASSERT(aux && aux->rx_last);
    1478:	b10c      	cbz	r4, 147e <ull_scan_aux_setup+0x21e>
    147a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    147c:	b963      	cbnz	r3, 1498 <ull_scan_aux_setup+0x238>
    147e:	4a0b      	ldr	r2, [pc, #44]	; (14ac <ull_scan_aux_setup+0x24c>)
    1480:	490f      	ldr	r1, [pc, #60]	; (14c0 <ull_scan_aux_setup+0x260>)
    1482:	480c      	ldr	r0, [pc, #48]	; (14b4 <ull_scan_aux_setup+0x254>)
    1484:	f240 137f 	movw	r3, #383	; 0x17f
    1488:	f00e f81d 	bl	f4c6 <printk>
    148c:	4040      	eors	r0, r0
    148e:	f380 8811 	msr	BASEPRI, r0
    1492:	f04f 0003 	mov.w	r0, #3
    1496:	df02      	svc	2
			aux->rx_last->rx_ftr.extra = rx;
    1498:	6b23      	ldr	r3, [r4, #48]	; 0x30
    149a:	60dd      	str	r5, [r3, #12]
			aux->rx_last = rx;
    149c:	6325      	str	r5, [r4, #48]	; 0x30
}
    149e:	b00d      	add	sp, #52	; 0x34
    14a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			aux->rx_head = rx;
    14a4:	62e5      	str	r5, [r4, #44]	; 0x2c
    14a6:	e752      	b.n	134e <ull_scan_aux_setup+0xee>
    14a8:	2000202c 	.word	0x2000202c
    14ac:	00013972 	.word	0x00013972
    14b0:	000139b6 	.word	0x000139b6
    14b4:	000133b6 	.word	0x000133b6
    14b8:	000139be 	.word	0x000139be
    14bc:	00014086 	.word	0x00014086
    14c0:	000139d1 	.word	0x000139d1
	if (lll) {
    14c4:	2f00      	cmp	r7, #0
    14c6:	f000 80a6 	beq.w	1616 <ull_scan_aux_setup+0x3b6>
		lll->lll_aux = NULL;
    14ca:	60fb      	str	r3, [r7, #12]
	if (aux_ptr->offs_units) {
    14cc:	f998 3000 	ldrsb.w	r3, [r8]
	aux_offset_us = (uint32_t)aux_ptr->offs * lll_aux->window_size_us;
    14d0:	f898 7002 	ldrb.w	r7, [r8, #2]
	if (aux_ptr->offs_units) {
    14d4:	f898 2000 	ldrb.w	r2, [r8]
	aux_offset_us = (uint32_t)aux_ptr->offs * lll_aux->window_size_us;
    14d8:	f898 b001 	ldrb.w	fp, [r8, #1]
    14dc:	4880      	ldr	r0, [pc, #512]	; (16e0 <ull_scan_aux_setup+0x480>)
		lll_aux->window_size_us = OFFS_UNIT_300_US;
    14de:	2b00      	cmp	r3, #0
	aux_offset_us = (uint32_t)aux_ptr->offs * lll_aux->window_size_us;
    14e0:	f007 071f 	and.w	r7, r7, #31
		lll_aux->window_size_us = OFFS_UNIT_300_US;
    14e4:	bfac      	ite	ge
    14e6:	231e      	movge	r3, #30
    14e8:	f44f 7396 	movlt.w	r3, #300	; 0x12c
	aux_offset_us = (uint32_t)aux_ptr->offs * lll_aux->window_size_us;
    14ec:	ea4b 2b07 	orr.w	fp, fp, r7, lsl #8
	if (aux_ptr->ca) {
    14f0:	f012 0f40 	tst.w	r2, #64	; 0x40
		window_widening_us = SCA_DRIFT_50_PPM_US(aux_offset_us);
    14f4:	bf14      	ite	ne
    14f6:	2232      	movne	r2, #50	; 0x32
		window_widening_us = SCA_DRIFT_500_PPM_US(aux_offset_us);
    14f8:	f44f 72fa 	moveq.w	r2, #500	; 0x1f4
	aux_offset_us = (uint32_t)aux_ptr->offs * lll_aux->window_size_us;
    14fc:	fb03 fb0b 	mul.w	fp, r3, fp
		window_widening_us = SCA_DRIFT_500_PPM_US(aux_offset_us);
    1500:	fb02 f20b 	mul.w	r2, r2, fp
    1504:	fbb2 f8f0 	udiv	r8, r2, r0
	ready_delay_us = lll_radio_rx_ready_delay_get(lll_aux->phy, 1);
    1508:	7970      	ldrb	r0, [r6, #5]
	lll_aux->window_size_us += (EVENT_TICKER_RES_MARGIN_US +
    150a:	eb03 0348 	add.w	r3, r3, r8, lsl #1
    150e:	3340      	adds	r3, #64	; 0x40
    1510:	60b3      	str	r3, [r6, #8]
	ready_delay_us = lll_radio_rx_ready_delay_get(lll_aux->phy, 1);
    1512:	2101      	movs	r1, #1
    1514:	f000 0007 	and.w	r0, r0, #7
    1518:	f010 f960 	bl	117dc <lll_radio_rx_ready_delay_get>
	aux_offset_us -= PDU_AC_US(pdu->len, phy, ftr->phy_flags);
    151c:	7f6f      	ldrb	r7, [r5, #29]
	aux_offset_us -= EVENT_JITTER_US;
    151e:	696b      	ldr	r3, [r5, #20]
	aux_offset_us -= PDU_AC_US(pdu->len, phy, ftr->phy_flags);
    1520:	f009 0203 	and.w	r2, r9, #3
    1524:	3709      	adds	r7, #9
    1526:	4417      	add	r7, r2
    1528:	00ff      	lsls	r7, r7, #3
    152a:	f3c9 0940 	ubfx	r9, r9, #1, #1
	aux_offset_us -= EVENT_JITTER_US;
    152e:	3b10      	subs	r3, #16
	aux_offset_us -= PDU_AC_US(pdu->len, phy, ftr->phy_flags);
    1530:	fa27 f909 	lsr.w	r9, r7, r9
	aux_offset_us -= EVENT_JITTER_US;
    1534:	eba3 0909 	sub.w	r9, r3, r9
    1538:	eb09 070b 	add.w	r7, r9, fp
	aux->ull.ticks_prepare_to_start =
    153c:	2331      	movs	r3, #49	; 0x31
    153e:	f04f 0900 	mov.w	r9, #0
    1542:	e9c4 9301 	strd	r9, r3, [r4, #4]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    1546:	7973      	ldrb	r3, [r6, #5]
    1548:	4e66      	ldr	r6, [pc, #408]	; (16e4 <ull_scan_aux_setup+0x484>)
	aux->ull.ticks_preempt_to_start =
    154a:	f8c4 900c 	str.w	r9, [r4, #12]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    154e:	f003 0103 	and.w	r1, r3, #3
    1552:	f501 7184 	add.w	r1, r1, #264	; 0x108
    1556:	f3c3 0340 	ubfx	r3, r3, #1, #1
    155a:	00c9      	lsls	r1, r1, #3
    155c:	40d9      	lsrs	r1, r3
    155e:	f501 71c8 	add.w	r1, r1, #400	; 0x190
	aux_offset_us -= ready_delay_us;
    1562:	1a3f      	subs	r7, r7, r0
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    1564:	4408      	add	r0, r1
    1566:	a35c      	add	r3, pc, #368	; (adr r3, 16d8 <ull_scan_aux_setup+0x478>)
    1568:	e9d3 2300 	ldrd	r2, r3, [r3]
    156c:	fba0 0106 	umull	r0, r1, r0, r6
    1570:	f7fe fdc6 	bl	100 <__aeabi_uldivmod>
    1574:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	aux->ull.ticks_slot =
    1578:	6120      	str	r0, [r4, #16]
	aux_offset_us -= window_widening_us;
    157a:	eba7 0008 	sub.w	r0, r7, r8
	ticks_aux_offset = HAL_TICKER_US_TO_TICKS(aux_offset_us);
    157e:	fba0 0106 	umull	r0, r1, r0, r6
    1582:	a355      	add	r3, pc, #340	; (adr r3, 16d8 <ull_scan_aux_setup+0x478>)
    1584:	e9d3 2300 	ldrd	r2, r3, [r3]
    1588:	f7fe fdba 	bl	100 <__aeabi_uldivmod>
    158c:	f020 467f 	bic.w	r6, r0, #4278190080	; 0xff000000
	if (scan) {
    1590:	f1ba 0f00 	cmp.w	sl, #0
    1594:	d01d      	beq.n	15d2 <ull_scan_aux_setup+0x372>
		handle = ull_scan_handle_get(scan);
    1596:	4650      	mov	r0, sl
    1598:	f006 fc84 	bl	7ea4 <ull_scan_handle_get>
		ticker_status = ticker_yield_abs(TICKER_INSTANCE_ID_CTLR,
    159c:	692b      	ldr	r3, [r5, #16]
						 (TICKER_ID_SCAN_BASE + handle),
    159e:	1d42      	adds	r2, r0, #5
		ticker_status = ticker_yield_abs(TICKER_INSTANCE_ID_CTLR,
    15a0:	3b3a      	subs	r3, #58	; 0x3a
    15a2:	4433      	add	r3, r6
    15a4:	e9cd 9900 	strd	r9, r9, [sp]
    15a8:	b2d2      	uxtb	r2, r2
    15aa:	2101      	movs	r1, #1
    15ac:	4648      	mov	r0, r9
    15ae:	f003 fabf 	bl	4b30 <ticker_yield_abs>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    15b2:	f030 0302 	bics.w	r3, r0, #2
    15b6:	d00c      	beq.n	15d2 <ull_scan_aux_setup+0x372>
    15b8:	4a4b      	ldr	r2, [pc, #300]	; (16e8 <ull_scan_aux_setup+0x488>)
    15ba:	494c      	ldr	r1, [pc, #304]	; (16ec <ull_scan_aux_setup+0x48c>)
    15bc:	484c      	ldr	r0, [pc, #304]	; (16f0 <ull_scan_aux_setup+0x490>)
    15be:	f240 2317 	movw	r3, #535	; 0x217
    15c2:	f00d ff80 	bl	f4c6 <printk>
    15c6:	4040      	eors	r0, r0
    15c8:	f380 8811 	msr	BASEPRI, r0
    15cc:	f04f 0003 	mov.w	r0, #3
    15d0:	df02      	svc	2
	mem_release(aux, &scan_aux_free);
}

static inline uint8_t aux_handle_get(struct ll_scan_aux_set *aux)
{
	return mem_index_get(aux, ll_scan_aux_pool,
    15d2:	4948      	ldr	r1, [pc, #288]	; (16f4 <ull_scan_aux_setup+0x494>)
    15d4:	2234      	movs	r2, #52	; 0x34
    15d6:	4620      	mov	r0, r4
    15d8:	f00f f850 	bl	1067c <mem_index_get>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    15dc:	4946      	ldr	r1, [pc, #280]	; (16f8 <ull_scan_aux_setup+0x498>)
    15de:	692b      	ldr	r3, [r5, #16]
    15e0:	9408      	str	r4, [sp, #32]
    15e2:	e9cd 4106 	strd	r4, r1, [sp, #24]
    15e6:	4945      	ldr	r1, [pc, #276]	; (16fc <ull_scan_aux_setup+0x49c>)
    15e8:	9105      	str	r1, [sp, #20]
    15ea:	6921      	ldr	r1, [r4, #16]
    15ec:	9104      	str	r1, [sp, #16]
				     TICKER_ID_SCAN_AUX_BASE + aux_handle,
    15ee:	1d82      	adds	r2, r0, #6
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    15f0:	2000      	movs	r0, #0
    15f2:	3b3a      	subs	r3, #58	; 0x3a
    15f4:	e9cd 0002 	strd	r0, r0, [sp, #8]
    15f8:	e9cd 6000 	strd	r6, r0, [sp]
    15fc:	b2d2      	uxtb	r2, r2
    15fe:	2101      	movs	r1, #1
    1600:	f00f faf3 	bl	10bea <ticker_start>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    1604:	f030 0302 	bics.w	r3, r0, #2
    1608:	f43f af49 	beq.w	149e <ull_scan_aux_setup+0x23e>
    160c:	4a36      	ldr	r2, [pc, #216]	; (16e8 <ull_scan_aux_setup+0x488>)
    160e:	4937      	ldr	r1, [pc, #220]	; (16ec <ull_scan_aux_setup+0x48c>)
    1610:	f44f 730a 	mov.w	r3, #552	; 0x228
    1614:	e720      	b.n	1458 <ull_scan_aux_setup+0x1f8>
		LL_ASSERT(sync_lll);
    1616:	2a00      	cmp	r2, #0
    1618:	f47f af58 	bne.w	14cc <ull_scan_aux_setup+0x26c>
    161c:	4a32      	ldr	r2, [pc, #200]	; (16e8 <ull_scan_aux_setup+0x488>)
    161e:	4938      	ldr	r1, [pc, #224]	; (1700 <ull_scan_aux_setup+0x4a0>)
    1620:	4833      	ldr	r0, [pc, #204]	; (16f0 <ull_scan_aux_setup+0x490>)
    1622:	f240 13cb 	movw	r3, #459	; 0x1cb
    1626:	f00d ff4e 	bl	f4c6 <printk>
    162a:	4040      	eors	r0, r0
    162c:	f380 8811 	msr	BASEPRI, r0
    1630:	f04f 0003 	mov.w	r0, #3
    1634:	df02      	svc	2
    1636:	e749      	b.n	14cc <ull_scan_aux_setup+0x26c>
	if (aux) {
    1638:	2c00      	cmp	r4, #0
    163a:	d042      	beq.n	16c2 <ull_scan_aux_setup+0x462>
		if (aux->rx_last) {
    163c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    163e:	b1c3      	cbz	r3, 1672 <ull_scan_aux_setup+0x412>
			aux->rx_last->rx_ftr.extra = rx;
    1640:	60dd      	str	r5, [r3, #12]
	return hdr->ref;
    1642:	7823      	ldrb	r3, [r4, #0]
		LL_ASSERT(ull_ref_get(hdr) < 2);
    1644:	2b01      	cmp	r3, #1
    1646:	d90c      	bls.n	1662 <ull_scan_aux_setup+0x402>
    1648:	4a27      	ldr	r2, [pc, #156]	; (16e8 <ull_scan_aux_setup+0x488>)
    164a:	492e      	ldr	r1, [pc, #184]	; (1704 <ull_scan_aux_setup+0x4a4>)
    164c:	4828      	ldr	r0, [pc, #160]	; (16f0 <ull_scan_aux_setup+0x490>)
    164e:	f44f 7313 	mov.w	r3, #588	; 0x24c
    1652:	f00d ff38 	bl	f4c6 <printk>
    1656:	4040      	eors	r0, r0
    1658:	f380 8811 	msr	BASEPRI, r0
    165c:	f04f 0003 	mov.w	r0, #3
    1660:	df02      	svc	2
    1662:	7823      	ldrb	r3, [r4, #0]
		if (ull_ref_get(hdr) == 0) {
    1664:	b9d3      	cbnz	r3, 169c <ull_scan_aux_setup+0x43c>
			flush(aux);
    1666:	4620      	mov	r0, r4
}
    1668:	b00d      	add	sp, #52	; 0x34
    166a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			flush(aux);
    166e:	f006 bd43 	b.w	80f8 <flush>
			LL_ASSERT(sync_lll);
    1672:	b962      	cbnz	r2, 168e <ull_scan_aux_setup+0x42e>
    1674:	4a1c      	ldr	r2, [pc, #112]	; (16e8 <ull_scan_aux_setup+0x488>)
    1676:	4922      	ldr	r1, [pc, #136]	; (1700 <ull_scan_aux_setup+0x4a0>)
    1678:	481d      	ldr	r0, [pc, #116]	; (16f0 <ull_scan_aux_setup+0x490>)
    167a:	f240 233d 	movw	r3, #573	; 0x23d
    167e:	f00d ff22 	bl	f4c6 <printk>
    1682:	4040      	eors	r0, r0
    1684:	f380 8811 	msr	BASEPRI, r0
    1688:	f04f 0003 	mov.w	r0, #3
    168c:	df02      	svc	2
			ll_rx_put(link, rx);
    168e:	4629      	mov	r1, r5
    1690:	4658      	mov	r0, fp
    1692:	f004 fee3 	bl	645c <ll_rx_put>
			ll_rx_sched();
    1696:	f004 fee7 	bl	6468 <ll_rx_sched>
    169a:	e7d2      	b.n	1642 <ull_scan_aux_setup+0x3e2>
			LL_ASSERT(!hdr->disabled_cb);
    169c:	6963      	ldr	r3, [r4, #20]
    169e:	b163      	cbz	r3, 16ba <ull_scan_aux_setup+0x45a>
    16a0:	4a11      	ldr	r2, [pc, #68]	; (16e8 <ull_scan_aux_setup+0x488>)
    16a2:	4919      	ldr	r1, [pc, #100]	; (1708 <ull_scan_aux_setup+0x4a8>)
    16a4:	4812      	ldr	r0, [pc, #72]	; (16f0 <ull_scan_aux_setup+0x490>)
    16a6:	f44f 7314 	mov.w	r3, #592	; 0x250
    16aa:	f00d ff0c 	bl	f4c6 <printk>
    16ae:	4040      	eors	r0, r0
    16b0:	f380 8811 	msr	BASEPRI, r0
    16b4:	f04f 0003 	mov.w	r0, #3
    16b8:	df02      	svc	2
			hdr->disabled_cb = last_disabled_cb;
    16ba:	4b14      	ldr	r3, [pc, #80]	; (170c <ull_scan_aux_setup+0x4ac>)
			hdr->disabled_param = aux;
    16bc:	61a4      	str	r4, [r4, #24]
			hdr->disabled_cb = last_disabled_cb;
    16be:	6163      	str	r3, [r4, #20]
    16c0:	e6ed      	b.n	149e <ull_scan_aux_setup+0x23e>
	ll_rx_put(link, rx);
    16c2:	4629      	mov	r1, r5
    16c4:	4658      	mov	r0, fp
    16c6:	f004 fec9 	bl	645c <ll_rx_put>
}
    16ca:	b00d      	add	sp, #52	; 0x34
    16cc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	ll_rx_sched();
    16d0:	f004 beca 	b.w	6468 <ll_rx_sched>
    16d4:	f3af 8000 	nop.w
    16d8:	1afd498d 	.word	0x1afd498d
    16dc:	00000007 	.word	0x00000007
    16e0:	000f4240 	.word	0x000f4240
    16e4:	3b9aca00 	.word	0x3b9aca00
    16e8:	00013972 	.word	0x00013972
    16ec:	000139ee 	.word	0x000139ee
    16f0:	000133b6 	.word	0x000133b6
    16f4:	20001fe8 	.word	0x20001fe8
    16f8:	00008125 	.word	0x00008125
    16fc:	00008075 	.word	0x00008075
    1700:	000139e5 	.word	0x000139e5
    1704:	00013a1b 	.word	0x00013a1b
    1708:	000137a1 	.word	0x000137a1
    170c:	0001168d 	.word	0x0001168d

00001710 <main>:
const struct bt_data ad2[] = {BT_DATA(0xff, mfg_data2, 8)
};


void main(void)
{
    1710:	b570      	push	{r4, r5, r6, lr}
    1712:	b0be      	sub	sp, #248	; 0xf8
    timing_t start_time, end_time;
    uint64_t time_in_ns;
    uint64_t cycles; 
    
    // start time measurement
    timing_init();
    1714:	f00b f8d2 	bl	c8bc <timing_init>
    timing_start();
    1718:	f00b f8dc 	bl	c8d4 <timing_start>
#if defined(CONFIG_BOARD_HAS_TIMING_FUNCTIONS)
	return board_timing_counter_get();
#elif defined(CONFIG_SOC_HAS_TIMING_FUNCTIONS)
	return soc_timing_counter_get();
#else
	return arch_timing_counter_get();
    171c:	f001 f96c 	bl	29f8 <arch_timing_counter_get>
    start_time = timing_counter_get();
    1720:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30

	int err;

	printk("Starting Broadcaster\n");
    1724:	485b      	ldr	r0, [pc, #364]	; (1894 <main+0x184>)
    1726:	f00d fece 	bl	f4c6 <printk>

    // Initialize BLE 
    err = bt_enable(NULL);
    172a:	2000      	movs	r0, #0
    172c:	f001 ff04 	bl	3538 <bt_enable>
	if (err) {
    1730:	4604      	mov	r4, r0
    1732:	b128      	cbz	r0, 1740 <main+0x30>
		printk("Bluetooth init failed (err %d)\n", err);
    1734:	4601      	mov	r1, r0
    1736:	4858      	ldr	r0, [pc, #352]	; (1898 <main+0x188>)

    // set new data to adv set 
    err = bt_le_ext_adv_set_data(adv, ad2, ARRAY_SIZE(ad2),
            NULL, 0);
    if(err){
        printk("Failed to set data for adv (err %d)\n",
    1738:	f00d fec5 	bl	f4c6 <printk>
	
	do {
		k_msleep(100);

	} while (1);
}
    173c:	b03e      	add	sp, #248	; 0xf8
    173e:	bd70      	pop	{r4, r5, r6, pc}
	printk("Bluetooth initialized\n");
    1740:	4856      	ldr	r0, [pc, #344]	; (189c <main+0x18c>)
    1742:	f00d fec0 	bl	f4c6 <printk>
	switch (addr->type) {
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
    1746:	ae18      	add	r6, sp, #96	; 0x60
    bt_addr_le_t receiver_addr = {
    1748:	2322      	movs	r3, #34	; 0x22
    174a:	4955      	ldr	r1, [pc, #340]	; (18a0 <main+0x190>)
    174c:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    1750:	2501      	movs	r5, #1
    1752:	23c0      	movs	r3, #192	; 0xc0
    1754:	4630      	mov	r0, r6
    1756:	f88d 402a 	strb.w	r4, [sp, #42]	; 0x2a
    175a:	f88d 402b 	strb.w	r4, [sp, #43]	; 0x2b
    175e:	f88d 402c 	strb.w	r4, [sp, #44]	; 0x2c
    1762:	f88d 402d 	strb.w	r4, [sp, #45]	; 0x2d
    1766:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    176a:	f88d 5028 	strb.w	r5, [sp, #40]	; 0x28
    176e:	f00e f9cb 	bl	fb08 <strcpy>
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    1772:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
    1776:	9304      	str	r3, [sp, #16]
    1778:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
    177c:	9303      	str	r3, [sp, #12]
    177e:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    1782:	9302      	str	r3, [sp, #8]
    1784:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    1788:	9301      	str	r3, [sp, #4]
    178a:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
    178e:	4a45      	ldr	r2, [pc, #276]	; (18a4 <main+0x194>)
    1790:	9300      	str	r3, [sp, #0]
    1792:	2181      	movs	r1, #129	; 0x81
    1794:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    1798:	9605      	str	r6, [sp, #20]
    179a:	a81d      	add	r0, sp, #116	; 0x74
    179c:	f00d fea0 	bl	f4e0 <snprintk>
    printk("Sending to node with identity: %s", r_identity); 
    17a0:	4841      	ldr	r0, [pc, #260]	; (18a8 <main+0x198>)
    17a2:	a91d      	add	r1, sp, #116	; 0x74
    17a4:	f00d fe8f 	bl	f4c6 <printk>
    struct bt_le_adv_param params = {
    17a8:	f44f 6282 	mov.w	r2, #1040	; 0x410
    17ac:	2330      	movs	r3, #48	; 0x30
    17ae:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
    17b2:	2360      	movs	r3, #96	; 0x60
    17b4:	931b      	str	r3, [sp, #108]	; 0x6c
	err = bt_le_ext_adv_create(
    17b6:	4621      	mov	r1, r4
    struct bt_le_adv_param params = {
    17b8:	ab0a      	add	r3, sp, #40	; 0x28
	err = bt_le_ext_adv_create(
    17ba:	aa07      	add	r2, sp, #28
    17bc:	4630      	mov	r0, r6
    struct bt_le_adv_param params = {
    17be:	9418      	str	r4, [sp, #96]	; 0x60
    17c0:	931c      	str	r3, [sp, #112]	; 0x70
	err = bt_le_ext_adv_create(
    17c2:	f002 f99b 	bl	3afc <bt_le_ext_adv_create>
    if(err){
    17c6:	4604      	mov	r4, r0
    17c8:	b110      	cbz	r0, 17d0 <main+0xc0>
        printk("Failed to create advertising set (err %d)\n",
    17ca:	4601      	mov	r1, r0
    17cc:	4837      	ldr	r0, [pc, #220]	; (18ac <main+0x19c>)
    17ce:	e7b3      	b.n	1738 <main+0x28>
    17d0:	f001 f912 	bl	29f8 <arch_timing_counter_get>
    end_time = timing_counter_get(); 
    17d4:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
#if defined(CONFIG_BOARD_HAS_TIMING_FUNCTIONS)
	return board_timing_cycles_get(start, end);
#elif defined(CONFIG_SOC_HAS_TIMING_FUNCTIONS)
	return soc_timing_cycles_get(start, end);
#else
	return arch_timing_cycles_get(start, end);
    17d8:	a90e      	add	r1, sp, #56	; 0x38
    17da:	a80c      	add	r0, sp, #48	; 0x30
    17dc:	f00e f97b 	bl	fad6 <arch_timing_cycles_get>
#if defined(CONFIG_BOARD_HAS_TIMING_FUNCTIONS)
	return board_timing_cycles_to_ns(cycles);
#elif defined(CONFIG_SOC_HAS_TIMING_FUNCTIONS)
	return soc_timing_cycles_to_ns(cycles);
#else
	return arch_timing_cycles_to_ns(cycles);
    17e0:	f00e f982 	bl	fae8 <arch_timing_cycles_to_ns>
    17e4:	460b      	mov	r3, r1
    time_in_ns = timing_cycles_to_ns(cycles); 
    17e6:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
    17ea:	4602      	mov	r2, r0
    printk("Measured start time: %llu", time_in_ns); 
    17ec:	4830      	ldr	r0, [pc, #192]	; (18b0 <main+0x1a0>)
    17ee:	f00d fe6a 	bl	f4c6 <printk>
    memcpy(&mfg_data[1], &time_in_ns, sizeof(time_in_ns));
    17f2:	2208      	movs	r2, #8
    17f4:	a910      	add	r1, sp, #64	; 0x40
    17f6:	f10d 0055 	add.w	r0, sp, #85	; 0x55
    17fa:	f00e f9d4 	bl	fba6 <memcpy>
    const struct bt_data ad[] = {BT_DATA(0xff, mfg_data, 9)
    17fe:	f640 13ff 	movw	r3, #2559	; 0x9ff
    1802:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
    1806:	ab15      	add	r3, sp, #84	; 0x54
    1808:	9314      	str	r3, [sp, #80]	; 0x50
    err = bt_le_ext_adv_set_data(adv, ad, ARRAY_SIZE(ad),
    180a:	a913      	add	r1, sp, #76	; 0x4c
    180c:	9807      	ldr	r0, [sp, #28]
    180e:	9400      	str	r4, [sp, #0]
    1810:	4623      	mov	r3, r4
    1812:	462a      	mov	r2, r5
    mfg_data[0] = 0x00; 
    1814:	f88d 4054 	strb.w	r4, [sp, #84]	; 0x54
    err = bt_le_ext_adv_set_data(adv, ad, ARRAY_SIZE(ad),
    1818:	f00e fe61 	bl	104de <bt_le_ext_adv_set_data>
    if(err){
    181c:	4601      	mov	r1, r0
    181e:	b108      	cbz	r0, 1824 <main+0x114>
        printk("Failed to set adv data (err %d)\n",
    1820:	4824      	ldr	r0, [pc, #144]	; (18b4 <main+0x1a4>)
    1822:	e789      	b.n	1738 <main+0x28>
        BT_LE_EXT_ADV_START_PARAM(0, 3));
    1824:	f8ad 0020 	strh.w	r0, [sp, #32]
    1828:	2303      	movs	r3, #3
    err = bt_le_ext_adv_start(adv,
    182a:	a908      	add	r1, sp, #32
    182c:	9807      	ldr	r0, [sp, #28]
        BT_LE_EXT_ADV_START_PARAM(0, 3));
    182e:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    err = bt_le_ext_adv_start(adv,
    1832:	f00e fe79 	bl	10528 <bt_le_ext_adv_start>
    if (err) {
    1836:	4601      	mov	r1, r0
    1838:	b108      	cbz	r0, 183e <main+0x12e>
        printk("Advertising failed to start (err %d)\n", err);
    183a:	481f      	ldr	r0, [pc, #124]	; (18b8 <main+0x1a8>)
    183c:	e77c      	b.n	1738 <main+0x28>
		/* coverity[OVERRUN] */
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
    183e:	2100      	movs	r1, #0
    1840:	f640 40cd 	movw	r0, #3277	; 0xccd
    1844:	f00d fb4a 	bl	eedc <z_impl_k_sleep>
    err = bt_le_adv_stop();
    1848:	f002 f932 	bl	3ab0 <bt_le_adv_stop>
    if (err) {
    184c:	4603      	mov	r3, r0
    184e:	b110      	cbz	r0, 1856 <main+0x146>
        printk("Advertising failed to stop (err %d)\n", err);
    1850:	4601      	mov	r1, r0
    1852:	481a      	ldr	r0, [pc, #104]	; (18bc <main+0x1ac>)
    1854:	e770      	b.n	1738 <main+0x28>
    err = bt_le_ext_adv_set_data(adv, ad2, ARRAY_SIZE(ad2),
    1856:	9000      	str	r0, [sp, #0]
    1858:	4919      	ldr	r1, [pc, #100]	; (18c0 <main+0x1b0>)
    185a:	9807      	ldr	r0, [sp, #28]
    185c:	462a      	mov	r2, r5
    185e:	f00e fe3e 	bl	104de <bt_le_ext_adv_set_data>
    if(err){
    1862:	4604      	mov	r4, r0
    1864:	b110      	cbz	r0, 186c <main+0x15c>
        printk("Failed to set data for adv (err %d)\n",
    1866:	4601      	mov	r1, r0
    1868:	4816      	ldr	r0, [pc, #88]	; (18c4 <main+0x1b4>)
    186a:	e765      	b.n	1738 <main+0x28>
    printk("Second message advertising...\n");
    186c:	4816      	ldr	r0, [pc, #88]	; (18c8 <main+0x1b8>)
    186e:	f00d fe2a 	bl	f4c6 <printk>
            BT_LE_EXT_ADV_START_PARAM(0, 15));
    1872:	250f      	movs	r5, #15
        err = bt_le_ext_adv_start(adv,
    1874:	9807      	ldr	r0, [sp, #28]
            BT_LE_EXT_ADV_START_PARAM(0, 15));
    1876:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
        err = bt_le_ext_adv_start(adv,
    187a:	a909      	add	r1, sp, #36	; 0x24
            BT_LE_EXT_ADV_START_PARAM(0, 15));
    187c:	f88d 5026 	strb.w	r5, [sp, #38]	; 0x26
        err = bt_le_ext_adv_start(adv,
    1880:	f00e fe52 	bl	10528 <bt_le_ext_adv_start>
    }while(err);
    1884:	2800      	cmp	r0, #0
    1886:	d1f5      	bne.n	1874 <main+0x164>
    1888:	2100      	movs	r1, #0
    188a:	f640 40cd 	movw	r0, #3277	; 0xccd
    188e:	f00d fb25 	bl	eedc <z_impl_k_sleep>
    1892:	e7f9      	b.n	1888 <main+0x178>
    1894:	000131d0 	.word	0x000131d0
    1898:	000131e6 	.word	0x000131e6
    189c:	00013206 	.word	0x00013206
    18a0:	0001321d 	.word	0x0001321d
    18a4:	00013224 	.word	0x00013224
    18a8:	00013247 	.word	0x00013247
    18ac:	00013269 	.word	0x00013269
    18b0:	00013294 	.word	0x00013294
    18b4:	000132ae 	.word	0x000132ae
    18b8:	000132cf 	.word	0x000132cf
    18bc:	000132f5 	.word	0x000132f5
    18c0:	00013018 	.word	0x00013018
    18c4:	0001331a 	.word	0x0001331a
    18c8:	0001333f 	.word	0x0001333f

000018cc <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    18cc:	680b      	ldr	r3, [r1, #0]
    18ce:	3301      	adds	r3, #1
    18d0:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    18d2:	4b01      	ldr	r3, [pc, #4]	; (18d8 <char_out+0xc>)
    18d4:	681b      	ldr	r3, [r3, #0]
    18d6:	4718      	bx	r3
    18d8:	200000f8 	.word	0x200000f8

000018dc <__printk_hook_install>:
	_char_out = fn;
    18dc:	4b01      	ldr	r3, [pc, #4]	; (18e4 <__printk_hook_install+0x8>)
    18de:	6018      	str	r0, [r3, #0]
}
    18e0:	4770      	bx	lr
    18e2:	bf00      	nop
    18e4:	200000f8 	.word	0x200000f8

000018e8 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
    18e8:	b507      	push	{r0, r1, r2, lr}
    18ea:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
    18ec:	2100      	movs	r1, #0
{
    18ee:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
    18f0:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
    18f2:	4803      	ldr	r0, [pc, #12]	; (1900 <vprintk+0x18>)
    18f4:	a901      	add	r1, sp, #4
    18f6:	f000 f8f9 	bl	1aec <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
    18fa:	b003      	add	sp, #12
    18fc:	f85d fb04 	ldr.w	pc, [sp], #4
    1900:	000018cd 	.word	0x000018cd

00001904 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    1904:	b530      	push	{r4, r5, lr}
    1906:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
    1908:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
    190c:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
    190e:	2500      	movs	r5, #0

	cbvprintf(str_out, &ctx, fmt, ap);
    1910:	a901      	add	r1, sp, #4
    1912:	4805      	ldr	r0, [pc, #20]	; (1928 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
    1914:	9503      	str	r5, [sp, #12]
	cbvprintf(str_out, &ctx, fmt, ap);
    1916:	f000 f8e9 	bl	1aec <cbvprintf>

	if (ctx.count < ctx.max) {
    191a:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
    191e:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
    1920:	bfb8      	it	lt
    1922:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
    1924:	b005      	add	sp, #20
    1926:	bd30      	pop	{r4, r5, pc}
    1928:	0000f4a1 	.word	0x0000f4a1

0000192c <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
    192c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    1930:	f8b0 9018 	ldrh.w	r9, [r0, #24]
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
    1934:	f019 0808 	ands.w	r8, r9, #8
{
    1938:	4604      	mov	r4, r0
    193a:	4693      	mov	fp, r2
	if (processing) {
    193c:	d00d      	beq.n	195a <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
    193e:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
    1940:	bf0c      	ite	eq
    1942:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
    1946:	f049 0920 	orrne.w	r9, r9, #32
    194a:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    194e:	f38b 8811 	msr	BASEPRI, fp
    1952:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
    1956:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    195a:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
    195e:	2902      	cmp	r1, #2
    1960:	d107      	bne.n	1972 <process_event+0x46>
			evt = process_recheck(mgr);
    1962:	4620      	mov	r0, r4
    1964:	f00d fdc9 	bl	f4fa <process_recheck>
		if (evt == EVT_NOP) {
    1968:	2800      	cmp	r0, #0
    196a:	d0f0      	beq.n	194e <process_event+0x22>
		if (evt == EVT_COMPLETE) {
    196c:	2801      	cmp	r0, #1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    196e:	8b23      	ldrh	r3, [r4, #24]
		if (evt == EVT_COMPLETE) {
    1970:	d14e      	bne.n	1a10 <process_event+0xe4>
			res = mgr->last_res;
    1972:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    1974:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
    1976:	2f00      	cmp	r7, #0
    1978:	da15      	bge.n	19a6 <process_event+0x7a>
		*clients = mgr->clients;
    197a:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    197c:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
    1980:	e9c4 8800 	strd	r8, r8, [r4]
    1984:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
    1988:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
    198a:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
    198c:	8b21      	ldrh	r1, [r4, #24]
    198e:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
    1992:	45ca      	cmp	sl, r9
    1994:	d002      	beq.n	199c <process_event+0x70>
		if (do_monitors
    1996:	68a3      	ldr	r3, [r4, #8]
    1998:	2b00      	cmp	r3, #0
    199a:	d15a      	bne.n	1a52 <process_event+0x126>
		    || !sys_slist_is_empty(&clients)
    199c:	b90d      	cbnz	r5, 19a2 <process_event+0x76>
		    || (transit != NULL)) {
    199e:	2e00      	cmp	r6, #0
    19a0:	d071      	beq.n	1a86 <process_event+0x15a>
    19a2:	2300      	movs	r3, #0
    19a4:	e056      	b.n	1a54 <process_event+0x128>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    19a6:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
    19aa:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
    19ac:	2a01      	cmp	r2, #1
    19ae:	d81e      	bhi.n	19ee <process_event+0xc2>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    19b0:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
    19b4:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
    19b6:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    19b8:	b289      	uxth	r1, r1
    19ba:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
    19be:	d10a      	bne.n	19d6 <process_event+0xaa>
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    19c0:	b13d      	cbz	r5, 19d2 <process_event+0xa6>
    19c2:	8b63      	ldrh	r3, [r4, #26]
    19c4:	462a      	mov	r2, r5

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
    19c6:	6812      	ldr	r2, [r2, #0]
				mgr->refs += 1U;
    19c8:	3301      	adds	r3, #1
    19ca:	b29b      	uxth	r3, r3
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    19cc:	2a00      	cmp	r2, #0
    19ce:	d1fa      	bne.n	19c6 <process_event+0x9a>
    19d0:	8363      	strh	r3, [r4, #26]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    19d2:	f041 0102 	orr.w	r1, r1, #2
	mgr->flags = (state & ONOFF_STATE_MASK)
    19d6:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
    19d8:	4620      	mov	r0, r4
    19da:	f00d fd8e 	bl	f4fa <process_recheck>
    19de:	4606      	mov	r6, r0
    19e0:	2800      	cmp	r0, #0
    19e2:	d0d3      	beq.n	198c <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    19e4:	8b23      	ldrh	r3, [r4, #24]
    19e6:	f043 0320 	orr.w	r3, r3, #32
    19ea:	8323      	strh	r3, [r4, #24]
    19ec:	e7cd      	b.n	198a <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
    19ee:	2b04      	cmp	r3, #4
    19f0:	d10c      	bne.n	1a0c <process_event+0xe0>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    19f2:	f021 0107 	bic.w	r1, r1, #7
    19f6:	b289      	uxth	r1, r1
	mgr->flags = (state & ONOFF_STATE_MASK)
    19f8:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
    19fa:	4620      	mov	r0, r4
    19fc:	f00d fd7d 	bl	f4fa <process_recheck>
    1a00:	4605      	mov	r5, r0
    1a02:	2800      	cmp	r0, #0
    1a04:	d0c1      	beq.n	198a <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    1a06:	f041 0120 	orr.w	r1, r1, #32
    1a0a:	8321      	strh	r1, [r4, #24]
    1a0c:	2500      	movs	r5, #0
    1a0e:	e7bc      	b.n	198a <process_event+0x5e>
		} else if (evt == EVT_START) {
    1a10:	2803      	cmp	r0, #3
    1a12:	d109      	bne.n	1a28 <process_event+0xfc>
			transit = mgr->transitions->start;
    1a14:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1a16:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
    1a1a:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1a1c:	f043 0306 	orr.w	r3, r3, #6
	mgr->flags = (state & ONOFF_STATE_MASK)
    1a20:	8323      	strh	r3, [r4, #24]
}
    1a22:	2500      	movs	r5, #0
		res = 0;
    1a24:	462f      	mov	r7, r5
    1a26:	e7b1      	b.n	198c <process_event+0x60>
		} else if (evt == EVT_STOP) {
    1a28:	2804      	cmp	r0, #4
    1a2a:	d106      	bne.n	1a3a <process_event+0x10e>
			transit = mgr->transitions->stop;
    1a2c:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1a2e:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
    1a32:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1a34:	f043 0304 	orr.w	r3, r3, #4
    1a38:	e7f2      	b.n	1a20 <process_event+0xf4>
		} else if (evt == EVT_RESET) {
    1a3a:	2805      	cmp	r0, #5
    1a3c:	d106      	bne.n	1a4c <process_event+0x120>
			transit = mgr->transitions->reset;
    1a3e:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1a40:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
    1a44:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    1a46:	f043 0305 	orr.w	r3, r3, #5
    1a4a:	e7e9      	b.n	1a20 <process_event+0xf4>
    1a4c:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
    1a4e:	462e      	mov	r6, r5
    1a50:	e7e8      	b.n	1a24 <process_event+0xf8>
				   && !sys_slist_is_empty(&mgr->monitors);
    1a52:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
    1a54:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
    1a58:	8321      	strh	r1, [r4, #24]
    1a5a:	f38b 8811 	msr	BASEPRI, fp
    1a5e:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
    1a62:	b9fb      	cbnz	r3, 1aa4 <process_event+0x178>
	while (!sys_slist_is_empty(list)) {
    1a64:	bb85      	cbnz	r5, 1ac8 <process_event+0x19c>
			if (transit != NULL) {
    1a66:	b116      	cbz	r6, 1a6e <process_event+0x142>
				transit(mgr, transition_complete);
    1a68:	491f      	ldr	r1, [pc, #124]	; (1ae8 <process_event+0x1bc>)
    1a6a:	4620      	mov	r0, r4
    1a6c:	47b0      	blx	r6
	__asm__ volatile(
    1a6e:	f04f 0320 	mov.w	r3, #32
    1a72:	f3ef 8b11 	mrs	fp, BASEPRI
    1a76:	f383 8812 	msr	BASEPRI_MAX, r3
    1a7a:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
    1a7e:	8b23      	ldrh	r3, [r4, #24]
    1a80:	f023 0308 	bic.w	r3, r3, #8
    1a84:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
    1a86:	8b23      	ldrh	r3, [r4, #24]
    1a88:	06da      	lsls	r2, r3, #27
    1a8a:	d525      	bpl.n	1ad8 <process_event+0x1ac>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
    1a8c:	f023 0310 	bic.w	r3, r3, #16
    1a90:	8323      	strh	r3, [r4, #24]
			evt = EVT_COMPLETE;
    1a92:	2101      	movs	r1, #1
		state = mgr->flags & ONOFF_STATE_MASK;
    1a94:	f8b4 9018 	ldrh.w	r9, [r4, #24]
    1a98:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
    1a9c:	2900      	cmp	r1, #0
    1a9e:	f47f af5e 	bne.w	195e <process_event+0x32>
out:
    1aa2:	e754      	b.n	194e <process_event+0x22>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
    1aa4:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    1aa6:	2900      	cmp	r1, #0
    1aa8:	d0dc      	beq.n	1a64 <process_event+0x138>
	return node->next;
    1aaa:	f8d1 9000 	ldr.w	r9, [r1]
		mon->callback(mgr, mon, state, res);
    1aae:	f8d1 b004 	ldr.w	fp, [r1, #4]
    1ab2:	463b      	mov	r3, r7
    1ab4:	4652      	mov	r2, sl
    1ab6:	4620      	mov	r0, r4
    1ab8:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    1aba:	f1b9 0f00 	cmp.w	r9, #0
    1abe:	d0d1      	beq.n	1a64 <process_event+0x138>
    1ac0:	4649      	mov	r1, r9
    1ac2:	f8d9 9000 	ldr.w	r9, [r9]
    1ac6:	e7f2      	b.n	1aae <process_event+0x182>
    1ac8:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
    1aca:	463b      	mov	r3, r7
    1acc:	4652      	mov	r2, sl
    1ace:	4620      	mov	r0, r4
    1ad0:	682d      	ldr	r5, [r5, #0]
    1ad2:	f00d fd2e 	bl	f532 <notify_one>
    1ad6:	e7c5      	b.n	1a64 <process_event+0x138>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
    1ad8:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
    1adc:	bf1e      	ittt	ne
    1ade:	f023 0320 	bicne.w	r3, r3, #32
    1ae2:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
    1ae4:	2102      	movne	r1, #2
    1ae6:	e7d5      	b.n	1a94 <process_event+0x168>
    1ae8:	0000f55f 	.word	0x0000f55f

00001aec <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    1aec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1af0:	b091      	sub	sp, #68	; 0x44
    1af2:	468b      	mov	fp, r1
    1af4:	9002      	str	r0, [sp, #8]
    1af6:	4692      	mov	sl, r2
    1af8:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    1afa:	2500      	movs	r5, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    1afc:	f89a 0000 	ldrb.w	r0, [sl]
    1b00:	b908      	cbnz	r0, 1b06 <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
    1b02:	4628      	mov	r0, r5
    1b04:	e35f      	b.n	21c6 <cbvprintf+0x6da>
		if (*fp != '%') {
    1b06:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
    1b08:	f10a 0701 	add.w	r7, sl, #1
		if (*fp != '%') {
    1b0c:	d007      	beq.n	1b1e <cbvprintf+0x32>
			OUTC('%');
    1b0e:	9b02      	ldr	r3, [sp, #8]
    1b10:	4659      	mov	r1, fp
    1b12:	4798      	blx	r3
    1b14:	2800      	cmp	r0, #0
    1b16:	f2c0 8356 	blt.w	21c6 <cbvprintf+0x6da>
    1b1a:	3501      	adds	r5, #1
			break;
    1b1c:	e212      	b.n	1f44 <cbvprintf+0x458>
		} state = {
    1b1e:	2218      	movs	r2, #24
    1b20:	2100      	movs	r1, #0
    1b22:	a80a      	add	r0, sp, #40	; 0x28
    1b24:	f00e f84a 	bl	fbbc <memset>
	if (*sp == '%') {
    1b28:	f89a 3001 	ldrb.w	r3, [sl, #1]
    1b2c:	2b25      	cmp	r3, #37	; 0x25
    1b2e:	d078      	beq.n	1c22 <cbvprintf+0x136>
    1b30:	2200      	movs	r2, #0
    1b32:	4610      	mov	r0, r2
    1b34:	4696      	mov	lr, r2
    1b36:	4694      	mov	ip, r2
    1b38:	4616      	mov	r6, r2
    1b3a:	4639      	mov	r1, r7
		switch (*sp) {
    1b3c:	f817 3b01 	ldrb.w	r3, [r7], #1
    1b40:	2b2b      	cmp	r3, #43	; 0x2b
    1b42:	f000 809d 	beq.w	1c80 <cbvprintf+0x194>
    1b46:	f200 8094 	bhi.w	1c72 <cbvprintf+0x186>
    1b4a:	2b20      	cmp	r3, #32
    1b4c:	f000 809b 	beq.w	1c86 <cbvprintf+0x19a>
    1b50:	2b23      	cmp	r3, #35	; 0x23
    1b52:	f000 809b 	beq.w	1c8c <cbvprintf+0x1a0>
    1b56:	b12e      	cbz	r6, 1b64 <cbvprintf+0x78>
    1b58:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    1b5c:	f046 0604 	orr.w	r6, r6, #4
    1b60:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
    1b64:	f1bc 0f00 	cmp.w	ip, #0
    1b68:	d005      	beq.n	1b76 <cbvprintf+0x8a>
    1b6a:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    1b6e:	f046 0608 	orr.w	r6, r6, #8
    1b72:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
    1b76:	f1be 0f00 	cmp.w	lr, #0
    1b7a:	d005      	beq.n	1b88 <cbvprintf+0x9c>
    1b7c:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    1b80:	f046 0610 	orr.w	r6, r6, #16
    1b84:	f88d 6030 	strb.w	r6, [sp, #48]	; 0x30
    1b88:	b128      	cbz	r0, 1b96 <cbvprintf+0xaa>
    1b8a:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
    1b8e:	f040 0020 	orr.w	r0, r0, #32
    1b92:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
    1b96:	b12a      	cbz	r2, 1ba4 <cbvprintf+0xb8>
    1b98:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    1b9c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    1ba0:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
    1ba4:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    1ba8:	f002 0044 	and.w	r0, r2, #68	; 0x44
    1bac:	2844      	cmp	r0, #68	; 0x44
    1bae:	d103      	bne.n	1bb8 <cbvprintf+0xcc>
		conv->flag_zero = false;
    1bb0:	f36f 1286 	bfc	r2, #6, #1
    1bb4:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
    1bb8:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
    1bbc:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
    1bbe:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    1bc2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
    1bc6:	d17b      	bne.n	1cc0 <cbvprintf+0x1d4>
		conv->width_star = true;
    1bc8:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    1bcc:	f042 0201 	orr.w	r2, r2, #1
			++sp;
    1bd0:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
    1bd2:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
    1bd6:	781a      	ldrb	r2, [r3, #0]
    1bd8:	2a2e      	cmp	r2, #46	; 0x2e
    1bda:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    1bde:	bf0c      	ite	eq
    1be0:	2101      	moveq	r1, #1
    1be2:	2100      	movne	r1, #0
    1be4:	f361 0241 	bfi	r2, r1, #1, #1
    1be8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
    1bec:	d174      	bne.n	1cd8 <cbvprintf+0x1ec>
	if (*sp == '*') {
    1bee:	785a      	ldrb	r2, [r3, #1]
    1bf0:	2a2a      	cmp	r2, #42	; 0x2a
    1bf2:	d06a      	beq.n	1cca <cbvprintf+0x1de>
	++sp;
    1bf4:	3301      	adds	r3, #1
	size_t val = 0;
    1bf6:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
    1bf8:	260a      	movs	r6, #10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    1bfa:	4618      	mov	r0, r3
    1bfc:	f810 2b01 	ldrb.w	r2, [r0], #1
    1c00:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
    1c04:	2f09      	cmp	r7, #9
    1c06:	f240 808e 	bls.w	1d26 <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
    1c0a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
    1c0e:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
    1c10:	f3c2 0040 	ubfx	r0, r2, #1, #1
    1c14:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
    1c18:	f361 0241 	bfi	r2, r1, #1, #1
    1c1c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
    1c20:	e05a      	b.n	1cd8 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
    1c22:	f10a 0702 	add.w	r7, sl, #2
    1c26:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
    1c2a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    1c2e:	07d9      	lsls	r1, r3, #31
    1c30:	f140 8149 	bpl.w	1ec6 <cbvprintf+0x3da>
			width = va_arg(ap, int);
    1c34:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
    1c38:	f1b9 0f00 	cmp.w	r9, #0
    1c3c:	da07      	bge.n	1c4e <cbvprintf+0x162>
				conv->flag_dash = true;
    1c3e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    1c42:	f042 0204 	orr.w	r2, r2, #4
    1c46:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				width = -width;
    1c4a:	f1c9 0900 	rsb	r9, r9, #0
		if (conv->prec_star) {
    1c4e:	075a      	lsls	r2, r3, #29
    1c50:	f140 8142 	bpl.w	1ed8 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
    1c54:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
    1c58:	f1b8 0f00 	cmp.w	r8, #0
    1c5c:	f280 8141 	bge.w	1ee2 <cbvprintf+0x3f6>
				conv->prec_present = false;
    1c60:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    1c64:	f36f 0341 	bfc	r3, #1, #1
    1c68:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
    1c6c:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    1c70:	e137      	b.n	1ee2 <cbvprintf+0x3f6>
		switch (*sp) {
    1c72:	2b2d      	cmp	r3, #45	; 0x2d
    1c74:	d00c      	beq.n	1c90 <cbvprintf+0x1a4>
    1c76:	2b30      	cmp	r3, #48	; 0x30
    1c78:	f47f af6d 	bne.w	1b56 <cbvprintf+0x6a>
			conv->flag_zero = true;
    1c7c:	2201      	movs	r2, #1
	} while (loop);
    1c7e:	e75c      	b.n	1b3a <cbvprintf+0x4e>
			conv->flag_plus = true;
    1c80:	f04f 0c01 	mov.w	ip, #1
    1c84:	e759      	b.n	1b3a <cbvprintf+0x4e>
			conv->flag_space = true;
    1c86:	f04f 0e01 	mov.w	lr, #1
    1c8a:	e756      	b.n	1b3a <cbvprintf+0x4e>
			conv->flag_hash = true;
    1c8c:	2001      	movs	r0, #1
    1c8e:	e754      	b.n	1b3a <cbvprintf+0x4e>
		switch (*sp) {
    1c90:	2601      	movs	r6, #1
    1c92:	e752      	b.n	1b3a <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
    1c94:	fb0c 0202 	mla	r2, ip, r2, r0
    1c98:	3a30      	subs	r2, #48	; 0x30
    1c9a:	4633      	mov	r3, r6
    1c9c:	461e      	mov	r6, r3
    1c9e:	f816 0b01 	ldrb.w	r0, [r6], #1
    1ca2:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
    1ca6:	2f09      	cmp	r7, #9
    1ca8:	d9f4      	bls.n	1c94 <cbvprintf+0x1a8>
	if (sp != wp) {
    1caa:	4299      	cmp	r1, r3
    1cac:	d093      	beq.n	1bd6 <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
    1cae:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
    1cb2:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
    1cb4:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
    1cb6:	f362 0141 	bfi	r1, r2, #1, #1
    1cba:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
    1cbe:	e78a      	b.n	1bd6 <cbvprintf+0xea>
    1cc0:	460b      	mov	r3, r1
	size_t val = 0;
    1cc2:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
    1cc4:	f04f 0c0a 	mov.w	ip, #10
    1cc8:	e7e8      	b.n	1c9c <cbvprintf+0x1b0>
		conv->prec_star = true;
    1cca:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    1cce:	f042 0204 	orr.w	r2, r2, #4
    1cd2:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
		return ++sp;
    1cd6:	3302      	adds	r3, #2
	switch (*sp) {
    1cd8:	461f      	mov	r7, r3
    1cda:	f817 2b01 	ldrb.w	r2, [r7], #1
    1cde:	2a6c      	cmp	r2, #108	; 0x6c
    1ce0:	d041      	beq.n	1d66 <cbvprintf+0x27a>
    1ce2:	d825      	bhi.n	1d30 <cbvprintf+0x244>
    1ce4:	2a68      	cmp	r2, #104	; 0x68
    1ce6:	d02b      	beq.n	1d40 <cbvprintf+0x254>
    1ce8:	2a6a      	cmp	r2, #106	; 0x6a
    1cea:	d046      	beq.n	1d7a <cbvprintf+0x28e>
    1cec:	2a4c      	cmp	r2, #76	; 0x4c
    1cee:	d04c      	beq.n	1d8a <cbvprintf+0x29e>
    1cf0:	461f      	mov	r7, r3
	conv->specifier = *sp++;
    1cf2:	f817 2b01 	ldrb.w	r2, [r7], #1
		if (conv->length_mod == LENGTH_UPPER_L) {
    1cf6:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	conv->specifier = *sp++;
    1cfa:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
    1cfe:	2a78      	cmp	r2, #120	; 0x78
    1d00:	f200 80d9 	bhi.w	1eb6 <cbvprintf+0x3ca>
    1d04:	2a57      	cmp	r2, #87	; 0x57
    1d06:	d84d      	bhi.n	1da4 <cbvprintf+0x2b8>
    1d08:	2a41      	cmp	r2, #65	; 0x41
    1d0a:	d003      	beq.n	1d14 <cbvprintf+0x228>
    1d0c:	3a45      	subs	r2, #69	; 0x45
    1d0e:	2a02      	cmp	r2, #2
    1d10:	f200 80d1 	bhi.w	1eb6 <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
    1d14:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    1d18:	2204      	movs	r2, #4
    1d1a:	f362 0302 	bfi	r3, r2, #0, #3
    1d1e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
    1d22:	2301      	movs	r3, #1
			break;
    1d24:	e09e      	b.n	1e64 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
    1d26:	fb06 2101 	mla	r1, r6, r1, r2
    1d2a:	3930      	subs	r1, #48	; 0x30
    1d2c:	4603      	mov	r3, r0
    1d2e:	e764      	b.n	1bfa <cbvprintf+0x10e>
	switch (*sp) {
    1d30:	2a74      	cmp	r2, #116	; 0x74
    1d32:	d026      	beq.n	1d82 <cbvprintf+0x296>
    1d34:	2a7a      	cmp	r2, #122	; 0x7a
    1d36:	d1db      	bne.n	1cf0 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
    1d38:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    1d3c:	2206      	movs	r2, #6
    1d3e:	e00d      	b.n	1d5c <cbvprintf+0x270>
		if (*++sp == 'h') {
    1d40:	785a      	ldrb	r2, [r3, #1]
    1d42:	2a68      	cmp	r2, #104	; 0x68
    1d44:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    1d48:	d106      	bne.n	1d58 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
    1d4a:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
    1d4c:	f361 02c6 	bfi	r2, r1, #3, #4
    1d50:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
    1d54:	1c9f      	adds	r7, r3, #2
    1d56:	e7cc      	b.n	1cf2 <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
    1d58:	4613      	mov	r3, r2
    1d5a:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
    1d5c:	f362 03c6 	bfi	r3, r2, #3, #4
    1d60:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
    1d64:	e7c5      	b.n	1cf2 <cbvprintf+0x206>
		if (*++sp == 'l') {
    1d66:	785a      	ldrb	r2, [r3, #1]
    1d68:	2a6c      	cmp	r2, #108	; 0x6c
    1d6a:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    1d6e:	d101      	bne.n	1d74 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
    1d70:	2104      	movs	r1, #4
    1d72:	e7eb      	b.n	1d4c <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
    1d74:	4613      	mov	r3, r2
    1d76:	2203      	movs	r2, #3
    1d78:	e7f0      	b.n	1d5c <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
    1d7a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    1d7e:	2205      	movs	r2, #5
    1d80:	e7ec      	b.n	1d5c <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
    1d82:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    1d86:	2207      	movs	r2, #7
    1d88:	e7e8      	b.n	1d5c <cbvprintf+0x270>
		conv->unsupported = true;
    1d8a:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    1d8e:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    1d92:	f023 0302 	bic.w	r3, r3, #2
    1d96:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    1d9a:	f043 0302 	orr.w	r3, r3, #2
    1d9e:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
    1da2:	e7a6      	b.n	1cf2 <cbvprintf+0x206>
	switch (conv->specifier) {
    1da4:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
    1da8:	2920      	cmp	r1, #32
    1daa:	f200 8084 	bhi.w	1eb6 <cbvprintf+0x3ca>
    1dae:	a001      	add	r0, pc, #4	; (adr r0, 1db4 <cbvprintf+0x2c8>)
    1db0:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
    1db4:	00001e79 	.word	0x00001e79
    1db8:	00001eb7 	.word	0x00001eb7
    1dbc:	00001eb7 	.word	0x00001eb7
    1dc0:	00001eb7 	.word	0x00001eb7
    1dc4:	00001eb7 	.word	0x00001eb7
    1dc8:	00001eb7 	.word	0x00001eb7
    1dcc:	00001eb7 	.word	0x00001eb7
    1dd0:	00001eb7 	.word	0x00001eb7
    1dd4:	00001eb7 	.word	0x00001eb7
    1dd8:	00001d15 	.word	0x00001d15
    1ddc:	00001eb7 	.word	0x00001eb7
    1de0:	00001e79 	.word	0x00001e79
    1de4:	00001e39 	.word	0x00001e39
    1de8:	00001d15 	.word	0x00001d15
    1dec:	00001d15 	.word	0x00001d15
    1df0:	00001d15 	.word	0x00001d15
    1df4:	00001eb7 	.word	0x00001eb7
    1df8:	00001e39 	.word	0x00001e39
    1dfc:	00001eb7 	.word	0x00001eb7
    1e00:	00001eb7 	.word	0x00001eb7
    1e04:	00001eb7 	.word	0x00001eb7
    1e08:	00001eb7 	.word	0x00001eb7
    1e0c:	00001e81 	.word	0x00001e81
    1e10:	00001e79 	.word	0x00001e79
    1e14:	00001e9d 	.word	0x00001e9d
    1e18:	00001eb7 	.word	0x00001eb7
    1e1c:	00001eb7 	.word	0x00001eb7
    1e20:	00001e9d 	.word	0x00001e9d
    1e24:	00001eb7 	.word	0x00001eb7
    1e28:	00001e79 	.word	0x00001e79
    1e2c:	00001eb7 	.word	0x00001eb7
    1e30:	00001eb7 	.word	0x00001eb7
    1e34:	00001e79 	.word	0x00001e79
		conv->specifier_cat = SPECIFIER_SINT;
    1e38:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
    1e3c:	2001      	movs	r0, #1
		if (conv->length_mod == LENGTH_UPPER_L) {
    1e3e:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
    1e42:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    1e46:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
    1e48:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
    1e4c:	bf02      	ittt	eq
    1e4e:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
    1e52:	f041 0101 	orreq.w	r1, r1, #1
    1e56:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
    1e5a:	2a63      	cmp	r2, #99	; 0x63
    1e5c:	d131      	bne.n	1ec2 <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
    1e5e:	3b00      	subs	r3, #0
    1e60:	bf18      	it	ne
    1e62:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
    1e64:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    1e68:	f3c2 0140 	ubfx	r1, r2, #1, #1
    1e6c:	430b      	orrs	r3, r1
    1e6e:	f363 0241 	bfi	r2, r3, #1, #1
    1e72:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
    1e76:	e6d8      	b.n	1c2a <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
    1e78:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
    1e7c:	2002      	movs	r0, #2
    1e7e:	e7de      	b.n	1e3e <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
    1e80:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    1e84:	f003 0378 	and.w	r3, r3, #120	; 0x78
    1e88:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
    1e8c:	2103      	movs	r1, #3
    1e8e:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    1e92:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
    1e94:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    1e98:	4143      	adcs	r3, r0
    1e9a:	e7e3      	b.n	1e64 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
    1e9c:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
    1ea0:	2103      	movs	r1, #3
		if (conv->length_mod != LENGTH_NONE) {
    1ea2:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
    1ea6:	f361 0202 	bfi	r2, r1, #0, #3
    1eaa:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
    1eae:	bf14      	ite	ne
    1eb0:	2301      	movne	r3, #1
    1eb2:	2300      	moveq	r3, #0
    1eb4:	e7d6      	b.n	1e64 <cbvprintf+0x378>
		conv->invalid = true;
    1eb6:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    1eba:	f043 0301 	orr.w	r3, r3, #1
    1ebe:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
    1ec2:	2300      	movs	r3, #0
    1ec4:	e7ce      	b.n	1e64 <cbvprintf+0x378>
		} else if (conv->width_present) {
    1ec6:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
    1eca:	2a00      	cmp	r2, #0
			width = conv->width_value;
    1ecc:	bfb4      	ite	lt
    1ece:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
		int width = -1;
    1ed2:	f04f 39ff 	movge.w	r9, #4294967295	; 0xffffffff
    1ed6:	e6ba      	b.n	1c4e <cbvprintf+0x162>
		} else if (conv->prec_present) {
    1ed8:	079b      	lsls	r3, r3, #30
    1eda:	f57f aec7 	bpl.w	1c6c <cbvprintf+0x180>
			precision = conv->prec_value;
    1ede:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
			= (enum length_mod_enum)conv->length_mod;
    1ee2:	f89d 1031 	ldrb.w	r1, [sp, #49]	; 0x31
		conv->pad0_value = 0;
    1ee6:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
    1ee8:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
    1eec:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
		enum specifier_cat_enum specifier_cat
    1ef0:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
    1ef4:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
    1ef6:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
    1efa:	d138      	bne.n	1f6e <cbvprintf+0x482>
			switch (length_mod) {
    1efc:	1ecb      	subs	r3, r1, #3
    1efe:	2b04      	cmp	r3, #4
    1f00:	d822      	bhi.n	1f48 <cbvprintf+0x45c>
    1f02:	e8df f003 	tbb	[pc, r3]
    1f06:	0903      	.short	0x0903
    1f08:	2109      	.short	0x2109
    1f0a:	21          	.byte	0x21
    1f0b:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
    1f0c:	f854 3b04 	ldr.w	r3, [r4], #4
				value->sint = (short)value->sint;
    1f10:	17da      	asrs	r2, r3, #31
    1f12:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
    1f16:	e006      	b.n	1f26 <cbvprintf+0x43a>
					(sint_value_type)va_arg(ap, intmax_t);
    1f18:	3407      	adds	r4, #7
    1f1a:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
    1f1e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
    1f22:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
    1f26:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    1f2a:	f013 0603 	ands.w	r6, r3, #3
    1f2e:	d056      	beq.n	1fde <cbvprintf+0x4f2>
			OUTS(sp, fp);
    1f30:	9802      	ldr	r0, [sp, #8]
    1f32:	463b      	mov	r3, r7
    1f34:	4652      	mov	r2, sl
    1f36:	4659      	mov	r1, fp
    1f38:	f00d fda0 	bl	fa7c <outs>
    1f3c:	2800      	cmp	r0, #0
    1f3e:	f2c0 8142 	blt.w	21c6 <cbvprintf+0x6da>
    1f42:	4405      	add	r5, r0
			continue;
    1f44:	46ba      	mov	sl, r7
    1f46:	e5d9      	b.n	1afc <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    1f48:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
    1f4c:	2901      	cmp	r1, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
    1f4e:	ea4f 72e3 	mov.w	r2, r3, asr #31
    1f52:	e9cd 320a 	strd	r3, r2, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
    1f56:	d105      	bne.n	1f64 <cbvprintf+0x478>
				value->uint = (unsigned char)value->uint;
    1f58:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
    1f5c:	930a      	str	r3, [sp, #40]	; 0x28
    1f5e:	2300      	movs	r3, #0
    1f60:	930b      	str	r3, [sp, #44]	; 0x2c
    1f62:	e7e0      	b.n	1f26 <cbvprintf+0x43a>
			} else if (length_mod == LENGTH_H) {
    1f64:	2902      	cmp	r1, #2
    1f66:	d1de      	bne.n	1f26 <cbvprintf+0x43a>
				value->sint = (short)value->sint;
    1f68:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
    1f6c:	e7d0      	b.n	1f10 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
    1f6e:	2b02      	cmp	r3, #2
    1f70:	d123      	bne.n	1fba <cbvprintf+0x4ce>
			switch (length_mod) {
    1f72:	1ecb      	subs	r3, r1, #3
    1f74:	2b04      	cmp	r3, #4
    1f76:	d813      	bhi.n	1fa0 <cbvprintf+0x4b4>
    1f78:	e8df f003 	tbb	[pc, r3]
    1f7c:	120a0a03 	.word	0x120a0a03
    1f80:	12          	.byte	0x12
    1f81:	00          	.byte	0x00
					value->uint = (wchar_t)va_arg(ap,
    1f82:	6822      	ldr	r2, [r4, #0]
    1f84:	920a      	str	r2, [sp, #40]	; 0x28
    1f86:	2300      	movs	r3, #0
				value->sint = va_arg(ap, int);
    1f88:	1d20      	adds	r0, r4, #4
					value->uint = (wchar_t)va_arg(ap,
    1f8a:	930b      	str	r3, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
    1f8c:	4604      	mov	r4, r0
    1f8e:	e7ca      	b.n	1f26 <cbvprintf+0x43a>
					(uint_value_type)va_arg(ap,
    1f90:	1de0      	adds	r0, r4, #7
    1f92:	f020 0007 	bic.w	r0, r0, #7
				value->uint =
    1f96:	e8f0 2302 	ldrd	r2, r3, [r0], #8
    1f9a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				break;
    1f9e:	e7f5      	b.n	1f8c <cbvprintf+0x4a0>
					(uint_value_type)va_arg(ap, size_t);
    1fa0:	f854 3b04 	ldr.w	r3, [r4], #4
    1fa4:	930a      	str	r3, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
    1fa6:	2901      	cmp	r1, #1
					(uint_value_type)va_arg(ap, size_t);
    1fa8:	f04f 0300 	mov.w	r3, #0
    1fac:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
    1fae:	d0d3      	beq.n	1f58 <cbvprintf+0x46c>
			} else if (length_mod == LENGTH_H) {
    1fb0:	2902      	cmp	r1, #2
    1fb2:	d1b8      	bne.n	1f26 <cbvprintf+0x43a>
				value->uint = (unsigned short)value->uint;
    1fb4:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
    1fb8:	e7d0      	b.n	1f5c <cbvprintf+0x470>
		} else if (specifier_cat == SPECIFIER_FP) {
    1fba:	2b04      	cmp	r3, #4
    1fbc:	d109      	bne.n	1fd2 <cbvprintf+0x4e6>
					(sint_value_type)va_arg(ap, long long);
    1fbe:	1de3      	adds	r3, r4, #7
    1fc0:	f023 0307 	bic.w	r3, r3, #7
    1fc4:	f103 0408 	add.w	r4, r3, #8
				value->ldbl = va_arg(ap, long double);
    1fc8:	e9d3 2300 	ldrd	r2, r3, [r3]
    1fcc:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    1fd0:	e7a9      	b.n	1f26 <cbvprintf+0x43a>
		} else if (specifier_cat == SPECIFIER_PTR) {
    1fd2:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
    1fd4:	bf04      	itt	eq
    1fd6:	f854 3b04 	ldreq.w	r3, [r4], #4
    1fda:	930a      	streq	r3, [sp, #40]	; 0x28
    1fdc:	e7a3      	b.n	1f26 <cbvprintf+0x43a>
		switch (conv->specifier) {
    1fde:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    1fe2:	2878      	cmp	r0, #120	; 0x78
    1fe4:	d8ae      	bhi.n	1f44 <cbvprintf+0x458>
    1fe6:	2862      	cmp	r0, #98	; 0x62
    1fe8:	d822      	bhi.n	2030 <cbvprintf+0x544>
    1fea:	2825      	cmp	r0, #37	; 0x25
    1fec:	f43f ad8f 	beq.w	1b0e <cbvprintf+0x22>
    1ff0:	2858      	cmp	r0, #88	; 0x58
    1ff2:	d1a7      	bne.n	1f44 <cbvprintf+0x458>
			bps = encode_uint(value->uint, conv, buf, bpe);
    1ff4:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    1ff8:	9300      	str	r3, [sp, #0]
    1ffa:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    1ffe:	ab04      	add	r3, sp, #16
    2000:	aa0c      	add	r2, sp, #48	; 0x30
    2002:	f00d fcf5 	bl	f9f0 <encode_uint>
    2006:	4682      	mov	sl, r0
			if (precision >= 0) {
    2008:	f1b8 0f00 	cmp.w	r8, #0
    200c:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    2010:	db0c      	blt.n	202c <cbvprintf+0x540>
				conv->flag_zero = false;
    2012:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
    2016:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
    201a:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
    201e:	4598      	cmp	r8, r3
				conv->flag_zero = false;
    2020:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
    2024:	d902      	bls.n	202c <cbvprintf+0x540>
					conv->pad0_value = precision - (int)len;
    2026:	eba8 0303 	sub.w	r3, r8, r3
    202a:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
    202c:	4680      	mov	r8, r0
    202e:	e03d      	b.n	20ac <cbvprintf+0x5c0>
		switch (conv->specifier) {
    2030:	3863      	subs	r0, #99	; 0x63
    2032:	2815      	cmp	r0, #21
    2034:	d886      	bhi.n	1f44 <cbvprintf+0x458>
    2036:	a201      	add	r2, pc, #4	; (adr r2, 203c <cbvprintf+0x550>)
    2038:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
    203c:	000020bd 	.word	0x000020bd
    2040:	00002121 	.word	0x00002121
    2044:	00001f45 	.word	0x00001f45
    2048:	00001f45 	.word	0x00001f45
    204c:	00001f45 	.word	0x00001f45
    2050:	00001f45 	.word	0x00001f45
    2054:	00002121 	.word	0x00002121
    2058:	00001f45 	.word	0x00001f45
    205c:	00001f45 	.word	0x00001f45
    2060:	00001f45 	.word	0x00001f45
    2064:	00001f45 	.word	0x00001f45
    2068:	0000217b 	.word	0x0000217b
    206c:	00002149 	.word	0x00002149
    2070:	0000214d 	.word	0x0000214d
    2074:	00001f45 	.word	0x00001f45
    2078:	00001f45 	.word	0x00001f45
    207c:	00002095 	.word	0x00002095
    2080:	00001f45 	.word	0x00001f45
    2084:	00002149 	.word	0x00002149
    2088:	00001f45 	.word	0x00001f45
    208c:	00001f45 	.word	0x00001f45
    2090:	00002149 	.word	0x00002149
			if (precision >= 0) {
    2094:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
    2098:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
    209c:	db0a      	blt.n	20b4 <cbvprintf+0x5c8>
				len = strnlen(bps, precision);
    209e:	4641      	mov	r1, r8
    20a0:	4650      	mov	r0, sl
    20a2:	f00d fd42 	bl	fb2a <strnlen>
			bpe = bps + len;
    20a6:	eb0a 0800 	add.w	r8, sl, r0
		char sign = 0;
    20aa:	2600      	movs	r6, #0
		if (bps == NULL) {
    20ac:	f1ba 0f00 	cmp.w	sl, #0
    20b0:	d10c      	bne.n	20cc <cbvprintf+0x5e0>
    20b2:	e747      	b.n	1f44 <cbvprintf+0x458>
				len = strlen(bps);
    20b4:	4650      	mov	r0, sl
    20b6:	f00d fd31 	bl	fb1c <strlen>
    20ba:	e7f4      	b.n	20a6 <cbvprintf+0x5ba>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    20bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    20be:	f88d 3010 	strb.w	r3, [sp, #16]
			break;
    20c2:	2600      	movs	r6, #0
			bps = buf;
    20c4:	f10d 0a10 	add.w	sl, sp, #16
			bpe = buf + 1;
    20c8:	f10d 0811 	add.w	r8, sp, #17
		size_t nj_len = (bpe - bps);
    20cc:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
    20d0:	b106      	cbz	r6, 20d4 <cbvprintf+0x5e8>
			nj_len += 1U;
    20d2:	3301      	adds	r3, #1
		if (conv->altform_0c) {
    20d4:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
    20d8:	06d0      	lsls	r0, r2, #27
    20da:	d568      	bpl.n	21ae <cbvprintf+0x6c2>
			nj_len += 2U;
    20dc:	3302      	adds	r3, #2
		if (conv->pad_fp) {
    20de:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
    20e0:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
    20e2:	bf48      	it	mi
    20e4:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
    20e6:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
    20e8:	bf48      	it	mi
    20ea:	189b      	addmi	r3, r3, r2
		if (width > 0) {
    20ec:	f1b9 0f00 	cmp.w	r9, #0
    20f0:	dd76      	ble.n	21e0 <cbvprintf+0x6f4>
			if (!conv->flag_dash) {
    20f2:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
    20f6:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
    20fa:	f3c2 0380 	ubfx	r3, r2, #2, #1
    20fe:	9303      	str	r3, [sp, #12]
    2100:	0753      	lsls	r3, r2, #29
    2102:	d46d      	bmi.n	21e0 <cbvprintf+0x6f4>
				if (conv->flag_zero) {
    2104:	0650      	lsls	r0, r2, #25
    2106:	d561      	bpl.n	21cc <cbvprintf+0x6e0>
					if (sign != 0) {
    2108:	b146      	cbz	r6, 211c <cbvprintf+0x630>
						OUTC(sign);
    210a:	9b02      	ldr	r3, [sp, #8]
    210c:	4659      	mov	r1, fp
    210e:	4630      	mov	r0, r6
    2110:	4798      	blx	r3
    2112:	2800      	cmp	r0, #0
    2114:	db57      	blt.n	21c6 <cbvprintf+0x6da>
						sign = 0;
    2116:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
    2118:	3501      	adds	r5, #1
						sign = 0;
    211a:	461e      	mov	r6, r3
					pad = '0';
    211c:	2330      	movs	r3, #48	; 0x30
    211e:	e056      	b.n	21ce <cbvprintf+0x6e2>
			if (conv->flag_plus) {
    2120:	071e      	lsls	r6, r3, #28
    2122:	d40f      	bmi.n	2144 <cbvprintf+0x658>
				sign = ' ';
    2124:	f013 0610 	ands.w	r6, r3, #16
    2128:	bf18      	it	ne
    212a:	2620      	movne	r6, #32
			sint = value->sint;
    212c:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
    2130:	2b00      	cmp	r3, #0
    2132:	f6bf af5f 	bge.w	1ff4 <cbvprintf+0x508>
				value->uint = (uint_value_type)-sint;
    2136:	4252      	negs	r2, r2
    2138:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    213c:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
				sign = '-';
    2140:	262d      	movs	r6, #45	; 0x2d
    2142:	e757      	b.n	1ff4 <cbvprintf+0x508>
				sign = '+';
    2144:	262b      	movs	r6, #43	; 0x2b
    2146:	e7f1      	b.n	212c <cbvprintf+0x640>
		switch (conv->specifier) {
    2148:	2600      	movs	r6, #0
    214a:	e753      	b.n	1ff4 <cbvprintf+0x508>
			if (value->ptr != NULL) {
    214c:	980a      	ldr	r0, [sp, #40]	; 0x28
    214e:	b340      	cbz	r0, 21a2 <cbvprintf+0x6b6>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    2150:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    2154:	9300      	str	r3, [sp, #0]
    2156:	aa0c      	add	r2, sp, #48	; 0x30
    2158:	ab04      	add	r3, sp, #16
    215a:	2100      	movs	r1, #0
    215c:	f00d fc48 	bl	f9f0 <encode_uint>
				conv->altform_0c = true;
    2160:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
    2164:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    2168:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
    216c:	f043 0310 	orr.w	r3, r3, #16
				bps = encode_uint((uintptr_t)value->ptr, conv,
    2170:	4682      	mov	sl, r0
				conv->altform_0c = true;
    2172:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
		char sign = 0;
    2176:	2600      	movs	r6, #0
				goto prec_int_pad0;
    2178:	e746      	b.n	2008 <cbvprintf+0x51c>
				store_count(conv, value->ptr, count);
    217a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
    217c:	2907      	cmp	r1, #7
    217e:	f63f aee1 	bhi.w	1f44 <cbvprintf+0x458>
    2182:	e8df f001 	tbb	[pc, r1]
    2186:	040c      	.short	0x040c
    2188:	08080c06 	.word	0x08080c06
    218c:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
    218e:	701d      	strb	r5, [r3, #0]
		break;
    2190:	e6d8      	b.n	1f44 <cbvprintf+0x458>
		*(short *)dp = (short)count;
    2192:	801d      	strh	r5, [r3, #0]
		break;
    2194:	e6d6      	b.n	1f44 <cbvprintf+0x458>
		*(intmax_t *)dp = (intmax_t)count;
    2196:	17ea      	asrs	r2, r5, #31
    2198:	e9c3 5200 	strd	r5, r2, [r3]
		break;
    219c:	e6d2      	b.n	1f44 <cbvprintf+0x458>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    219e:	601d      	str	r5, [r3, #0]
		break;
    21a0:	e6d0      	b.n	1f44 <cbvprintf+0x458>
			bps = "(nil)";
    21a2:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 226c <cbvprintf+0x780>
    21a6:	4606      	mov	r6, r0
			bpe = bps + 5;
    21a8:	f10a 0805 	add.w	r8, sl, #5
    21ac:	e78e      	b.n	20cc <cbvprintf+0x5e0>
		} else if (conv->altform_0) {
    21ae:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
    21b0:	bf48      	it	mi
    21b2:	3301      	addmi	r3, #1
    21b4:	e793      	b.n	20de <cbvprintf+0x5f2>
					OUTC(pad);
    21b6:	4618      	mov	r0, r3
    21b8:	9303      	str	r3, [sp, #12]
    21ba:	4659      	mov	r1, fp
    21bc:	9b02      	ldr	r3, [sp, #8]
    21be:	4798      	blx	r3
    21c0:	2800      	cmp	r0, #0
    21c2:	9b03      	ldr	r3, [sp, #12]
    21c4:	da04      	bge.n	21d0 <cbvprintf+0x6e4>
#undef OUTS
#undef OUTC
}
    21c6:	b011      	add	sp, #68	; 0x44
    21c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
    21cc:	2320      	movs	r3, #32
    21ce:	444d      	add	r5, r9
    21d0:	464a      	mov	r2, r9
				while (width-- > 0) {
    21d2:	2a00      	cmp	r2, #0
    21d4:	eba5 0109 	sub.w	r1, r5, r9
    21d8:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    21dc:	dceb      	bgt.n	21b6 <cbvprintf+0x6ca>
    21de:	460d      	mov	r5, r1
		if (sign != 0) {
    21e0:	b136      	cbz	r6, 21f0 <cbvprintf+0x704>
			OUTC(sign);
    21e2:	9b02      	ldr	r3, [sp, #8]
    21e4:	4659      	mov	r1, fp
    21e6:	4630      	mov	r0, r6
    21e8:	4798      	blx	r3
    21ea:	2800      	cmp	r0, #0
    21ec:	dbeb      	blt.n	21c6 <cbvprintf+0x6da>
    21ee:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
    21f0:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    21f4:	06d9      	lsls	r1, r3, #27
    21f6:	d401      	bmi.n	21fc <cbvprintf+0x710>
    21f8:	071a      	lsls	r2, r3, #28
    21fa:	d506      	bpl.n	220a <cbvprintf+0x71e>
				OUTC('0');
    21fc:	9b02      	ldr	r3, [sp, #8]
    21fe:	4659      	mov	r1, fp
    2200:	2030      	movs	r0, #48	; 0x30
    2202:	4798      	blx	r3
    2204:	2800      	cmp	r0, #0
    2206:	dbde      	blt.n	21c6 <cbvprintf+0x6da>
    2208:	3501      	adds	r5, #1
			if (conv->altform_0c) {
    220a:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    220e:	06db      	lsls	r3, r3, #27
    2210:	d507      	bpl.n	2222 <cbvprintf+0x736>
				OUTC(conv->specifier);
    2212:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    2216:	9b02      	ldr	r3, [sp, #8]
    2218:	4659      	mov	r1, fp
    221a:	4798      	blx	r3
    221c:	2800      	cmp	r0, #0
    221e:	dbd2      	blt.n	21c6 <cbvprintf+0x6da>
    2220:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
    2222:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    2224:	442e      	add	r6, r5
    2226:	1b73      	subs	r3, r6, r5
    2228:	2b00      	cmp	r3, #0
    222a:	dc16      	bgt.n	225a <cbvprintf+0x76e>
			OUTS(bps, bpe);
    222c:	9802      	ldr	r0, [sp, #8]
    222e:	4643      	mov	r3, r8
    2230:	4652      	mov	r2, sl
    2232:	4659      	mov	r1, fp
    2234:	f00d fc22 	bl	fa7c <outs>
    2238:	2800      	cmp	r0, #0
    223a:	dbc4      	blt.n	21c6 <cbvprintf+0x6da>
    223c:	4405      	add	r5, r0
		while (width > 0) {
    223e:	44a9      	add	r9, r5
    2240:	eba9 0305 	sub.w	r3, r9, r5
    2244:	2b00      	cmp	r3, #0
    2246:	f77f ae7d 	ble.w	1f44 <cbvprintf+0x458>
			OUTC(' ');
    224a:	9b02      	ldr	r3, [sp, #8]
    224c:	4659      	mov	r1, fp
    224e:	2020      	movs	r0, #32
    2250:	4798      	blx	r3
    2252:	2800      	cmp	r0, #0
    2254:	dbb7      	blt.n	21c6 <cbvprintf+0x6da>
    2256:	3501      	adds	r5, #1
			--width;
    2258:	e7f2      	b.n	2240 <cbvprintf+0x754>
				OUTC('0');
    225a:	9b02      	ldr	r3, [sp, #8]
    225c:	4659      	mov	r1, fp
    225e:	2030      	movs	r0, #48	; 0x30
    2260:	4798      	blx	r3
    2262:	2800      	cmp	r0, #0
    2264:	dbaf      	blt.n	21c6 <cbvprintf+0x6da>
    2266:	3501      	adds	r5, #1
    2268:	e7dd      	b.n	2226 <cbvprintf+0x73a>
    226a:	bf00      	nop
    226c:	0001335e 	.word	0x0001335e

00002270 <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
    2270:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2274:	4605      	mov	r5, r0
    2276:	f04f 0320 	mov.w	r3, #32
    227a:	f3ef 8611 	mrs	r6, BASEPRI
    227e:	f383 8812 	msr	BASEPRI_MAX, r3
    2282:	f3bf 8f6f 	isb	sy
	return list->head;
    2286:	4b0e      	ldr	r3, [pc, #56]	; (22c0 <pm_state_notify+0x50>)
    2288:	681c      	ldr	r4, [r3, #0]
	struct pm_notifier *notifier;
	k_spinlock_key_t pm_notifier_key;
	void (*callback)(enum pm_state state);

	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    228a:	b19c      	cbz	r4, 22b4 <pm_state_notify+0x44>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_power_states[_current_cpu->id].state);
    228c:	4f0d      	ldr	r7, [pc, #52]	; (22c4 <pm_state_notify+0x54>)
    228e:	f8df 8038 	ldr.w	r8, [pc, #56]	; 22c8 <pm_state_notify+0x58>
    2292:	f04f 090c 	mov.w	r9, #12
			callback = notifier->state_exit;
    2296:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
    229a:	2d00      	cmp	r5, #0
    229c:	bf08      	it	eq
    229e:	4613      	moveq	r3, r2
		if (callback) {
    22a0:	b12b      	cbz	r3, 22ae <pm_state_notify+0x3e>
			callback(z_power_states[_current_cpu->id].state);
    22a2:	f898 2014 	ldrb.w	r2, [r8, #20]
    22a6:	fb09 f202 	mul.w	r2, r9, r2
    22aa:	5cb8      	ldrb	r0, [r7, r2]
    22ac:	4798      	blx	r3
	return node->next;
    22ae:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    22b0:	2c00      	cmp	r4, #0
    22b2:	d1f0      	bne.n	2296 <pm_state_notify+0x26>
	__asm__ volatile(
    22b4:	f386 8811 	msr	BASEPRI, r6
    22b8:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
    22bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    22c0:	20000a08 	.word	0x20000a08
    22c4:	20000a14 	.word	0x20000a14
    22c8:	200026a0 	.word	0x200026a0

000022cc <atomic_test_and_set_bit.constprop.0>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    22cc:	f000 031f 	and.w	r3, r0, #31
    22d0:	2201      	movs	r2, #1
    22d2:	409a      	lsls	r2, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    22d4:	4b0a      	ldr	r3, [pc, #40]	; (2300 <atomic_test_and_set_bit.constprop.0+0x34>)
    22d6:	f3bf 8f5b 	dmb	ish
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    22da:	0940      	lsrs	r0, r0, #5
    22dc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    22e0:	e850 3f00 	ldrex	r3, [r0]
    22e4:	ea43 0102 	orr.w	r1, r3, r2
    22e8:	e840 1c00 	strex	ip, r1, [r0]
    22ec:	f1bc 0f00 	cmp.w	ip, #0
    22f0:	d1f6      	bne.n	22e0 <atomic_test_and_set_bit.constprop.0+0x14>
    22f2:	f3bf 8f5b 	dmb	ish

	return (old & mask) != 0;
    22f6:	421a      	tst	r2, r3
}
    22f8:	bf14      	ite	ne
    22fa:	2001      	movne	r0, #1
    22fc:	2000      	moveq	r0, #0
    22fe:	4770      	bx	lr
    2300:	20000a20 	.word	0x20000a20

00002304 <pm_system_resume>:

void pm_system_resume(void)
{
    2304:	b530      	push	{r4, r5, lr}
	uint8_t id = _current_cpu->id;
    2306:	4b1d      	ldr	r3, [pc, #116]	; (237c <pm_system_resume+0x78>)
    2308:	7d1c      	ldrb	r4, [r3, #20]
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    230a:	f3bf 8f5b 	dmb	ish
	atomic_val_t mask = ATOMIC_MASK(bit);
    230e:	f004 031f 	and.w	r3, r4, #31
    2312:	2201      	movs	r2, #1
    2314:	409a      	lsls	r2, r3
    2316:	4b1a      	ldr	r3, [pc, #104]	; (2380 <pm_system_resume+0x7c>)
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    2318:	0961      	lsrs	r1, r4, #5
{
    231a:	b085      	sub	sp, #20
    231c:	43d0      	mvns	r0, r2
    231e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    2322:	e853 1f00 	ldrex	r1, [r3]
    2326:	ea01 0500 	and.w	r5, r1, r0
    232a:	e843 5c00 	strex	ip, r5, [r3]
    232e:	f1bc 0f00 	cmp.w	ip, #0
    2332:	d1f6      	bne.n	2322 <pm_system_resume+0x1e>
    2334:	f3bf 8f5b 	dmb	ish
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
    2338:	4211      	tst	r1, r2
    233a:	d017      	beq.n	236c <pm_system_resume+0x68>
		exit_pos_ops(z_power_states[id]);
    233c:	4d11      	ldr	r5, [pc, #68]	; (2384 <pm_system_resume+0x80>)
    233e:	220c      	movs	r2, #12
    2340:	fb02 5204 	mla	r2, r2, r4, r5
    2344:	ca07      	ldmia	r2, {r0, r1, r2}
    2346:	ab01      	add	r3, sp, #4
    2348:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
    234c:	4a0e      	ldr	r2, [pc, #56]	; (2388 <pm_system_resume+0x84>)
    234e:	b17a      	cbz	r2, 2370 <pm_system_resume+0x6c>
		pm_power_state_exit_post_ops(info);
    2350:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    2354:	f00d fc51 	bl	fbfa <pm_power_state_exit_post_ops>
		pm_state_notify(false);
    2358:	2000      	movs	r0, #0
    235a:	f7ff ff89 	bl	2270 <pm_state_notify>
		z_power_states[id] = (struct pm_state_info){PM_STATE_ACTIVE,
    235e:	230c      	movs	r3, #12
    2360:	435c      	muls	r4, r3
    2362:	192a      	adds	r2, r5, r4
    2364:	2300      	movs	r3, #0
    2366:	512b      	str	r3, [r5, r4]
    2368:	e9c2 3301 	strd	r3, r3, [r2, #4]
			0, 0};
	}
}
    236c:	b005      	add	sp, #20
    236e:	bd30      	pop	{r4, r5, pc}
    2370:	f382 8811 	msr	BASEPRI, r2
    2374:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    2378:	e7ee      	b.n	2358 <pm_system_resume+0x54>
    237a:	bf00      	nop
    237c:	200026a0 	.word	0x200026a0
    2380:	20000a10 	.word	0x20000a10
    2384:	20000a14 	.word	0x20000a14
    2388:	0000fbfb 	.word	0x0000fbfb

0000238c <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
    238c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool ret = true;
	uint8_t id = _current_cpu->id;
    2390:	4b37      	ldr	r3, [pc, #220]	; (2470 <pm_system_suspend+0xe4>)
    2392:	4c38      	ldr	r4, [pc, #224]	; (2474 <pm_system_suspend+0xe8>)
    2394:	7d1d      	ldrb	r5, [r3, #20]
{
    2396:	b088      	sub	sp, #32
    2398:	4680      	mov	r8, r0

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_and_set_bit(z_power_states_forced, id)) {
    239a:	4628      	mov	r0, r5
    239c:	f7ff ff96 	bl	22cc <atomic_test_and_set_bit.constprop.0>
    23a0:	b960      	cbnz	r0, 23bc <pm_system_suspend+0x30>
		z_power_states[id] = pm_policy_next_state(id, ticks);
    23a2:	466f      	mov	r7, sp
    23a4:	4642      	mov	r2, r8
    23a6:	4629      	mov	r1, r5
    23a8:	4638      	mov	r0, r7
    23aa:	f00d fb7e 	bl	faaa <pm_policy_next_state>
    23ae:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    23b2:	260c      	movs	r6, #12
    23b4:	fb06 4605 	mla	r6, r6, r5, r4
    23b8:	e886 0007 	stmia.w	r6, {r0, r1, r2}
	}

	if (z_power_states[id].state == PM_STATE_ACTIVE) {
    23bc:	230c      	movs	r3, #12
    23be:	436b      	muls	r3, r5
    23c0:	18e2      	adds	r2, r4, r3
    23c2:	5ce0      	ldrb	r0, [r4, r3]
    23c4:	096e      	lsrs	r6, r5, #5
    23c6:	f005 071f 	and.w	r7, r5, #31
    23ca:	2800      	cmp	r0, #0
    23cc:	d03b      	beq.n	2446 <pm_system_suspend+0xba>
				   z_power_states[id].state);
		ret = false;
		goto end;
	}

	if (ticks != K_TICKS_FOREVER) {
    23ce:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    23d2:	d010      	beq.n	23f6 <pm_system_suspend+0x6a>
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
    23d4:	f8d2 e008 	ldr.w	lr, [r2, #8]
    23d8:	4827      	ldr	r0, [pc, #156]	; (2478 <pm_system_suspend+0xec>)
    23da:	4a28      	ldr	r2, [pc, #160]	; (247c <pm_system_suspend+0xf0>)
    23dc:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
    23e0:	2100      	movs	r1, #0
    23e2:	2300      	movs	r3, #0
    23e4:	fbee 010c 	umlal	r0, r1, lr, ip
    23e8:	f7fd fe8a 	bl	100 <__aeabi_uldivmod>

		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		z_set_timeout_expiry(ticks -
    23ec:	2101      	movs	r1, #1
    23ee:	eba8 0000 	sub.w	r0, r8, r0
    23f2:	f010 fb12 	bl	12a1a <z_set_timeout_expiry>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
    23f6:	f00c fb3b 	bl	ea70 <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
    23fa:	2001      	movs	r0, #1
    23fc:	f7ff ff38 	bl	2270 <pm_state_notify>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    2400:	f3bf 8f5b 	dmb	ish
    2404:	4b1e      	ldr	r3, [pc, #120]	; (2480 <pm_system_suspend+0xf4>)
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    2406:	2201      	movs	r2, #1
    2408:	40ba      	lsls	r2, r7
    240a:	eb03 0386 	add.w	r3, r3, r6, lsl #2
    240e:	e853 1f00 	ldrex	r1, [r3]
    2412:	4311      	orrs	r1, r2
    2414:	e843 1000 	strex	r0, r1, [r3]
    2418:	2800      	cmp	r0, #0
    241a:	d1f8      	bne.n	240e <pm_system_suspend+0x82>
    241c:	f3bf 8f5b 	dmb	ish
	atomic_set_bit(z_post_ops_required, id);
	pm_state_set(z_power_states[id]);
    2420:	230c      	movs	r3, #12
    2422:	fb03 4405 	mla	r4, r3, r5, r4
    2426:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    242a:	ab05      	add	r3, sp, #20
    242c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
    2430:	4a14      	ldr	r2, [pc, #80]	; (2484 <pm_system_suspend+0xf8>)
    2432:	b11a      	cbz	r2, 243c <pm_system_suspend+0xb0>
		pm_power_state_set(info);
    2434:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    2438:	f00d fbcc 	bl	fbd4 <pm_power_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_power_states[id].state);
	pm_system_resume();
    243c:	f7ff ff62 	bl	2304 <pm_system_resume>
	k_sched_unlock();
    2440:	f00c fc9c 	bl	ed7c <k_sched_unlock>
	bool ret = true;
    2444:	2001      	movs	r0, #1
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    2446:	4a10      	ldr	r2, [pc, #64]	; (2488 <pm_system_suspend+0xfc>)
    2448:	f3bf 8f5b 	dmb	ish
	atomic_val_t mask = ATOMIC_MASK(bit);
    244c:	2301      	movs	r3, #1
    244e:	40bb      	lsls	r3, r7
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    2450:	43db      	mvns	r3, r3
    2452:	eb02 0686 	add.w	r6, r2, r6, lsl #2
    2456:	e856 2f00 	ldrex	r2, [r6]
    245a:	401a      	ands	r2, r3
    245c:	e846 2100 	strex	r1, r2, [r6]
    2460:	2900      	cmp	r1, #0
    2462:	d1f8      	bne.n	2456 <pm_system_suspend+0xca>
    2464:	f3bf 8f5b 	dmb	ish
				   z_power_states[id].state);

end:
	atomic_clear_bit(z_power_states_forced, id);
	return ret;
}
    2468:	b008      	add	sp, #32
    246a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    246e:	bf00      	nop
    2470:	200026a0 	.word	0x200026a0
    2474:	20000a14 	.word	0x20000a14
    2478:	000f423f 	.word	0x000f423f
    247c:	000f4240 	.word	0x000f4240
    2480:	20000a10 	.word	0x20000a10
    2484:	0000fbd5 	.word	0x0000fbd5
    2488:	20000a20 	.word	0x20000a20

0000248c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    248c:	4901      	ldr	r1, [pc, #4]	; (2494 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    248e:	2210      	movs	r2, #16
	str	r2, [r1]
    2490:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    2492:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    2494:	e000ed10 	.word	0xe000ed10

00002498 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    2498:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    249a:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    249c:	f380 8811 	msr	BASEPRI, r0
	isb
    24a0:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    24a4:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    24a8:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    24aa:	b662      	cpsie	i
	isb
    24ac:	f3bf 8f6f 	isb	sy

	bx	lr
    24b0:	4770      	bx	lr
    24b2:	bf00      	nop

000024b4 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    24b4:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    24b6:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    24b8:	f381 8811 	msr	BASEPRI, r1

	wfe
    24bc:	bf20      	wfe

	msr	BASEPRI, r0
    24be:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    24c2:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    24c4:	4770      	bx	lr
    24c6:	bf00      	nop

000024c8 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    24c8:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    24ca:	2b00      	cmp	r3, #0
    24cc:	db08      	blt.n	24e0 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    24ce:	2201      	movs	r2, #1
    24d0:	f000 001f 	and.w	r0, r0, #31
    24d4:	fa02 f000 	lsl.w	r0, r2, r0
    24d8:	095b      	lsrs	r3, r3, #5
    24da:	4a02      	ldr	r2, [pc, #8]	; (24e4 <arch_irq_enable+0x1c>)
    24dc:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    24e0:	4770      	bx	lr
    24e2:	bf00      	nop
    24e4:	e000e100 	.word	0xe000e100

000024e8 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    24e8:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    24ea:	2b00      	cmp	r3, #0
    24ec:	db0d      	blt.n	250a <arch_irq_disable+0x22>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    24ee:	2201      	movs	r2, #1
    24f0:	095b      	lsrs	r3, r3, #5
    24f2:	f000 001f 	and.w	r0, r0, #31
    24f6:	fa02 f000 	lsl.w	r0, r2, r0
    24fa:	3320      	adds	r3, #32
    24fc:	4a03      	ldr	r2, [pc, #12]	; (250c <arch_irq_disable+0x24>)
    24fe:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    2502:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2506:	f3bf 8f6f 	isb	sy
}
    250a:	4770      	bx	lr
    250c:	e000e100 	.word	0xe000e100

00002510 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    2510:	4b05      	ldr	r3, [pc, #20]	; (2528 <arch_irq_is_enabled+0x18>)
    2512:	0942      	lsrs	r2, r0, #5
    2514:	f000 001f 	and.w	r0, r0, #31
    2518:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    251c:	2301      	movs	r3, #1
    251e:	fa03 f000 	lsl.w	r0, r3, r0
}
    2522:	4010      	ands	r0, r2
    2524:	4770      	bx	lr
    2526:	bf00      	nop
    2528:	e000e100 	.word	0xe000e100

0000252c <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    252c:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    252e:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    2530:	bfa8      	it	ge
    2532:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
		prio += _IRQ_PRIO_OFFSET;
    2536:	f101 0101 	add.w	r1, r1, #1
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    253a:	bfb8      	it	lt
    253c:	4b06      	ldrlt	r3, [pc, #24]	; (2558 <z_arm_irq_priority_set+0x2c>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    253e:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2542:	bfac      	ite	ge
    2544:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    2548:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    254c:	b2c9      	uxtb	r1, r1
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    254e:	bfb4      	ite	lt
    2550:	5419      	strblt	r1, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    2552:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
}
    2556:	4770      	bx	lr
    2558:	e000ed14 	.word	0xe000ed14

0000255c <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
    255c:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
    255e:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
    2560:	4b04      	ldr	r3, [pc, #16]	; (2574 <_arch_isr_direct_pm+0x18>)
    2562:	699a      	ldr	r2, [r3, #24]
    2564:	b11a      	cbz	r2, 256e <_arch_isr_direct_pm+0x12>
		_kernel.idle = 0;
    2566:	2200      	movs	r2, #0
    2568:	619a      	str	r2, [r3, #24]
		z_pm_save_idle_exit();
    256a:	f00f ffbf 	bl	124ec <z_pm_save_idle_exit>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
    256e:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
    2570:	bd08      	pop	{r3, pc}
    2572:	bf00      	nop
    2574:	200026a0 	.word	0x200026a0

00002578 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    2578:	bf30      	wfi
    b z_SysNmiOnReset
    257a:	f7ff bffd 	b.w	2578 <z_SysNmiOnReset>
    257e:	bf00      	nop

00002580 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    2580:	4a0f      	ldr	r2, [pc, #60]	; (25c0 <z_arm_prep_c+0x40>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    2582:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    2584:	4b0f      	ldr	r3, [pc, #60]	; (25c4 <z_arm_prep_c+0x44>)
    2586:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    258a:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    258c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2590:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    2594:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    2598:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    259c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    25a0:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    25a4:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    25a8:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
    25ac:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    25b0:	f00b fed2 	bl	e358 <z_bss_zero>
	z_data_copy();
    25b4:	f00c fd26 	bl	f004 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    25b8:	f000 f9ca 	bl	2950 <z_arm_interrupt_init>
	z_cstart();
    25bc:	f00b fed6 	bl	e36c <z_cstart>
    25c0:	00000000 	.word	0x00000000
    25c4:	e000ed00 	.word	0xe000ed00

000025c8 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    25c8:	4a09      	ldr	r2, [pc, #36]	; (25f0 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    25ca:	490a      	ldr	r1, [pc, #40]	; (25f4 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    25cc:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    25ce:	6809      	ldr	r1, [r1, #0]
    25d0:	67d9      	str	r1, [r3, #124]	; 0x7c

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    25d2:	4909      	ldr	r1, [pc, #36]	; (25f8 <arch_swap+0x30>)
	_current->arch.basepri = key;
    25d4:	6798      	str	r0, [r3, #120]	; 0x78
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    25d6:	684b      	ldr	r3, [r1, #4]
    25d8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    25dc:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
    25de:	2300      	movs	r3, #0
    25e0:	f383 8811 	msr	BASEPRI, r3
    25e4:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    25e8:	6893      	ldr	r3, [r2, #8]
}
    25ea:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
    25ec:	4770      	bx	lr
    25ee:	bf00      	nop
    25f0:	200026a0 	.word	0x200026a0
    25f4:	000131cc 	.word	0x000131cc
    25f8:	e000ed00 	.word	0xe000ed00

000025fc <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    25fc:	4912      	ldr	r1, [pc, #72]	; (2648 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    25fe:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    2600:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    2604:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    2606:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    260a:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    260e:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
    2610:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    2614:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    2618:	4f0c      	ldr	r7, [pc, #48]	; (264c <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    261a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    261e:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
    2620:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    2622:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    2624:	6f90      	ldr	r0, [r2, #120]	; 0x78
    movs r3, #0
    2626:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    2628:	6793      	str	r3, [r2, #120]	; 0x78
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    262a:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
    262e:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    2630:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    2632:	f000 fa03 	bl	2a3c <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    2636:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    263a:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    263e:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    2642:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
    2646:	4770      	bx	lr
    ldr r1, =_kernel
    2648:	200026a0 	.word	0x200026a0
    ldr v4, =_SCS_ICSR
    264c:	e000ed04 	.word	0xe000ed04

00002650 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
    2650:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    2654:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    2656:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    265a:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    265e:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    2660:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    2664:	2902      	cmp	r1, #2
    beq _oops
    2666:	d0ff      	beq.n	2668 <_oops>

00002668 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    2668:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    266a:	f00d fa25 	bl	fab8 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    266e:	bd01      	pop	{r0, pc}

00002670 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
    2670:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
    2674:	9b00      	ldr	r3, [sp, #0]
    2676:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->pc &= 0xfffffffe;
    267a:	490a      	ldr	r1, [pc, #40]	; (26a4 <arch_new_thread+0x34>)
	iframe->a3 = (uint32_t)p2;
    267c:	9b01      	ldr	r3, [sp, #4]
    267e:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
    2682:	9b02      	ldr	r3, [sp, #8]
    2684:	f842 3c14 	str.w	r3, [r2, #-20]
	iframe->pc &= 0xfffffffe;
    2688:	f021 0101 	bic.w	r1, r1, #1

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    268c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    2690:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->pc &= 0xfffffffe;
    2694:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
    2698:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    269a:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
    269c:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    269e:	6783      	str	r3, [r0, #120]	; 0x78
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    26a0:	4770      	bx	lr
    26a2:	bf00      	nop
    26a4:	0000f651 	.word	0x0000f651

000026a8 <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
    26a8:	4a09      	ldr	r2, [pc, #36]	; (26d0 <z_check_thread_stack_fail+0x28>)
{
    26aa:	4603      	mov	r3, r0
	const struct k_thread *thread = _current;
    26ac:	6890      	ldr	r0, [r2, #8]

	if (thread == NULL) {
    26ae:	b170      	cbz	r0, 26ce <z_check_thread_stack_fail+0x26>
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    26b0:	f113 0f16 	cmn.w	r3, #22
    26b4:	6e80      	ldr	r0, [r0, #104]	; 0x68
    26b6:	d005      	beq.n	26c4 <z_check_thread_stack_fail+0x1c>
    26b8:	f1a0 0220 	sub.w	r2, r0, #32
    26bc:	429a      	cmp	r2, r3
    26be:	d805      	bhi.n	26cc <z_check_thread_stack_fail+0x24>
    26c0:	4283      	cmp	r3, r0
    26c2:	d203      	bcs.n	26cc <z_check_thread_stack_fail+0x24>
		return (uint32_t)Z_THREAD_STACK_BUFFER(z_main_stack);
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
    26c4:	4281      	cmp	r1, r0
    26c6:	bf28      	it	cs
    26c8:	2000      	movcs	r0, #0
    26ca:	4770      	bx	lr
    26cc:	2000      	movs	r0, #0
}
    26ce:	4770      	bx	lr
    26d0:	200026a0 	.word	0x200026a0

000026d4 <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    26d4:	b508      	push	{r3, lr}
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    26d6:	4b09      	ldr	r3, [pc, #36]	; (26fc <arch_switch_to_main_thread+0x28>)
    26d8:	6098      	str	r0, [r3, #8]
{
    26da:	460d      	mov	r5, r1
    26dc:	4614      	mov	r4, r2
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    26de:	f000 f9ad 	bl	2a3c <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    26e2:	4620      	mov	r0, r4
    26e4:	f385 8809 	msr	PSP, r5
    26e8:	2100      	movs	r1, #0
    26ea:	b663      	cpsie	if
    26ec:	f381 8811 	msr	BASEPRI, r1
    26f0:	f3bf 8f6f 	isb	sy
    26f4:	2200      	movs	r2, #0
    26f6:	2300      	movs	r3, #0
    26f8:	f00c ffaa 	bl	f650 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    26fc:	200026a0 	.word	0x200026a0

00002700 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    2700:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    2702:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    2704:	4a0b      	ldr	r2, [pc, #44]	; (2734 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    2706:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
    2708:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    270a:	bf1e      	ittt	ne
	movne	r1, #0
    270c:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    270e:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
    2710:	f00f feec 	blne	124ec <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    2714:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    2716:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    271a:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    271e:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    2722:	4905      	ldr	r1, [pc, #20]	; (2738 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    2724:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    2726:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    2728:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    272a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    272e:	4903      	ldr	r1, [pc, #12]	; (273c <_isr_wrapper+0x3c>)
	bx r1
    2730:	4708      	bx	r1
    2732:	0000      	.short	0x0000
	ldr r2, =_kernel
    2734:	200026a0 	.word	0x200026a0
	ldr r1, =_sw_isr_table
    2738:	00012e4c 	.word	0x00012e4c
	ldr r1, =z_arm_int_exit
    273c:	00002741 	.word	0x00002741

00002740 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    2740:	4b04      	ldr	r3, [pc, #16]	; (2754 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    2742:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    2744:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
    2746:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    2748:	d003      	beq.n	2752 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    274a:	4903      	ldr	r1, [pc, #12]	; (2758 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    274c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    2750:	600a      	str	r2, [r1, #0]

00002752 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    2752:	4770      	bx	lr
	ldr r3, =_kernel
    2754:	200026a0 	.word	0x200026a0
	ldr r1, =_SCS_ICSR
    2758:	e000ed04 	.word	0xe000ed04

0000275c <mem_manage_fault>:
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
			      bool *recoverable)
{
    275c:	b538      	push	{r3, r4, r5, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    275e:	4b19      	ldr	r3, [pc, #100]	; (27c4 <mem_manage_fault+0x68>)
{
    2760:	4614      	mov	r4, r2
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    2762:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    2764:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    2766:	6a9a      	ldr	r2, [r3, #40]	; 0x28
{
    2768:	4605      	mov	r5, r0
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    276a:	0790      	lsls	r0, r2, #30
    276c:	d519      	bpl.n	27a2 <mem_manage_fault+0x46>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		uint32_t temp = SCB->MMFAR;
    276e:	6b58      	ldr	r0, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    2770:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2772:	0612      	lsls	r2, r2, #24
    2774:	d515      	bpl.n	27a2 <mem_manage_fault+0x46>
			mmfar = temp;
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault != 0) {
    2776:	b119      	cbz	r1, 2780 <mem_manage_fault+0x24>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    2778:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    277a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    277e:	629a      	str	r2, [r3, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    2780:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Instruction Access Violation");
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    2782:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	 * crossed into an area beyond the thread stack.]
	 *
	 * Data Access Violation errors may or may not be caused by
	 * thread stack overflows.
	 */
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    2784:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2786:	06d1      	lsls	r1, r2, #27
    2788:	d40e      	bmi.n	27a8 <mem_manage_fault+0x4c>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    278a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    278c:	079a      	lsls	r2, r3, #30
    278e:	d40b      	bmi.n	27a8 <mem_manage_fault+0x4c>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    2790:	2000      	movs	r0, #0
		"without stack guard, user-mode or null-pointer detection\n");
#endif /* CONFIG_MPU_STACK_GUARD || CONFIG_USERSPACE */
	}

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    2792:	4a0c      	ldr	r2, [pc, #48]	; (27c4 <mem_manage_fault+0x68>)
    2794:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2796:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
    279a:	6293      	str	r3, [r2, #40]	; 0x28

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf, true);
    279c:	2300      	movs	r3, #0
    279e:	7023      	strb	r3, [r4, #0]

	return reason;
}
    27a0:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t mmfar = -EINVAL;
    27a2:	f06f 0015 	mvn.w	r0, #21
    27a6:	e7eb      	b.n	2780 <mem_manage_fault+0x24>
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
    27a8:	4b06      	ldr	r3, [pc, #24]	; (27c4 <mem_manage_fault+0x68>)
    27aa:	685b      	ldr	r3, [r3, #4]
    27ac:	051b      	lsls	r3, r3, #20
    27ae:	d5ef      	bpl.n	2790 <mem_manage_fault+0x34>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
    27b0:	4629      	mov	r1, r5
    27b2:	f7ff ff79 	bl	26a8 <z_check_thread_stack_fail>
			if (min_stack_ptr) {
    27b6:	2800      	cmp	r0, #0
    27b8:	d0ea      	beq.n	2790 <mem_manage_fault+0x34>
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
    27ba:	f380 8809 	msr	PSP, r0
				reason = K_ERR_STACK_CHK_FAIL;
    27be:	2002      	movs	r0, #2
    27c0:	e7e7      	b.n	2792 <mem_manage_fault+0x36>
    27c2:	bf00      	nop
    27c4:	e000ed00 	.word	0xe000ed00

000027c8 <bus_fault.constprop.0>:
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    27c8:	4b0d      	ldr	r3, [pc, #52]	; (2800 <bus_fault.constprop.0+0x38>)
    27ca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    27cc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    27ce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    27d0:	0592      	lsls	r2, r2, #22
    27d2:	d508      	bpl.n	27e6 <bus_fault.constprop.0+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    27d4:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    27d6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    27d8:	0412      	lsls	r2, r2, #16
    27da:	d504      	bpl.n	27e6 <bus_fault.constprop.0+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault != 0) {
    27dc:	b118      	cbz	r0, 27e6 <bus_fault.constprop.0+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    27de:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    27e0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    27e4:	629a      	str	r2, [r3, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    27e6:	4b06      	ldr	r3, [pc, #24]	; (2800 <bus_fault.constprop.0+0x38>)
    27e8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Imprecise data bus error");
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    27ea:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    27ec:	05d2      	lsls	r2, r2, #23
		PR_FAULT_INFO("  Instruction bus error");
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    27ee:	bf58      	it	pl
    27f0:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    27f2:	6a9a      	ldr	r2, [r3, #40]	; 0x28

	*recoverable = memory_fault_recoverable(esf, true);
    27f4:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    27f6:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
    27fa:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    27fc:	7008      	strb	r0, [r1, #0]

	return reason;
}
    27fe:	4770      	bx	lr
    2800:	e000ed00 	.word	0xe000ed00

00002804 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    2804:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    2806:	4b48      	ldr	r3, [pc, #288]	; (2928 <z_arm_fault+0x124>)
    2808:	685b      	ldr	r3, [r3, #4]
{
    280a:	b08a      	sub	sp, #40	; 0x28
    280c:	460d      	mov	r5, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    280e:	f3c3 0308 	ubfx	r3, r3, #0, #9
    2812:	2600      	movs	r6, #0
    2814:	f386 8811 	msr	BASEPRI, r6
    2818:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    281c:	f002 417f 	and.w	r1, r2, #4278190080	; 0xff000000
    2820:	f1b1 4f7f 	cmp.w	r1, #4278190080	; 0xff000000
    2824:	d111      	bne.n	284a <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    2826:	f002 010c 	and.w	r1, r2, #12
    282a:	2908      	cmp	r1, #8
    282c:	d00d      	beq.n	284a <z_arm_fault+0x46>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    282e:	0711      	lsls	r1, r2, #28
    2830:	d401      	bmi.n	2836 <z_arm_fault+0x32>
			ptr_esf = (z_arch_esf_t *)msp;
    2832:	4605      	mov	r5, r0
			*nested_exc = true;
    2834:	2601      	movs	r6, #1
	*recoverable = false;
    2836:	2200      	movs	r2, #0
	switch (fault) {
    2838:	3b03      	subs	r3, #3
	*recoverable = false;
    283a:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
    283e:	2b03      	cmp	r3, #3
    2840:	d86b      	bhi.n	291a <z_arm_fault+0x116>
    2842:	e8df f003 	tbb	[pc, r3]
    2846:	5504      	.short	0x5504
    2848:	5d59      	.short	0x5d59
		return NULL;
    284a:	4635      	mov	r5, r6
    284c:	e7f3      	b.n	2836 <z_arm_fault+0x32>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    284e:	4b36      	ldr	r3, [pc, #216]	; (2928 <z_arm_fault+0x124>)
    2850:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    2852:	f014 0402 	ands.w	r4, r4, #2
    2856:	d160      	bne.n	291a <z_arm_fault+0x116>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
    2858:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    285a:	2a00      	cmp	r2, #0
    285c:	db15      	blt.n	288a <z_arm_fault+0x86>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    285e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2860:	0052      	lsls	r2, r2, #1
    2862:	d512      	bpl.n	288a <z_arm_fault+0x86>
	uint16_t fault_insn = *(ret_addr - 1);
    2864:	69aa      	ldr	r2, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
    2866:	f832 1c02 	ldrh.w	r1, [r2, #-2]
    286a:	f64d 7202 	movw	r2, #57090	; 0xdf02
    286e:	4291      	cmp	r1, r2
    2870:	d00a      	beq.n	2888 <z_arm_fault+0x84>
		} else if (SCB_MMFSR != 0) {
    2872:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    2876:	b30a      	cbz	r2, 28bc <z_arm_fault+0xb8>
			reason = mem_manage_fault(esf, 1, recoverable);
    2878:	f10d 0207 	add.w	r2, sp, #7
    287c:	2101      	movs	r1, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    287e:	4628      	mov	r0, r5
    2880:	f7ff ff6c 	bl	275c <mem_manage_fault>
		reason = bus_fault(esf, 0, recoverable);
    2884:	4604      	mov	r4, r0
		break;
    2886:	e000      	b.n	288a <z_arm_fault+0x86>
			reason = esf->basic.r0;
    2888:	682c      	ldr	r4, [r5, #0]
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    288a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    288e:	b99b      	cbnz	r3, 28b8 <z_arm_fault+0xb4>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    2890:	2220      	movs	r2, #32
    2892:	4629      	mov	r1, r5
    2894:	a802      	add	r0, sp, #8
    2896:	f00d f986 	bl	fba6 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    289a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    289c:	2e00      	cmp	r6, #0
    289e:	d03e      	beq.n	291e <z_arm_fault+0x11a>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    28a0:	f3c3 0208 	ubfx	r2, r3, #0, #9
    28a4:	b922      	cbnz	r2, 28b0 <z_arm_fault+0xac>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    28a6:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    28aa:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    28ae:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    28b0:	a902      	add	r1, sp, #8
    28b2:	4620      	mov	r0, r4
    28b4:	f00d f8fe 	bl	fab4 <z_arm_fatal_error>
}
    28b8:	b00a      	add	sp, #40	; 0x28
    28ba:	bd70      	pop	{r4, r5, r6, pc}
		} else if (SCB_BFSR != 0) {
    28bc:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
    28c0:	b12a      	cbz	r2, 28ce <z_arm_fault+0xca>
			reason = bus_fault(esf, 1, recoverable);
    28c2:	f10d 0107 	add.w	r1, sp, #7
    28c6:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    28c8:	f7ff ff7e 	bl	27c8 <bus_fault.constprop.0>
    28cc:	e7da      	b.n	2884 <z_arm_fault+0x80>
		} else if (SCB_UFSR != 0) {
    28ce:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
    28d0:	b292      	uxth	r2, r2
    28d2:	2a00      	cmp	r2, #0
    28d4:	d0d9      	beq.n	288a <z_arm_fault+0x86>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    28d6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    28d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    28da:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    28dc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    28de:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    28e0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    28e2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    28e4:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    28e8:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    28ec:	629a      	str	r2, [r3, #40]	; 0x28
	return reason;
    28ee:	e7cc      	b.n	288a <z_arm_fault+0x86>
		reason = mem_manage_fault(esf, 0, recoverable);
    28f0:	f10d 0207 	add.w	r2, sp, #7
    28f4:	2100      	movs	r1, #0
    28f6:	e7c2      	b.n	287e <z_arm_fault+0x7a>
		reason = bus_fault(esf, 0, recoverable);
    28f8:	f10d 0107 	add.w	r1, sp, #7
    28fc:	2000      	movs	r0, #0
    28fe:	e7e3      	b.n	28c8 <z_arm_fault+0xc4>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    2900:	4b09      	ldr	r3, [pc, #36]	; (2928 <z_arm_fault+0x124>)
    2902:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    2904:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    2906:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    2908:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    290a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    290c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    290e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2910:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    2914:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    2918:	629a      	str	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    291a:	2400      	movs	r4, #0
    291c:	e7b5      	b.n	288a <z_arm_fault+0x86>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    291e:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    2922:	f023 0301 	bic.w	r3, r3, #1
    2926:	e7c2      	b.n	28ae <z_arm_fault+0xaa>
    2928:	e000ed00 	.word	0xe000ed00

0000292c <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    292c:	4a02      	ldr	r2, [pc, #8]	; (2938 <z_arm_fault_init+0xc>)
    292e:	6953      	ldr	r3, [r2, #20]
    2930:	f043 0310 	orr.w	r3, r3, #16
    2934:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    2936:	4770      	bx	lr
    2938:	e000ed00 	.word	0xe000ed00

0000293c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    293c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    2940:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    2944:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    2946:	4672      	mov	r2, lr
	bl z_arm_fault
    2948:	f7ff ff5c 	bl	2804 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    294c:	bd01      	pop	{r0, pc}
    294e:	bf00      	nop

00002950 <z_arm_interrupt_init>:
    2950:	4804      	ldr	r0, [pc, #16]	; (2964 <z_arm_interrupt_init+0x14>)
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    2952:	2300      	movs	r3, #0
    2954:	2120      	movs	r1, #32
    2956:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    2958:	3301      	adds	r3, #1
    295a:	2b30      	cmp	r3, #48	; 0x30
    295c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    2960:	d1f9      	bne.n	2956 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    2962:	4770      	bx	lr
    2964:	e000e100 	.word	0xe000e100

00002968 <__start>:
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
    2968:	f010 f9ee 	bl	12d48 <z_arm_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    296c:	2020      	movs	r0, #32
    msr BASEPRI, r0
    296e:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    2972:	4808      	ldr	r0, [pc, #32]	; (2994 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    2974:	f44f 6102 	mov.w	r1, #2080	; 0x820
    adds r0, r0, r1
    2978:	1840      	adds	r0, r0, r1
    msr PSP, r0
    297a:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    297e:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    2982:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    2984:	4308      	orrs	r0, r1
    msr CONTROL, r0
    2986:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    298a:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    298e:	f7ff fdf7 	bl	2580 <z_arm_prep_c>
    2992:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
    2994:	20003cc0 	.word	0x20003cc0

00002998 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
    2998:	4b06      	ldr	r3, [pc, #24]	; (29b4 <z_impl_k_thread_abort+0x1c>)
    299a:	689b      	ldr	r3, [r3, #8]
    299c:	4283      	cmp	r3, r0
    299e:	d107      	bne.n	29b0 <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    29a0:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    29a4:	b123      	cbz	r3, 29b0 <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    29a6:	4a04      	ldr	r2, [pc, #16]	; (29b8 <z_impl_k_thread_abort+0x20>)
    29a8:	6853      	ldr	r3, [r2, #4]
    29aa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    29ae:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
    29b0:	f00c bac4 	b.w	ef3c <z_thread_abort>
    29b4:	200026a0 	.word	0x200026a0
    29b8:	e000ed00 	.word	0xe000ed00

000029bc <arch_timing_init>:
 * @return 0
 */
static inline int z_arm_dwt_init(void)
{
	/* Enable tracing */
	CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
    29bc:	4a07      	ldr	r2, [pc, #28]	; (29dc <arch_timing_init+0x20>)
    29be:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
    29c2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    29c6:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
 * @return 0
 */
static inline int z_arm_dwt_init_cycle_counter(void)
{
	/* Clear and enable the cycle counter */
	DWT->CYCCNT = 0;
    29ca:	4b05      	ldr	r3, [pc, #20]	; (29e0 <arch_timing_init+0x24>)
    29cc:	2200      	movs	r2, #0
    29ce:	605a      	str	r2, [r3, #4]
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
    29d0:	681a      	ldr	r2, [r3, #0]
    29d2:	f042 0201 	orr.w	r2, r2, #1
    29d6:	601a      	str	r2, [r3, #0]

void arch_timing_init(void)
{
	z_arm_dwt_init();
	z_arm_dwt_init_cycle_counter();
}
    29d8:	4770      	bx	lr
    29da:	bf00      	nop
    29dc:	e000ed00 	.word	0xe000ed00
    29e0:	e0001000 	.word	0xe0001000

000029e4 <arch_timing_start>:
 *
 * @return N/A
 */
static inline void z_arm_dwt_cycle_count_start(void)
{
	DWT->CYCCNT = 0;
    29e4:	4b03      	ldr	r3, [pc, #12]	; (29f4 <arch_timing_start+0x10>)
    29e6:	2200      	movs	r2, #0
    29e8:	605a      	str	r2, [r3, #4]
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
    29ea:	681a      	ldr	r2, [r3, #0]
    29ec:	f042 0201 	orr.w	r2, r2, #1
    29f0:	601a      	str	r2, [r3, #0]

void arch_timing_start(void)
{
	z_arm_dwt_cycle_count_start();
}
    29f2:	4770      	bx	lr
    29f4:	e0001000 	.word	0xe0001000

000029f8 <arch_timing_counter_get>:
	return DWT->CYCCNT;
    29f8:	4b01      	ldr	r3, [pc, #4]	; (2a00 <arch_timing_counter_get+0x8>)
}

timing_t arch_timing_counter_get(void)
{
	return (timing_t)z_arm_dwt_get_cycles();
}
    29fa:	2100      	movs	r1, #0
    29fc:	6858      	ldr	r0, [r3, #4]
    29fe:	4770      	bx	lr
    2a00:	e0001000 	.word	0xe0001000

00002a04 <arch_timing_freq_get_mhz>:
{
	return arch_timing_cycles_to_ns(cycles) / count;
}

uint32_t arch_timing_freq_get_mhz(void)
{
    2a04:	b508      	push	{r3, lr}
	SystemCoreClockUpdate();
    2a06:	f00a fec3 	bl	d790 <SystemCoreClockUpdate>
	return (uint32_t)(arch_timing_freq_get() / 1000000U);
    2a0a:	4904      	ldr	r1, [pc, #16]	; (2a1c <arch_timing_freq_get_mhz+0x18>)
    2a0c:	4a04      	ldr	r2, [pc, #16]	; (2a20 <arch_timing_freq_get_mhz+0x1c>)
    2a0e:	6808      	ldr	r0, [r1, #0]
    2a10:	2300      	movs	r3, #0
    2a12:	2100      	movs	r1, #0
    2a14:	f7fd fb74 	bl	100 <__aeabi_uldivmod>
}
    2a18:	bd08      	pop	{r3, pc}
    2a1a:	bf00      	nop
    2a1c:	200004e4 	.word	0x200004e4
    2a20:	000f4240 	.word	0x000f4240

00002a24 <z_arm_configure_static_mpu_regions>:
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    2a24:	4b02      	ldr	r3, [pc, #8]	; (2a30 <z_arm_configure_static_mpu_regions+0xc>)
    2a26:	4a03      	ldr	r2, [pc, #12]	; (2a34 <z_arm_configure_static_mpu_regions+0x10>)
    2a28:	4803      	ldr	r0, [pc, #12]	; (2a38 <z_arm_configure_static_mpu_regions+0x14>)
    2a2a:	2101      	movs	r1, #1
    2a2c:	f000 b86e 	b.w	2b0c <arm_core_mpu_configure_static_mpu_regions>
    2a30:	20040000 	.word	0x20040000
    2a34:	20000000 	.word	0x20000000
    2a38:	00013020 	.word	0x00013020

00002a3c <z_arm_configure_dynamic_mpu_regions>:
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
    2a3c:	6e82      	ldr	r2, [r0, #104]	; 0x68
	}

	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
    2a3e:	4b05      	ldr	r3, [pc, #20]	; (2a54 <z_arm_configure_dynamic_mpu_regions+0x18>)
		guard_start = thread->stack_info.start - guard_size;
    2a40:	3a20      	subs	r2, #32
	dynamic_regions[region_num].start = guard_start;
    2a42:	601a      	str	r2, [r3, #0]
	dynamic_regions[region_num].size = guard_size;
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
    2a44:	4a04      	ldr	r2, [pc, #16]	; (2a58 <z_arm_configure_dynamic_mpu_regions+0x1c>)
    2a46:	2120      	movs	r1, #32
    2a48:	e9c3 1201 	strd	r1, r2, [r3, #4]

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
    2a4c:	4618      	mov	r0, r3
    2a4e:	2101      	movs	r1, #1
    2a50:	f000 b866 	b.w	2b20 <arm_core_mpu_configure_dynamic_mpu_regions>
    2a54:	20000a24 	.word	0x20000a24
    2a58:	150b0000 	.word	0x150b0000

00002a5c <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
    2a5c:	b5f0      	push	{r4, r5, r6, r7, lr}
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
    2a5e:	4f1f      	ldr	r7, [pc, #124]	; (2adc <mpu_configure_regions+0x80>)
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    2a60:	2600      	movs	r6, #0
    2a62:	428e      	cmp	r6, r1
    2a64:	db01      	blt.n	2a6a <mpu_configure_regions+0xe>
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    2a66:	4610      	mov	r0, r2
    2a68:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (regions[i].size == 0U) {
    2a6a:	6844      	ldr	r4, [r0, #4]
    2a6c:	b39c      	cbz	r4, 2ad6 <mpu_configure_regions+0x7a>
		if (do_sanity_check &&
    2a6e:	b153      	cbz	r3, 2a86 <mpu_configure_regions+0x2a>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1U)) == 0U)
    2a70:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    2a74:	ea14 0f0c 	tst.w	r4, ip
    2a78:	d118      	bne.n	2aac <mpu_configure_regions+0x50>
		&&
    2a7a:	2c1f      	cmp	r4, #31
    2a7c:	d916      	bls.n	2aac <mpu_configure_regions+0x50>
		((part->start & (part->size - 1U)) == 0U);
    2a7e:	6805      	ldr	r5, [r0, #0]
		&&
    2a80:	ea1c 0f05 	tst.w	ip, r5
    2a84:	d112      	bne.n	2aac <mpu_configure_regions+0x50>
 * to that power-of-two value.
 */
static inline uint32_t size_to_mpu_rasr_size(uint32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    2a86:	2c20      	cmp	r4, #32
	region_conf.base = new_region->start;
    2a88:	6805      	ldr	r5, [r0, #0]
#if defined(CONFIG_CPU_CORTEX_R)
	(void) size;

	p_attr->rasr = attr->rasr_attr;
#else
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    2a8a:	f8d0 c008 	ldr.w	ip, [r0, #8]
		reg_index = mpu_configure_region(reg_index, &regions[i]);
    2a8e:	b2d2      	uxtb	r2, r2
	if (size <= 32U) {
    2a90:	d90f      	bls.n	2ab2 <mpu_configure_regions+0x56>
	if (size > (1UL << 31)) {
    2a92:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    2a96:	d80e      	bhi.n	2ab6 <mpu_configure_regions+0x5a>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    2a98:	3c01      	subs	r4, #1
    2a9a:	fab4 f484 	clz	r4, r4
    2a9e:	f1c4 041f 	rsb	r4, r4, #31
    2aa2:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1U)) {
    2aa4:	2a07      	cmp	r2, #7
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    2aa6:	ea4c 0404 	orr.w	r4, ip, r4
    2aaa:	d906      	bls.n	2aba <mpu_configure_regions+0x5e>
			return -EINVAL;
    2aac:	f06f 0215 	mvn.w	r2, #21
    2ab0:	e7d9      	b.n	2a66 <mpu_configure_regions+0xa>
		return REGION_32B;
    2ab2:	2408      	movs	r4, #8
    2ab4:	e7f6      	b.n	2aa4 <mpu_configure_regions+0x48>
		return REGION_4G;
    2ab6:	243e      	movs	r4, #62	; 0x3e
    2ab8:	e7f4      	b.n	2aa4 <mpu_configure_regions+0x48>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    2aba:	f025 051f 	bic.w	r5, r5, #31
				| MPU_RBAR_VALID_Msk | index;
    2abe:	4315      	orrs	r5, r2
    2ac0:	f045 0510 	orr.w	r5, r5, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    2ac4:	f044 0401 	orr.w	r4, r4, #1
    2ac8:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    2acc:	f8c7 509c 	str.w	r5, [r7, #156]	; 0x9c
		reg_index++;
    2ad0:	3201      	adds	r2, #1
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    2ad2:	f8c7 40a0 	str.w	r4, [r7, #160]	; 0xa0
	for (i = 0; i < regions_num; i++) {
    2ad6:	3601      	adds	r6, #1
    2ad8:	300c      	adds	r0, #12
    2ada:	e7c2      	b.n	2a62 <mpu_configure_regions+0x6>
    2adc:	e000ed00 	.word	0xe000ed00

00002ae0 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    2ae0:	4b04      	ldr	r3, [pc, #16]	; (2af4 <arm_core_mpu_enable+0x14>)
    2ae2:	2205      	movs	r2, #5
    2ae4:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
    2ae8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2aec:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    2af0:	4770      	bx	lr
    2af2:	bf00      	nop
    2af4:	e000ed00 	.word	0xe000ed00

00002af8 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    2af8:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    2afc:	4b02      	ldr	r3, [pc, #8]	; (2b08 <arm_core_mpu_disable+0x10>)
    2afe:	2200      	movs	r2, #0
    2b00:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    2b04:	4770      	bx	lr
    2b06:	bf00      	nop
    2b08:	e000ed00 	.word	0xe000ed00

00002b0c <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
    2b0c:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    2b0e:	4c03      	ldr	r4, [pc, #12]	; (2b1c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    2b10:	2301      	movs	r3, #1
    2b12:	7822      	ldrb	r2, [r4, #0]
    2b14:	f7ff ffa2 	bl	2a5c <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    2b18:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
    2b1a:	bd10      	pop	{r4, pc}
    2b1c:	20002904 	.word	0x20002904

00002b20 <arm_core_mpu_configure_dynamic_mpu_regions>:
/**
 * @brief configure dynamic MPU regions.
 */
void arm_core_mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	dynamic_regions[], uint8_t regions_num)
{
    2b20:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    2b22:	4a09      	ldr	r2, [pc, #36]	; (2b48 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
    2b24:	2300      	movs	r3, #0
    2b26:	7812      	ldrb	r2, [r2, #0]
    2b28:	f7ff ff98 	bl	2a5c <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    2b2c:	f110 0f16 	cmn.w	r0, #22
    2b30:	d002      	beq.n	2b38 <arm_core_mpu_configure_dynamic_mpu_regions+0x18>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    2b32:	4a06      	ldr	r2, [pc, #24]	; (2b4c <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>)

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    2b34:	2807      	cmp	r0, #7
    2b36:	dd00      	ble.n	2b3a <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
		== -EINVAL) {

		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
			regions_num);
	}
}
    2b38:	bd08      	pop	{r3, pc}
    2b3a:	f8c2 0098 	str.w	r0, [r2, #152]	; 0x98
  MPU->RASR = 0U;
    2b3e:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
    2b42:	3001      	adds	r0, #1
    2b44:	e7f6      	b.n	2b34 <arm_core_mpu_configure_dynamic_mpu_regions+0x14>
    2b46:	bf00      	nop
    2b48:	20002904 	.word	0x20002904
    2b4c:	e000ed00 	.word	0xe000ed00

00002b50 <z_arm_mpu_init>:
 */
int z_arm_mpu_init(void)
{
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    2b50:	4914      	ldr	r1, [pc, #80]	; (2ba4 <z_arm_mpu_init+0x54>)
    2b52:	6808      	ldr	r0, [r1, #0]
    2b54:	2808      	cmp	r0, #8
{
    2b56:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    2b58:	d821      	bhi.n	2b9e <z_arm_mpu_init+0x4e>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    2b5a:	f7ff ffcd 	bl	2af8 <arm_core_mpu_disable>
    2b5e:	4c12      	ldr	r4, [pc, #72]	; (2ba8 <z_arm_mpu_init+0x58>)
    2b60:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    2b62:	2200      	movs	r2, #0
    2b64:	4290      	cmp	r0, r2
    2b66:	f101 010c 	add.w	r1, r1, #12
    2b6a:	d105      	bne.n	2b78 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    2b6c:	4b0f      	ldr	r3, [pc, #60]	; (2bac <z_arm_mpu_init+0x5c>)
    2b6e:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    2b70:	f7ff ffb6 	bl	2ae0 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
    2b74:	2000      	movs	r0, #0
}
    2b76:	bd10      	pop	{r4, pc}
    2b78:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    2b7c:	f851 3c0c 	ldr.w	r3, [r1, #-12]
    2b80:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    2b84:	4313      	orrs	r3, r2
    2b86:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    2b8a:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    2b8e:	f851 3c04 	ldr.w	r3, [r1, #-4]
    2b92:	f043 0301 	orr.w	r3, r3, #1
    2b96:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    2b9a:	3201      	adds	r2, #1
    2b9c:	e7e2      	b.n	2b64 <z_arm_mpu_init+0x14>
		return -1;
    2b9e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2ba2:	e7e8      	b.n	2b76 <z_arm_mpu_init+0x26>
    2ba4:	0001302c 	.word	0x0001302c
    2ba8:	e000ed00 	.word	0xe000ed00
    2bac:	20002904 	.word	0x20002904

00002bb0 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    2bb0:	4b01      	ldr	r3, [pc, #4]	; (2bb8 <__stdout_hook_install+0x8>)
    2bb2:	6018      	str	r0, [r3, #0]
}
    2bb4:	4770      	bx	lr
    2bb6:	bf00      	nop
    2bb8:	200000fc 	.word	0x200000fc

00002bbc <nordicsemi_nrf52_init>:
	nrf_power_gpregret_set(NRF_POWER, (uint8_t)type);
	NVIC_SystemReset();
}

static int nordicsemi_nrf52_init(const struct device *arg)
{
    2bbc:	b510      	push	{r4, lr}
	__asm__ volatile(
    2bbe:	f04f 0320 	mov.w	r3, #32
    2bc2:	f3ef 8011 	mrs	r0, BASEPRI
    2bc6:	f383 8812 	msr	BASEPRI_MAX, r3
    2bca:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    2bce:	4a11      	ldr	r2, [pc, #68]	; (2c14 <nordicsemi_nrf52_init+0x58>)
    2bd0:	2301      	movs	r3, #1
    2bd2:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    2bd6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
{
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    2bda:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    2bde:	f8c2 3578 	str.w	r3, [r2, #1400]	; 0x578
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
    2be2:	f8d1 4130 	ldr.w	r4, [r1, #304]	; 0x130
    2be6:	2c08      	cmp	r4, #8
    2be8:	d108      	bne.n	2bfc <nordicsemi_nrf52_init+0x40>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    2bea:	f8d1 1134 	ldr.w	r1, [r1, #308]	; 0x134
            {
                switch(var2)
    2bee:	2905      	cmp	r1, #5
    2bf0:	d804      	bhi.n	2bfc <nordicsemi_nrf52_init+0x40>
#endif // defined(POWER_RAM_POWER_S0POWER_Msk)

#if NRF_POWER_HAS_DCDCEN_VDDH
NRF_STATIC_INLINE void nrf_power_dcdcen_vddh_set(NRF_POWER_Type * p_reg, bool enable)
{
    if (enable && nrf52_errata_197())
    2bf2:	4c09      	ldr	r4, [pc, #36]	; (2c18 <nordicsemi_nrf52_init+0x5c>)
    2bf4:	5c61      	ldrb	r1, [r4, r1]
    2bf6:	b109      	cbz	r1, 2bfc <nordicsemi_nrf52_init+0x40>
    {
        // Workaround for anomaly 197 "POWER: DCDC of REG0 not functional".
        *(volatile uint32_t *)0x40000638ul = 1ul;
    2bf8:	f8c2 3638 	str.w	r3, [r2, #1592]	; 0x638
    }
    p_reg->DCDCEN0 = (enable ? POWER_DCDCEN0_DCDCEN_Enabled : POWER_DCDCEN0_DCDCEN_Disabled) <<
    2bfc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2c00:	2201      	movs	r2, #1
    2c02:	f8c3 2580 	str.w	r2, [r3, #1408]	; 0x580
	__asm__ volatile(
    2c06:	f380 8811 	msr	BASEPRI, r0
    2c0a:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    2c0e:	2000      	movs	r0, #0
    2c10:	bd10      	pop	{r4, pc}
    2c12:	bf00      	nop
    2c14:	4001e000 	.word	0x4001e000
    2c18:	00013373 	.word	0x00013373

00002c1c <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    2c1c:	b120      	cbz	r0, 2c28 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    2c1e:	4b03      	ldr	r3, [pc, #12]	; (2c2c <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    2c20:	0180      	lsls	r0, r0, #6
    2c22:	f043 0301 	orr.w	r3, r3, #1
    2c26:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    2c28:	4770      	bx	lr
    2c2a:	bf00      	nop
    2c2c:	00013010 	.word	0x00013010

00002c30 <bt_buf_get_rx>:
			  BT_BUF_RX_SIZE, 8,
			  NULL);
#endif /* CONFIG_BT_HCI_ACL_FLOW_CONTROL */

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
    2c30:	b538      	push	{r3, r4, r5, lr}
    2c32:	4605      	mov	r5, r0
 * @copydetails net_buf_alloc_fixed
 */
static inline struct net_buf * __must_check net_buf_alloc(struct net_buf_pool *pool,
							  k_timeout_t timeout)
{
	return net_buf_alloc_fixed(pool, timeout);
    2c34:	4805      	ldr	r0, [pc, #20]	; (2c4c <bt_buf_get_rx+0x1c>)
    2c36:	f00f f902 	bl	11e3e <net_buf_alloc_fixed>
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
#endif

	if (buf) {
    2c3a:	4604      	mov	r4, r0
    2c3c:	b120      	cbz	r0, 2c48 <bt_buf_get_rx+0x18>
 * @param buf Buffer to initialize.
 * @param reserve How much headroom to reserve.
 */
static inline void net_buf_reserve(struct net_buf *buf, size_t reserve)
{
	net_buf_simple_reserve(&buf->b, reserve);
    2c3e:	2100      	movs	r1, #0
    2c40:	3008      	adds	r0, #8
    2c42:	f00f f91b 	bl	11e7c <net_buf_simple_reserve>
 *  @param buf   Bluetooth buffer
 *  @param type  The BT_* type to set the buffer to
 */
static inline void bt_buf_set_type(struct net_buf *buf, enum bt_buf_type type)
{
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    2c46:	7525      	strb	r5, [r4, #20]
		net_buf_reserve(buf, BT_BUF_RESERVE);
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    2c48:	4620      	mov	r0, r4
    2c4a:	bd38      	pop	{r3, r4, r5, pc}
    2c4c:	20000628 	.word	0x20000628

00002c50 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(k_timeout_t timeout)
{
    2c50:	460b      	mov	r3, r1
	struct net_buf *buf;

	if (bt_dev.sent_cmd) {
    2c52:	490b      	ldr	r1, [pc, #44]	; (2c80 <bt_buf_get_cmd_complete+0x30>)
{
    2c54:	4602      	mov	r2, r0
	if (bt_dev.sent_cmd) {
    2c56:	f8d1 00c8 	ldr.w	r0, [r1, #200]	; 0xc8
{
    2c5a:	b510      	push	{r4, lr}
	if (bt_dev.sent_cmd) {
    2c5c:	b920      	cbnz	r0, 2c68 <bt_buf_get_cmd_complete+0x18>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
    2c5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    2c62:	2001      	movs	r0, #1
    2c64:	f7ff bfe4 	b.w	2c30 <bt_buf_get_rx>
		buf = net_buf_ref(bt_dev.sent_cmd);
    2c68:	f00f f919 	bl	11e9e <net_buf_ref>
    2c6c:	2301      	movs	r3, #1
		buf->len = 0U;
    2c6e:	2100      	movs	r1, #0
    2c70:	7503      	strb	r3, [r0, #20]
    2c72:	8181      	strh	r1, [r0, #12]
		buf = net_buf_ref(bt_dev.sent_cmd);
    2c74:	4604      	mov	r4, r0
    2c76:	3008      	adds	r0, #8
    2c78:	f00f f900 	bl	11e7c <net_buf_simple_reserve>
}
    2c7c:	4620      	mov	r0, r4
    2c7e:	bd10      	pop	{r4, pc}
    2c80:	20000000 	.word	0x20000000

00002c84 <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable,
			       k_timeout_t timeout)
{
    2c84:	b570      	push	{r4, r5, r6, lr}
    2c86:	4605      	mov	r5, r0
	switch (evt) {
    2c88:	3d0e      	subs	r5, #14
    2c8a:	2d01      	cmp	r5, #1
{
    2c8c:	460c      	mov	r4, r1
    2c8e:	4610      	mov	r0, r2
    2c90:	4619      	mov	r1, r3
	switch (evt) {
    2c92:	d803      	bhi.n	2c9c <bt_buf_get_evt+0x18>
		}
#endif /* CONFIG_BT_BUF_EVT_DISCARDABLE_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
    2c94:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_cmd_complete(timeout);
    2c98:	f7ff bfda 	b.w	2c50 <bt_buf_get_cmd_complete>
		if (discardable) {
    2c9c:	b164      	cbz	r4, 2cb8 <bt_buf_get_evt+0x34>
	return net_buf_alloc_fixed(pool, timeout);
    2c9e:	4809      	ldr	r0, [pc, #36]	; (2cc4 <bt_buf_get_evt+0x40>)
    2ca0:	f00f f8cd 	bl	11e3e <net_buf_alloc_fixed>
			if (buf) {
    2ca4:	4604      	mov	r4, r0
    2ca6:	b128      	cbz	r0, 2cb4 <bt_buf_get_evt+0x30>
	net_buf_simple_reserve(&buf->b, reserve);
    2ca8:	2100      	movs	r1, #0
    2caa:	3008      	adds	r0, #8
    2cac:	f00f f8e6 	bl	11e7c <net_buf_simple_reserve>
    2cb0:	2301      	movs	r3, #1
    2cb2:	7523      	strb	r3, [r4, #20]
}
    2cb4:	4620      	mov	r0, r4
    2cb6:	bd70      	pop	{r4, r5, r6, pc}
    2cb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    2cbc:	2001      	movs	r0, #1
    2cbe:	f7ff bfb7 	b.w	2c30 <bt_buf_get_rx>
    2cc2:	bf00      	nop
    2cc4:	200005d0 	.word	0x200005d0

00002cc8 <hci_le_meta_event>:
		      sizeof(struct bt_hci_evt_le_connection_iq_report)),
#endif /* CONFIG_BT_DF_CONNECTION_CTE_RX */
};

static void hci_le_meta_event(struct net_buf *buf)
{
    2cc8:	b510      	push	{r4, lr}
 *
 * @return Pointer to the old beginning of the buffer data.
 */
static inline void *net_buf_pull_mem(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull_mem(&buf->b, len);
    2cca:	2101      	movs	r1, #1
    2ccc:	4604      	mov	r4, r0
    2cce:	3008      	adds	r0, #8
    2cd0:	f00f f93a 	bl	11f48 <net_buf_simple_pull_mem>

	evt = net_buf_pull_mem(buf, sizeof(*evt));

	BT_DBG("subevent 0x%02x", evt->subevent);

	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    2cd4:	4621      	mov	r1, r4
    2cd6:	4a03      	ldr	r2, [pc, #12]	; (2ce4 <hci_le_meta_event+0x1c>)
    2cd8:	7800      	ldrb	r0, [r0, #0]
}
    2cda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    2cde:	2305      	movs	r3, #5
    2ce0:	f00c bfeb 	b.w	fcba <handle_event>
    2ce4:	0001306c 	.word	0x0001306c

00002ce8 <hci_cmd_done>:
{
    2ce8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2cea:	4607      	mov	r7, r0
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    2cec:	7990      	ldrb	r0, [r2, #6]
{
    2cee:	460e      	mov	r6, r1
    2cf0:	4614      	mov	r4, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    2cf2:	f009 fced 	bl	c6d0 <net_buf_pool_get>
    2cf6:	4b30      	ldr	r3, [pc, #192]	; (2db8 <hci_cmd_done+0xd0>)
    2cf8:	4283      	cmp	r3, r0
    2cfa:	d15b      	bne.n	2db4 <hci_cmd_done+0xcc>
	if (cmd(buf)->opcode != opcode) {
    2cfc:	4620      	mov	r0, r4
    2cfe:	f009 fcef 	bl	c6e0 <net_buf_id>
    2d02:	4d2e      	ldr	r5, [pc, #184]	; (2dbc <hci_cmd_done+0xd4>)
    2d04:	230c      	movs	r3, #12
    2d06:	fb03 5000 	mla	r0, r3, r0, r5
    2d0a:	8843      	ldrh	r3, [r0, #2]
    2d0c:	42bb      	cmp	r3, r7
    2d0e:	d151      	bne.n	2db4 <hci_cmd_done+0xcc>
	if (bt_dev.sent_cmd) {
    2d10:	4f2b      	ldr	r7, [pc, #172]	; (2dc0 <hci_cmd_done+0xd8>)
    2d12:	f8d7 00c8 	ldr.w	r0, [r7, #200]	; 0xc8
    2d16:	b120      	cbz	r0, 2d22 <hci_cmd_done+0x3a>
		net_buf_unref(bt_dev.sent_cmd);
    2d18:	f009 fd9e 	bl	c858 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    2d1c:	2300      	movs	r3, #0
    2d1e:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	if (cmd(buf)->state && !status) {
    2d22:	4620      	mov	r0, r4
    2d24:	f009 fcdc 	bl	c6e0 <net_buf_id>
    2d28:	270c      	movs	r7, #12
    2d2a:	fb07 5000 	mla	r0, r7, r0, r5
    2d2e:	6843      	ldr	r3, [r0, #4]
    2d30:	b1e3      	cbz	r3, 2d6c <hci_cmd_done+0x84>
    2d32:	b9de      	cbnz	r6, 2d6c <hci_cmd_done+0x84>
		struct bt_hci_cmd_state_set *update = cmd(buf)->state;
    2d34:	4620      	mov	r0, r4
    2d36:	f009 fcd3 	bl	c6e0 <net_buf_id>
    2d3a:	fb07 5000 	mla	r0, r7, r0, r5
 *
 * @return N/A
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    2d3e:	2201      	movs	r2, #1
    2d40:	6840      	ldr	r0, [r0, #4]
    2d42:	e9d0 3100 	ldrd	r3, r1, [r0]

	if (val) {
    2d46:	7a00      	ldrb	r0, [r0, #8]
	atomic_val_t mask = ATOMIC_MASK(bit);
    2d48:	f001 071f 	and.w	r7, r1, #31
    2d4c:	40ba      	lsls	r2, r7
	if (val) {
    2d4e:	0949      	lsrs	r1, r1, #5
    2d50:	b318      	cbz	r0, 2d9a <hci_cmd_done+0xb2>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    2d52:	f3bf 8f5b 	dmb	ish
    2d56:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    2d5a:	e853 1f00 	ldrex	r1, [r3]
    2d5e:	4311      	orrs	r1, r2
    2d60:	e843 1000 	strex	r0, r1, [r3]
    2d64:	2800      	cmp	r0, #0
    2d66:	d1f8      	bne.n	2d5a <hci_cmd_done+0x72>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    2d68:	f3bf 8f5b 	dmb	ish
	if (cmd(buf)->sync) {
    2d6c:	4620      	mov	r0, r4
    2d6e:	f009 fcb7 	bl	c6e0 <net_buf_id>
    2d72:	270c      	movs	r7, #12
    2d74:	fb07 5000 	mla	r0, r7, r0, r5
    2d78:	6883      	ldr	r3, [r0, #8]
    2d7a:	b1db      	cbz	r3, 2db4 <hci_cmd_done+0xcc>
		cmd(buf)->status = status;
    2d7c:	4620      	mov	r0, r4
    2d7e:	f009 fcaf 	bl	c6e0 <net_buf_id>
    2d82:	4378      	muls	r0, r7
    2d84:	542e      	strb	r6, [r5, r0]
		k_sem_give(cmd(buf)->sync);
    2d86:	4620      	mov	r0, r4
    2d88:	f009 fcaa 	bl	c6e0 <net_buf_id>
    2d8c:	fb07 5500 	mla	r5, r7, r0, r5
    2d90:	68a8      	ldr	r0, [r5, #8]
}
    2d92:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    2d96:	f00b bc71 	b.w	e67c <z_impl_k_sem_give>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    2d9a:	43d2      	mvns	r2, r2
    2d9c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    2da0:	f3bf 8f5b 	dmb	ish
    2da4:	e853 1f00 	ldrex	r1, [r3]
    2da8:	4011      	ands	r1, r2
    2daa:	e843 1000 	strex	r0, r1, [r3]
    2dae:	2800      	cmp	r0, #0
    2db0:	d0da      	beq.n	2d68 <hci_cmd_done+0x80>
    2db2:	e7f7      	b.n	2da4 <hci_cmd_done+0xbc>
    2db4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2db6:	bf00      	nop
    2db8:	200005fc 	.word	0x200005fc
    2dbc:	20000a30 	.word	0x20000a30
    2dc0:	20000000 	.word	0x20000000

00002dc4 <hci_cmd_complete>:
{
    2dc4:	b538      	push	{r3, r4, r5, lr}
    2dc6:	2103      	movs	r1, #3
    2dc8:	4604      	mov	r4, r0
    2dca:	3008      	adds	r0, #8
    2dcc:	f00f f8bc 	bl	11f48 <net_buf_simple_pull_mem>
	status = buf->data[0];
    2dd0:	68a3      	ldr	r3, [r4, #8]
	ncmd = evt->ncmd;
    2dd2:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
    2dd4:	7819      	ldrb	r1, [r3, #0]
    2dd6:	f8b0 0001 	ldrh.w	r0, [r0, #1]
    2dda:	4622      	mov	r2, r4
    2ddc:	f7ff ff84 	bl	2ce8 <hci_cmd_done>
	if (ncmd) {
    2de0:	b125      	cbz	r5, 2dec <hci_cmd_complete+0x28>
    2de2:	4803      	ldr	r0, [pc, #12]	; (2df0 <hci_cmd_complete+0x2c>)
}
    2de4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    2de8:	f00b bc48 	b.w	e67c <z_impl_k_sem_give>
    2dec:	bd38      	pop	{r3, r4, r5, pc}
    2dee:	bf00      	nop
    2df0:	200000b0 	.word	0x200000b0

00002df4 <hci_cmd_status>:
{
    2df4:	b538      	push	{r3, r4, r5, lr}
    2df6:	2104      	movs	r1, #4
    2df8:	4604      	mov	r4, r0
    2dfa:	3008      	adds	r0, #8
    2dfc:	f00f f8a4 	bl	11f48 <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    2e00:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
    2e02:	7801      	ldrb	r1, [r0, #0]
    2e04:	8840      	ldrh	r0, [r0, #2]
    2e06:	4622      	mov	r2, r4
    2e08:	f7ff ff6e 	bl	2ce8 <hci_cmd_done>
	if (ncmd) {
    2e0c:	b125      	cbz	r5, 2e18 <hci_cmd_status+0x24>
    2e0e:	4803      	ldr	r0, [pc, #12]	; (2e1c <hci_cmd_status+0x28>)
}
    2e10:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    2e14:	f00b bc32 	b.w	e67c <z_impl_k_sem_give>
    2e18:	bd38      	pop	{r3, r4, r5, pc}
    2e1a:	bf00      	nop
    2e1c:	200000b0 	.word	0x200000b0

00002e20 <bt_hci_cmd_state_set_init>:
{
    2e20:	b510      	push	{r4, lr}
	state->bit = bit;
    2e22:	e9c1 2300 	strd	r2, r3, [r1]
	state->val = val;
    2e26:	f89d 3008 	ldrb.w	r3, [sp, #8]
    2e2a:	720b      	strb	r3, [r1, #8]
{
    2e2c:	460c      	mov	r4, r1
	cmd(buf)->state = state;
    2e2e:	f009 fc57 	bl	c6e0 <net_buf_id>
    2e32:	4b03      	ldr	r3, [pc, #12]	; (2e40 <bt_hci_cmd_state_set_init+0x20>)
    2e34:	220c      	movs	r2, #12
    2e36:	fb02 3300 	mla	r3, r2, r0, r3
    2e3a:	605c      	str	r4, [r3, #4]
}
    2e3c:	bd10      	pop	{r4, pc}
    2e3e:	bf00      	nop
    2e40:	20000a30 	.word	0x20000a30

00002e44 <bt_hci_cmd_create>:
{
    2e44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return net_buf_alloc_fixed(pool, timeout);
    2e48:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2e4c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2e50:	4606      	mov	r6, r0
    2e52:	4817      	ldr	r0, [pc, #92]	; (2eb0 <bt_hci_cmd_create+0x6c>)
	cmd(buf)->opcode = opcode;
    2e54:	4d17      	ldr	r5, [pc, #92]	; (2eb4 <bt_hci_cmd_create+0x70>)
{
    2e56:	460f      	mov	r7, r1
    2e58:	f00e fff1 	bl	11e3e <net_buf_alloc_fixed>
    2e5c:	4604      	mov	r4, r0
	net_buf_simple_reserve(&buf->b, reserve);
    2e5e:	f100 0a08 	add.w	sl, r0, #8
    2e62:	2100      	movs	r1, #0
    2e64:	f04f 0800 	mov.w	r8, #0
    2e68:	4650      	mov	r0, sl
    2e6a:	f00f f807 	bl	11e7c <net_buf_simple_reserve>
    2e6e:	f884 8014 	strb.w	r8, [r4, #20]
	cmd(buf)->opcode = opcode;
    2e72:	4620      	mov	r0, r4
    2e74:	f009 fc34 	bl	c6e0 <net_buf_id>
    2e78:	f04f 090c 	mov.w	r9, #12
    2e7c:	fb09 5000 	mla	r0, r9, r0, r5
    2e80:	8046      	strh	r6, [r0, #2]
	cmd(buf)->sync = NULL;
    2e82:	4620      	mov	r0, r4
    2e84:	f009 fc2c 	bl	c6e0 <net_buf_id>
    2e88:	fb09 5000 	mla	r0, r9, r0, r5
    2e8c:	f8c0 8008 	str.w	r8, [r0, #8]
	cmd(buf)->state = NULL;
    2e90:	4620      	mov	r0, r4
    2e92:	f009 fc25 	bl	c6e0 <net_buf_id>
    2e96:	fb09 5500 	mla	r5, r9, r0, r5
	return net_buf_simple_add(&buf->b, len);
    2e9a:	2103      	movs	r1, #3
    2e9c:	f8c5 8004 	str.w	r8, [r5, #4]
    2ea0:	4650      	mov	r0, sl
    2ea2:	f00f f828 	bl	11ef6 <net_buf_simple_add>
	hdr->param_len = param_len;
    2ea6:	7087      	strb	r7, [r0, #2]
	hdr->opcode = sys_cpu_to_le16(opcode);
    2ea8:	8006      	strh	r6, [r0, #0]
}
    2eaa:	4620      	mov	r0, r4
    2eac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2eb0:	200005fc 	.word	0x200005fc
    2eb4:	20000a30 	.word	0x20000a30

00002eb8 <bt_hci_cmd_send_sync>:
{
    2eb8:	b5f0      	push	{r4, r5, r6, r7, lr}
    2eba:	4615      	mov	r5, r2
    2ebc:	b087      	sub	sp, #28
	if (!buf) {
    2ebe:	460c      	mov	r4, r1
    2ec0:	b921      	cbnz	r1, 2ecc <bt_hci_cmd_send_sync+0x14>
		buf = bt_hci_cmd_create(opcode, 0);
    2ec2:	f7ff ffbf 	bl	2e44 <bt_hci_cmd_create>
		if (!buf) {
    2ec6:	4604      	mov	r4, r0
    2ec8:	2800      	cmp	r0, #0
    2eca:	d048      	beq.n	2f5e <bt_hci_cmd_send_sync+0xa6>
	return z_impl_k_sem_init(sem, initial_count, limit);
    2ecc:	2201      	movs	r2, #1
    2ece:	2100      	movs	r1, #0
    2ed0:	4668      	mov	r0, sp
    2ed2:	f00f fbd3 	bl	1267c <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
    2ed6:	4620      	mov	r0, r4
    2ed8:	f009 fc02 	bl	c6e0 <net_buf_id>
    2edc:	4f21      	ldr	r7, [pc, #132]	; (2f64 <bt_hci_cmd_send_sync+0xac>)
    2ede:	230c      	movs	r3, #12
    2ee0:	fb03 7000 	mla	r0, r3, r0, r7
    2ee4:	f8c0 d008 	str.w	sp, [r0, #8]
	net_buf_put(&bt_dev.cmd_tx_queue, net_buf_ref(buf));
    2ee8:	4620      	mov	r0, r4
    2eea:	f00e ffd8 	bl	11e9e <net_buf_ref>
    2eee:	4601      	mov	r1, r0
    2ef0:	481d      	ldr	r0, [pc, #116]	; (2f68 <bt_hci_cmd_send_sync+0xb0>)
    2ef2:	f00e ffc7 	bl	11e84 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    2ef6:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    2efa:	2300      	movs	r3, #0
    2efc:	4668      	mov	r0, sp
    2efe:	f00b fbe3 	bl	e6c8 <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
    2f02:	4606      	mov	r6, r0
    2f04:	b180      	cbz	r0, 2f28 <bt_hci_cmd_send_sync+0x70>
    2f06:	4a19      	ldr	r2, [pc, #100]	; (2f6c <bt_hci_cmd_send_sync+0xb4>)
    2f08:	4919      	ldr	r1, [pc, #100]	; (2f70 <bt_hci_cmd_send_sync+0xb8>)
    2f0a:	481a      	ldr	r0, [pc, #104]	; (2f74 <bt_hci_cmd_send_sync+0xbc>)
    2f0c:	f240 1331 	movw	r3, #305	; 0x131
    2f10:	f00c fad9 	bl	f4c6 <printk>
    2f14:	4818      	ldr	r0, [pc, #96]	; (2f78 <bt_hci_cmd_send_sync+0xc0>)
    2f16:	4631      	mov	r1, r6
    2f18:	f00c fad5 	bl	f4c6 <printk>
    2f1c:	4040      	eors	r0, r0
    2f1e:	f380 8811 	msr	BASEPRI, r0
    2f22:	f04f 0003 	mov.w	r0, #3
    2f26:	df02      	svc	2
	status = cmd(buf)->status;
    2f28:	4620      	mov	r0, r4
    2f2a:	f009 fbd9 	bl	c6e0 <net_buf_id>
    2f2e:	230c      	movs	r3, #12
    2f30:	4358      	muls	r0, r3
    2f32:	5c3e      	ldrb	r6, [r7, r0]
	if (status) {
    2f34:	b156      	cbz	r6, 2f4c <bt_hci_cmd_send_sync+0x94>
		net_buf_unref(buf);
    2f36:	4620      	mov	r0, r4
    2f38:	f009 fc8e 	bl	c858 <net_buf_unref>
			return -EIO;
    2f3c:	2e09      	cmp	r6, #9
    2f3e:	bf0c      	ite	eq
    2f40:	f06f 006e 	mvneq.w	r0, #110	; 0x6e
    2f44:	f06f 0004 	mvnne.w	r0, #4
}
    2f48:	b007      	add	sp, #28
    2f4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (rsp) {
    2f4c:	b115      	cbz	r5, 2f54 <bt_hci_cmd_send_sync+0x9c>
		*rsp = buf;
    2f4e:	602c      	str	r4, [r5, #0]
	return 0;
    2f50:	4630      	mov	r0, r6
    2f52:	e7f9      	b.n	2f48 <bt_hci_cmd_send_sync+0x90>
		net_buf_unref(buf);
    2f54:	4620      	mov	r0, r4
    2f56:	f009 fc7f 	bl	c858 <net_buf_unref>
	return 0;
    2f5a:	4628      	mov	r0, r5
    2f5c:	e7f4      	b.n	2f48 <bt_hci_cmd_send_sync+0x90>
			return -ENOBUFS;
    2f5e:	f06f 0068 	mvn.w	r0, #104	; 0x68
    2f62:	e7f1      	b.n	2f48 <bt_hci_cmd_send_sync+0x90>
    2f64:	20000a30 	.word	0x20000a30
    2f68:	200000cc 	.word	0x200000cc
    2f6c:	00013379 	.word	0x00013379
    2f70:	000133ad 	.word	0x000133ad
    2f74:	000133b6 	.word	0x000133b6
    2f78:	000133d3 	.word	0x000133d3

00002f7c <hci_init>:
	}
}
#endif /* CONFIG_BT_HCI_VS_EXT */

static int hci_init(void)
{
    2f7c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    2f7e:	4d9f      	ldr	r5, [pc, #636]	; (31fc <hci_init+0x280>)
    2f80:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
    2f84:	6899      	ldr	r1, [r3, #8]
    2f86:	f011 0101 	ands.w	r1, r1, #1
    2f8a:	d123      	bne.n	2fd4 <hci_init+0x58>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    2f8c:	aa01      	add	r2, sp, #4
    2f8e:	f640 4003 	movw	r0, #3075	; 0xc03
    2f92:	f7ff ff91 	bl	2eb8 <bt_hci_cmd_send_sync>
		if (err) {
    2f96:	4604      	mov	r4, r0
    2f98:	2800      	cmp	r0, #0
    2f9a:	d168      	bne.n	306e <hci_init+0xf2>
	uint8_t status = buf->data[0];
    2f9c:	9b01      	ldr	r3, [sp, #4]
    2f9e:	689b      	ldr	r3, [r3, #8]
	if (status) {
    2fa0:	781b      	ldrb	r3, [r3, #0]
    2fa2:	b9a3      	cbnz	r3, 2fce <hci_init+0x52>
		bt_scan_reset();
    2fa4:	f000 ff02 	bl	3dac <bt_scan_reset>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    2fa8:	f3bf 8f5b 	dmb	ish
    2fac:	462b      	mov	r3, r5
    2fae:	f853 2f98 	ldr.w	r2, [r3, #152]!
    2fb2:	f3bf 8f5b 	dmb	ish
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
    2fb6:	f002 0205 	and.w	r2, r2, #5
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    2fba:	f3bf 8f5b 	dmb	ish
    2fbe:	e853 1f00 	ldrex	r1, [r3]
    2fc2:	e843 2000 	strex	r0, r2, [r3]
    2fc6:	2800      	cmp	r0, #0
    2fc8:	d1f9      	bne.n	2fbe <hci_init+0x42>
    2fca:	f3bf 8f5b 	dmb	ish
		net_buf_unref(rsp);
    2fce:	9801      	ldr	r0, [sp, #4]
    2fd0:	f009 fc42 	bl	c858 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    2fd4:	aa01      	add	r2, sp, #4
    2fd6:	2100      	movs	r1, #0
    2fd8:	f241 0003 	movw	r0, #4099	; 0x1003
    2fdc:	f7ff ff6c 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    2fe0:	4604      	mov	r4, r0
    2fe2:	2800      	cmp	r0, #0
    2fe4:	d143      	bne.n	306e <hci_init+0xf2>
	struct bt_hci_rp_read_local_features *rp = (void *)buf->data;
    2fe6:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
    2fe8:	4885      	ldr	r0, [pc, #532]	; (3200 <hci_init+0x284>)
    2fea:	6899      	ldr	r1, [r3, #8]
    2fec:	2208      	movs	r2, #8
    2fee:	3101      	adds	r1, #1
    2ff0:	f00c fdd9 	bl	fba6 <memcpy>
	net_buf_unref(rsp);
    2ff4:	9801      	ldr	r0, [sp, #4]
    2ff6:	f009 fc2f 	bl	c858 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    2ffa:	4621      	mov	r1, r4
    2ffc:	aa01      	add	r2, sp, #4
    2ffe:	f241 0001 	movw	r0, #4097	; 0x1001
    3002:	f7ff ff59 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    3006:	4604      	mov	r4, r0
    3008:	2800      	cmp	r0, #0
    300a:	d130      	bne.n	306e <hci_init+0xf2>
	read_local_ver_complete(rsp);
    300c:	9801      	ldr	r0, [sp, #4]
	struct bt_hci_rp_read_local_version_info *rp = (void *)buf->data;
    300e:	6883      	ldr	r3, [r0, #8]
	bt_dev.hci_version = rp->hci_version;
    3010:	785a      	ldrb	r2, [r3, #1]
    3012:	f885 2034 	strb.w	r2, [r5, #52]	; 0x34
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
    3016:	78d9      	ldrb	r1, [r3, #3]
    3018:	789a      	ldrb	r2, [r3, #2]
    301a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    301e:	86ea      	strh	r2, [r5, #54]	; 0x36
	bt_dev.lmp_version = rp->lmp_version;
    3020:	791a      	ldrb	r2, [r3, #4]
    3022:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    3026:	7a19      	ldrb	r1, [r3, #8]
    3028:	79da      	ldrb	r2, [r3, #7]
    302a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    302e:	872a      	strh	r2, [r5, #56]	; 0x38
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    3030:	795a      	ldrb	r2, [r3, #5]
    3032:	799b      	ldrb	r3, [r3, #6]
    3034:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    3038:	876b      	strh	r3, [r5, #58]	; 0x3a
	net_buf_unref(rsp);
    303a:	f009 fc0d 	bl	c858 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    303e:	4621      	mov	r1, r4
    3040:	aa01      	add	r2, sp, #4
    3042:	f241 0002 	movw	r0, #4098	; 0x1002
    3046:	f7ff ff37 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    304a:	4604      	mov	r4, r0
    304c:	b978      	cbnz	r0, 306e <hci_init+0xf2>
	struct bt_hci_rp_read_supported_commands *rp = (void *)buf->data;
    304e:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.supported_commands, rp->commands,
    3050:	486c      	ldr	r0, [pc, #432]	; (3204 <hci_init+0x288>)
    3052:	6899      	ldr	r1, [r3, #8]
    3054:	2240      	movs	r2, #64	; 0x40
    3056:	3101      	adds	r1, #1
    3058:	f00c fda5 	bl	fba6 <memcpy>
	net_buf_unref(rsp);
    305c:	9801      	ldr	r0, [sp, #4]
    305e:	f009 fbfb 	bl	c858 <net_buf_unref>
	if (!BT_FEAT_LE(bt_dev.features)) {
    3062:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
    3066:	0658      	lsls	r0, r3, #25
    3068:	d404      	bmi.n	3074 <hci_init+0xf8>
		return -ENODEV;
    306a:	f06f 0412 	mvn.w	r4, #18
	if (err) {
		return err;
	}

	return 0;
}
    306e:	4620      	mov	r0, r4
    3070:	b003      	add	sp, #12
    3072:	bdf0      	pop	{r4, r5, r6, r7, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    3074:	4621      	mov	r1, r4
    3076:	aa01      	add	r2, sp, #4
    3078:	f242 0003 	movw	r0, #8195	; 0x2003
    307c:	f7ff ff1c 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    3080:	4604      	mov	r4, r0
    3082:	2800      	cmp	r0, #0
    3084:	d1f3      	bne.n	306e <hci_init+0xf2>
	struct bt_hci_rp_le_read_local_features *rp = (void *)buf->data;
    3086:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
    3088:	485f      	ldr	r0, [pc, #380]	; (3208 <hci_init+0x28c>)
    308a:	6899      	ldr	r1, [r3, #8]
    308c:	2208      	movs	r2, #8
    308e:	3101      	adds	r1, #1
    3090:	f00c fd89 	bl	fba6 <memcpy>
	net_buf_unref(rsp);
    3094:	9801      	ldr	r0, [sp, #4]
    3096:	f009 fbdf 	bl	c858 <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    309a:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
    309e:	0699      	lsls	r1, r3, #26
    30a0:	d57a      	bpl.n	3198 <hci_init+0x21c>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
    30a2:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
    30a6:	071a      	lsls	r2, r3, #28
    30a8:	f100 8092 	bmi.w	31d0 <hci_init+0x254>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    30ac:	2108      	movs	r1, #8
    30ae:	f242 0001 	movw	r0, #8193	; 0x2001
    30b2:	f7ff fec7 	bl	2e44 <bt_hci_cmd_create>
	if (!buf) {
    30b6:	4604      	mov	r4, r0
    30b8:	2800      	cmp	r0, #0
    30ba:	d074      	beq.n	31a6 <hci_init+0x22a>
    30bc:	2108      	movs	r1, #8
    30be:	4408      	add	r0, r1
    30c0:	f00e ff19 	bl	11ef6 <net_buf_simple_add>
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
	dst[1] = val >> 8;
    30c4:	2310      	movs	r3, #16
    30c6:	2200      	movs	r2, #0
    30c8:	7043      	strb	r3, [r0, #1]
	dst[0] = val;
    30ca:	2702      	movs	r7, #2
    30cc:	2307      	movs	r3, #7
    30ce:	7007      	strb	r7, [r0, #0]
    30d0:	7083      	strb	r3, [r0, #2]
	dst[1] = val >> 8;
    30d2:	70c2      	strb	r2, [r0, #3]
	dst[0] = val;
    30d4:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    30d6:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    30d8:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    30da:	71c2      	strb	r2, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    30dc:	4621      	mov	r1, r4
    30de:	f242 0001 	movw	r0, #8193	; 0x2001
    30e2:	f7ff fee9 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    30e6:	4604      	mov	r4, r0
    30e8:	2800      	cmp	r0, #0
    30ea:	d1c0      	bne.n	306e <hci_init+0xf2>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    30ec:	2108      	movs	r1, #8
    30ee:	f640 4001 	movw	r0, #3073	; 0xc01
    30f2:	f7ff fea7 	bl	2e44 <bt_hci_cmd_create>
	if (!buf) {
    30f6:	4606      	mov	r6, r0
    30f8:	2800      	cmp	r0, #0
    30fa:	d054      	beq.n	31a6 <hci_init+0x22a>
    30fc:	2108      	movs	r1, #8
    30fe:	4408      	add	r0, r1
    3100:	f00e fef9 	bl	11ef6 <net_buf_simple_add>
    3104:	2380      	movs	r3, #128	; 0x80
    3106:	7043      	strb	r3, [r0, #1]
    3108:	2320      	movs	r3, #32
	dst[0] = val;
    310a:	7004      	strb	r4, [r0, #0]
    310c:	7084      	strb	r4, [r0, #2]
    310e:	7104      	strb	r4, [r0, #4]
	dst[1] = val >> 8;
    3110:	7144      	strb	r4, [r0, #5]
	dst[0] = val;
    3112:	7184      	strb	r4, [r0, #6]
	dst[1] = val >> 8;
    3114:	70c7      	strb	r7, [r0, #3]
    3116:	71c3      	strb	r3, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
    3118:	4622      	mov	r2, r4
    311a:	4631      	mov	r1, r6
    311c:	f640 4001 	movw	r0, #3073	; 0xc01
    3120:	f7ff feca 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    3124:	4604      	mov	r4, r0
    3126:	2800      	cmp	r0, #0
    3128:	d1a1      	bne.n	306e <hci_init+0xf2>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
    312a:	4601      	mov	r1, r0
    312c:	aa01      	add	r2, sp, #4
    312e:	f64f 4001 	movw	r0, #64513	; 0xfc01
    3132:	f7ff fec1 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    3136:	4604      	mov	r4, r0
    3138:	bb48      	cbnz	r0, 318e <hci_init+0x212>
	net_buf_unref(rsp);
    313a:	9801      	ldr	r0, [sp, #4]
    313c:	f009 fb8c 	bl	c858 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
    3140:	4621      	mov	r1, r4
    3142:	aa01      	add	r2, sp, #4
    3144:	f64f 4002 	movw	r0, #64514	; 0xfc02
    3148:	f7ff feb6 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    314c:	4604      	mov	r4, r0
    314e:	b9f0      	cbnz	r0, 318e <hci_init+0x212>
	rp.cmds = (void *)rsp->data;
    3150:	9b01      	ldr	r3, [sp, #4]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
    3152:	482e      	ldr	r0, [pc, #184]	; (320c <hci_init+0x290>)
    3154:	6899      	ldr	r1, [r3, #8]
    3156:	463a      	mov	r2, r7
    3158:	3101      	adds	r1, #1
    315a:	f00c fd24 	bl	fba6 <memcpy>
	net_buf_unref(rsp);
    315e:	9801      	ldr	r0, [sp, #4]
    3160:	f009 fb7a 	bl	c858 <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
    3164:	f895 3085 	ldrb.w	r3, [r5, #133]	; 0x85
    3168:	075b      	lsls	r3, r3, #29
    316a:	d510      	bpl.n	318e <hci_init+0x212>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
    316c:	aa01      	add	r2, sp, #4
    316e:	4621      	mov	r1, r4
    3170:	f64f 4003 	movw	r0, #64515	; 0xfc03
    3174:	f7ff fea0 	bl	2eb8 <bt_hci_cmd_send_sync>
		if (err) {
    3178:	b948      	cbnz	r0, 318e <hci_init+0x212>
		rp.feat = (void *)rsp->data;
    317a:	9b01      	ldr	r3, [sp, #4]
		memcpy(bt_dev.vs_features, rp.feat->features,
    317c:	4824      	ldr	r0, [pc, #144]	; (3210 <hci_init+0x294>)
    317e:	6899      	ldr	r1, [r3, #8]
    3180:	2201      	movs	r2, #1
    3182:	4411      	add	r1, r2
    3184:	f00c fd0f 	bl	fba6 <memcpy>
		net_buf_unref(rsp);
    3188:	9801      	ldr	r0, [sp, #4]
    318a:	f009 fb65 	bl	c858 <net_buf_unref>
}
    318e:	b003      	add	sp, #12
    3190:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	err = bt_id_init();
    3194:	f000 bbf0 	b.w	3978 <bt_id_init>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    3198:	2102      	movs	r1, #2
    319a:	f640 406d 	movw	r0, #3181	; 0xc6d
    319e:	f7ff fe51 	bl	2e44 <bt_hci_cmd_create>
		if (!buf) {
    31a2:	4606      	mov	r6, r0
    31a4:	b910      	cbnz	r0, 31ac <hci_init+0x230>
		return -ENOBUFS;
    31a6:	f06f 0468 	mvn.w	r4, #104	; 0x68
    31aa:	e760      	b.n	306e <hci_init+0xf2>
    31ac:	2102      	movs	r1, #2
    31ae:	3008      	adds	r0, #8
    31b0:	f00e fea1 	bl	11ef6 <net_buf_simple_add>
		cp_le->le = 0x01;
    31b4:	2301      	movs	r3, #1
		cp_le->simul = 0x00;
    31b6:	7044      	strb	r4, [r0, #1]
		cp_le->le = 0x01;
    31b8:	7003      	strb	r3, [r0, #0]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    31ba:	4622      	mov	r2, r4
    31bc:	4631      	mov	r1, r6
    31be:	f640 406d 	movw	r0, #3181	; 0xc6d
    31c2:	f7ff fe79 	bl	2eb8 <bt_hci_cmd_send_sync>
		if (err) {
    31c6:	4604      	mov	r4, r0
    31c8:	2800      	cmp	r0, #0
    31ca:	f43f af6a 	beq.w	30a2 <hci_init+0x126>
    31ce:	e74e      	b.n	306e <hci_init+0xf2>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    31d0:	aa01      	add	r2, sp, #4
    31d2:	2100      	movs	r1, #0
    31d4:	f242 001c 	movw	r0, #8220	; 0x201c
    31d8:	f7ff fe6e 	bl	2eb8 <bt_hci_cmd_send_sync>
		if (err) {
    31dc:	4604      	mov	r4, r0
    31de:	2800      	cmp	r0, #0
    31e0:	f47f af45 	bne.w	306e <hci_init+0xf2>
		le_read_supp_states_complete(rsp);
    31e4:	9801      	ldr	r0, [sp, #4]
 *
 *  @return 64-bit integer in host endianness.
 */
static inline uint64_t sys_get_le64(const uint8_t src[8])
{
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
    31e6:	6883      	ldr	r3, [r0, #8]
    31e8:	f8d3 2001 	ldr.w	r2, [r3, #1]
    31ec:	f8d3 3005 	ldr.w	r3, [r3, #5]
	bt_dev.le.states = sys_get_le64(rp->le_states);
    31f0:	e9c5 232a 	strd	r2, r3, [r5, #168]	; 0xa8
		net_buf_unref(rsp);
    31f4:	f009 fb30 	bl	c858 <net_buf_unref>
    31f8:	e758      	b.n	30ac <hci_init+0x130>
    31fa:	bf00      	nop
    31fc:	20000000 	.word	0x20000000
    3200:	2000003c 	.word	0x2000003c
    3204:	20000044 	.word	0x20000044
    3208:	200000a0 	.word	0x200000a0
    320c:	20000085 	.word	0x20000085
    3210:	20000084 	.word	0x20000084

00003214 <bt_get_phy>:
	switch (hci_phy) {
    3214:	3801      	subs	r0, #1
    3216:	b2c0      	uxtb	r0, r0
    3218:	2802      	cmp	r0, #2
    321a:	bf9a      	itte	ls
    321c:	4b01      	ldrls	r3, [pc, #4]	; (3224 <bt_get_phy+0x10>)
    321e:	5c18      	ldrbls	r0, [r3, r0]
{
    3220:	2000      	movhi	r0, #0
}
    3222:	4770      	bx	lr
    3224:	00013485 	.word	0x00013485

00003228 <bt_send>:

	if (IS_ENABLED(CONFIG_BT_TINYCRYPT_ECC)) {
		return bt_hci_ecc_send(buf);
	}

	return bt_dev.drv->send(buf);
    3228:	4b02      	ldr	r3, [pc, #8]	; (3234 <bt_send+0xc>)
    322a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
    322e:	691b      	ldr	r3, [r3, #16]
    3230:	4718      	bx	r3
    3232:	bf00      	nop
    3234:	20000000 	.word	0x20000000

00003238 <hci_tx_thread>:
{
    3238:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    323a:	4d37      	ldr	r5, [pc, #220]	; (3318 <hci_tx_thread+0xe0>)
		events[0].state = K_POLL_STATE_NOT_READY;
    323c:	4e37      	ldr	r6, [pc, #220]	; (331c <hci_tx_thread+0xe4>)
    323e:	f105 07b0 	add.w	r7, r5, #176	; 0xb0
    3242:	68f3      	ldr	r3, [r6, #12]
    3244:	f36f 3352 	bfc	r3, #13, #6
    3248:	60f3      	str	r3, [r6, #12]
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke4(*(uintptr_t *)&events, *(uintptr_t *)&num_events, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    324a:	4834      	ldr	r0, [pc, #208]	; (331c <hci_tx_thread+0xe4>)
    324c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3250:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3254:	2101      	movs	r1, #1
    3256:	f00c f829 	bl	f2ac <z_impl_k_poll>
		BT_ASSERT(err == 0);
    325a:	b160      	cbz	r0, 3276 <hci_tx_thread+0x3e>
    325c:	4a30      	ldr	r2, [pc, #192]	; (3320 <hci_tx_thread+0xe8>)
    325e:	4931      	ldr	r1, [pc, #196]	; (3324 <hci_tx_thread+0xec>)
    3260:	4831      	ldr	r0, [pc, #196]	; (3328 <hci_tx_thread+0xf0>)
    3262:	f640 138e 	movw	r3, #2446	; 0x98e
    3266:	f00c f92e 	bl	f4c6 <printk>
    326a:	4040      	eors	r0, r0
    326c:	f380 8811 	msr	BASEPRI, r0
    3270:	f04f 0003 	mov.w	r0, #3
    3274:	df02      	svc	2
		switch (ev->state) {
    3276:	68f3      	ldr	r3, [r6, #12]
    3278:	f3c3 3345 	ubfx	r3, r3, #13, #6
    327c:	2b04      	cmp	r3, #4
    327e:	d134      	bne.n	32ea <hci_tx_thread+0xb2>
			if (ev->tag == BT_EVENT_CMD_TX) {
    3280:	7b33      	ldrb	r3, [r6, #12]
    3282:	bb93      	cbnz	r3, 32ea <hci_tx_thread+0xb2>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    3284:	4829      	ldr	r0, [pc, #164]	; (332c <hci_tx_thread+0xf4>)
    3286:	2200      	movs	r2, #0
    3288:	2300      	movs	r3, #0
    328a:	f00e fddd 	bl	11e48 <net_buf_get>
	BT_ASSERT(buf);
    328e:	4604      	mov	r4, r0
    3290:	b3a0      	cbz	r0, 32fc <hci_tx_thread+0xc4>
	return z_impl_k_sem_take(sem, timeout);
    3292:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3296:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    329a:	4638      	mov	r0, r7
    329c:	f00b fa14 	bl	e6c8 <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    32a0:	f8d5 00c8 	ldr.w	r0, [r5, #200]	; 0xc8
    32a4:	bb20      	cbnz	r0, 32f0 <hci_tx_thread+0xb8>
	bt_dev.sent_cmd = net_buf_ref(buf);
    32a6:	4620      	mov	r0, r4
    32a8:	f00e fdf9 	bl	11e9e <net_buf_ref>
    32ac:	f8c5 00c8 	str.w	r0, [r5, #200]	; 0xc8
	err = bt_send(buf);
    32b0:	4620      	mov	r0, r4
    32b2:	f7ff ffb9 	bl	3228 <bt_send>
	if (err) {
    32b6:	b1c0      	cbz	r0, 32ea <hci_tx_thread+0xb2>
	z_impl_k_sem_give(sem);
    32b8:	481d      	ldr	r0, [pc, #116]	; (3330 <hci_tx_thread+0xf8>)
    32ba:	f00b f9df 	bl	e67c <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);
    32be:	4620      	mov	r0, r4
    32c0:	f009 fa0e 	bl	c6e0 <net_buf_id>
    32c4:	4b1b      	ldr	r3, [pc, #108]	; (3334 <hci_tx_thread+0xfc>)
    32c6:	220c      	movs	r2, #12
    32c8:	fb02 3000 	mla	r0, r2, r0, r3
    32cc:	211f      	movs	r1, #31
    32ce:	8840      	ldrh	r0, [r0, #2]
    32d0:	4622      	mov	r2, r4
    32d2:	f7ff fd09 	bl	2ce8 <hci_cmd_done>
		net_buf_unref(bt_dev.sent_cmd);
    32d6:	f8d5 00c8 	ldr.w	r0, [r5, #200]	; 0xc8
    32da:	f009 fabd 	bl	c858 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    32de:	2300      	movs	r3, #0
		net_buf_unref(buf);
    32e0:	4620      	mov	r0, r4
		bt_dev.sent_cmd = NULL;
    32e2:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
		net_buf_unref(buf);
    32e6:	f009 fab7 	bl	c858 <net_buf_unref>
	z_impl_k_yield();
    32ea:	f00b fd6f 	bl	edcc <z_impl_k_yield>
	while (1) {
    32ee:	e7a8      	b.n	3242 <hci_tx_thread+0xa>
		net_buf_unref(bt_dev.sent_cmd);
    32f0:	f009 fab2 	bl	c858 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    32f4:	2300      	movs	r3, #0
    32f6:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
    32fa:	e7d4      	b.n	32a6 <hci_tx_thread+0x6e>
	BT_ASSERT(buf);
    32fc:	4a08      	ldr	r2, [pc, #32]	; (3320 <hci_tx_thread+0xe8>)
    32fe:	490e      	ldr	r1, [pc, #56]	; (3338 <hci_tx_thread+0x100>)
    3300:	4809      	ldr	r0, [pc, #36]	; (3328 <hci_tx_thread+0xf0>)
    3302:	f640 1325 	movw	r3, #2341	; 0x925
    3306:	f00c f8de 	bl	f4c6 <printk>
    330a:	4040      	eors	r0, r0
    330c:	f380 8811 	msr	BASEPRI, r0
    3310:	f04f 0003 	mov.w	r0, #3
    3314:	df02      	svc	2
    3316:	e7bc      	b.n	3292 <hci_tx_thread+0x5a>
    3318:	20000000 	.word	0x20000000
    331c:	20000100 	.word	0x20000100
    3320:	00013379 	.word	0x00013379
    3324:	000133ad 	.word	0x000133ad
    3328:	000133b6 	.word	0x000133b6
    332c:	200000cc 	.word	0x200000cc
    3330:	200000b0 	.word	0x200000b0
    3334:	20000a30 	.word	0x20000a30
    3338:	000133f3 	.word	0x000133f3

0000333c <hci_event_prio>:
		      sizeof(struct bt_hci_evt_num_completed_packets)),
#endif /* CONFIG_BT_CONN_TX */
};

void hci_event_prio(struct net_buf *buf)
{
    333c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3340:	4604      	mov	r4, r0
	struct net_buf_simple_state state;
	struct bt_hci_evt_hdr *hdr;
	uint8_t evt_flags;

	net_buf_simple_save(&buf->b, &state);
    3342:	f100 0608 	add.w	r6, r0, #8
	state->offset = net_buf_simple_headroom(buf);
    3346:	4630      	mov	r0, r6
    3348:	f00e fe0e 	bl	11f68 <net_buf_simple_headroom>
	state->len = buf->len;
    334c:	89a7      	ldrh	r7, [r4, #12]

	BT_ASSERT(buf->len >= sizeof(*hdr));
    334e:	2f01      	cmp	r7, #1
	state->offset = net_buf_simple_headroom(buf);
    3350:	4605      	mov	r5, r0
    3352:	d80c      	bhi.n	336e <hci_event_prio+0x32>
    3354:	4a21      	ldr	r2, [pc, #132]	; (33dc <hci_event_prio+0xa0>)
    3356:	4922      	ldr	r1, [pc, #136]	; (33e0 <hci_event_prio+0xa4>)
    3358:	4822      	ldr	r0, [pc, #136]	; (33e4 <hci_event_prio+0xa8>)
    335a:	f640 5322 	movw	r3, #3362	; 0xd22
    335e:	f00c f8b2 	bl	f4c6 <printk>
    3362:	4040      	eors	r0, r0
    3364:	f380 8811 	msr	BASEPRI, r0
    3368:	f04f 0003 	mov.w	r0, #3
    336c:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
    336e:	4630      	mov	r0, r6
    3370:	2102      	movs	r1, #2
    3372:	f00e fde9 	bl	11f48 <net_buf_simple_pull_mem>

	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
    3376:	7803      	ldrb	r3, [r0, #0]
 *
 * @return HCI event flags for the specified event.
 */
static inline uint8_t bt_hci_evt_get_flags(uint8_t evt)
{
	switch (evt) {
    3378:	2b05      	cmp	r3, #5
    337a:	4606      	mov	r6, r0
    337c:	d026      	beq.n	33cc <hci_event_prio+0x90>
    337e:	3b0e      	subs	r3, #14
#endif /* CONFIG_BT_CONN ||  CONFIG_BT_ISO */
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return BT_HCI_EVT_FLAG_RECV_PRIO;
	default:
		return BT_HCI_EVT_FLAG_RECV;
    3380:	2b01      	cmp	r3, #1
    3382:	bf94      	ite	ls
    3384:	f04f 0801 	movls.w	r8, #1
    3388:	f04f 0802 	movhi.w	r8, #2
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
    338c:	f018 0f01 	tst.w	r8, #1
    3390:	d10c      	bne.n	33ac <hci_event_prio+0x70>
    3392:	4a12      	ldr	r2, [pc, #72]	; (33dc <hci_event_prio+0xa0>)
    3394:	4914      	ldr	r1, [pc, #80]	; (33e8 <hci_event_prio+0xac>)
    3396:	4813      	ldr	r0, [pc, #76]	; (33e4 <hci_event_prio+0xa8>)
    3398:	f640 5326 	movw	r3, #3366	; 0xd26
    339c:	f00c f893 	bl	f4c6 <printk>
    33a0:	4040      	eors	r0, r0
    33a2:	f380 8811 	msr	BASEPRI, r0
    33a6:	f04f 0003 	mov.w	r0, #3
    33aa:	df02      	svc	2

	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    33ac:	4a0f      	ldr	r2, [pc, #60]	; (33ec <hci_event_prio+0xb0>)
    33ae:	7830      	ldrb	r0, [r6, #0]
    33b0:	2302      	movs	r3, #2
    33b2:	4621      	mov	r1, r4
    33b4:	f00c fc81 	bl	fcba <handle_event>

	if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
    33b8:	f018 0f02 	tst.w	r8, #2
    33bc:	d009      	beq.n	33d2 <hci_event_prio+0x96>
	buf->data = buf->__buf + state->offset;
    33be:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    33c0:	81a7      	strh	r7, [r4, #12]
	buf->data = buf->__buf + state->offset;
    33c2:	fa10 f585 	uxtah	r5, r0, r5
    33c6:	60a5      	str	r5, [r4, #8]
		net_buf_simple_restore(&buf->b, &state);
	} else {
		net_buf_unref(buf);
	}
}
    33c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_EVT_FLAG_RECV | BT_HCI_EVT_FLAG_RECV_PRIO;
    33cc:	f04f 0803 	mov.w	r8, #3
    33d0:	e7dc      	b.n	338c <hci_event_prio+0x50>
		net_buf_unref(buf);
    33d2:	4620      	mov	r0, r4
}
    33d4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		net_buf_unref(buf);
    33d8:	f009 ba3e 	b.w	c858 <net_buf_unref>
    33dc:	00013379 	.word	0x00013379
    33e0:	000133f7 	.word	0x000133f7
    33e4:	000133b6 	.word	0x000133b6
    33e8:	00013410 	.word	0x00013410
    33ec:	000130bc 	.word	0x000130bc

000033f0 <bt_recv>:

int bt_recv(struct net_buf *buf)
{
    33f0:	b570      	push	{r4, r5, r6, lr}
 *
 *  @return The BT_* type to of the buffer
 */
static inline enum bt_buf_type bt_buf_get_type(struct net_buf *buf)
{
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
    33f2:	7d05      	ldrb	r5, [r0, #20]
	bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);

	BT_DBG("buf %p len %u", buf, buf->len);

	switch (bt_buf_get_type(buf)) {
    33f4:	2d01      	cmp	r5, #1
{
    33f6:	4604      	mov	r4, r0
	switch (bt_buf_get_type(buf)) {
    33f8:	d138      	bne.n	346c <bt_recv+0x7c>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    33fa:	8983      	ldrh	r3, [r0, #12]
    33fc:	2b01      	cmp	r3, #1
    33fe:	d80c      	bhi.n	341a <bt_recv+0x2a>
    3400:	4a1d      	ldr	r2, [pc, #116]	; (3478 <bt_recv+0x88>)
    3402:	491e      	ldr	r1, [pc, #120]	; (347c <bt_recv+0x8c>)
    3404:	481e      	ldr	r0, [pc, #120]	; (3480 <bt_recv+0x90>)
    3406:	f640 1312 	movw	r3, #2322	; 0x912
    340a:	f00c f85c 	bl	f4c6 <printk>
    340e:	4040      	eors	r0, r0
    3410:	f380 8811 	msr	BASEPRI, r0
    3414:	f04f 0003 	mov.w	r0, #3
    3418:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
    341a:	2102      	movs	r1, #2
    341c:	f104 0008 	add.w	r0, r4, #8
    3420:	f00e fd92 	bl	11f48 <net_buf_simple_pull_mem>
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
    3424:	7803      	ldrb	r3, [r0, #0]
	switch (evt) {
    3426:	2b05      	cmp	r3, #5
    3428:	4606      	mov	r6, r0
    342a:	d01d      	beq.n	3468 <bt_recv+0x78>
    342c:	3b0e      	subs	r3, #14
		return BT_HCI_EVT_FLAG_RECV;
    342e:	2b01      	cmp	r3, #1
    3430:	bf88      	it	hi
    3432:	2502      	movhi	r5, #2
    3434:	07ab      	lsls	r3, r5, #30
    3436:	d40c      	bmi.n	3452 <bt_recv+0x62>
    3438:	4a0f      	ldr	r2, [pc, #60]	; (3478 <bt_recv+0x88>)
    343a:	4912      	ldr	r1, [pc, #72]	; (3484 <bt_recv+0x94>)
    343c:	4810      	ldr	r0, [pc, #64]	; (3480 <bt_recv+0x90>)
    343e:	f640 1316 	movw	r3, #2326	; 0x916
    3442:	f00c f840 	bl	f4c6 <printk>
    3446:	4040      	eors	r0, r0
    3448:	f380 8811 	msr	BASEPRI, r0
    344c:	f04f 0003 	mov.w	r0, #3
    3450:	df02      	svc	2
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    3452:	4a0d      	ldr	r2, [pc, #52]	; (3488 <bt_recv+0x98>)
    3454:	7830      	ldrb	r0, [r6, #0]
    3456:	2303      	movs	r3, #3
    3458:	4621      	mov	r1, r4
    345a:	f00c fc2e 	bl	fcba <handle_event>
	net_buf_unref(buf);
    345e:	4620      	mov	r0, r4
    3460:	f009 f9fa 	bl	c858 <net_buf_unref>

		if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
			net_buf_put(&bt_dev.rx_queue, buf);
		}
#endif
		return 0;
    3464:	2000      	movs	r0, #0
	default:
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
		net_buf_unref(buf);
		return -EINVAL;
	}
}
    3466:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_EVT_FLAG_RECV | BT_HCI_EVT_FLAG_RECV_PRIO;
    3468:	2503      	movs	r5, #3
    346a:	e7e3      	b.n	3434 <bt_recv+0x44>
		net_buf_unref(buf);
    346c:	f009 f9f4 	bl	c858 <net_buf_unref>
		return -EINVAL;
    3470:	f06f 0015 	mvn.w	r0, #21
    3474:	e7f7      	b.n	3466 <bt_recv+0x76>
    3476:	bf00      	nop
    3478:	00013379 	.word	0x00013379
    347c:	000133f7 	.word	0x000133f7
    3480:	000133b6 	.word	0x000133b6
    3484:	00013429 	.word	0x00013429
    3488:	000130a4 	.word	0x000130a4

0000348c <bt_recv_prio>:

#if defined(CONFIG_BT_RECV_IS_RX_THREAD)
int bt_recv_prio(struct net_buf *buf)
{
    348c:	b510      	push	{r4, lr}
	bt_monitor_send(bt_monitor_opcode(buf), buf->data, buf->len);

	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    348e:	7d03      	ldrb	r3, [r0, #20]
    3490:	2b01      	cmp	r3, #1
{
    3492:	4604      	mov	r4, r0
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
    3494:	d00c      	beq.n	34b0 <bt_recv_prio+0x24>
    3496:	4a09      	ldr	r2, [pc, #36]	; (34bc <bt_recv_prio+0x30>)
    3498:	4909      	ldr	r1, [pc, #36]	; (34c0 <bt_recv_prio+0x34>)
    349a:	480a      	ldr	r0, [pc, #40]	; (34c4 <bt_recv_prio+0x38>)
    349c:	f640 5369 	movw	r3, #3433	; 0xd69
    34a0:	f00c f811 	bl	f4c6 <printk>
    34a4:	4040      	eors	r0, r0
    34a6:	f380 8811 	msr	BASEPRI, r0
    34aa:	f04f 0003 	mov.w	r0, #3
    34ae:	df02      	svc	2

	hci_event_prio(buf);
    34b0:	4620      	mov	r0, r4
    34b2:	f7ff ff43 	bl	333c <hci_event_prio>

	return 0;
}
    34b6:	2000      	movs	r0, #0
    34b8:	bd10      	pop	{r4, pc}
    34ba:	bf00      	nop
    34bc:	00013379 	.word	0x00013379
    34c0:	00013457 	.word	0x00013457
    34c4:	000133b6 	.word	0x000133b6

000034c8 <bt_hci_driver_register>:
#endif /* defined(CONFIG_BT_RECV_IS_RX_THREAD) */

int bt_hci_driver_register(const struct bt_hci_driver *drv)
{
	if (bt_dev.drv) {
    34c8:	4a08      	ldr	r2, [pc, #32]	; (34ec <bt_hci_driver_register+0x24>)
{
    34ca:	4603      	mov	r3, r0
	if (bt_dev.drv) {
    34cc:	f8d2 00e4 	ldr.w	r0, [r2, #228]	; 0xe4
    34d0:	b930      	cbnz	r0, 34e0 <bt_hci_driver_register+0x18>
		return -EALREADY;
	}

	if (!drv->open || !drv->send) {
    34d2:	68d9      	ldr	r1, [r3, #12]
    34d4:	b139      	cbz	r1, 34e6 <bt_hci_driver_register+0x1e>
    34d6:	6919      	ldr	r1, [r3, #16]
    34d8:	b129      	cbz	r1, 34e6 <bt_hci_driver_register+0x1e>
		return -EINVAL;
	}

	bt_dev.drv = drv;
    34da:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
	BT_DBG("Registered %s", drv->name ? drv->name : "");

	bt_monitor_new_index(BT_MONITOR_TYPE_PRIMARY, drv->bus,
			     BT_ADDR_ANY, drv->name ? drv->name : "bt0");

	return 0;
    34de:	4770      	bx	lr
		return -EALREADY;
    34e0:	f06f 0077 	mvn.w	r0, #119	; 0x77
    34e4:	4770      	bx	lr
		return -EINVAL;
    34e6:	f06f 0015 	mvn.w	r0, #21
}
    34ea:	4770      	bx	lr
    34ec:	20000000 	.word	0x20000000

000034f0 <bt_finalize_init>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    34f0:	4b07      	ldr	r3, [pc, #28]	; (3510 <bt_finalize_init+0x20>)
    34f2:	f3bf 8f5b 	dmb	ish
    34f6:	e853 2f00 	ldrex	r2, [r3]
    34fa:	f042 0202 	orr.w	r2, r2, #2
    34fe:	e843 2100 	strex	r1, r2, [r3]
    3502:	2900      	cmp	r1, #0
    3504:	d1f7      	bne.n	34f6 <bt_finalize_init+0x6>
    3506:	f3bf 8f5b 	dmb	ish
void bt_finalize_init(void)
{
	atomic_set_bit(bt_dev.flags, BT_DEV_READY);

	if (IS_ENABLED(CONFIG_BT_OBSERVER)) {
		bt_le_scan_update(false);
    350a:	2000      	movs	r0, #0
    350c:	f000 bc54 	b.w	3db8 <bt_le_scan_update>
    3510:	20000098 	.word	0x20000098

00003514 <init_work>:
	bt_finalize_init();
	return 0;
}

static void init_work(struct k_work *work)
{
    3514:	b510      	push	{r4, lr}
	err = hci_init();
    3516:	f7ff fd31 	bl	2f7c <hci_init>
	if (err) {
    351a:	4604      	mov	r4, r0
    351c:	b908      	cbnz	r0, 3522 <init_work+0xe>
	bt_finalize_init();
    351e:	f7ff ffe7 	bl	34f0 <bt_finalize_init>
	int err;

	err = bt_init();
	if (ready_cb) {
    3522:	4b04      	ldr	r3, [pc, #16]	; (3534 <init_work+0x20>)
    3524:	681b      	ldr	r3, [r3, #0]
    3526:	b11b      	cbz	r3, 3530 <init_work+0x1c>
		ready_cb(err);
    3528:	4620      	mov	r0, r4
	}
}
    352a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
    352e:	4718      	bx	r3
}
    3530:	bd10      	pop	{r4, pc}
    3532:	bf00      	nop
    3534:	20000a48 	.word	0x20000a48

00003538 <bt_enable>:
	}
}
#endif /* !CONFIG_BT_RECV_IS_RX_THREAD */

int bt_enable(bt_ready_cb_t cb)
{
    3538:	b570      	push	{r4, r5, r6, lr}
	int err;

	if (!bt_dev.drv) {
    353a:	4d25      	ldr	r5, [pc, #148]	; (35d0 <bt_enable+0x98>)
    353c:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
{
    3540:	b088      	sub	sp, #32
    3542:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
    3544:	2b00      	cmp	r3, #0
    3546:	d03d      	beq.n	35c4 <bt_enable+0x8c>
    3548:	f3bf 8f5b 	dmb	ish
    354c:	f105 0298 	add.w	r2, r5, #152	; 0x98
    3550:	e852 3f00 	ldrex	r3, [r2]
    3554:	f043 0101 	orr.w	r1, r3, #1
    3558:	e842 1000 	strex	r0, r1, [r2]
    355c:	2800      	cmp	r0, #0
    355e:	d1f7      	bne.n	3550 <bt_enable+0x18>
    3560:	f3bf 8f5b 	dmb	ish
		BT_ERR("No HCI driver registered");
		return -ENODEV;
	}

	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    3564:	f013 0301 	ands.w	r3, r3, #1
    3568:	d12f      	bne.n	35ca <bt_enable+0x92>
		if (err) {
			BT_WARN("Failed to set device name (%d)", err);
		}
	}

	ready_cb = cb;
    356a:	4a1a      	ldr	r2, [pc, #104]	; (35d4 <bt_enable+0x9c>)
    356c:	6016      	str	r6, [r2, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    356e:	2000      	movs	r0, #0
    3570:	2100      	movs	r1, #0
    3572:	f06f 0208 	mvn.w	r2, #8
    3576:	e9cd 0106 	strd	r0, r1, [sp, #24]
    357a:	e9cd 3202 	strd	r3, r2, [sp, #8]
    357e:	e9cd 3300 	strd	r3, r3, [sp]
    3582:	9304      	str	r3, [sp, #16]
    3584:	4914      	ldr	r1, [pc, #80]	; (35d8 <bt_enable+0xa0>)
    3586:	4b15      	ldr	r3, [pc, #84]	; (35dc <bt_enable+0xa4>)
    3588:	4815      	ldr	r0, [pc, #84]	; (35e0 <bt_enable+0xa8>)
    358a:	f44f 7220 	mov.w	r2, #640	; 0x280
    358e:	f00a ffa3 	bl	e4d8 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    3592:	4914      	ldr	r1, [pc, #80]	; (35e4 <bt_enable+0xac>)
    3594:	4812      	ldr	r0, [pc, #72]	; (35e0 <bt_enable+0xa8>)
    3596:	f00e ffa4 	bl	124e2 <z_impl_k_thread_name_set>

	if (IS_ENABLED(CONFIG_BT_TINYCRYPT_ECC)) {
		bt_hci_ecc_init();
	}

	err = bt_dev.drv->open();
    359a:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
    359e:	68db      	ldr	r3, [r3, #12]
    35a0:	4798      	blx	r3
	if (err) {
    35a2:	4604      	mov	r4, r0
    35a4:	b930      	cbnz	r0, 35b4 <bt_enable+0x7c>
		return err;
	}

	bt_monitor_send(BT_MONITOR_OPEN_INDEX, NULL, 0);

	if (!cb) {
    35a6:	b946      	cbnz	r6, 35ba <bt_enable+0x82>
	err = hci_init();
    35a8:	f7ff fce8 	bl	2f7c <hci_init>
	if (err) {
    35ac:	4604      	mov	r4, r0
    35ae:	b908      	cbnz	r0, 35b4 <bt_enable+0x7c>
	bt_finalize_init();
    35b0:	f7ff ff9e 	bl	34f0 <bt_finalize_init>
		return bt_init();
	}

	k_work_submit(&bt_dev.init);
	return 0;
}
    35b4:	4620      	mov	r0, r4
    35b6:	b008      	add	sp, #32
    35b8:	bd70      	pop	{r4, r5, r6, pc}
	k_work_submit(&bt_dev.init);
    35ba:	f105 0088 	add.w	r0, r5, #136	; 0x88
    35be:	f00b f991 	bl	e8e4 <k_work_submit>
	return 0;
    35c2:	e7f7      	b.n	35b4 <bt_enable+0x7c>
		return -ENODEV;
    35c4:	f06f 0412 	mvn.w	r4, #18
    35c8:	e7f4      	b.n	35b4 <bt_enable+0x7c>
		return -EALREADY;
    35ca:	f06f 0477 	mvn.w	r4, #119	; 0x77
    35ce:	e7f1      	b.n	35b4 <bt_enable+0x7c>
    35d0:	20000000 	.word	0x20000000
    35d4:	20000a48 	.word	0x20000a48
    35d8:	20002ea0 	.word	0x20002ea0
    35dc:	00003239 	.word	0x00003239
    35e0:	20000658 	.word	0x20000658
    35e4:	0001347a 	.word	0x0001347a

000035e8 <bt_get_name>:
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	return bt_dev.name;
#else
	return CONFIG_BT_DEVICE_NAME;
#endif
}
    35e8:	4800      	ldr	r0, [pc, #0]	; (35ec <bt_get_name+0x4>)
    35ea:	4770      	bx	lr
    35ec:	00013480 	.word	0x00013480

000035f0 <id_find>:
		*count = bt_dev.id_count;
	}
}

static int id_find(const bt_addr_le_t *addr)
{
    35f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
    35f2:	4f0b      	ldr	r7, [pc, #44]	; (3620 <id_find+0x30>)
{
    35f4:	4606      	mov	r6, r0
	for (id = 0U; id < bt_dev.id_count; id++) {
    35f6:	2500      	movs	r5, #0
    35f8:	7d7b      	ldrb	r3, [r7, #21]
    35fa:	b2ec      	uxtb	r4, r5
    35fc:	42a3      	cmp	r3, r4
    35fe:	d802      	bhi.n	3606 <id_find+0x16>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
    3600:	f06f 0401 	mvn.w	r4, #1
    3604:	e009      	b.n	361a <id_find+0x2a>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    3606:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
    360a:	2207      	movs	r2, #7
    360c:	4439      	add	r1, r7
    360e:	4630      	mov	r0, r6
    3610:	f00c faa0 	bl	fb54 <memcmp>
    3614:	3501      	adds	r5, #1
    3616:	2800      	cmp	r0, #0
    3618:	d1ee      	bne.n	35f8 <id_find+0x8>
}
    361a:	4620      	mov	r0, r4
    361c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    361e:	bf00      	nop
    3620:	20000000 	.word	0x20000000

00003624 <set_random_address>:
{
    3624:	b538      	push	{r3, r4, r5, lr}
	return memcmp(a, b, sizeof(*a));
    3626:	4914      	ldr	r1, [pc, #80]	; (3678 <set_random_address+0x54>)
    3628:	2206      	movs	r2, #6
    362a:	4605      	mov	r5, r0
    362c:	f00c fa92 	bl	fb54 <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    3630:	4604      	mov	r4, r0
    3632:	b1e0      	cbz	r0, 366e <set_random_address+0x4a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    3634:	2106      	movs	r1, #6
    3636:	f242 0005 	movw	r0, #8197	; 0x2005
    363a:	f7ff fc03 	bl	2e44 <bt_hci_cmd_create>
	if (!buf) {
    363e:	4604      	mov	r4, r0
    3640:	b1b8      	cbz	r0, 3672 <set_random_address+0x4e>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    3642:	2206      	movs	r2, #6
    3644:	4629      	mov	r1, r5
    3646:	3008      	adds	r0, #8
    3648:	f00e fc5b 	bl	11f02 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    364c:	4621      	mov	r1, r4
    364e:	2200      	movs	r2, #0
    3650:	f242 0005 	movw	r0, #8197	; 0x2005
    3654:	f7ff fc30 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    3658:	4604      	mov	r4, r0
    365a:	b940      	cbnz	r0, 366e <set_random_address+0x4a>
	memcpy(dst, src, sizeof(*dst));
    365c:	2206      	movs	r2, #6
    365e:	4806      	ldr	r0, [pc, #24]	; (3678 <set_random_address+0x54>)
    3660:	4629      	mov	r1, r5
    3662:	f00c faa0 	bl	fba6 <memcpy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    3666:	4b05      	ldr	r3, [pc, #20]	; (367c <set_random_address+0x58>)
    3668:	2201      	movs	r2, #1
    366a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
}
    366e:	4620      	mov	r0, r4
    3670:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOBUFS;
    3672:	f06f 0468 	mvn.w	r4, #104	; 0x68
    3676:	e7fa      	b.n	366e <set_random_address+0x4a>
    3678:	2000002d 	.word	0x2000002d
    367c:	20000000 	.word	0x20000000

00003680 <id_create.constprop.0>:

static int id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
    3680:	b530      	push	{r4, r5, lr}
    3682:	4604      	mov	r4, r0
    3684:	b085      	sub	sp, #20
{
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    3686:	460d      	mov	r5, r1
    3688:	b1a1      	cbz	r1, 36b4 <id_create.constprop.0+0x34>
    368a:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    368c:	2207      	movs	r2, #7
    368e:	a902      	add	r1, sp, #8
    3690:	4628      	mov	r0, r5
    3692:	9302      	str	r3, [sp, #8]
    3694:	f8cd 300b 	str.w	r3, [sp, #11]
    3698:	f00c fa5c 	bl	fb54 <memcmp>
    369c:	b150      	cbz	r0, 36b4 <id_create.constprop.0+0x34>
	memcpy(dst, src, sizeof(*dst));
    369e:	4812      	ldr	r0, [pc, #72]	; (36e8 <id_create.constprop.0+0x68>)
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    36a0:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    36a4:	2207      	movs	r2, #7
    36a6:	4629      	mov	r1, r5
    36a8:	4420      	add	r0, r4
    36aa:	f00c fa7c 	bl	fba6 <memcpy>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
		bt_settings_save_id();
	}

	return 0;
    36ae:	2000      	movs	r0, #0
}
    36b0:	b005      	add	sp, #20
    36b2:	bd30      	pop	{r4, r5, pc}
			err = bt_addr_le_create_static(&new_addr);
    36b4:	4668      	mov	r0, sp
    36b6:	f00c faf2 	bl	fc9e <bt_addr_le_create_static>
			if (err) {
    36ba:	2800      	cmp	r0, #0
    36bc:	d1f8      	bne.n	36b0 <id_create.constprop.0+0x30>
		} while (id_find(&new_addr) >= 0);
    36be:	4668      	mov	r0, sp
    36c0:	f7ff ff96 	bl	35f0 <id_find>
    36c4:	2800      	cmp	r0, #0
    36c6:	daf5      	bge.n	36b4 <id_create.constprop.0+0x34>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    36c8:	4807      	ldr	r0, [pc, #28]	; (36e8 <id_create.constprop.0+0x68>)
    36ca:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    36ce:	4404      	add	r4, r0
    36d0:	2207      	movs	r2, #7
    36d2:	4669      	mov	r1, sp
    36d4:	4620      	mov	r0, r4
    36d6:	f00c fa66 	bl	fba6 <memcpy>
		if (addr) {
    36da:	2d00      	cmp	r5, #0
    36dc:	d0e7      	beq.n	36ae <id_create.constprop.0+0x2e>
    36de:	2207      	movs	r2, #7
    36e0:	4621      	mov	r1, r4
    36e2:	4628      	mov	r0, r5
    36e4:	e7e1      	b.n	36aa <id_create.constprop.0+0x2a>
    36e6:	bf00      	nop
    36e8:	20000000 	.word	0x20000000

000036ec <bt_id_create>:

int bt_id_create(bt_addr_le_t *addr, uint8_t *irk)
{
    36ec:	b573      	push	{r0, r1, r4, r5, r6, lr}
    36ee:	460c      	mov	r4, r1
	int new_id, err;

	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    36f0:	4605      	mov	r5, r0
    36f2:	b918      	cbnz	r0, 36fc <bt_id_create+0x10>
		if (id_find(addr) >= 0) {
			return -EALREADY;
		}
	}

	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
    36f4:	b1ec      	cbz	r4, 3732 <bt_id_create+0x46>
		return -EINVAL;
    36f6:	f06f 0015 	mvn.w	r0, #21
    36fa:	e018      	b.n	372e <bt_id_create+0x42>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    36fc:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    36fe:	2207      	movs	r2, #7
    3700:	4669      	mov	r1, sp
    3702:	9300      	str	r3, [sp, #0]
    3704:	f8cd 3003 	str.w	r3, [sp, #3]
    3708:	f00c fa24 	bl	fb54 <memcmp>
    370c:	2800      	cmp	r0, #0
    370e:	d0f1      	beq.n	36f4 <bt_id_create+0x8>
		if (addr->type != BT_ADDR_LE_RANDOM ||
    3710:	782b      	ldrb	r3, [r5, #0]
    3712:	2b01      	cmp	r3, #1
    3714:	d1ef      	bne.n	36f6 <bt_id_create+0xa>
    3716:	79ab      	ldrb	r3, [r5, #6]
    3718:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    371c:	2bc0      	cmp	r3, #192	; 0xc0
    371e:	d1ea      	bne.n	36f6 <bt_id_create+0xa>
		if (id_find(addr) >= 0) {
    3720:	4628      	mov	r0, r5
    3722:	f7ff ff65 	bl	35f0 <id_find>
    3726:	2800      	cmp	r0, #0
    3728:	dbe4      	blt.n	36f4 <bt_id_create+0x8>
			return -EALREADY;
    372a:	f06f 0077 	mvn.w	r0, #119	; 0x77
	if (err) {
		return err;
	}

	return new_id;
}
    372e:	b002      	add	sp, #8
    3730:	bd70      	pop	{r4, r5, r6, pc}
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
    3732:	4e13      	ldr	r6, [pc, #76]	; (3780 <bt_id_create+0x94>)
    3734:	7d73      	ldrb	r3, [r6, #21]
    3736:	2b03      	cmp	r3, #3
    3738:	d01e      	beq.n	3778 <bt_id_create+0x8c>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    373a:	f3bf 8f5b 	dmb	ish
    373e:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
    3742:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    3746:	07db      	lsls	r3, r3, #31
    3748:	d40b      	bmi.n	3762 <bt_id_create+0x76>
		if (!(addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY))) {
    374a:	2d00      	cmp	r5, #0
    374c:	d0d3      	beq.n	36f6 <bt_id_create+0xa>
    374e:	2207      	movs	r2, #7
    3750:	4669      	mov	r1, sp
    3752:	4628      	mov	r0, r5
    3754:	9400      	str	r4, [sp, #0]
    3756:	f8cd 4003 	str.w	r4, [sp, #3]
    375a:	f00c f9fb 	bl	fb54 <memcmp>
    375e:	2800      	cmp	r0, #0
    3760:	d0c9      	beq.n	36f6 <bt_id_create+0xa>
	new_id = bt_dev.id_count++;
    3762:	7d74      	ldrb	r4, [r6, #21]
	err = id_create(new_id, addr, irk);
    3764:	4629      	mov	r1, r5
	new_id = bt_dev.id_count++;
    3766:	1c63      	adds	r3, r4, #1
	err = id_create(new_id, addr, irk);
    3768:	4620      	mov	r0, r4
	new_id = bt_dev.id_count++;
    376a:	7573      	strb	r3, [r6, #21]
	err = id_create(new_id, addr, irk);
    376c:	f7ff ff88 	bl	3680 <id_create.constprop.0>
	new_id = bt_dev.id_count++;
    3770:	2800      	cmp	r0, #0
    3772:	bf08      	it	eq
    3774:	4620      	moveq	r0, r4
    3776:	e7da      	b.n	372e <bt_id_create+0x42>
		return -ENOMEM;
    3778:	f06f 000b 	mvn.w	r0, #11
    377c:	e7d7      	b.n	372e <bt_id_create+0x42>
    377e:	bf00      	nop
    3780:	20000000 	.word	0x20000000

00003784 <bt_id_read_public_addr>:
#endif /* defined(CONFIG_BT_HCI_VS_EXT) */
}
#endif /* defined(CONFIG_BT_PRIVACY) */

uint8_t bt_id_read_public_addr(bt_addr_le_t *addr)
{
    3784:	b570      	push	{r4, r5, r6, lr}
    3786:	b086      	sub	sp, #24
    3788:	4606      	mov	r6, r0
	struct bt_hci_rp_read_bd_addr *rp;
	struct net_buf *rsp;
	int err;

	/* Read Bluetooth Address */
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
    378a:	aa01      	add	r2, sp, #4
    378c:	2100      	movs	r1, #0
    378e:	f241 0009 	movw	r0, #4105	; 0x1009
    3792:	f7ff fb91 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    3796:	4604      	mov	r4, r0
    3798:	b970      	cbnz	r0, 37b8 <bt_id_read_public_addr+0x34>
		BT_WARN("Failed to read public address");
		return 0U;
	}

	rp = (void *)rsp->data;
    379a:	9b01      	ldr	r3, [sp, #4]

	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    379c:	9002      	str	r0, [sp, #8]
    379e:	689d      	ldr	r5, [r3, #8]
    37a0:	f8ad 000c 	strh.w	r0, [sp, #12]
    37a4:	3501      	adds	r5, #1
	return memcmp(a, b, sizeof(*a));
    37a6:	2206      	movs	r2, #6
    37a8:	a902      	add	r1, sp, #8
    37aa:	4628      	mov	r0, r5
    37ac:	f00c f9d2 	bl	fb54 <memcmp>
    37b0:	b920      	cbnz	r0, 37bc <bt_id_read_public_addr+0x38>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
		BT_DBG("Controller has no public address");
		net_buf_unref(rsp);
    37b2:	9801      	ldr	r0, [sp, #4]
    37b4:	f009 f850 	bl	c858 <net_buf_unref>
		return 0U;
    37b8:	2000      	movs	r0, #0
    37ba:	e016      	b.n	37ea <bt_id_read_public_addr+0x66>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
    37bc:	4b0c      	ldr	r3, [pc, #48]	; (37f0 <bt_id_read_public_addr+0x6c>)
    37be:	6818      	ldr	r0, [r3, #0]
    37c0:	9004      	str	r0, [sp, #16]
    37c2:	889b      	ldrh	r3, [r3, #4]
    37c4:	f8ad 3014 	strh.w	r3, [sp, #20]
    37c8:	2206      	movs	r2, #6
    37ca:	a904      	add	r1, sp, #16
    37cc:	4628      	mov	r0, r5
    37ce:	f00c f9c1 	bl	fb54 <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    37d2:	2800      	cmp	r0, #0
    37d4:	d0ed      	beq.n	37b2 <bt_id_read_public_addr+0x2e>
	memcpy(dst, src, sizeof(*dst));
    37d6:	2206      	movs	r2, #6
    37d8:	4629      	mov	r1, r5
    37da:	1c70      	adds	r0, r6, #1
    37dc:	f00c f9e3 	bl	fba6 <memcpy>
	}

	bt_addr_copy(&addr->a, &rp->bdaddr);
	addr->type = BT_ADDR_LE_PUBLIC;

	net_buf_unref(rsp);
    37e0:	9801      	ldr	r0, [sp, #4]
	addr->type = BT_ADDR_LE_PUBLIC;
    37e2:	7034      	strb	r4, [r6, #0]
	net_buf_unref(rsp);
    37e4:	f009 f838 	bl	c858 <net_buf_unref>
	return 1U;
    37e8:	2001      	movs	r0, #1
}
    37ea:	b006      	add	sp, #24
    37ec:	bd70      	pop	{r4, r5, r6, pc}
    37ee:	bf00      	nop
    37f0:	00012ff0 	.word	0x00012ff0

000037f4 <bt_setup_public_id_addr>:

int bt_setup_public_id_addr(void)
{
    37f4:	b507      	push	{r0, r1, r2, lr}
	bt_addr_le_t addr;
	uint8_t *irk = NULL;

	bt_dev.id_count = bt_id_read_public_addr(&addr);
    37f6:	4668      	mov	r0, sp
    37f8:	f7ff ffc4 	bl	3784 <bt_id_read_public_addr>
    37fc:	4b04      	ldr	r3, [pc, #16]	; (3810 <bt_setup_public_id_addr+0x1c>)
    37fe:	7558      	strb	r0, [r3, #21]

	if (!bt_dev.id_count) {
    3800:	b118      	cbz	r0, 380a <bt_setup_public_id_addr+0x16>
	} else if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}
#endif /* defined(CONFIG_BT_PRIVACY) */

	return id_create(BT_ID_DEFAULT, &addr, irk);
    3802:	4669      	mov	r1, sp
    3804:	2000      	movs	r0, #0
    3806:	f7ff ff3b 	bl	3680 <id_create.constprop.0>
}
    380a:	b003      	add	sp, #12
    380c:	f85d fb04 	ldr.w	pc, [sp], #4
    3810:	20000000 	.word	0x20000000

00003814 <bt_read_static_addr>:

#if defined(CONFIG_BT_HCI_VS_EXT)
uint8_t bt_read_static_addr(struct bt_hci_vs_static_addr addrs[], uint8_t size)
{
    3814:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct bt_hci_rp_vs_read_static_addrs *rp;
	struct net_buf *rsp;
	int err, i;
	uint8_t cnt;

	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    3818:	4b15      	ldr	r3, [pc, #84]	; (3870 <bt_read_static_addr+0x5c>)
    381a:	f893 4086 	ldrb.w	r4, [r3, #134]	; 0x86
    381e:	f014 0401 	ands.w	r4, r4, #1
{
    3822:	4607      	mov	r7, r0
    3824:	460e      	mov	r6, r1
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    3826:	d015      	beq.n	3854 <bt_read_static_addr+0x40>
		BT_WARN("Read Static Addresses command not available");
		return 0;
	}

	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
    3828:	aa01      	add	r2, sp, #4
    382a:	2100      	movs	r1, #0
    382c:	f64f 4009 	movw	r0, #64521	; 0xfc09
    3830:	f7ff fb42 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    3834:	4605      	mov	r5, r0
    3836:	b9c8      	cbnz	r0, 386c <bt_read_static_addr+0x58>
		BT_WARN("Invalid Vendor HCI extensions");
		net_buf_unref(rsp);
		return 0;
	}

	rp = (void *)rsp->data;
    3838:	9b01      	ldr	r3, [sp, #4]
    383a:	689b      	ldr	r3, [r3, #8]
	cnt = MIN(rp->num_addrs, size);
    383c:	785c      	ldrb	r4, [r3, #1]
    383e:	42b4      	cmp	r4, r6
    3840:	bf28      	it	cs
    3842:	4634      	movcs	r4, r6
		net_buf_unref(rsp);
		return 0;
	}

	for (i = 0; i < cnt; i++) {
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    3844:	f04f 0816 	mov.w	r8, #22
    3848:	1c9e      	adds	r6, r3, #2
	for (i = 0; i < cnt; i++) {
    384a:	42a5      	cmp	r5, r4
    384c:	db06      	blt.n	385c <bt_read_static_addr+0x48>
	}

	net_buf_unref(rsp);
    384e:	9801      	ldr	r0, [sp, #4]
    3850:	f009 f802 	bl	c858 <net_buf_unref>
	if (!cnt) {
		BT_WARN("No static addresses stored in controller");
	}

	return cnt;
}
    3854:	4620      	mov	r0, r4
    3856:	b002      	add	sp, #8
    3858:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    385c:	fb08 7005 	mla	r0, r8, r5, r7
    3860:	2216      	movs	r2, #22
    3862:	4631      	mov	r1, r6
    3864:	f00c f99f 	bl	fba6 <memcpy>
	for (i = 0; i < cnt; i++) {
    3868:	3501      	adds	r5, #1
    386a:	e7ee      	b.n	384a <bt_read_static_addr+0x36>
		return 0;
    386c:	2400      	movs	r4, #0
    386e:	e7f1      	b.n	3854 <bt_read_static_addr+0x40>
    3870:	20000000 	.word	0x20000000

00003874 <bt_setup_random_id_addr>:
#endif /* CONFIG_BT_HCI_VS_EXT */

int bt_setup_random_id_addr(void)
{
    3874:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined(CONFIG_BT_HCI_VS_EXT) || defined(CONFIG_BT_CTLR)
	/* Only read the addresses if the user has not already configured one or
	 * more identities (!bt_dev.id_count).
	 */
	if (!bt_dev.id_count) {
    3876:	4e15      	ldr	r6, [pc, #84]	; (38cc <bt_setup_random_id_addr+0x58>)
    3878:	7d74      	ldrb	r4, [r6, #21]
{
    387a:	b095      	sub	sp, #84	; 0x54
	if (!bt_dev.id_count) {
    387c:	b9f4      	cbnz	r4, 38bc <bt_setup_random_id_addr+0x48>
		struct bt_hci_vs_static_addr addrs[CONFIG_BT_ID_MAX];

		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
    387e:	2103      	movs	r1, #3
    3880:	a803      	add	r0, sp, #12
    3882:	f7ff ffc7 	bl	3814 <bt_read_static_addr>
    3886:	7570      	strb	r0, [r6, #21]

		if (bt_dev.id_count) {
    3888:	b1c0      	cbz	r0, 38bc <bt_setup_random_id_addr+0x48>
					atomic_set_bit(bt_dev.flags,
						       BT_DEV_STORE_ID);
				}
#endif /* CONFIG_BT_PRIVACY */

				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
    388a:	2716      	movs	r7, #22
    388c:	ab03      	add	r3, sp, #12
    388e:	b2e5      	uxtb	r5, r4
    3890:	fb07 3105 	mla	r1, r7, r5, r3
    3894:	2206      	movs	r2, #6
    3896:	f10d 0005 	add.w	r0, sp, #5
    389a:	f00c f984 	bl	fba6 <memcpy>
				addr.type = BT_ADDR_LE_RANDOM;
    389e:	2301      	movs	r3, #1

				err = id_create(i, &addr, irk);
    38a0:	a901      	add	r1, sp, #4
    38a2:	4628      	mov	r0, r5
				addr.type = BT_ADDR_LE_RANDOM;
    38a4:	f88d 3004 	strb.w	r3, [sp, #4]
				err = id_create(i, &addr, irk);
    38a8:	f7ff feea 	bl	3680 <id_create.constprop.0>
				if (err) {
    38ac:	b920      	cbnz	r0, 38b8 <bt_setup_random_id_addr+0x44>
			for (uint8_t i = 0; i < bt_dev.id_count; i++) {
    38ae:	7d72      	ldrb	r2, [r6, #21]
    38b0:	3401      	adds	r4, #1
    38b2:	b2e3      	uxtb	r3, r4
    38b4:	429a      	cmp	r2, r3
    38b6:	d8e9      	bhi.n	388c <bt_setup_random_id_addr+0x18>
	if (IS_ENABLED(CONFIG_BT_PRIVACY) && IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}

	return bt_id_create(NULL, NULL);
}
    38b8:	b015      	add	sp, #84	; 0x54
    38ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return bt_id_create(NULL, NULL);
    38bc:	2100      	movs	r1, #0
    38be:	4608      	mov	r0, r1
}
    38c0:	b015      	add	sp, #84	; 0x54
    38c2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	return bt_id_create(NULL, NULL);
    38c6:	f7ff bf11 	b.w	36ec <bt_id_create>
    38ca:	bf00      	nop
    38cc:	20000000 	.word	0x20000000

000038d0 <bt_id_set_adv_own_addr>:
}
#endif /* defined(CONFIG_BT_OBSERVER) */

int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options,
			   bool dir_adv, uint8_t *own_addr_type)
{
    38d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int err = 0;

	/* Set which local identity address we're advertising with */
	id_addr = &bt_dev.id_addr[adv->id];

	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    38d4:	f011 0401 	ands.w	r4, r1, #1
	id_addr = &bt_dev.id_addr[adv->id];
    38d8:	7805      	ldrb	r5, [r0, #0]
{
    38da:	4684      	mov	ip, r0
    38dc:	460e      	mov	r6, r1
    38de:	4690      	mov	r8, r2
    38e0:	461f      	mov	r7, r3
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    38e2:	d027      	beq.n	3934 <bt_id_set_adv_own_addr+0x64>
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
    38e4:	4c23      	ldr	r4, [pc, #140]	; (3974 <bt_id_set_adv_own_addr+0xa4>)
    38e6:	b12a      	cbz	r2, 38f4 <bt_id_set_adv_own_addr+0x24>
    38e8:	0688      	lsls	r0, r1, #26
    38ea:	d503      	bpl.n	38f4 <bt_id_set_adv_own_addr+0x24>
    38ec:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
    38f0:	0659      	lsls	r1, r3, #25
    38f2:	d53b      	bpl.n	396c <bt_id_set_adv_own_addr+0x9c>
			 * If Static Random address is used as Identity
			 * address we need to restore it before advertising
			 * is enabled. Otherwise NRPA used for active scan
			 * could be used for advertising.
			 */
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    38f4:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
    38f8:	ea4f 09c5 	mov.w	r9, r5, lsl #3
    38fc:	5ce3      	ldrb	r3, [r4, r3]
    38fe:	2b01      	cmp	r3, #1
    3900:	d008      	beq.n	3914 <bt_id_set_adv_own_addr+0x44>
				if (err) {
					return err;
				}
			}

			*own_addr_type = id_addr->type;
    3902:	eba9 0505 	sub.w	r5, r9, r5
    3906:	5d63      	ldrb	r3, [r4, r5]

			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    3908:	f1b8 0f00 	cmp.w	r8, #0
    390c:	d10d      	bne.n	392a <bt_id_set_adv_own_addr+0x5a>
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
    390e:	703b      	strb	r3, [r7, #0]
		if (err) {
			return err;
		}
	}

	return 0;
    3910:	2000      	movs	r0, #0
    3912:	e008      	b.n	3926 <bt_id_set_adv_own_addr+0x56>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
    3914:	2107      	movs	r1, #7
    3916:	fb11 3105 	smlabb	r1, r1, r5, r3
    391a:	4421      	add	r1, r4
    391c:	4660      	mov	r0, ip
    391e:	f00c fa1e 	bl	fd5e <bt_id_set_adv_random_addr>
				if (err) {
    3922:	2800      	cmp	r0, #0
    3924:	d0ed      	beq.n	3902 <bt_id_set_adv_own_addr+0x32>
}
    3926:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    392a:	06b2      	lsls	r2, r6, #26
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
    392c:	bf48      	it	mi
    392e:	f043 0302 	orrmi.w	r3, r3, #2
    3932:	e7ec      	b.n	390e <bt_id_set_adv_own_addr+0x3e>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
    3934:	074b      	lsls	r3, r1, #29
    3936:	d515      	bpl.n	3964 <bt_id_set_adv_own_addr+0x94>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    3938:	f8df 8038 	ldr.w	r8, [pc, #56]	; 3974 <bt_id_set_adv_own_addr+0xa4>
    393c:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
    3940:	00ee      	lsls	r6, r5, #3
    3942:	f818 3003 	ldrb.w	r3, [r8, r3]
    3946:	2b01      	cmp	r3, #1
    3948:	d10a      	bne.n	3960 <bt_id_set_adv_own_addr+0x90>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
    394a:	2107      	movs	r1, #7
    394c:	fb11 3105 	smlabb	r1, r1, r5, r3
    3950:	4441      	add	r1, r8
    3952:	f00c fa04 	bl	fd5e <bt_id_set_adv_random_addr>
			*own_addr_type = id_addr->type;
    3956:	1b75      	subs	r5, r6, r5
    3958:	f818 3005 	ldrb.w	r3, [r8, r5]
			*own_addr_type = BT_ADDR_LE_RANDOM;
    395c:	703b      	strb	r3, [r7, #0]
		if (err) {
    395e:	e7e2      	b.n	3926 <bt_id_set_adv_own_addr+0x56>
	int err = 0;
    3960:	4620      	mov	r0, r4
    3962:	e7f8      	b.n	3956 <bt_id_set_adv_own_addr+0x86>
			err = bt_id_set_adv_private_addr(adv);
    3964:	f00c fa45 	bl	fdf2 <bt_id_set_adv_private_addr>
			*own_addr_type = BT_ADDR_LE_RANDOM;
    3968:	2301      	movs	r3, #1
    396a:	e7f7      	b.n	395c <bt_id_set_adv_own_addr+0x8c>
			return -ENOTSUP;
    396c:	f06f 0085 	mvn.w	r0, #133	; 0x85
    3970:	e7d9      	b.n	3926 <bt_id_set_adv_own_addr+0x56>
    3972:	bf00      	nop
    3974:	20000000 	.word	0x20000000

00003978 <bt_id_init>:
}
#endif /* !defined(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY) */
#endif /* defined(CONFIG_BT_SMP) */

int bt_id_init(void)
{
    3978:	b510      	push	{r4, lr}
	int err;

	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    397a:	4c0a      	ldr	r4, [pc, #40]	; (39a4 <bt_id_init+0x2c>)
    397c:	7d63      	ldrb	r3, [r4, #21]
    397e:	b10b      	cbz	r3, 3984 <bt_id_init+0xc>

#if defined(CONFIG_BT_PRIVACY)
	k_work_init_delayable(&bt_dev.rpa_update, rpa_timeout);
#endif

	return 0;
    3980:	2000      	movs	r0, #0
}
    3982:	bd10      	pop	{r4, pc}
		err = bt_setup_public_id_addr();
    3984:	f7ff ff36 	bl	37f4 <bt_setup_public_id_addr>
		if (err) {
    3988:	2800      	cmp	r0, #0
    398a:	d1fa      	bne.n	3982 <bt_id_init+0xa>
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    398c:	7d63      	ldrb	r3, [r4, #21]
    398e:	2b00      	cmp	r3, #0
    3990:	d1f6      	bne.n	3980 <bt_id_init+0x8>
		err = bt_setup_random_id_addr();
    3992:	f7ff ff6f 	bl	3874 <bt_setup_random_id_addr>
		if (err) {
    3996:	2800      	cmp	r0, #0
    3998:	d1f3      	bne.n	3982 <bt_id_init+0xa>
		err = set_random_address(&bt_dev.id_addr[0].a);
    399a:	1c60      	adds	r0, r4, #1
}
    399c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		err = set_random_address(&bt_dev.id_addr[0].a);
    39a0:	f7ff be40 	b.w	3624 <set_random_address>
    39a4:	20000000 	.word	0x20000000

000039a8 <valid_adv_ext_param>:

	return bt_le_adv_set_enable_legacy(adv, enable);
}

static bool valid_adv_ext_param(const struct bt_le_adv_param *param)
{
    39a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
		if (param->peer &&
    39aa:	6902      	ldr	r2, [r0, #16]
		    !(param->options & BT_LE_ADV_OPT_EXT_ADV) &&
    39ac:	6843      	ldr	r3, [r0, #4]
{
    39ae:	4604      	mov	r4, r0
		if (param->peer &&
    39b0:	b15a      	cbz	r2, 39ca <valid_adv_ext_param+0x22>
		    !(param->options & BT_LE_ADV_OPT_EXT_ADV) &&
    39b2:	f240 4201 	movw	r2, #1025	; 0x401
    39b6:	4213      	tst	r3, r2
    39b8:	d102      	bne.n	39c0 <valid_adv_ext_param+0x18>
		return false;
	}

	if (param->id >= bt_dev.id_count ||
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
		return false;
    39ba:	2000      	movs	r0, #0
	    (param->options & BT_LE_ADV_OPT_DISABLE_CHAN_39)) {
		return false;
	}

	return true;
}
    39bc:	b003      	add	sp, #12
    39be:	bd30      	pop	{r4, r5, pc}
		    (param->options & BT_LE_ADV_OPT_EXT_ADV) &&
    39c0:	f403 6282 	and.w	r2, r3, #1040	; 0x410
    39c4:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    39c8:	d0f7      	beq.n	39ba <valid_adv_ext_param+0x12>
		if (!(param->options & BT_LE_ADV_OPT_EXT_ADV) &&
    39ca:	0559      	lsls	r1, r3, #21
    39cc:	d402      	bmi.n	39d4 <valid_adv_ext_param+0x2c>
    39ce:	f413 4ff8 	tst.w	r3, #31744	; 0x7c00
    39d2:	d1f2      	bne.n	39ba <valid_adv_ext_param+0x12>
		if ((param->options & BT_LE_ADV_OPT_EXT_ADV) &&
    39d4:	4a1c      	ldr	r2, [pc, #112]	; (3a48 <valid_adv_ext_param+0xa0>)
    39d6:	ea32 0303 	bics.w	r3, r2, r3
    39da:	d0ee      	beq.n	39ba <valid_adv_ext_param+0x12>
	if (param->id >= bt_dev.id_count ||
    39dc:	4d1b      	ldr	r5, [pc, #108]	; (3a4c <valid_adv_ext_param+0xa4>)
    39de:	7820      	ldrb	r0, [r4, #0]
    39e0:	7d6b      	ldrb	r3, [r5, #21]
    39e2:	4283      	cmp	r3, r0
    39e4:	d9e9      	bls.n	39ba <valid_adv_ext_param+0x12>
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
    39e6:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    39ea:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
    39ec:	2207      	movs	r2, #7
    39ee:	4669      	mov	r1, sp
    39f0:	4428      	add	r0, r5
    39f2:	9300      	str	r3, [sp, #0]
    39f4:	f8cd 3003 	str.w	r3, [sp, #3]
    39f8:	f00c f8ac 	bl	fb54 <memcmp>
	if (param->id >= bt_dev.id_count ||
    39fc:	2800      	cmp	r0, #0
    39fe:	d0dc      	beq.n	39ba <valid_adv_ext_param+0x12>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    3a00:	6860      	ldr	r0, [r4, #4]
    3a02:	07c2      	lsls	r2, r0, #31
    3a04:	d406      	bmi.n	3a14 <valid_adv_ext_param+0x6c>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    3a06:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
    3a0a:	2b08      	cmp	r3, #8
    3a0c:	d802      	bhi.n	3a14 <valid_adv_ext_param+0x6c>
    3a0e:	68a3      	ldr	r3, [r4, #8]
    3a10:	2b9f      	cmp	r3, #159	; 0x9f
    3a12:	d9d2      	bls.n	39ba <valid_adv_ext_param+0x12>
	if ((param->options & (BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY |
    3a14:	f010 0f30 	tst.w	r0, #48	; 0x30
    3a18:	d002      	beq.n	3a20 <valid_adv_ext_param+0x78>
			       BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
    3a1a:	6923      	ldr	r3, [r4, #16]
    3a1c:	2b00      	cmp	r3, #0
    3a1e:	d0cc      	beq.n	39ba <valid_adv_ext_param+0x12>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
    3a20:	06c3      	lsls	r3, r0, #27
    3a22:	d401      	bmi.n	3a28 <valid_adv_ext_param+0x80>
    3a24:	6923      	ldr	r3, [r4, #16]
    3a26:	b943      	cbnz	r3, 3a3a <valid_adv_ext_param+0x92>
		if (param->interval_min > param->interval_max ||
    3a28:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
    3a2c:	429a      	cmp	r2, r3
    3a2e:	d8c4      	bhi.n	39ba <valid_adv_ext_param+0x12>
    3a30:	2a1f      	cmp	r2, #31
    3a32:	d9c2      	bls.n	39ba <valid_adv_ext_param+0x12>
		    param->interval_min < 0x0020 ||
    3a34:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    3a38:	d8bf      	bhi.n	39ba <valid_adv_ext_param+0x12>
	    (param->options & BT_LE_ADV_OPT_DISABLE_CHAN_38) &&
    3a3a:	f400 3060 	and.w	r0, r0, #229376	; 0x38000
	if ((param->options & BT_LE_ADV_OPT_DISABLE_CHAN_37) &&
    3a3e:	f5b0 3060 	subs.w	r0, r0, #229376	; 0x38000
    3a42:	bf18      	it	ne
    3a44:	2001      	movne	r0, #1
    3a46:	e7b9      	b.n	39bc <valid_adv_ext_param+0x14>
    3a48:	00040600 	.word	0x00040600
    3a4c:	20000000 	.word	0x20000000

00003a50 <adv_new>:
{
    3a50:	b570      	push	{r4, r5, r6, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    3a52:	4c0f      	ldr	r4, [pc, #60]	; (3a90 <adv_new+0x40>)
    3a54:	f104 0610 	add.w	r6, r4, #16
    3a58:	4630      	mov	r0, r6
    3a5a:	f00c f9ec 	bl	fe36 <atomic_get>
		if (!atomic_test_bit(adv_pool[i].flags, BT_ADV_CREATED)) {
    3a5e:	f010 0501 	ands.w	r5, r0, #1
    3a62:	d001      	beq.n	3a68 <adv_new+0x18>
		return NULL;
    3a64:	2000      	movs	r0, #0
}
    3a66:	bd70      	pop	{r4, r5, r6, pc}
	(void)memset(adv, 0, sizeof(*adv));
    3a68:	2250      	movs	r2, #80	; 0x50
    3a6a:	4629      	mov	r1, r5
    3a6c:	4620      	mov	r0, r4
    3a6e:	f00c f8a5 	bl	fbbc <memset>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    3a72:	f3bf 8f5b 	dmb	ish
    3a76:	e856 3f00 	ldrex	r3, [r6]
    3a7a:	f043 0301 	orr.w	r3, r3, #1
    3a7e:	e846 3200 	strex	r2, r3, [r6]
    3a82:	2a00      	cmp	r2, #0
    3a84:	d1f7      	bne.n	3a76 <adv_new+0x26>
    3a86:	f3bf 8f5b 	dmb	ish
			adv = &adv_pool[i];
    3a8a:	4620      	mov	r0, r4
	adv->handle = i;
    3a8c:	7065      	strb	r5, [r4, #1]
	return adv;
    3a8e:	e7ea      	b.n	3a66 <adv_new+0x16>
    3a90:	200006d8 	.word	0x200006d8

00003a94 <bt_le_adv_delete_legacy>:
{
    3a94:	b510      	push	{r4, lr}
	if (bt_dev.adv) {
    3a96:	4c05      	ldr	r4, [pc, #20]	; (3aac <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x14>)
    3a98:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    3a9a:	b130      	cbz	r0, 3aaa <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x12>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    3a9c:	f06f 0101 	mvn.w	r1, #1
    3aa0:	3010      	adds	r0, #16
    3aa2:	f00c f9d5 	bl	fe50 <atomic_and>
		bt_dev.adv = NULL;
    3aa6:	2300      	movs	r3, #0
    3aa8:	62a3      	str	r3, [r4, #40]	; 0x28
}
    3aaa:	bd10      	pop	{r4, pc}
    3aac:	20000000 	.word	0x20000000

00003ab0 <bt_le_adv_stop>:

	return err;
}

int bt_le_adv_stop(void)
{
    3ab0:	b538      	push	{r3, r4, r5, lr}
	return bt_dev.adv;
    3ab2:	4b11      	ldr	r3, [pc, #68]	; (3af8 <bt_le_adv_stop+0x48>)
    3ab4:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
	int err;

	(void)bt_le_lim_adv_cancel_timeout(adv);
    3ab6:	4620      	mov	r0, r4
    3ab8:	f00c fd0e 	bl	104d8 <bt_le_lim_adv_cancel_timeout>

	if (!adv) {
    3abc:	b17c      	cbz	r4, 3ade <bt_le_adv_stop+0x2e>
	}

	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(adv->flags, BT_ADV_PERSIST);
    3abe:	f104 0510 	add.w	r5, r4, #16
    3ac2:	f46f 5100 	mvn.w	r1, #8192	; 0x2000
    3ac6:	4628      	mov	r0, r5
    3ac8:	f00c f9c2 	bl	fe50 <atomic_and>

	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    3acc:	4628      	mov	r0, r5
    3ace:	2106      	movs	r1, #6
    3ad0:	f00c f9b7 	bl	fe42 <atomic_test_bit>
    3ad4:	4605      	mov	r5, r0
    3ad6:	b920      	cbnz	r0, 3ae2 <bt_le_adv_stop+0x32>
		/* Legacy advertiser exists, but is not currently advertising.
		 * This happens when keep advertising behavior is active but
		 * no conn object is available to do connectable advertising.
		 */
		bt_le_adv_delete_legacy();
    3ad8:	f7ff ffdc 	bl	3a94 <bt_le_adv_delete_legacy>
		return 0;
    3adc:	462c      	mov	r4, r5
		}
	}
#endif /* defined(CONFIG_BT_OBSERVER) */

	return 0;
}
    3ade:	4620      	mov	r0, r4
    3ae0:	bd38      	pop	{r3, r4, r5, pc}
		err = bt_le_adv_set_enable_ext(adv, false, NULL);
    3ae2:	2200      	movs	r2, #0
    3ae4:	4620      	mov	r0, r4
    3ae6:	4611      	mov	r1, r2
    3ae8:	f00c fcb5 	bl	10456 <bt_le_adv_set_enable_ext>
		if (err) {
    3aec:	4604      	mov	r4, r0
    3aee:	2800      	cmp	r0, #0
    3af0:	d1f5      	bne.n	3ade <bt_le_adv_stop+0x2e>
	bt_le_adv_delete_legacy();
    3af2:	f7ff ffcf 	bl	3a94 <bt_le_adv_delete_legacy>
	return 0;
    3af6:	e7f2      	b.n	3ade <bt_le_adv_stop+0x2e>
    3af8:	20000000 	.word	0x20000000

00003afc <bt_le_ext_adv_create>:
}

int bt_le_ext_adv_create(const struct bt_le_adv_param *param,
			 const struct bt_le_ext_adv_cb *cb,
			 struct bt_le_ext_adv **out_adv)
{
    3afc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3afe:	4604      	mov	r4, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    3b00:	4815      	ldr	r0, [pc, #84]	; (3b58 <bt_le_ext_adv_create+0x5c>)
    3b02:	f00c f998 	bl	fe36 <atomic_get>
	struct bt_le_ext_adv *adv;
	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    3b06:	0783      	lsls	r3, r0, #30
{
    3b08:	460f      	mov	r7, r1
    3b0a:	4616      	mov	r6, r2
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    3b0c:	d51a      	bpl.n	3b44 <bt_le_ext_adv_create+0x48>
		return -EAGAIN;
	}

	if (!valid_adv_ext_param(param)) {
    3b0e:	4620      	mov	r0, r4
    3b10:	f7ff ff4a 	bl	39a8 <valid_adv_ext_param>
    3b14:	b1c8      	cbz	r0, 3b4a <bt_le_ext_adv_create+0x4e>
		return -EINVAL;
	}

	adv = adv_new();
    3b16:	f7ff ff9b 	bl	3a50 <adv_new>
    3b1a:	4605      	mov	r5, r0
	if (!adv) {
    3b1c:	b1c0      	cbz	r0, 3b50 <bt_le_ext_adv_create+0x54>
		return -ENOMEM;
	}

	adv->id = param->id;
    3b1e:	7823      	ldrb	r3, [r4, #0]
    3b20:	7003      	strb	r3, [r0, #0]
	adv->cb = cb;

	err = le_ext_adv_param_set(adv, param, false);
    3b22:	4621      	mov	r1, r4
	adv->cb = cb;
    3b24:	6147      	str	r7, [r0, #20]
	err = le_ext_adv_param_set(adv, param, false);
    3b26:	2200      	movs	r2, #0
    3b28:	f00c fb81 	bl	1022e <le_ext_adv_param_set>
	if (err) {
    3b2c:	4604      	mov	r4, r0
    3b2e:	b138      	cbz	r0, 3b40 <bt_le_ext_adv_create+0x44>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    3b30:	f06f 0101 	mvn.w	r1, #1
    3b34:	f105 0010 	add.w	r0, r5, #16
    3b38:	f00c f98a 	bl	fe50 <atomic_and>
		return err;
	}

	*out_adv = adv;
	return 0;
}
    3b3c:	4620      	mov	r0, r4
    3b3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	*out_adv = adv;
    3b40:	6035      	str	r5, [r6, #0]
	return 0;
    3b42:	e7fb      	b.n	3b3c <bt_le_ext_adv_create+0x40>
		return -EAGAIN;
    3b44:	f06f 040a 	mvn.w	r4, #10
    3b48:	e7f8      	b.n	3b3c <bt_le_ext_adv_create+0x40>
		return -EINVAL;
    3b4a:	f06f 0415 	mvn.w	r4, #21
    3b4e:	e7f5      	b.n	3b3c <bt_le_ext_adv_create+0x40>
		return -ENOMEM;
    3b50:	f06f 040b 	mvn.w	r4, #11
    3b54:	e7f2      	b.n	3b3c <bt_le_ext_adv_create+0x40>
    3b56:	bf00      	nop
    3b58:	20000098 	.word	0x20000098

00003b5c <bt_hci_le_adv_set_terminated>:
#endif /* CONFIG_BT_PER_ADV */

#if defined(CONFIG_BT_EXT_ADV)
#if defined(CONFIG_BT_BROADCASTER)
void bt_hci_le_adv_set_terminated(struct net_buf *buf)
{
    3b5c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct bt_hci_evt_le_adv_set_terminated *evt;
	struct bt_le_ext_adv *adv;
	uint16_t conn_handle;

	evt = (void *)buf->data;
    3b5e:	6886      	ldr	r6, [r0, #8]
	if (handle < ARRAY_SIZE(adv_pool) &&
    3b60:	7873      	ldrb	r3, [r6, #1]
    3b62:	b37b      	cbz	r3, 3bc4 <bt_hci_le_adv_set_terminated+0x68>
	return NULL;
    3b64:	2400      	movs	r4, #0
	adv = bt_adv_lookup_handle(evt->adv_handle);
	conn_handle = sys_le16_to_cpu(evt->conn_handle);

	(void)bt_le_lim_adv_cancel_timeout(adv);
    3b66:	4620      	mov	r0, r4
    3b68:	f00c fcb6 	bl	104d8 <bt_le_lim_adv_cancel_timeout>

	BT_DBG("status 0x%02x adv_handle %u conn_handle 0x%02x num %u",
	       evt->status, evt->adv_handle, conn_handle,
	       evt->num_completed_ext_adv_evts);

	if (!adv) {
    3b6c:	b38c      	cbz	r4, 3bd2 <bt_hci_le_adv_set_terminated+0x76>
		BT_ERR("No valid adv");
		return;
	}

	atomic_clear_bit(adv->flags, BT_ADV_ENABLED);
    3b6e:	f104 0510 	add.w	r5, r4, #16
    3b72:	f06f 0140 	mvn.w	r1, #64	; 0x40
    3b76:	4628      	mov	r0, r5
    3b78:	f00c f96a 	bl	fe50 <atomic_and>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    3b7c:	f06f 0120 	mvn.w	r1, #32
    3b80:	4628      	mov	r0, r5
    3b82:	f00c f965 	bl	fe50 <atomic_and>

			bt_conn_unref(conn);
		}
	}

	if (atomic_test_and_clear_bit(adv->flags, BT_ADV_LIMITED)) {
    3b86:	0683      	lsls	r3, r0, #26
    3b88:	d50e      	bpl.n	3ba8 <bt_hci_le_adv_set_terminated+0x4c>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    3b8a:	f06f 0110 	mvn.w	r1, #16
    3b8e:	4628      	mov	r0, r5
    3b90:	f00c f95e 	bl	fe50 <atomic_and>

#if defined(CONFIG_BT_SMP)
		bt_id_pending_keys_update();
#endif

		if (adv->cb && adv->cb->sent) {
    3b94:	6963      	ldr	r3, [r4, #20]
    3b96:	b13b      	cbz	r3, 3ba8 <bt_hci_le_adv_set_terminated+0x4c>
    3b98:	681b      	ldr	r3, [r3, #0]
    3b9a:	b12b      	cbz	r3, 3ba8 <bt_hci_le_adv_set_terminated+0x4c>
			struct bt_le_ext_adv_sent_info info = {
    3b9c:	7932      	ldrb	r2, [r6, #4]
    3b9e:	f88d 2004 	strb.w	r2, [sp, #4]
				.num_sent = evt->num_completed_ext_adv_evts,
			};

			adv->cb->sent(adv, &info);
    3ba2:	a901      	add	r1, sp, #4
    3ba4:	4620      	mov	r0, r4
    3ba6:	4798      	blx	r3
		}
	}

	if (!atomic_test_bit(adv->flags, BT_ADV_PERSIST) && adv == bt_dev.adv) {
    3ba8:	210d      	movs	r1, #13
    3baa:	4628      	mov	r0, r5
    3bac:	f00c f949 	bl	fe42 <atomic_test_bit>
    3bb0:	b978      	cbnz	r0, 3bd2 <bt_hci_le_adv_set_terminated+0x76>
    3bb2:	4b09      	ldr	r3, [pc, #36]	; (3bd8 <bt_hci_le_adv_set_terminated+0x7c>)
    3bb4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3bb6:	42a3      	cmp	r3, r4
    3bb8:	d10b      	bne.n	3bd2 <bt_hci_le_adv_set_terminated+0x76>
		bt_le_adv_delete_legacy();
	}
}
    3bba:	b002      	add	sp, #8
    3bbc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		bt_le_adv_delete_legacy();
    3bc0:	f7ff bf68 	b.w	3a94 <bt_le_adv_delete_legacy>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    3bc4:	4805      	ldr	r0, [pc, #20]	; (3bdc <bt_hci_le_adv_set_terminated+0x80>)
    3bc6:	f00c f936 	bl	fe36 <atomic_get>
	if (handle < ARRAY_SIZE(adv_pool) &&
    3bca:	07c2      	lsls	r2, r0, #31
    3bcc:	d5ca      	bpl.n	3b64 <bt_hci_le_adv_set_terminated+0x8>
		return &adv_pool[handle];
    3bce:	4c04      	ldr	r4, [pc, #16]	; (3be0 <bt_hci_le_adv_set_terminated+0x84>)
    3bd0:	e7c9      	b.n	3b66 <bt_hci_le_adv_set_terminated+0xa>
}
    3bd2:	b002      	add	sp, #8
    3bd4:	bd70      	pop	{r4, r5, r6, pc}
    3bd6:	bf00      	nop
    3bd8:	20000000 	.word	0x20000000
    3bdc:	200006e8 	.word	0x200006e8
    3be0:	200006d8 	.word	0x200006d8

00003be4 <bt_hci_le_scan_req_received>:

void bt_hci_le_scan_req_received(struct net_buf *buf)
{
    3be4:	b530      	push	{r4, r5, lr}
	struct bt_hci_evt_le_scan_req_received *evt;
	struct bt_le_ext_adv *adv;

	evt = (void *)buf->data;
    3be6:	6883      	ldr	r3, [r0, #8]
	if (handle < ARRAY_SIZE(adv_pool) &&
    3be8:	781a      	ldrb	r2, [r3, #0]
{
    3bea:	b085      	sub	sp, #20
	if (handle < ARRAY_SIZE(adv_pool) &&
    3bec:	b9f2      	cbnz	r2, 3c2c <bt_hci_le_scan_req_received+0x48>
    3bee:	4c14      	ldr	r4, [pc, #80]	; (3c40 <bt_hci_le_scan_req_received+0x5c>)
    3bf0:	f104 0010 	add.w	r0, r4, #16
    3bf4:	f00c f91f 	bl	fe36 <atomic_get>
    3bf8:	07c2      	lsls	r2, r0, #31
    3bfa:	d517      	bpl.n	3c2c <bt_hci_le_scan_req_received+0x48>
	if (!adv) {
		BT_ERR("No valid adv");
		return;
	}

	if (adv->cb && adv->cb->scanned) {
    3bfc:	6962      	ldr	r2, [r4, #20]
    3bfe:	b1aa      	cbz	r2, 3c2c <bt_hci_le_scan_req_received+0x48>
    3c00:	6892      	ldr	r2, [r2, #8]
    3c02:	b19a      	cbz	r2, 3c2c <bt_hci_le_scan_req_received+0x48>
		struct bt_le_ext_adv_scanned_info info;
		bt_addr_le_t id_addr;

		if (evt->addr.type == BT_ADDR_LE_PUBLIC_ID ||
		    evt->addr.type == BT_ADDR_LE_RANDOM_ID) {
			bt_addr_le_copy(&id_addr, &evt->addr);
    3c04:	1c59      	adds	r1, r3, #1
		if (evt->addr.type == BT_ADDR_LE_PUBLIC_ID ||
    3c06:	785b      	ldrb	r3, [r3, #1]
    3c08:	3b02      	subs	r3, #2
    3c0a:	2b01      	cmp	r3, #1
    3c0c:	ad02      	add	r5, sp, #8
    3c0e:	d80f      	bhi.n	3c30 <bt_hci_le_scan_req_received+0x4c>
			bt_addr_le_copy(&id_addr, &evt->addr);
    3c10:	4628      	mov	r0, r5
    3c12:	f00c fa57 	bl	100c4 <bt_addr_le_copy>
			id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    3c16:	f89d 3008 	ldrb.w	r3, [sp, #8]
    3c1a:	3b02      	subs	r3, #2
    3c1c:	f88d 3008 	strb.w	r3, [sp, #8]
			bt_addr_le_copy(&id_addr,
					bt_lookup_id_addr(adv->id, &evt->addr));
		}

		info.addr = &id_addr;
		adv->cb->scanned(adv, &info);
    3c20:	6963      	ldr	r3, [r4, #20]
    3c22:	4807      	ldr	r0, [pc, #28]	; (3c40 <bt_hci_le_scan_req_received+0x5c>)
    3c24:	689b      	ldr	r3, [r3, #8]
		info.addr = &id_addr;
    3c26:	9501      	str	r5, [sp, #4]
		adv->cb->scanned(adv, &info);
    3c28:	a901      	add	r1, sp, #4
    3c2a:	4798      	blx	r3
	}
}
    3c2c:	b005      	add	sp, #20
    3c2e:	bd30      	pop	{r4, r5, pc}
			bt_addr_le_copy(&id_addr,
    3c30:	7820      	ldrb	r0, [r4, #0]
    3c32:	f00c f892 	bl	fd5a <bt_lookup_id_addr>
    3c36:	4601      	mov	r1, r0
    3c38:	4628      	mov	r0, r5
    3c3a:	f00c fa43 	bl	100c4 <bt_addr_le_copy>
    3c3e:	e7ef      	b.n	3c20 <bt_hci_le_scan_req_received+0x3c>
    3c40:	200006d8 	.word	0x200006d8

00003c44 <set_le_ext_scan_enable>:
{
	scan_dev_found_cb = NULL;
}

static int set_le_ext_scan_enable(uint8_t enable, uint16_t duration)
{
    3c44:	b570      	push	{r4, r5, r6, lr}
    3c46:	4604      	mov	r4, r0
    3c48:	b086      	sub	sp, #24
    3c4a:	460e      	mov	r6, r1
	struct bt_hci_cp_le_set_ext_scan_enable *cp;
	struct bt_hci_cmd_state_set state;
	struct net_buf *buf;
	int err;

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EXT_SCAN_ENABLE, sizeof(*cp));
    3c4c:	f242 0042 	movw	r0, #8258	; 0x2042
    3c50:	2106      	movs	r1, #6
    3c52:	f7ff f8f7 	bl	2e44 <bt_hci_cmd_create>
	if (!buf) {
    3c56:	4605      	mov	r5, r0
    3c58:	b340      	cbz	r0, 3cac <set_le_ext_scan_enable+0x68>
	return net_buf_simple_add(&buf->b, len);
    3c5a:	2106      	movs	r1, #6
    3c5c:	3008      	adds	r0, #8
    3c5e:	f00e f94a 	bl	11ef6 <net_buf_simple_add>
		return -ENOBUFS;
	}

	cp = net_buf_add(buf, sizeof(*cp));

	if (enable == BT_HCI_LE_SCAN_ENABLE) {
    3c62:	2c01      	cmp	r4, #1
    3c64:	4603      	mov	r3, r0
    3c66:	d11f      	bne.n	3ca8 <set_le_ext_scan_enable+0x64>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    3c68:	f3bf 8f5b 	dmb	ish
    3c6c:	4a11      	ldr	r2, [pc, #68]	; (3cb4 <set_le_ext_scan_enable+0x70>)
    3c6e:	6812      	ldr	r2, [r2, #0]
    3c70:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    3c74:	f3c2 2200 	ubfx	r2, r2, #8, #1
	} else {
		cp->filter_dup = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
	}

	cp->enable = enable;
	cp->duration = sys_cpu_to_le16(duration);
    3c78:	805e      	strh	r6, [r3, #2]
	cp->period = 0;
    3c7a:	2600      	movs	r6, #0
		cp->filter_dup = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
    3c7c:	705a      	strb	r2, [r3, #1]
	cp->enable = enable;
    3c7e:	701c      	strb	r4, [r3, #0]
	cp->period = 0;
    3c80:	711e      	strb	r6, [r3, #4]
    3c82:	715e      	strb	r6, [r3, #5]

	bt_hci_cmd_state_set_init(buf, &state, bt_dev.flags, BT_DEV_SCANNING,
    3c84:	1e63      	subs	r3, r4, #1
    3c86:	425c      	negs	r4, r3
    3c88:	415c      	adcs	r4, r3
    3c8a:	4a0a      	ldr	r2, [pc, #40]	; (3cb4 <set_le_ext_scan_enable+0x70>)
    3c8c:	9400      	str	r4, [sp, #0]
    3c8e:	a903      	add	r1, sp, #12
    3c90:	4628      	mov	r0, r5
    3c92:	2305      	movs	r3, #5
    3c94:	f7ff f8c4 	bl	2e20 <bt_hci_cmd_state_set_init>
				  enable == BT_HCI_LE_SCAN_ENABLE);

	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EXT_SCAN_ENABLE, buf, NULL);
    3c98:	4632      	mov	r2, r6
    3c9a:	4629      	mov	r1, r5
    3c9c:	f242 0042 	movw	r0, #8258	; 0x2042
    3ca0:	f7ff f90a 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
		return err;
	}

	return 0;
}
    3ca4:	b006      	add	sp, #24
    3ca6:	bd70      	pop	{r4, r5, r6, pc}
		cp->filter_dup = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
    3ca8:	2200      	movs	r2, #0
    3caa:	e7e5      	b.n	3c78 <set_le_ext_scan_enable+0x34>
		return -ENOBUFS;
    3cac:	f06f 0068 	mvn.w	r0, #104	; 0x68
    3cb0:	e7f8      	b.n	3ca4 <set_le_ext_scan_enable+0x60>
    3cb2:	bf00      	nop
    3cb4:	20000098 	.word	0x20000098

00003cb8 <le_adv_recv>:
	}
}

static void le_adv_recv(bt_addr_le_t *addr, struct bt_le_scan_recv_info *info,
			struct net_buf *buf, uint8_t len)
{
    3cb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3cbc:	4698      	mov	r8, r3
	    (info->adv_props & BT_HCI_LE_ADV_PROP_DIRECT)) {
		BT_DBG("Dropped direct adv report");
		return;
	}

	if (addr->type == BT_ADDR_LE_PUBLIC_ID ||
    3cbe:	7803      	ldrb	r3, [r0, #0]
{
    3cc0:	4614      	mov	r4, r2
	if (addr->type == BT_ADDR_LE_PUBLIC_ID ||
    3cc2:	1e9a      	subs	r2, r3, #2
    3cc4:	2a01      	cmp	r2, #1
{
    3cc6:	b085      	sub	sp, #20
    3cc8:	460e      	mov	r6, r1
	if (addr->type == BT_ADDR_LE_PUBLIC_ID ||
    3cca:	d854      	bhi.n	3d76 <le_adv_recv+0xbe>
	memcpy(dst, src, sizeof(*dst));
    3ccc:	4601      	mov	r1, r0
    3cce:	2207      	movs	r2, #7
    3cd0:	4668      	mov	r0, sp
    3cd2:	f00b ff68 	bl	fba6 <memcpy>
	    addr->type == BT_ADDR_LE_RANDOM_ID) {
		bt_addr_le_copy(&id_addr, addr);
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    3cd6:	f89d 3000 	ldrb.w	r3, [sp]
    3cda:	3b02      	subs	r3, #2
    3cdc:	f88d 3000 	strb.w	r3, [sp]
				bt_lookup_id_addr(BT_ID_DEFAULT, addr));
	}

	info->addr = &id_addr;

	if (scan_dev_found_cb) {
    3ce0:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 3da4 <le_adv_recv+0xec>
	info->addr = &id_addr;
    3ce4:	f8c6 d000 	str.w	sp, [r6]
	if (scan_dev_found_cb) {
    3ce8:	f8d9 3000 	ldr.w	r3, [r9]
    3cec:	b1bb      	cbz	r3, 3d1e <le_adv_recv+0x66>
		net_buf_simple_save(&buf->b, &state);
    3cee:	f104 0708 	add.w	r7, r4, #8
	state->offset = net_buf_simple_headroom(buf);
    3cf2:	4638      	mov	r0, r7
    3cf4:	f00e f938 	bl	11f68 <net_buf_simple_headroom>
	state->len = buf->len;
    3cf8:	f8b4 a00c 	ldrh.w	sl, [r4, #12]

		buf->len = len;
    3cfc:	f8a4 800c 	strh.w	r8, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
    3d00:	4605      	mov	r5, r0
		scan_dev_found_cb(&id_addr, info->rssi, info->adv_type,
    3d02:	f8d9 9000 	ldr.w	r9, [r9]
    3d06:	79f2      	ldrb	r2, [r6, #7]
    3d08:	f996 1005 	ldrsb.w	r1, [r6, #5]
    3d0c:	4668      	mov	r0, sp
    3d0e:	463b      	mov	r3, r7
    3d10:	47c8      	blx	r9
	buf->data = buf->__buf + state->offset;
    3d12:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    3d14:	f8a4 a00c 	strh.w	sl, [r4, #12]
	buf->data = buf->__buf + state->offset;
    3d18:	fa10 f585 	uxtah	r5, r0, r5
    3d1c:	60a5      	str	r5, [r4, #8]
	return list->head;
    3d1e:	4b22      	ldr	r3, [pc, #136]	; (3da8 <le_adv_recv+0xf0>)
    3d20:	681b      	ldr	r3, [r3, #0]
				  &buf->b);

		net_buf_simple_restore(&buf->b, &state);
	}

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&scan_cbs, listener, next, node) {
    3d22:	2b00      	cmp	r3, #0
    3d24:	d03a      	beq.n	3d9c <le_adv_recv+0xe4>
    3d26:	f1b3 0908 	subs.w	r9, r3, #8
    3d2a:	d037      	beq.n	3d9c <le_adv_recv+0xe4>
	return node->next;
    3d2c:	681d      	ldr	r5, [r3, #0]
    3d2e:	b105      	cbz	r5, 3d32 <le_adv_recv+0x7a>
    3d30:	3d08      	subs	r5, #8
		if (listener->recv) {
			net_buf_simple_save(&buf->b, &state);
    3d32:	f104 0a08 	add.w	sl, r4, #8
		if (listener->recv) {
    3d36:	f8d9 3000 	ldr.w	r3, [r9]
    3d3a:	b193      	cbz	r3, 3d62 <le_adv_recv+0xaa>
	state->offset = net_buf_simple_headroom(buf);
    3d3c:	4650      	mov	r0, sl
    3d3e:	f00e f913 	bl	11f68 <net_buf_simple_headroom>
	state->len = buf->len;
    3d42:	f8b4 b00c 	ldrh.w	fp, [r4, #12]

			buf->len = len;
			listener->recv(info, &buf->b);
    3d46:	f8d9 3000 	ldr.w	r3, [r9]
			buf->len = len;
    3d4a:	f8a4 800c 	strh.w	r8, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
    3d4e:	4607      	mov	r7, r0
			listener->recv(info, &buf->b);
    3d50:	4651      	mov	r1, sl
    3d52:	4630      	mov	r0, r6
    3d54:	4798      	blx	r3
	buf->data = buf->__buf + state->offset;
    3d56:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    3d58:	f8a4 b00c 	strh.w	fp, [r4, #12]
	buf->data = buf->__buf + state->offset;
    3d5c:	fa10 f787 	uxtah	r7, r0, r7
    3d60:	60a7      	str	r7, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&scan_cbs, listener, next, node) {
    3d62:	b1dd      	cbz	r5, 3d9c <le_adv_recv+0xe4>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
    3d64:	f115 0208 	adds.w	r2, r5, #8
    3d68:	d002      	beq.n	3d70 <le_adv_recv+0xb8>
	return node->next;
    3d6a:	68aa      	ldr	r2, [r5, #8]
    3d6c:	b102      	cbz	r2, 3d70 <le_adv_recv+0xb8>
    3d6e:	3a08      	subs	r2, #8
{
    3d70:	46a9      	mov	r9, r5
    3d72:	4615      	mov	r5, r2
    3d74:	e7df      	b.n	3d36 <le_adv_recv+0x7e>
	} else if (addr->type == BT_HCI_PEER_ADDR_ANONYMOUS) {
    3d76:	2bff      	cmp	r3, #255	; 0xff
    3d78:	d109      	bne.n	3d8e <le_adv_recv+0xd6>
		bt_addr_le_copy(&id_addr, BT_ADDR_LE_ANY);
    3d7a:	2300      	movs	r3, #0
    3d7c:	9302      	str	r3, [sp, #8]
    3d7e:	2207      	movs	r2, #7
    3d80:	f8cd 300b 	str.w	r3, [sp, #11]
    3d84:	a902      	add	r1, sp, #8
    3d86:	4668      	mov	r0, sp
    3d88:	f00b ff0d 	bl	fba6 <memcpy>
}
    3d8c:	e7a8      	b.n	3ce0 <le_adv_recv+0x28>
		bt_addr_le_copy(&id_addr,
    3d8e:	4601      	mov	r1, r0
    3d90:	2000      	movs	r0, #0
    3d92:	f00b ffe2 	bl	fd5a <bt_lookup_id_addr>
	memcpy(dst, src, sizeof(*dst));
    3d96:	2207      	movs	r2, #7
    3d98:	4601      	mov	r1, r0
    3d9a:	e7f4      	b.n	3d86 <le_adv_recv+0xce>
	}

#if defined(CONFIG_BT_CENTRAL)
	check_pending_conn(&id_addr, addr, info->adv_props);
#endif /* CONFIG_BT_CENTRAL */
}
    3d9c:	b005      	add	sp, #20
    3d9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3da2:	bf00      	nop
    3da4:	20000a54 	.word	0x20000a54
    3da8:	20000a4c 	.word	0x20000a4c

00003dac <bt_scan_reset>:
	scan_dev_found_cb = NULL;
    3dac:	4b01      	ldr	r3, [pc, #4]	; (3db4 <bt_scan_reset+0x8>)
    3dae:	2200      	movs	r2, #0
    3db0:	601a      	str	r2, [r3, #0]
}
    3db2:	4770      	bx	lr
    3db4:	20000a54 	.word	0x20000a54

00003db8 <bt_le_scan_update>:
    3db8:	4b0a      	ldr	r3, [pc, #40]	; (3de4 <bt_le_scan_update+0x2c>)
    3dba:	f3bf 8f5b 	dmb	ish
    3dbe:	681a      	ldr	r2, [r3, #0]
    3dc0:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
    3dc4:	f3c2 1080 	ubfx	r0, r2, #6, #1
    3dc8:	0652      	lsls	r2, r2, #25
    3dca:	d408      	bmi.n	3dde <bt_le_scan_update+0x26>
    3dcc:	f3bf 8f5b 	dmb	ish
    3dd0:	681b      	ldr	r3, [r3, #0]
    3dd2:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
    3dd6:	069b      	lsls	r3, r3, #26
    3dd8:	d501      	bpl.n	3dde <bt_le_scan_update+0x26>
		err = bt_le_scan_set_enable(BT_HCI_LE_SCAN_DISABLE);
    3dda:	f00c bbf6 	b.w	105ca <bt_le_scan_set_enable>
}
    3dde:	2000      	movs	r0, #0
    3de0:	4770      	bx	lr
    3de2:	bf00      	nop
    3de4:	20000098 	.word	0x20000098

00003de8 <bt_hci_le_scan_timeout>:

#if defined(CONFIG_BT_EXT_ADV)
void bt_hci_le_scan_timeout(struct net_buf *buf)
{
    3de8:	b510      	push	{r4, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    3dea:	f06f 0120 	mvn.w	r1, #32
    3dee:	4814      	ldr	r0, [pc, #80]	; (3e40 <bt_hci_le_scan_timeout+0x58>)
    3df0:	f00c fbdc 	bl	105ac <atomic_and>
    3df4:	f06f 0140 	mvn.w	r1, #64	; 0x40
    3df8:	4811      	ldr	r0, [pc, #68]	; (3e40 <bt_hci_le_scan_timeout+0x58>)
    3dfa:	f00c fbd7 	bl	105ac <atomic_and>
    3dfe:	f46f 6180 	mvn.w	r1, #1024	; 0x400
    3e02:	480f      	ldr	r0, [pc, #60]	; (3e40 <bt_hci_le_scan_timeout+0x58>)
    3e04:	f00c fbd2 	bl	105ac <atomic_and>
    3e08:	480d      	ldr	r0, [pc, #52]	; (3e40 <bt_hci_le_scan_timeout+0x58>)
    3e0a:	f46f 5180 	mvn.w	r1, #4096	; 0x1000
    3e0e:	f00c fbcd 	bl	105ac <atomic_and>
	return list->head;
    3e12:	4b0c      	ldr	r3, [pc, #48]	; (3e44 <bt_hci_le_scan_timeout+0x5c>)
    3e14:	681b      	ldr	r3, [r3, #0]

#if defined(CONFIG_BT_SMP)
	bt_id_pending_keys_update();
#endif

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&scan_cbs, listener, next, node) {
    3e16:	b193      	cbz	r3, 3e3e <bt_hci_le_scan_timeout+0x56>
    3e18:	f1b3 0208 	subs.w	r2, r3, #8
    3e1c:	d00f      	beq.n	3e3e <bt_hci_le_scan_timeout+0x56>
	return node->next;
    3e1e:	681c      	ldr	r4, [r3, #0]
    3e20:	b104      	cbz	r4, 3e24 <bt_hci_le_scan_timeout+0x3c>
    3e22:	3c08      	subs	r4, #8
		if (listener->timeout) {
    3e24:	6853      	ldr	r3, [r2, #4]
    3e26:	b103      	cbz	r3, 3e2a <bt_hci_le_scan_timeout+0x42>
			listener->timeout();
    3e28:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&scan_cbs, listener, next, node) {
    3e2a:	b144      	cbz	r4, 3e3e <bt_hci_le_scan_timeout+0x56>
Z_GENLIST_PEEK_NEXT(slist, snode)
    3e2c:	f114 0308 	adds.w	r3, r4, #8
    3e30:	d002      	beq.n	3e38 <bt_hci_le_scan_timeout+0x50>
	return node->next;
    3e32:	68a3      	ldr	r3, [r4, #8]
    3e34:	b103      	cbz	r3, 3e38 <bt_hci_le_scan_timeout+0x50>
    3e36:	3b08      	subs	r3, #8
{
    3e38:	4622      	mov	r2, r4
    3e3a:	461c      	mov	r4, r3
    3e3c:	e7f2      	b.n	3e24 <bt_hci_le_scan_timeout+0x3c>
		}
	}
}
    3e3e:	bd10      	pop	{r4, pc}
    3e40:	20000098 	.word	0x20000098
    3e44:	20000a4c 	.word	0x20000a4c

00003e48 <bt_hci_le_adv_ext_report>:
		return BT_GAP_ADV_TYPE_EXT_ADV;
	}
}

void bt_hci_le_adv_ext_report(struct net_buf *buf)
{
    3e48:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 *
 * @return The 8-bit removed value
 */
static inline uint8_t net_buf_pull_u8(struct net_buf *buf)
{
	return net_buf_simple_pull_u8(&buf->b);
    3e4c:	f100 0708 	add.w	r7, r0, #8
    3e50:	4606      	mov	r6, r0
    3e52:	4638      	mov	r0, r7
    3e54:	f00e f880 	bl	11f58 <net_buf_simple_pull_u8>
    3e58:	f8df 8084 	ldr.w	r8, [pc, #132]	; 3ee0 <bt_hci_le_adv_ext_report+0x98>
    3e5c:	4605      	mov	r5, r0
	uint8_t num_reports = net_buf_pull_u8(buf);

	BT_DBG("Adv number of reports %u",  num_reports);

	while (num_reports--) {
    3e5e:	b915      	cbnz	r5, 3e66 <bt_hci_le_adv_ext_report+0x1e>

		le_adv_recv(&evt->addr, &adv_info, buf, evt->length);

		net_buf_pull(buf, evt->length);
	}
}
    3e60:	b004      	add	sp, #16
    3e62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (buf->len < sizeof(*evt)) {
    3e66:	89b3      	ldrh	r3, [r6, #12]
    3e68:	2b17      	cmp	r3, #23
    3e6a:	d9f9      	bls.n	3e60 <bt_hci_le_adv_ext_report+0x18>
	return net_buf_simple_pull_mem(&buf->b, len);
    3e6c:	2118      	movs	r1, #24
    3e6e:	4638      	mov	r0, r7
    3e70:	f00e f86a 	bl	11f48 <net_buf_simple_pull_mem>
    3e74:	4604      	mov	r4, r0
		adv_info.primary_phy = bt_get_phy(evt->prim_phy);
    3e76:	7a40      	ldrb	r0, [r0, #9]
    3e78:	f7ff f9cc 	bl	3214 <bt_get_phy>
    3e7c:	f88d 000c 	strb.w	r0, [sp, #12]
		adv_info.secondary_phy = bt_get_phy(evt->sec_phy);
    3e80:	7aa0      	ldrb	r0, [r4, #10]
    3e82:	f7ff f9c7 	bl	3214 <bt_get_phy>
    3e86:	f88d 000d 	strb.w	r0, [sp, #13]
		adv_info.tx_power = evt->tx_power;
    3e8a:	7b23      	ldrb	r3, [r4, #12]
    3e8c:	f88d 3006 	strb.w	r3, [sp, #6]
		adv_info.rssi = evt->rssi;
    3e90:	7b63      	ldrb	r3, [r4, #13]
    3e92:	f88d 3005 	strb.w	r3, [sp, #5]
		adv_info.sid = evt->sid;
    3e96:	7ae3      	ldrb	r3, [r4, #11]
    3e98:	f88d 3004 	strb.w	r3, [sp, #4]
		adv_info.interval = sys_le16_to_cpu(evt->interval);
    3e9c:	7be2      	ldrb	r2, [r4, #15]
    3e9e:	7ba3      	ldrb	r3, [r4, #14]
    3ea0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    3ea4:	f8ad 300a 	strh.w	r3, [sp, #10]
		adv_info.adv_type = get_adv_type(evt->evt_type);
    3ea8:	8823      	ldrh	r3, [r4, #0]
	switch (evt_type) {
    3eaa:	f1a3 0210 	sub.w	r2, r3, #16
    3eae:	b2d2      	uxtb	r2, r2
    3eb0:	2a0b      	cmp	r2, #11
    3eb2:	bf94      	ite	ls
    3eb4:	f818 2002 	ldrbls.w	r2, [r8, r2]
		adv_info.adv_type = get_adv_type(evt->evt_type);
    3eb8:	2205      	movhi	r2, #5
		adv_info.adv_props = evt->evt_type ^ BT_HCI_LE_ADV_PROP_LEGACY;
    3eba:	f083 0310 	eor.w	r3, r3, #16
		adv_info.adv_type = get_adv_type(evt->evt_type);
    3ebe:	f88d 2007 	strb.w	r2, [sp, #7]
		adv_info.adv_props = evt->evt_type ^ BT_HCI_LE_ADV_PROP_LEGACY;
    3ec2:	f8ad 3008 	strh.w	r3, [sp, #8]
		le_adv_recv(&evt->addr, &adv_info, buf, evt->length);
    3ec6:	4632      	mov	r2, r6
    3ec8:	7de3      	ldrb	r3, [r4, #23]
    3eca:	4669      	mov	r1, sp
    3ecc:	1ca0      	adds	r0, r4, #2
    3ece:	f7ff fef3 	bl	3cb8 <le_adv_recv>
	return net_buf_simple_pull(&buf->b, len);
    3ed2:	3d01      	subs	r5, #1
    3ed4:	7de1      	ldrb	r1, [r4, #23]
    3ed6:	4638      	mov	r0, r7
    3ed8:	f00e f82e 	bl	11f38 <net_buf_simple_pull>
    3edc:	b2ed      	uxtb	r5, r5
    3ede:	e7be      	b.n	3e5e <bt_hci_le_adv_ext_report+0x16>
    3ee0:	0001348d 	.word	0x0001348d

00003ee4 <bt_hci_le_adv_report>:
#endif /* CONFIG_BT_DF_CONNECTIONLESS_CTE_RX */
#endif /* defined(CONFIG_BT_PER_ADV_SYNC) */
#endif /* defined(CONFIG_BT_EXT_ADV) */

void bt_hci_le_adv_report(struct net_buf *buf)
{
    3ee4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return net_buf_simple_pull_u8(&buf->b);
    3ee8:	f100 0708 	add.w	r7, r0, #8
    3eec:	b085      	sub	sp, #20
    3eee:	4606      	mov	r6, r0
    3ef0:	4638      	mov	r0, r7
    3ef2:	f00e f831 	bl	11f58 <net_buf_simple_pull_u8>
    3ef6:	f8df 906c 	ldr.w	r9, [pc, #108]	; 3f64 <bt_hci_le_adv_report+0x80>
    3efa:	4604      	mov	r4, r0

		evt = net_buf_pull_mem(buf, sizeof(*evt));

		adv_info.primary_phy = BT_GAP_LE_PHY_1M;
		adv_info.secondary_phy = 0;
		adv_info.tx_power = BT_GAP_TX_POWER_INVALID;
    3efc:	f04f 087f 	mov.w	r8, #127	; 0x7f
	while (num_reports--) {
    3f00:	b914      	cbnz	r4, 3f08 <bt_hci_le_adv_report+0x24>

		le_adv_recv(&evt->addr, &adv_info, buf, evt->length);

		net_buf_pull(buf, evt->length + sizeof(adv_info.rssi));
	}
}
    3f02:	b005      	add	sp, #20
    3f04:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (buf->len < sizeof(*evt)) {
    3f08:	89b3      	ldrh	r3, [r6, #12]
    3f0a:	2b08      	cmp	r3, #8
    3f0c:	d9f9      	bls.n	3f02 <bt_hci_le_adv_report+0x1e>
	return net_buf_simple_pull_mem(&buf->b, len);
    3f0e:	2109      	movs	r1, #9
    3f10:	4638      	mov	r0, r7
    3f12:	f00e f819 	bl	11f48 <net_buf_simple_pull_mem>
		adv_info.rssi = evt->data[evt->length];
    3f16:	7a03      	ldrb	r3, [r0, #8]
		adv_info.tx_power = BT_GAP_TX_POWER_INVALID;
    3f18:	f88d 8006 	strb.w	r8, [sp, #6]
		adv_info.rssi = evt->data[evt->length];
    3f1c:	18c2      	adds	r2, r0, r3
		adv_info.primary_phy = BT_GAP_LE_PHY_1M;
    3f1e:	2101      	movs	r1, #1
		adv_info.rssi = evt->data[evt->length];
    3f20:	7a52      	ldrb	r2, [r2, #9]
    3f22:	f88d 2005 	strb.w	r2, [sp, #5]
		adv_info.sid = BT_GAP_SID_INVALID;
    3f26:	22ff      	movs	r2, #255	; 0xff
    3f28:	f88d 2004 	strb.w	r2, [sp, #4]
		adv_info.interval = 0U;
    3f2c:	2200      	movs	r2, #0
    3f2e:	f8ad 200a 	strh.w	r2, [sp, #10]
		adv_info.primary_phy = BT_GAP_LE_PHY_1M;
    3f32:	f8ad 100c 	strh.w	r1, [sp, #12]
		adv_info.adv_type = evt->evt_type;
    3f36:	7801      	ldrb	r1, [r0, #0]
    3f38:	f88d 1007 	strb.w	r1, [sp, #7]
    3f3c:	2904      	cmp	r1, #4
    3f3e:	bf98      	it	ls
    3f40:	f819 2001 	ldrbls.w	r2, [r9, r1]
		adv_info.adv_props = get_adv_props(evt->evt_type);
    3f44:	f8ad 2008 	strh.w	r2, [sp, #8]
    3f48:	4605      	mov	r5, r0
		le_adv_recv(&evt->addr, &adv_info, buf, evt->length);
    3f4a:	4632      	mov	r2, r6
    3f4c:	4669      	mov	r1, sp
    3f4e:	3001      	adds	r0, #1
    3f50:	f7ff feb2 	bl	3cb8 <le_adv_recv>
		net_buf_pull(buf, evt->length + sizeof(adv_info.rssi));
    3f54:	7a29      	ldrb	r1, [r5, #8]
	return net_buf_simple_pull(&buf->b, len);
    3f56:	4638      	mov	r0, r7
    3f58:	3101      	adds	r1, #1
    3f5a:	3c01      	subs	r4, #1
    3f5c:	f00d ffec 	bl	11f38 <net_buf_simple_pull>
    3f60:	b2e4      	uxtb	r4, r4
    3f62:	e7cd      	b.n	3f00 <bt_hci_le_adv_report+0x1c>
    3f64:	00013488 	.word	0x00013488

00003f68 <mayfly_init>:
#if defined(MAYFLY_UT)
static uint8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
    3f68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	while (callee_id--) {
		uint8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
    3f6c:	4f11      	ldr	r7, [pc, #68]	; (3fb4 <mayfly_init+0x4c>)
    3f6e:	f8df a048 	ldr.w	sl, [pc, #72]	; 3fb8 <mayfly_init+0x50>
	callee_id = MAYFLY_CALLEE_COUNT;
    3f72:	2404      	movs	r4, #4
	while (callee_id--) {
    3f74:	3c01      	subs	r4, #1
    3f76:	b2e4      	uxtb	r4, r4
    3f78:	2cff      	cmp	r4, #255	; 0xff
    3f7a:	d018      	beq.n	3fae <mayfly_init+0x46>
    3f7c:	eb04 0644 	add.w	r6, r4, r4, lsl #1
    3f80:	ea4f 0984 	mov.w	r9, r4, lsl #2
    3f84:	0136      	lsls	r6, r6, #4
		caller_id = MAYFLY_CALLER_COUNT;
    3f86:	2504      	movs	r5, #4
    3f88:	f04f 080c 	mov.w	r8, #12
    3f8c:	e00a      	b.n	3fa4 <mayfly_init+0x3c>
			memq_init(&mfl[callee_id][caller_id],
    3f8e:	fb18 6105 	smlabb	r1, r8, r5, r6
    3f92:	1d0a      	adds	r2, r1, #4
    3f94:	eb05 0009 	add.w	r0, r5, r9
    3f98:	443a      	add	r2, r7
    3f9a:	4439      	add	r1, r7
    3f9c:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
    3fa0:	f00c fb8b 	bl	106ba <memq_init>
		while (caller_id--) {
    3fa4:	3d01      	subs	r5, #1
    3fa6:	b2ed      	uxtb	r5, r5
    3fa8:	2dff      	cmp	r5, #255	; 0xff
    3faa:	d1f0      	bne.n	3f8e <mayfly_init+0x26>
    3fac:	e7e2      	b.n	3f74 <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
    3fae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3fb2:	bf00      	nop
    3fb4:	20000ad8 	.word	0x20000ad8
    3fb8:	20000a58 	.word	0x20000a58

00003fbc <mayfly_enqueue>:
	}
}

uint32_t mayfly_enqueue(uint8_t caller_id, uint8_t callee_id, uint8_t chain,
			struct mayfly *m)
{
    3fbc:	b570      	push	{r4, r5, r6, lr}
    3fbe:	4606      	mov	r6, r0
    3fc0:	460d      	mov	r5, r1
    3fc2:	461c      	mov	r4, r3
	uint8_t state;
	uint8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
    3fc4:	b1a2      	cbz	r2, 3ff0 <mayfly_enqueue+0x34>
    3fc6:	2301      	movs	r3, #1
		(mft[callee_id][caller_id].disable_req !=
		 mft[callee_id][caller_id].disable_ack);

	/* shadow the ack */
	ack = m->_ack;
    3fc8:	7862      	ldrb	r2, [r4, #1]

	/* already in queue */
	state = (m->_req - ack) & 0x03;
    3fca:	7820      	ldrb	r0, [r4, #0]
    3fcc:	1a80      	subs	r0, r0, r2
	if (state != 0U) {
    3fce:	f010 0003 	ands.w	r0, r0, #3
    3fd2:	d02c      	beq.n	402e <mayfly_enqueue+0x72>
		if (chain) {
    3fd4:	b31b      	cbz	r3, 401e <mayfly_enqueue+0x62>
			if (state != 1U) {
    3fd6:	2801      	cmp	r0, #1
    3fd8:	d028      	beq.n	402c <mayfly_enqueue+0x70>
				/* mark as ready in queue */
				m->_req = ack + 1;
    3fda:	3201      	adds	r2, #1
    3fdc:	b2d2      	uxtb	r2, r2
    3fde:	7022      	strb	r2, [r4, #0]
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
    3fe0:	4b1c      	ldr	r3, [pc, #112]	; (4054 <mayfly_enqueue+0x98>)
    3fe2:	2201      	movs	r2, #1
    3fe4:	555a      	strb	r2, [r3, r5]

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
    3fe6:	4629      	mov	r1, r5
    3fe8:	4630      	mov	r0, r6
    3fea:	f008 fabf 	bl	c56c <mayfly_pend>
    3fee:	e01c      	b.n	402a <mayfly_enqueue+0x6e>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    3ff0:	f00d fe79 	bl	11ce6 <mayfly_prio_is_equal>
    3ff4:	2800      	cmp	r0, #0
    3ff6:	d0e6      	beq.n	3fc6 <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
    3ff8:	4629      	mov	r1, r5
    3ffa:	4630      	mov	r0, r6
    3ffc:	f008 fa96 	bl	c52c <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
    4000:	2800      	cmp	r0, #0
    4002:	d0e0      	beq.n	3fc6 <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
    4004:	2330      	movs	r3, #48	; 0x30
    4006:	220c      	movs	r2, #12
    4008:	436b      	muls	r3, r5
    400a:	fb02 3306 	mla	r3, r2, r6, r3
    400e:	4a12      	ldr	r2, [pc, #72]	; (4058 <mayfly_enqueue+0x9c>)
    4010:	441a      	add	r2, r3
		!mayfly_is_enabled(caller_id, callee_id) ||
    4012:	7a93      	ldrb	r3, [r2, #10]
    4014:	7ad2      	ldrb	r2, [r2, #11]
    4016:	1a9b      	subs	r3, r3, r2
    4018:	bf18      	it	ne
    401a:	2301      	movne	r3, #1
    401c:	e7d4      	b.n	3fc8 <mayfly_enqueue+0xc>
		m->_req = ack + 2;
    401e:	3202      	adds	r2, #2
    4020:	b2d2      	uxtb	r2, r2
    4022:	7022      	strb	r2, [r4, #0]
		m->fp(m->param);
    4024:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
    4028:	4798      	blx	r3

	return 0;
    402a:	2000      	movs	r0, #0
}
    402c:	bd70      	pop	{r4, r5, r6, pc}
	if (!chain) {
    402e:	2b00      	cmp	r3, #0
    4030:	d0f8      	beq.n	4024 <mayfly_enqueue+0x68>
	m->_req = ack + 1;
    4032:	3201      	adds	r2, #1
    4034:	b2d2      	uxtb	r2, r2
    4036:	7022      	strb	r2, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
    4038:	2304      	movs	r3, #4
    403a:	2230      	movs	r2, #48	; 0x30
    403c:	fb12 3205 	smlabb	r2, r2, r5, r3
    4040:	230c      	movs	r3, #12
    4042:	fb13 2306 	smlabb	r3, r3, r6, r2
    4046:	4a04      	ldr	r2, [pc, #16]	; (4058 <mayfly_enqueue+0x9c>)
    4048:	6860      	ldr	r0, [r4, #4]
    404a:	441a      	add	r2, r3
    404c:	4621      	mov	r1, r4
    404e:	f00c fb37 	bl	106c0 <memq_enqueue>
    4052:	e7c5      	b.n	3fe0 <mayfly_enqueue+0x24>
    4054:	20002905 	.word	0x20002905
    4058:	20000ad8 	.word	0x20000ad8

0000405c <mayfly_run>:
		}
	}
}

void mayfly_run(uint8_t callee_id)
{
    405c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t disable = 0U;
	uint8_t enable = 0U;
	uint8_t caller_id;

	if (!mfp[callee_id]) {
    4060:	4b55      	ldr	r3, [pc, #340]	; (41b8 <mayfly_run+0x15c>)
    4062:	5c1a      	ldrb	r2, [r3, r0]
{
    4064:	b089      	sub	sp, #36	; 0x24
    4066:	4604      	mov	r4, r0
	if (!mfp[callee_id]) {
    4068:	2a00      	cmp	r2, #0
    406a:	f000 809e 	beq.w	41aa <mayfly_run+0x14e>
		return;
	}
	mfp[callee_id] = 0U;
    406e:	f04f 0800 	mov.w	r8, #0
    4072:	f803 8000 	strb.w	r8, [r3, r0]

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
    4076:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    407a:	011b      	lsls	r3, r3, #4
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
    407c:	4e4f      	ldr	r6, [pc, #316]	; (41bc <mayfly_run+0x160>)
    407e:	9304      	str	r3, [sp, #16]
    4080:	2504      	movs	r5, #4
    4082:	233c      	movs	r3, #60	; 0x3c
    4084:	fb13 5300 	smlabb	r3, r3, r0, r5
    4088:	18f3      	adds	r3, r6, r3
    408a:	9303      	str	r3, [sp, #12]
	uint8_t disable = 0U;
    408c:	46c3      	mov	fp, r8
	while (caller_id--) {
    408e:	3d01      	subs	r5, #1
    4090:	b2ed      	uxtb	r5, r5
    4092:	2dff      	cmp	r5, #255	; 0xff
    4094:	d10f      	bne.n	40b6 <mayfly_run+0x5a>
			mft[callee_id][caller_id].enable_ack =
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
    4096:	f1bb 0f00 	cmp.w	fp, #0
    409a:	f000 8086 	beq.w	41aa <mayfly_run+0x14e>
    409e:	f1b8 0f00 	cmp.w	r8, #0
    40a2:	f040 8082 	bne.w	41aa <mayfly_run+0x14e>
		mayfly_enable_cb(callee_id, callee_id, 0);
    40a6:	4642      	mov	r2, r8
    40a8:	4621      	mov	r1, r4
    40aa:	4620      	mov	r0, r4
	}
}
    40ac:	b009      	add	sp, #36	; 0x24
    40ae:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		mayfly_enable_cb(callee_id, callee_id, 0);
    40b2:	f008 ba1b 	b.w	c4ec <mayfly_enable_cb>
		struct mayfly *m = 0;
    40b6:	2300      	movs	r3, #0
		link = memq_peek(mft[callee_id][caller_id].head,
    40b8:	f04f 090c 	mov.w	r9, #12
		struct mayfly *m = 0;
    40bc:	9307      	str	r3, [sp, #28]
		link = memq_peek(mft[callee_id][caller_id].head,
    40be:	fb09 fa05 	mul.w	sl, r9, r5
    40c2:	2330      	movs	r3, #48	; 0x30
    40c4:	fb03 a304 	mla	r3, r3, r4, sl
    40c8:	18f1      	adds	r1, r6, r3
    40ca:	58f0      	ldr	r0, [r6, r3]
    40cc:	6849      	ldr	r1, [r1, #4]
    40ce:	aa07      	add	r2, sp, #28
    40d0:	f00c fafd 	bl	106ce <memq_peek>
		memq_dequeue(mft[callee_id][caller_id].tail,
    40d4:	9b04      	ldr	r3, [sp, #16]
    40d6:	fb19 3905 	smlabb	r9, r9, r5, r3
    40da:	eb06 0309 	add.w	r3, r6, r9
		link = memq_peek(mft[callee_id][caller_id].head,
    40de:	4607      	mov	r7, r0
		memq_dequeue(mft[callee_id][caller_id].tail,
    40e0:	9302      	str	r3, [sp, #8]
		while (link) {
    40e2:	2f00      	cmp	r7, #0
    40e4:	d043      	beq.n	416e <mayfly_run+0x112>
			state = (m->_req - m->_ack) & 0x03;
    40e6:	9b07      	ldr	r3, [sp, #28]
    40e8:	f893 9000 	ldrb.w	r9, [r3]
    40ec:	785a      	ldrb	r2, [r3, #1]
    40ee:	eba9 0902 	sub.w	r9, r9, r2
    40f2:	f009 0903 	and.w	r9, r9, #3
			if (state == 1U) {
    40f6:	f1b9 0f01 	cmp.w	r9, #1
    40fa:	d104      	bne.n	4106 <mayfly_run+0xaa>
				m->_ack--;
    40fc:	3a01      	subs	r2, #1
    40fe:	705a      	strb	r2, [r3, #1]
				m->fp(m->param);
    4100:	e9d3 0202 	ldrd	r0, r2, [r3, #8]
    4104:	4790      	blx	r2
			dequeue(callee_id, caller_id, link, m);
    4106:	9b07      	ldr	r3, [sp, #28]
	if (((req - m->_ack) & 0x03) != 1U) {
    4108:	9305      	str	r3, [sp, #20]
	req = m->_req;
    410a:	781a      	ldrb	r2, [r3, #0]
    410c:	b2d1      	uxtb	r1, r2
    410e:	9101      	str	r1, [sp, #4]
	if (((req - m->_ack) & 0x03) != 1U) {
    4110:	7859      	ldrb	r1, [r3, #1]
    4112:	1a52      	subs	r2, r2, r1
    4114:	f002 0203 	and.w	r2, r2, #3
    4118:	2a01      	cmp	r2, #1
    411a:	d019      	beq.n	4150 <mayfly_run+0xf4>
		memq_dequeue(mft[callee_id][caller_id].tail,
    411c:	2030      	movs	r0, #48	; 0x30
    411e:	fb00 a004 	mla	r0, r0, r4, sl
    4122:	4430      	add	r0, r6
    4124:	9902      	ldr	r1, [sp, #8]
    4126:	6840      	ldr	r0, [r0, #4]
    4128:	2200      	movs	r2, #0
    412a:	f00c fad8 	bl	106de <memq_dequeue>
		m->_link = link;
    412e:	9b05      	ldr	r3, [sp, #20]
		m->_ack = req;
    4130:	9a01      	ldr	r2, [sp, #4]
		ack = m->_ack;
    4132:	7859      	ldrb	r1, [r3, #1]
		m->_ack = req;
    4134:	705a      	strb	r2, [r3, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
    4136:	781a      	ldrb	r2, [r3, #0]
		m->_link = link;
    4138:	605f      	str	r7, [r3, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
    413a:	1a52      	subs	r2, r2, r1
    413c:	f002 0203 	and.w	r2, r2, #3
    4140:	2a01      	cmp	r2, #1
    4142:	d105      	bne.n	4150 <mayfly_run+0xf4>
			m->_ack = ack;
    4144:	7059      	strb	r1, [r3, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
    4146:	9a03      	ldr	r2, [sp, #12]
    4148:	4619      	mov	r1, r3
    414a:	4638      	mov	r0, r7
    414c:	f00c fab8 	bl	106c0 <memq_enqueue>
			link = memq_peek(mft[callee_id][caller_id].head,
    4150:	2330      	movs	r3, #48	; 0x30
    4152:	fb03 a304 	mla	r3, r3, r4, sl
    4156:	18f1      	adds	r1, r6, r3
    4158:	58f0      	ldr	r0, [r6, r3]
    415a:	6849      	ldr	r1, [r1, #4]
    415c:	aa07      	add	r2, sp, #28
    415e:	f00c fab6 	bl	106ce <memq_peek>
			if (state == 1U) {
    4162:	f1b9 0f01 	cmp.w	r9, #1
			link = memq_peek(mft[callee_id][caller_id].head,
    4166:	4607      	mov	r7, r0
			if (state == 1U) {
    4168:	d1bb      	bne.n	40e2 <mayfly_run+0x86>
				if (caller_id || link) {
    416a:	b9bd      	cbnz	r5, 419c <mayfly_run+0x140>
    416c:	b9b0      	cbnz	r0, 419c <mayfly_run+0x140>
		if (mft[callee_id][caller_id].disable_req !=
    416e:	2230      	movs	r2, #48	; 0x30
    4170:	210c      	movs	r1, #12
    4172:	4362      	muls	r2, r4
    4174:	fb01 2205 	mla	r2, r1, r5, r2
    4178:	4432      	add	r2, r6
    417a:	7a93      	ldrb	r3, [r2, #10]
    417c:	7ad0      	ldrb	r0, [r2, #11]
    417e:	4298      	cmp	r0, r3
    4180:	d116      	bne.n	41b0 <mayfly_run+0x154>
		if (mft[callee_id][caller_id].enable_req !=
    4182:	2330      	movs	r3, #48	; 0x30
    4184:	4363      	muls	r3, r4
    4186:	fb01 3305 	mla	r3, r1, r5, r3
    418a:	4433      	add	r3, r6
    418c:	7a1a      	ldrb	r2, [r3, #8]
    418e:	7a59      	ldrb	r1, [r3, #9]
    4190:	4291      	cmp	r1, r2
			mft[callee_id][caller_id].enable_ack =
    4192:	bf1c      	itt	ne
    4194:	725a      	strbne	r2, [r3, #9]
			enable = 1U;
    4196:	f04f 0801 	movne.w	r8, #1
    419a:	e778      	b.n	408e <mayfly_run+0x32>
					mfp[callee_id] = 1U;
    419c:	4b06      	ldr	r3, [pc, #24]	; (41b8 <mayfly_run+0x15c>)
    419e:	2201      	movs	r2, #1
    41a0:	551a      	strb	r2, [r3, r4]
					mayfly_pend(callee_id, callee_id);
    41a2:	4621      	mov	r1, r4
    41a4:	4620      	mov	r0, r4
    41a6:	f008 f9e1 	bl	c56c <mayfly_pend>
}
    41aa:	b009      	add	sp, #36	; 0x24
    41ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mft[callee_id][caller_id].disable_ack =
    41b0:	72d3      	strb	r3, [r2, #11]
			disable = 1U;
    41b2:	f04f 0b01 	mov.w	fp, #1
    41b6:	e7e4      	b.n	4182 <mayfly_run+0x126>
    41b8:	20002905 	.word	0x20002905
    41bc:	20000ad8 	.word	0x20000ad8

000041c0 <ticker_job>:
 * @param param Pointer to ticker instance
 *
 * @internal
 */
void ticker_job(void *param)
{
    41c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t flag_compare_update;

	DEBUG_TICKER_JOB(1);

	/* Defer job, as worker is running */
	if (instance->worker_trigger) {
    41c4:	7fc3      	ldrb	r3, [r0, #31]
{
    41c6:	b08b      	sub	sp, #44	; 0x2c
    41c8:	4604      	mov	r4, r0
	if (instance->worker_trigger) {
    41ca:	2b00      	cmp	r3, #0
    41cc:	f040 83bf 	bne.w	494e <ticker_job+0x78e>
		DEBUG_TICKER_JOB(0);
		return;
	}

	/* Defer job, as job is already running */
	if (instance->job_guard) {
    41d0:	7f82      	ldrb	r2, [r0, #30]
    41d2:	b14a      	cbz	r2, 41e8 <ticker_job+0x28>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_JOB, 1,
    41d4:	6a45      	ldr	r5, [r0, #36]	; 0x24
    41d6:	4603      	mov	r3, r0
    41d8:	2201      	movs	r2, #1
    41da:	2104      	movs	r1, #4
	/* Permit worker to run */
	instance->job_guard = 0U;

	/* trigger worker if deferred */
	if (instance->worker_trigger) {
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    41dc:	2004      	movs	r0, #4
    41de:	46ac      	mov	ip, r5
				   instance);
	}

	DEBUG_TICKER_JOB(0);
}
    41e0:	b00b      	add	sp, #44	; 0x2c
    41e2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    41e6:	4760      	bx	ip
	ticks_previous = instance->ticks_current;
    41e8:	6943      	ldr	r3, [r0, #20]
    41ea:	9304      	str	r3, [sp, #16]
	instance->job_guard = 1U;
    41ec:	2101      	movs	r1, #1
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    41ee:	7a83      	ldrb	r3, [r0, #10]
	instance->job_guard = 1U;
    41f0:	7781      	strb	r1, [r0, #30]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
    41f2:	7ac0      	ldrb	r0, [r0, #11]
    41f4:	4298      	cmp	r0, r3
    41f6:	d057      	beq.n	42a8 <ticker_job+0xe8>
	uint8_t idx = *ticks_elapsed_index + 1;
    41f8:	440b      	add	r3, r1
    41fa:	b2db      	uxtb	r3, r3
		idx = 0U;
    41fc:	2b02      	cmp	r3, #2
    41fe:	bf08      	it	eq
    4200:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
    4202:	72a3      	strb	r3, [r4, #10]
		ticks_elapsed =
    4204:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		flag_elapsed = 1U;
    4208:	9101      	str	r1, [sp, #4]
		ticks_elapsed =
    420a:	68db      	ldr	r3, [r3, #12]
    420c:	9300      	str	r3, [sp, #0]
		instance->ticks_current += ticks_elapsed;
    420e:	9a00      	ldr	r2, [sp, #0]
    4210:	9b04      	ldr	r3, [sp, #16]
    4212:	4413      	add	r3, r2
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
    4214:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    4218:	6163      	str	r3, [r4, #20]
	ticker_id_old_head = instance->ticker_id_head;
    421a:	7f63      	ldrb	r3, [r4, #29]
    421c:	9303      	str	r3, [sp, #12]
	node = &instance->nodes[0];
    421e:	6823      	ldr	r3, [r4, #0]
    4220:	9302      	str	r3, [sp, #8]
	users = &instance->users[0];
    4222:	6863      	ldr	r3, [r4, #4]
    4224:	9308      	str	r3, [sp, #32]
	while (count_user--) {
    4226:	7a63      	ldrb	r3, [r4, #9]
    4228:	3b01      	subs	r3, #1
    422a:	fa5f fb83 	uxtb.w	fp, r3
	pending = 0U;
    422e:	2300      	movs	r3, #0
    4230:	9305      	str	r3, [sp, #20]
	insert_head = TICKER_NULL;
    4232:	f04f 09ff 	mov.w	r9, #255	; 0xff
	while (count_user--) {
    4236:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
    423a:	d138      	bne.n	42ae <ticker_job+0xee>
	if (instance->ticker_id_head != ticker_id_old_head) {
    423c:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
    423e:	9a03      	ldr	r2, [sp, #12]
    4240:	1a9b      	subs	r3, r3, r2
    4242:	bf18      	it	ne
    4244:	2301      	movne	r3, #1
    4246:	9302      	str	r3, [sp, #8]
	if (flag_elapsed) {
    4248:	9b01      	ldr	r3, [sp, #4]
    424a:	2b00      	cmp	r3, #0
    424c:	f000 8225 	beq.w	469a <ticker_job+0x4da>
	ticks_now = cntr_cnt_get();
    4250:	f007 fd5e 	bl	bd10 <cntr_cnt_get>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
uint32_t ticker_ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4254:	9b04      	ldr	r3, [sp, #16]
	while (instance->ticker_id_head != TICKER_NULL) {
    4256:	9f00      	ldr	r7, [sp, #0]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4258:	eba0 0b03 	sub.w	fp, r0, r3
	node = &instance->nodes[0];
    425c:	6823      	ldr	r3, [r4, #0]
    425e:	9306      	str	r3, [sp, #24]
	ticks_expired = 0U;
    4260:	2300      	movs	r3, #0
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4262:	f02b 4b7f 	bic.w	fp, fp, #4278190080	; 0xff000000
	ticks_expired = 0U;
    4266:	9307      	str	r3, [sp, #28]
	while (instance->ticker_id_head != TICKER_NULL) {
    4268:	7f66      	ldrb	r6, [r4, #29]
    426a:	2eff      	cmp	r6, #255	; 0xff
    426c:	d00d      	beq.n	428a <ticker_job+0xca>
		ticker = &node[id_expired];
    426e:	b235      	sxth	r5, r6
    4270:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    4274:	012b      	lsls	r3, r5, #4
    4276:	9308      	str	r3, [sp, #32]
    4278:	9b06      	ldr	r3, [sp, #24]
    427a:	eb03 1505 	add.w	r5, r3, r5, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
    427e:	68ab      	ldr	r3, [r5, #8]
		if (ticks_elapsed < ticks_to_expire) {
    4280:	42bb      	cmp	r3, r7
    4282:	f240 80c8 	bls.w	4416 <ticker_job+0x256>
			ticker->ticks_to_expire -= ticks_elapsed;
    4286:	1bdb      	subs	r3, r3, r7
    4288:	60ab      	str	r3, [r5, #8]
			flag_compare_update = 1U;
    428a:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
    428e:	9903      	ldr	r1, [sp, #12]
		ticker_job_list_insert(instance, insert_head);
    4290:	4620      	mov	r0, r4
			flag_compare_update = 1U;
    4292:	42b1      	cmp	r1, r6
    4294:	bf18      	it	ne
    4296:	4613      	movne	r3, r2
		ticker_job_list_insert(instance, insert_head);
    4298:	4649      	mov	r1, r9
			flag_compare_update = 1U;
    429a:	9302      	str	r3, [sp, #8]
		ticker_job_list_insert(instance, insert_head);
    429c:	f00c fa94 	bl	107c8 <ticker_job_list_insert>
	nodes = &instance->nodes[0];
    42a0:	6825      	ldr	r5, [r4, #0]
	uint8_t  rescheduled = 0U;
    42a2:	2300      	movs	r3, #0
		ticker_id_head = instance->ticker_id_head;
    42a4:	7f67      	ldrb	r7, [r4, #29]
		while (ticker_id_head != TICKER_NULL) {
    42a6:	e16c      	b.n	4582 <ticker_job+0x3c2>
		flag_elapsed = 0U;
    42a8:	9201      	str	r2, [sp, #4]
		ticks_elapsed = 0U;
    42aa:	9200      	str	r2, [sp, #0]
    42ac:	e7b5      	b.n	421a <ticker_job+0x5a>
		user = &users[count_user];
    42ae:	9b08      	ldr	r3, [sp, #32]
    42b0:	eb03 08cb 	add.w	r8, r3, fp, lsl #3
		user_ops = &user->user_op[0];
    42b4:	f8d8 3004 	ldr.w	r3, [r8, #4]
    42b8:	9306      	str	r3, [sp, #24]
		while (user->middle != user->last) {
    42ba:	f898 1003 	ldrb.w	r1, [r8, #3]
			user_op = &user_ops[user->middle];
    42be:	2034      	movs	r0, #52	; 0x34
		while (user->middle != user->last) {
    42c0:	f898 7002 	ldrb.w	r7, [r8, #2]
    42c4:	428f      	cmp	r7, r1
    42c6:	f000 82dc 	beq.w	4882 <ticker_job+0x6c2>
			user_op = &user_ops[user->middle];
    42ca:	9b06      	ldr	r3, [sp, #24]
			if (middle == user->count_user_op) {
    42cc:	f898 5000 	ldrb.w	r5, [r8]
			user_op = &user_ops[user->middle];
    42d0:	fb17 f200 	smulbb	r2, r7, r0
    42d4:	189e      	adds	r6, r3, r2
			middle = user->middle + 1;
    42d6:	1c7b      	adds	r3, r7, #1
    42d8:	b2db      	uxtb	r3, r3
				middle = 0U;
    42da:	429d      	cmp	r5, r3
    42dc:	bf08      	it	eq
    42de:	2300      	moveq	r3, #0
			user->middle = middle;
    42e0:	f888 3002 	strb.w	r3, [r8, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
    42e4:	9b06      	ldr	r3, [sp, #24]
    42e6:	5c9a      	ldrb	r2, [r3, r2]
    42e8:	2a04      	cmp	r2, #4
    42ea:	d9e9      	bls.n	42c0 <ticker_job+0x100>
			ticker = &node[user_op->id];
    42ec:	7871      	ldrb	r1, [r6, #1]
    42ee:	eb01 0541 	add.w	r5, r1, r1, lsl #1
    42f2:	012b      	lsls	r3, r5, #4
    42f4:	9309      	str	r3, [sp, #36]	; 0x24
    42f6:	9b02      	ldr	r3, [sp, #8]
    42f8:	eb03 1505 	add.w	r5, r3, r5, lsl #4
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
    42fc:	2a08      	cmp	r2, #8
			state = (ticker->req - ticker->ack) & 0xff;
    42fe:	786b      	ldrb	r3, [r5, #1]
    4300:	78a8      	ldrb	r0, [r5, #2]
    4302:	eba3 0300 	sub.w	r3, r3, r0
    4306:	b2db      	uxtb	r3, r3
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
    4308:	d818      	bhi.n	433c <ticker_job+0x17c>
    430a:	b1bb      	cbz	r3, 433c <ticker_job+0x17c>
			    (state == 0U) ||
    430c:	2a05      	cmp	r2, #5
    430e:	f040 82ab 	bne.w	4868 <ticker_job+0x6a8>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
    4312:	6872      	ldr	r2, [r6, #4]
    4314:	2a00      	cmp	r2, #0
    4316:	f040 82b9 	bne.w	488c <ticker_job+0x6cc>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
    431a:	68b2      	ldr	r2, [r6, #8]
    431c:	2a00      	cmp	r2, #0
    431e:	f040 82b5 	bne.w	488c <ticker_job+0x6cc>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
    4322:	68f2      	ldr	r2, [r6, #12]
    4324:	2a00      	cmp	r2, #0
    4326:	f040 82b1 	bne.w	488c <ticker_job+0x6cc>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
    432a:	6932      	ldr	r2, [r6, #16]
    432c:	2a00      	cmp	r2, #0
    432e:	f040 82ad 	bne.w	488c <ticker_job+0x6cc>
			     (user_op->params.update.lazy == 0U) &&
    4332:	6972      	ldr	r2, [r6, #20]
    4334:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    4338:	f040 82a8 	bne.w	488c <ticker_job+0x6cc>
				ticker_job_op_cb(user_op,
    433c:	2101      	movs	r1, #1
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
    433e:	4630      	mov	r0, r6
    4340:	f00c fa38 	bl	107b4 <ticker_job_op_cb>
}
    4344:	e7b9      	b.n	42ba <ticker_job+0xfa>
	if ((ticker->remainder_current >= BIT(31)) ||
    4346:	6a69      	ldr	r1, [r5, #36]	; 0x24
    4348:	4f92      	ldr	r7, [pc, #584]	; (4594 <ticker_job+0x3d4>)
    434a:	f8df a24c 	ldr.w	sl, [pc, #588]	; 4598 <ticker_job+0x3d8>
    434e:	19cf      	adds	r7, r1, r7
    4350:	4557      	cmp	r7, sl
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
    4352:	bf81      	itttt	hi
    4354:	f101 71e8 	addhi.w	r1, r1, #30408704	; 0x1d00000
    4358:	f501 31d4 	addhi.w	r1, r1, #108544	; 0x1a800
    435c:	f501 71a5 	addhi.w	r1, r1, #330	; 0x14a
    4360:	6269      	strhi	r1, [r5, #36]	; 0x24
	ticker->remainder_current -= ticker->remainder_periodic;
    4362:	e9d5 1708 	ldrd	r1, r7, [r5, #32]
		decrement++;
    4366:	bf8c      	ite	hi
    4368:	f04f 0a01 	movhi.w	sl, #1
	uint8_t decrement = 0U;
    436c:	f04f 0a00 	movls.w	sl, #0
	ticker->remainder_current -= ticker->remainder_periodic;
    4370:	1a79      	subs	r1, r7, r1
			ticks_to_expire -= ticker->ticks_periodic +
    4372:	4482      	add	sl, r0
			ticker->lazy_current--;
    4374:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
	ticker->remainder_current -= ticker->remainder_periodic;
    4378:	6269      	str	r1, [r5, #36]	; 0x24
			ticks_to_expire -= ticker->ticks_periodic +
    437a:	eba3 030a 	sub.w	r3, r3, sl
			ticker->lazy_current--;
    437e:	f8a5 e01e 	strh.w	lr, [r5, #30]
    4382:	e2a9      	b.n	48d8 <ticker_job+0x718>
	ticker->remainder_current += ticker->remainder_periodic;
    4384:	e9d5 1708 	ldrd	r1, r7, [r5, #32]
    4388:	4439      	add	r1, r7
	if ((ticker->remainder_current < BIT(31)) &&
    438a:	4f82      	ldr	r7, [pc, #520]	; (4594 <ticker_job+0x3d4>)
    438c:	f8df a208 	ldr.w	sl, [pc, #520]	; 4598 <ticker_job+0x3d8>
    4390:	19cf      	adds	r7, r1, r7
    4392:	4557      	cmp	r7, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    4394:	bf9d      	ittte	ls
    4396:	f1a1 71e8 	subls.w	r1, r1, #30408704	; 0x1d00000
    439a:	f5a1 31d4 	subls.w	r1, r1, #108544	; 0x1a800
    439e:	f5a1 71a5 	subls.w	r1, r1, #330	; 0x14a
	ticker->remainder_current += ticker->remainder_periodic;
    43a2:	6269      	strhi	r1, [r5, #36]	; 0x24
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    43a4:	bf96      	itet	ls
    43a6:	6269      	strls	r1, [r5, #36]	; 0x24
	return 0;
    43a8:	2100      	movhi	r1, #0
		return 1;
    43aa:	2101      	movls	r1, #1
			ticks_to_expire += ticker->ticks_periodic +
    43ac:	4401      	add	r1, r0
			ticker->lazy_current++;
    43ae:	f10e 0e01 	add.w	lr, lr, #1
			ticks_to_expire += ticker->ticks_periodic +
    43b2:	440b      	add	r3, r1
			ticker->lazy_current++;
    43b4:	f8a5 e01e 	strh.w	lr, [r5, #30]
    43b8:	e295      	b.n	48e6 <ticker_job+0x726>
		if (user_op->op != TICKER_USER_OP_TYPE_YIELD_ABS) {
    43ba:	2a06      	cmp	r2, #6
    43bc:	d005      	beq.n	43ca <ticker_job+0x20a>
			ticker->ticks_to_expire = ticker_dequeue(instance,
    43be:	4620      	mov	r0, r4
    43c0:	f00c f9af 	bl	10722 <ticker_dequeue>
			ticker->req = ticker->ack;
    43c4:	78ab      	ldrb	r3, [r5, #2]
			ticker->ticks_to_expire = ticker_dequeue(instance,
    43c6:	60a8      	str	r0, [r5, #8]
			ticker->req = ticker->ack;
    43c8:	706b      	strb	r3, [r5, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
    43ca:	7f22      	ldrb	r2, [r4, #28]
    43cc:	7873      	ldrb	r3, [r6, #1]
    43ce:	429a      	cmp	r2, r3
    43d0:	f040 82bb 	bne.w	494a <ticker_job+0x78a>
			instance->ticker_id_slot_previous = TICKER_NULL;
    43d4:	23ff      	movs	r3, #255	; 0xff
    43d6:	7723      	strb	r3, [r4, #28]
			if ((user_op->op == TICKER_USER_OP_TYPE_YIELD_ABS) ||
    43d8:	7833      	ldrb	r3, [r6, #0]
    43da:	2b06      	cmp	r3, #6
    43dc:	d001      	beq.n	43e2 <ticker_job+0x222>
    43de:	2b08      	cmp	r3, #8
    43e0:	d10d      	bne.n	43fe <ticker_job+0x23e>
				ticks_at_yield =
    43e2:	6870      	ldr	r0, [r6, #4]
			ticks_current = instance->ticks_current;
    43e4:	6963      	ldr	r3, [r4, #20]
			if (!((ticks_at_yield - ticks_current) &
    43e6:	1ac2      	subs	r2, r0, r3
    43e8:	0211      	lsls	r1, r2, #8
    43ea:	d40b      	bmi.n	4404 <ticker_job+0x244>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    43ec:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
				ticks_used = ticks_elapsed +
    43f0:	9a00      	ldr	r2, [sp, #0]
    43f2:	4413      	add	r3, r2
			if (instance->ticks_slot_previous > ticks_used) {
    43f4:	69a2      	ldr	r2, [r4, #24]
    43f6:	429a      	cmp	r2, r3
				instance->ticks_slot_previous = ticks_used;
    43f8:	bf88      	it	hi
    43fa:	61a3      	strhi	r3, [r4, #24]
    43fc:	e2a5      	b.n	494a <ticker_job+0x78a>
				ticks_at_yield = cntr_cnt_get();
    43fe:	f007 fc87 	bl	bd10 <cntr_cnt_get>
    4402:	e7ef      	b.n	43e4 <ticker_job+0x224>
				if (ticks_elapsed > ticks_used) {
    4404:	9a00      	ldr	r2, [sp, #0]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4406:	1a1b      	subs	r3, r3, r0
    4408:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
				if (ticks_elapsed > ticks_used) {
    440c:	429a      	cmp	r2, r3
					ticks_used = ticks_elapsed -
    440e:	bf8c      	ite	hi
    4410:	1ad3      	subhi	r3, r2, r3
					ticks_used = 0;
    4412:	2300      	movls	r3, #0
    4414:	e7ee      	b.n	43f4 <ticker_job+0x234>
		ticks_expired += ticks_to_expire;
    4416:	9a07      	ldr	r2, [sp, #28]
		skip_collision = (ticker->lazy_current != 0U);
    4418:	f8b5 c01e 	ldrh.w	ip, [r5, #30]
		ticks_expired += ticks_to_expire;
    441c:	441a      	add	r2, r3
    441e:	9207      	str	r2, [sp, #28]
		if (instance->ticks_slot_previous > ticks_to_expire) {
    4420:	69a2      	ldr	r2, [r4, #24]
    4422:	4293      	cmp	r3, r2
		ticks_elapsed -= ticks_to_expire;
    4424:	eba7 0703 	sub.w	r7, r7, r3
		ticks_latency -= ticks_to_expire;
    4428:	ebab 0b03 	sub.w	fp, fp, r3
			instance->ticker_id_slot_previous = TICKER_NULL;
    442c:	bf25      	ittet	cs
    442e:	23ff      	movcs	r3, #255	; 0xff
    4430:	7723      	strbcs	r3, [r4, #28]
			instance->ticks_slot_previous -= ticks_to_expire;
    4432:	1ad3      	subcc	r3, r2, r3
			instance->ticks_slot_previous = 0U;
    4434:	2300      	movcs	r3, #0
    4436:	61a3      	str	r3, [r4, #24]
		state = (ticker->req - ticker->ack) & 0xff;
    4438:	78a9      	ldrb	r1, [r5, #2]
    443a:	786b      	ldrb	r3, [r5, #1]
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
    443c:	69a8      	ldr	r0, [r5, #24]
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
    443e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
		state = (ticker->req - ticker->ack) & 0xff;
    4440:	1a5b      	subs	r3, r3, r1
    4442:	b2db      	uxtb	r3, r3
		if (ticker->ticks_slot && (state == 2U) && !skip_collision &&
    4444:	b160      	cbz	r0, 4460 <ticker_job+0x2a0>
    4446:	2b02      	cmp	r3, #2
    4448:	d10a      	bne.n	4460 <ticker_job+0x2a0>
    444a:	f1bc 0f00 	cmp.w	ip, #0
    444e:	d107      	bne.n	4460 <ticker_job+0x2a0>
    4450:	b122      	cbz	r2, 445c <ticker_job+0x29c>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
    4452:	f892 e008 	ldrb.w	lr, [r2, #8]
    4456:	f1be 0f01 	cmp.w	lr, #1
    445a:	d001      	beq.n	4460 <ticker_job+0x2a0>
			instance->ticker_id_slot_previous = id_expired;
    445c:	7726      	strb	r6, [r4, #28]
			instance->ticks_slot_previous = ticker->ticks_slot;
    445e:	61a0      	str	r0, [r4, #24]
		ticker->ticks_to_expire = 0U;
    4460:	2000      	movs	r0, #0
    4462:	60a8      	str	r0, [r5, #8]
		instance->ticker_id_head = ticker->next;
    4464:	f8dd e020 	ldr.w	lr, [sp, #32]
    4468:	9806      	ldr	r0, [sp, #24]
    446a:	f810 000e 	ldrb.w	r0, [r0, lr]
    446e:	7760      	strb	r0, [r4, #29]
		if ((ticker->ticks_periodic != 0U) ||
    4470:	f8d5 e004 	ldr.w	lr, [r5, #4]
    4474:	f1be 0f00 	cmp.w	lr, #0
    4478:	d119      	bne.n	44ae <ticker_job+0x2ee>
    447a:	2a00      	cmp	r2, #0
    447c:	d064      	beq.n	4548 <ticker_job+0x388>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
    447e:	7a10      	ldrb	r0, [r2, #8]
    4480:	2801      	cmp	r0, #1
    4482:	d161      	bne.n	4548 <ticker_job+0x388>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
    4484:	7a13      	ldrb	r3, [r2, #8]
    4486:	2b01      	cmp	r3, #1
    4488:	d113      	bne.n	44b2 <ticker_job+0x2f2>
				ticker->ticks_to_expire = ticks_elapsed;
    448a:	60af      	str	r7, [r5, #8]
				ticker->req = ticker->ack;
    448c:	7069      	strb	r1, [r5, #1]
			ticks_to_expire_prep(ticker, instance->ticks_current,
    448e:	9b04      	ldr	r3, [sp, #16]
    4490:	9a07      	ldr	r2, [sp, #28]
    4492:	6961      	ldr	r1, [r4, #20]
    4494:	189a      	adds	r2, r3, r2
    4496:	4628      	mov	r0, r5
    4498:	f00c f96e 	bl	10778 <ticks_to_expire_prep>
			ticker->next = *insert_head;
    449c:	9b06      	ldr	r3, [sp, #24]
    449e:	9a08      	ldr	r2, [sp, #32]
    44a0:	f803 9002 	strb.w	r9, [r3, r2]
			ticker->req++;
    44a4:	786b      	ldrb	r3, [r5, #1]
    44a6:	3301      	adds	r3, #1
    44a8:	706b      	strb	r3, [r5, #1]
			ticker->req = ticker->ack;
    44aa:	46b1      	mov	r9, r6
    44ac:	e6dc      	b.n	4268 <ticker_job+0xa8>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
    44ae:	2a00      	cmp	r2, #0
    44b0:	d1e8      	bne.n	4484 <ticker_job+0x2c4>
				if (!ticker->lazy_current) {
    44b2:	f1bc 0f00 	cmp.w	ip, #0
    44b6:	d125      	bne.n	4504 <ticker_job+0x344>
					lazy_periodic = ticker->lazy_periodic;
    44b8:	8bab      	ldrh	r3, [r5, #28]
				while (count--) {
    44ba:	4698      	mov	r8, r3
				ticks_to_expire = 0U;
    44bc:	2000      	movs	r0, #0
	ticker->remainder_current += ticker->remainder_periodic;
    44be:	e9d5 1208 	ldrd	r1, r2, [r5, #32]
    44c2:	440a      	add	r2, r1
	if ((ticker->remainder_current < BIT(31)) &&
    44c4:	4933      	ldr	r1, [pc, #204]	; (4594 <ticker_job+0x3d4>)
    44c6:	f8df a0d0 	ldr.w	sl, [pc, #208]	; 4598 <ticker_job+0x3d8>
    44ca:	1851      	adds	r1, r2, r1
    44cc:	4551      	cmp	r1, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    44ce:	bf9f      	itttt	ls
    44d0:	f1a2 72e8 	subls.w	r2, r2, #30408704	; 0x1d00000
    44d4:	f5a2 32d4 	subls.w	r2, r2, #108544	; 0x1a800
    44d8:	f5a2 72a5 	subls.w	r2, r2, #330	; 0x14a
    44dc:	626a      	strls	r2, [r5, #36]	; 0x24
		return 1;
    44de:	bf92      	itee	ls
    44e0:	9a01      	ldrls	r2, [sp, #4]
	ticker->remainder_current += ticker->remainder_periodic;
    44e2:	626a      	strhi	r2, [r5, #36]	; 0x24
	return 0;
    44e4:	2200      	movhi	r2, #0
					ticks_to_expire +=
    44e6:	4472      	add	r2, lr
				while (count--) {
    44e8:	f1b8 0801 	subs.w	r8, r8, #1
					ticks_to_expire +=
    44ec:	4410      	add	r0, r2
				while (count--) {
    44ee:	d2e6      	bcs.n	44be <ticker_job+0x2fe>
				} else if (!ticker->must_expire) {
    44f0:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
    44f4:	b332      	cbz	r2, 4544 <ticker_job+0x384>
				lazy = 0U;
    44f6:	2200      	movs	r2, #0
				ticker->lazy_current += (lazy_periodic + lazy);
    44f8:	4413      	add	r3, r2
    44fa:	449c      	add	ip, r3
				ticker->ticks_to_expire = ticks_to_expire;
    44fc:	60a8      	str	r0, [r5, #8]
				ticker->lazy_current += (lazy_periodic + lazy);
    44fe:	f8a5 c01e 	strh.w	ip, [r5, #30]
    4502:	e7c4      	b.n	448e <ticker_job+0x2ce>
					ticker->req = ticker->ack;
    4504:	7069      	strb	r1, [r5, #1]
					lazy_periodic = 0U;
    4506:	2300      	movs	r3, #0
    4508:	e7d7      	b.n	44ba <ticker_job+0x2fa>
	ticker->remainder_current += ticker->remainder_periodic;
    450a:	e9d5 1208 	ldrd	r1, r2, [r5, #32]
    450e:	440a      	add	r2, r1
	if ((ticker->remainder_current < BIT(31)) &&
    4510:	4920      	ldr	r1, [pc, #128]	; (4594 <ticker_job+0x3d4>)
    4512:	f8df a084 	ldr.w	sl, [pc, #132]	; 4598 <ticker_job+0x3d8>
    4516:	1851      	adds	r1, r2, r1
    4518:	4551      	cmp	r1, sl
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
    451a:	bf9f      	itttt	ls
    451c:	f1a2 72e8 	subls.w	r2, r2, #30408704	; 0x1d00000
    4520:	f5a2 32d4 	subls.w	r2, r2, #108544	; 0x1a800
    4524:	f5a2 72a5 	subls.w	r2, r2, #330	; 0x14a
    4528:	626a      	strls	r2, [r5, #36]	; 0x24
		return 1;
    452a:	bf92      	itee	ls
    452c:	9a01      	ldrls	r2, [sp, #4]
	ticker->remainder_current += ticker->remainder_periodic;
    452e:	626a      	strhi	r2, [r5, #36]	; 0x24
	return 0;
    4530:	2200      	movhi	r2, #0
						ticks_to_expire +=
    4532:	4472      	add	r2, lr
    4534:	4410      	add	r0, r2
						lazy++;
    4536:	f108 0801 	add.w	r8, r8, #1
					while (ticks_to_expire <
    453a:	4583      	cmp	fp, r0
    453c:	fa1f f288 	uxth.w	r2, r8
    4540:	d8e3      	bhi.n	450a <ticker_job+0x34a>
    4542:	e7d9      	b.n	44f8 <ticker_job+0x338>
    4544:	4690      	mov	r8, r2
    4546:	e7f8      	b.n	453a <ticker_job+0x37a>
			if (state && ((state == 1U) || skip_collision) &&
    4548:	b14b      	cbz	r3, 455e <ticker_job+0x39e>
    454a:	2b01      	cmp	r3, #1
    454c:	d002      	beq.n	4554 <ticker_job+0x394>
    454e:	f1bc 0f00 	cmp.w	ip, #0
    4552:	d004      	beq.n	455e <ticker_job+0x39e>
			    ticker->fp_op_func) {
    4554:	6a2b      	ldr	r3, [r5, #32]
			if (state && ((state == 1U) || skip_collision) &&
    4556:	b113      	cbz	r3, 455e <ticker_job+0x39e>
				ticker->fp_op_func(TICKER_STATUS_FAILURE,
    4558:	6a69      	ldr	r1, [r5, #36]	; 0x24
    455a:	2001      	movs	r0, #1
    455c:	4798      	blx	r3
			ticker->req = ticker->ack;
    455e:	78ab      	ldrb	r3, [r5, #2]
    4560:	706b      	strb	r3, [r5, #1]
    4562:	464e      	mov	r6, r9
    4564:	e7a1      	b.n	44aa <ticker_job+0x2ea>
			ticker = &nodes[ticker_id_head];
    4566:	eb07 0247 	add.w	r2, r7, r7, lsl #1
    456a:	0111      	lsls	r1, r2, #4
    456c:	eb05 1202 	add.w	r2, r5, r2, lsl #4
			ext_data = ticker->ext_data;
    4570:	f815 e001 	ldrb.w	lr, [r5, r1]
    4574:	6a96      	ldr	r6, [r2, #40]	; 0x28
			if (ext_data && ext_data->reschedule_state ==
    4576:	b11e      	cbz	r6, 4580 <ticker_job+0x3c0>
    4578:	7a31      	ldrb	r1, [r6, #8]
    457a:	2901      	cmp	r1, #1
    457c:	f000 816e 	beq.w	485c <ticker_job+0x69c>
			ticker_id_head = ticker->next;
    4580:	4677      	mov	r7, lr
		while (ticker_id_head != TICKER_NULL) {
    4582:	2fff      	cmp	r7, #255	; 0xff
    4584:	d1ef      	bne.n	4566 <ticker_job+0x3a6>
			flag_compare_update = 1U;
    4586:	2b00      	cmp	r3, #0
    4588:	9a02      	ldr	r2, [sp, #8]
    458a:	bf18      	it	ne
    458c:	461a      	movne	r2, r3
    458e:	9202      	str	r2, [sp, #8]
    4590:	e087      	b.n	46a2 <ticker_job+0x4e2>
    4592:	bf00      	nop
    4594:	ff172b5a 	.word	0xff172b5a
    4598:	7f172b59 	.word	0x7f172b59
			instance->ticks_slot_previous > ticks_elapsed) {
    459c:	69a0      	ldr	r0, [r4, #24]
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
    459e:	9b00      	ldr	r3, [sp, #0]
    45a0:	4283      	cmp	r3, r0
    45a2:	f080 815f 	bcs.w	4864 <ticker_job+0x6a4>
			window_start_ticks = instance->ticks_slot_previous -
    45a6:	1ac3      	subs	r3, r0, r3
		window_start_ticks = 0U;
    45a8:	9301      	str	r3, [sp, #4]
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
    45aa:	e9d6 3a00 	ldrd	r3, sl, [r6]
    45ae:	459a      	cmp	sl, r3
    45b0:	d25b      	bcs.n	466a <ticker_job+0x4aa>
			ticks_slot_window = ext_data->ticks_slot_window -
    45b2:	f04f 0c00 	mov.w	ip, #0
    45b6:	eba3 0b0a 	sub.w	fp, r3, sl
		ticker_id_iter = nodes[ticker_id_head].next;
    45ba:	4671      	mov	r1, lr
			ticks_slot_window = ext_data->ticks_slot_window -
    45bc:	4663      	mov	r3, ip
		while (ticker_id_iter != TICKER_NULL &&
    45be:	29ff      	cmp	r1, #255	; 0xff
    45c0:	d006      	beq.n	45d0 <ticker_job+0x410>
		       ticks_start_offset + ticker->ticks_slot <=
    45c2:	f8d2 8018 	ldr.w	r8, [r2, #24]
    45c6:	eb0c 0008 	add.w	r0, ip, r8
		while (ticker_id_iter != TICKER_NULL &&
    45ca:	4583      	cmp	fp, r0
		       ticks_start_offset + ticker->ticks_slot <=
    45cc:	9006      	str	r0, [sp, #24]
		while (ticker_id_iter != TICKER_NULL &&
    45ce:	d21c      	bcs.n	460a <ticker_job+0x44a>
		ticker->ext_data->ticks_drift += ticks_to_expire -
    45d0:	6891      	ldr	r1, [r2, #8]
    45d2:	ebaa 0101 	sub.w	r1, sl, r1
    45d6:	4419      	add	r1, r3
    45d8:	6071      	str	r1, [r6, #4]
		ticker->ticks_to_expire = ticks_to_expire;
    45da:	6093      	str	r3, [r2, #8]
		ticker_id_iter = nodes[ticker_id_head].next;
    45dc:	4671      	mov	r1, lr
		ticker_id_prev = TICKER_NULL;
    45de:	23ff      	movs	r3, #255	; 0xff
		while (ticker_id_iter != TICKER_NULL) {
    45e0:	29ff      	cmp	r1, #255	; 0xff
    45e2:	d047      	beq.n	4674 <ticker_job+0x4b4>
			node = &nodes[ticker_id_iter];
    45e4:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    45e8:	ea4f 1900 	mov.w	r9, r0, lsl #4
    45ec:	eb05 1000 	add.w	r0, r5, r0, lsl #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
    45f0:	f8d2 8008 	ldr.w	r8, [r2, #8]
    45f4:	f8d0 c008 	ldr.w	ip, [r0, #8]
    45f8:	45e0      	cmp	r8, ip
    45fa:	d938      	bls.n	466e <ticker_job+0x4ae>
				ticker->ticks_to_expire -=
    45fc:	eba8 030c 	sub.w	r3, r8, ip
    4600:	6093      	str	r3, [r2, #8]
			ticker_id_iter = node->next;
    4602:	460b      	mov	r3, r1
    4604:	f815 1009 	ldrb.w	r1, [r5, r9]
    4608:	e7ea      	b.n	45e0 <ticker_job+0x420>
			node = &nodes[ticker_id_iter];
    460a:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    460e:	0108      	lsls	r0, r1, #4
    4610:	eb05 1101 	add.w	r1, r5, r1, lsl #4
    4614:	9004      	str	r0, [sp, #16]
			if (node->ext_data &&
    4616:	f8d1 9028 	ldr.w	r9, [r1, #40]	; 0x28
    461a:	f1b9 0f00 	cmp.w	r9, #0
    461e:	d007      	beq.n	4630 <ticker_job+0x470>
    4620:	f899 9008 	ldrb.w	r9, [r9, #8]
    4624:	f1b9 0f01 	cmp.w	r9, #1
    4628:	d102      	bne.n	4630 <ticker_job+0x470>
				ticker_id_iter = node->next;
    462a:	4601      	mov	r1, r0
			ticker_id_iter = node->next;
    462c:	5c69      	ldrb	r1, [r5, r1]
    462e:	e7c6      	b.n	45be <ticker_job+0x3fe>
			if (node->ticks_to_expire >
    4630:	f8d1 9008 	ldr.w	r9, [r1, #8]
    4634:	f1b9 0f04 	cmp.w	r9, #4
    4638:	d90e      	bls.n	4658 <ticker_job+0x498>
					MIN(ticks_slot_window,
    463a:	f1ac 0304 	sub.w	r3, ip, #4
    463e:	444b      	add	r3, r9
				window_end_ticks =
    4640:	455b      	cmp	r3, fp
			if (window_end_ticks > ticks_start_offset +
    4642:	9806      	ldr	r0, [sp, #24]
				window_end_ticks =
    4644:	bf28      	it	cs
    4646:	465b      	movcs	r3, fp
			if (window_end_ticks > ticks_start_offset +
    4648:	4283      	cmp	r3, r0
    464a:	d905      	bls.n	4658 <ticker_job+0x498>
			if (ticks_to_expire != 0U &&
    464c:	ebb3 0308 	subs.w	r3, r3, r8
    4650:	d002      	beq.n	4658 <ticker_job+0x498>
    4652:	9801      	ldr	r0, [sp, #4]
    4654:	4283      	cmp	r3, r0
    4656:	d2bb      	bcs.n	45d0 <ticker_job+0x410>
			window_start_ticks  = node->ticks_to_expire +
    4658:	6988      	ldr	r0, [r1, #24]
			ticker_id_iter = node->next;
    465a:	9904      	ldr	r1, [sp, #16]
			window_start_ticks  = node->ticks_to_expire +
    465c:	eb00 0309 	add.w	r3, r0, r9
    4660:	9301      	str	r3, [sp, #4]
			ticks_start_offset += node->ticks_to_expire;
    4662:	44cc      	add	ip, r9
			ticks_to_expire     = ticks_slot_window -
    4664:	ebab 0308 	sub.w	r3, fp, r8
			ticker_id_iter = node->next;
    4668:	e7e0      	b.n	462c <ticker_job+0x46c>
    466a:	2300      	movs	r3, #0
    466c:	e7b0      	b.n	45d0 <ticker_job+0x410>
				node->ticks_to_expire -=
    466e:	ebac 0108 	sub.w	r1, ip, r8
    4672:	6081      	str	r1, [r0, #8]
		if (ticker_id_prev != TICKER_NULL) {
    4674:	2bff      	cmp	r3, #255	; 0xff
    4676:	d008      	beq.n	468a <ticker_job+0x4ca>
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
    4678:	b21b      	sxth	r3, r3
    467a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    467e:	011b      	lsls	r3, r3, #4
			instance->ticker_id_head = nodes[ticker_id_head].next;
    4680:	f884 e01d 	strb.w	lr, [r4, #29]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
    4684:	5ce9      	ldrb	r1, [r5, r3]
    4686:	7011      	strb	r1, [r2, #0]
			nodes[ticker_id_prev].next = ticker_id_head;
    4688:	54ef      	strb	r7, [r5, r3]
		ticker->lazy_current--;
    468a:	8bd3      	ldrh	r3, [r2, #30]
    468c:	3b01      	subs	r3, #1
    468e:	83d3      	strh	r3, [r2, #30]
		ext_data->reschedule_state =
    4690:	f04f 0302 	mov.w	r3, #2
    4694:	7233      	strb	r3, [r6, #8]
		rescheduled  = 1U;
    4696:	2301      	movs	r3, #1
    4698:	e604      	b.n	42a4 <ticker_job+0xe4>
		ticker_job_list_insert(instance, insert_head);
    469a:	4649      	mov	r1, r9
    469c:	4620      	mov	r0, r4
    469e:	f00c f893 	bl	107c8 <ticker_job_list_insert>
	if (instance->ticker_id_head != ticker_id_old_head) {
    46a2:	7f63      	ldrb	r3, [r4, #29]
    46a4:	9a03      	ldr	r2, [sp, #12]
    46a6:	4293      	cmp	r3, r2
	if (!pending) {
    46a8:	9b05      	ldr	r3, [sp, #20]
	if (instance->ticker_id_head != ticker_id_old_head) {
    46aa:	f040 80d1 	bne.w	4850 <ticker_job+0x690>
	if (!pending) {
    46ae:	b93b      	cbnz	r3, 46c0 <ticker_job+0x500>
	users = &instance->users[0];
    46b0:	7a65      	ldrb	r5, [r4, #9]
    46b2:	6863      	ldr	r3, [r4, #4]
    46b4:	9300      	str	r3, [sp, #0]
	while (count_user--) {
    46b6:	3d01      	subs	r5, #1
    46b8:	b2ed      	uxtb	r5, r5
		uop->status = TICKER_STATUS_SUCCESS;
    46ba:	2700      	movs	r7, #0
	while (count_user--) {
    46bc:	2dff      	cmp	r5, #255	; 0xff
    46be:	d116      	bne.n	46ee <ticker_job+0x52e>
	if (flag_compare_update) {
    46c0:	9b02      	ldr	r3, [sp, #8]
    46c2:	b14b      	cbz	r3, 46d8 <ticker_job+0x518>
	if (instance->ticker_id_head == TICKER_NULL) {
    46c4:	7f63      	ldrb	r3, [r4, #29]
    46c6:	2bff      	cmp	r3, #255	; 0xff
    46c8:	d179      	bne.n	47be <ticker_job+0x5fe>
		if (cntr_stop() == 0) {
    46ca:	f007 fafb 	bl	bcc4 <cntr_stop>
    46ce:	b918      	cbnz	r0, 46d8 <ticker_job+0x518>
			instance->ticks_slot_previous = 0U;
    46d0:	61a0      	str	r0, [r4, #24]
			instance->ticks_current = cntr_cnt_get();
    46d2:	f007 fb1d 	bl	bd10 <cntr_cnt_get>
    46d6:	6160      	str	r0, [r4, #20]
	instance->job_guard = 0U;
    46d8:	2300      	movs	r3, #0
    46da:	77a3      	strb	r3, [r4, #30]
	if (instance->worker_trigger) {
    46dc:	7fe3      	ldrb	r3, [r4, #31]
    46de:	2b00      	cmp	r3, #0
    46e0:	f000 8135 	beq.w	494e <ticker_job+0x78e>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
    46e4:	6a65      	ldr	r5, [r4, #36]	; 0x24
    46e6:	4623      	mov	r3, r4
    46e8:	2201      	movs	r2, #1
    46ea:	2103      	movs	r1, #3
    46ec:	e576      	b.n	41dc <ticker_job+0x1c>
		user = &users[count_user];
    46ee:	9b00      	ldr	r3, [sp, #0]
    46f0:	eb03 06c5 	add.w	r6, r3, r5, lsl #3
		user_op = &user->user_op[0];
    46f4:	f8d6 8004 	ldr.w	r8, [r6, #4]
		while (user->first != user->last) {
    46f8:	7873      	ldrb	r3, [r6, #1]
    46fa:	78f2      	ldrb	r2, [r6, #3]
    46fc:	429a      	cmp	r2, r3
    46fe:	d102      	bne.n	4706 <ticker_job+0x546>
    4700:	3d01      	subs	r5, #1
    4702:	b2ed      	uxtb	r5, r5
    4704:	e7da      	b.n	46bc <ticker_job+0x4fc>
			ticker_job_op_inquire(instance, &user_op[user->first]);
    4706:	2234      	movs	r2, #52	; 0x34
    4708:	fb13 f202 	smulbb	r2, r3, r2
    470c:	eb08 0302 	add.w	r3, r8, r2
	switch (uop->op) {
    4710:	f818 2002 	ldrb.w	r2, [r8, r2]
    4714:	2a02      	cmp	r2, #2
    4716:	d012      	beq.n	473e <ticker_job+0x57e>
    4718:	2a03      	cmp	r2, #3
    471a:	d040      	beq.n	479e <ticker_job+0x5de>
    471c:	2a01      	cmp	r2, #1
    471e:	d105      	bne.n	472c <ticker_job+0x56c>
			uop->status = TICKER_STATUS_SUCCESS;
    4720:	629f      	str	r7, [r3, #40]	; 0x28
		fp_op_func = uop->fp_op_func;
    4722:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	if (fp_op_func) {
    4724:	b112      	cbz	r2, 472c <ticker_job+0x56c>
		fp_op_func(uop->status, uop->op_context);
    4726:	6b19      	ldr	r1, [r3, #48]	; 0x30
    4728:	6a98      	ldr	r0, [r3, #40]	; 0x28
    472a:	4790      	blx	r2
			first = user->first + 1;
    472c:	7873      	ldrb	r3, [r6, #1]
			if (first == user->count_user_op) {
    472e:	7832      	ldrb	r2, [r6, #0]
			first = user->first + 1;
    4730:	3301      	adds	r3, #1
    4732:	b2db      	uxtb	r3, r3
				first = 0U;
    4734:	429a      	cmp	r2, r3
    4736:	bf08      	it	eq
    4738:	2300      	moveq	r3, #0
			user->first = first;
    473a:	7073      	strb	r3, [r6, #1]
    473c:	e7dc      	b.n	46f8 <ticker_job+0x538>
		ticker_by_next_slot_get(instance,
    473e:	e9d3 9001 	ldrd	r9, r0, [r3, #4]
	_ticker_id_head = *ticker_id_head;
    4742:	f899 2000 	ldrb.w	r2, [r9]
		ticker_by_next_slot_get(instance,
    4746:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	node = instance->nodes;
    474a:	f8d4 c000 	ldr.w	ip, [r4]
	    (*ticks_current != instance->ticks_current)) {
    474e:	6961      	ldr	r1, [r4, #20]
	if ((_ticker_id_head == TICKER_NULL) ||
    4750:	2aff      	cmp	r2, #255	; 0xff
    4752:	d003      	beq.n	475c <ticker_job+0x59c>
    4754:	f8d0 a000 	ldr.w	sl, [r0]
    4758:	458a      	cmp	sl, r1
    475a:	d009      	beq.n	4770 <ticker_job+0x5b0>
		_ticker_id_head = instance->ticker_id_head;
    475c:	7f62      	ldrb	r2, [r4, #29]
		*ticks_current = instance->ticks_current;
    475e:	6001      	str	r1, [r0, #0]
		_ticks_to_expire = 0U;
    4760:	2000      	movs	r0, #0
	while (_ticker_id_head != TICKER_NULL) {
    4762:	2aff      	cmp	r2, #255	; 0xff
    4764:	d10c      	bne.n	4780 <ticker_job+0x5c0>
	*ticker_id_head = _ticker_id_head;
    4766:	f889 2000 	strb.w	r2, [r9]
	*ticks_to_expire = _ticks_to_expire;
    476a:	f8ce 0000 	str.w	r0, [lr]
}
    476e:	e7d7      	b.n	4720 <ticker_job+0x560>
		ticker = &node[_ticker_id_head];
    4770:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    4774:	0112      	lsls	r2, r2, #4
	_ticks_to_expire = *ticks_to_expire;
    4776:	f8de 0000 	ldr.w	r0, [lr]
		_ticker_id_head = ticker->next;
    477a:	f81c 2002 	ldrb.w	r2, [ip, r2]
    477e:	e7f0      	b.n	4762 <ticker_job+0x5a2>
		ticker = &node[_ticker_id_head];
    4780:	eb02 0142 	add.w	r1, r2, r2, lsl #1
    4784:	ea4f 1b01 	mov.w	fp, r1, lsl #4
    4788:	eb0c 1101 	add.w	r1, ip, r1, lsl #4
		_ticks_to_expire += ticker->ticks_to_expire;
    478c:	f8d1 a008 	ldr.w	sl, [r1, #8]
			if (ticker->ticks_slot) {
    4790:	6989      	ldr	r1, [r1, #24]
		_ticks_to_expire += ticker->ticks_to_expire;
    4792:	4450      	add	r0, sl
			if (ticker->ticks_slot) {
    4794:	2900      	cmp	r1, #0
    4796:	d1e6      	bne.n	4766 <ticker_job+0x5a6>
		_ticker_id_head = ticker->next;
    4798:	f81c 200b 	ldrb.w	r2, [ip, fp]
    479c:	e7e1      	b.n	4762 <ticker_job+0x5a2>
		if (uop->id < instance->count_node) {
    479e:	785a      	ldrb	r2, [r3, #1]
    47a0:	7a21      	ldrb	r1, [r4, #8]
    47a2:	4291      	cmp	r1, r2
    47a4:	d908      	bls.n	47b8 <ticker_job+0x5f8>
			node[uop->id].priority =
    47a6:	6821      	ldr	r1, [r4, #0]
    47a8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    47ac:	eb01 1202 	add.w	r2, r1, r2, lsl #4
    47b0:	7919      	ldrb	r1, [r3, #4]
    47b2:	f882 102d 	strb.w	r1, [r2, #45]	; 0x2d
    47b6:	e7b3      	b.n	4720 <ticker_job+0x560>
			uop->status = TICKER_STATUS_FAILURE;
    47b8:	2201      	movs	r2, #1
    47ba:	629a      	str	r2, [r3, #40]	; 0x28
    47bc:	e7b1      	b.n	4722 <ticker_job+0x562>
	if (ticker_id_old_head == TICKER_NULL) {
    47be:	9b03      	ldr	r3, [sp, #12]
    47c0:	2bff      	cmp	r3, #255	; 0xff
    47c2:	d106      	bne.n	47d2 <ticker_job+0x612>
		ticks_current = cntr_cnt_get();
    47c4:	f007 faa4 	bl	bd10 <cntr_cnt_get>
    47c8:	4605      	mov	r5, r0
		if (cntr_start() == 0) {
    47ca:	f007 fa6d 	bl	bca8 <cntr_start>
    47ce:	b900      	cbnz	r0, 47d2 <ticker_job+0x612>
			instance->ticks_current = ticks_current;
    47d0:	6165      	str	r5, [r4, #20]
	ticker = &instance->nodes[instance->ticker_id_head];
    47d2:	7f63      	ldrb	r3, [r4, #29]
	ticks_to_expire = ticker->ticks_to_expire;
    47d4:	6822      	ldr	r2, [r4, #0]
		LL_ASSERT(i);
    47d6:	f8df 817c 	ldr.w	r8, [pc, #380]	; 4954 <ticker_job+0x794>
    47da:	f8df 917c 	ldr.w	r9, [pc, #380]	; 4958 <ticker_job+0x798>
    47de:	f8df a17c 	ldr.w	sl, [pc, #380]	; 495c <ticker_job+0x79c>
	ticker = &instance->nodes[instance->ticker_id_head];
    47e2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	ticks_to_expire = ticker->ticks_to_expire;
    47e6:	eb02 1303 	add.w	r3, r2, r3, lsl #4
	i = 10U;
    47ea:	260a      	movs	r6, #10
	ticks_to_expire = ticker->ticks_to_expire;
    47ec:	689f      	ldr	r7, [r3, #8]
		ctr = cntr_cnt_get();
    47ee:	f007 fa8f 	bl	bd10 <cntr_cnt_get>
		cc = instance->ticks_current;
    47f2:	6965      	ldr	r5, [r4, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    47f4:	1b43      	subs	r3, r0, r5
    47f6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
    47fa:	3303      	adds	r3, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
    47fc:	42bb      	cmp	r3, r7
    47fe:	bf2c      	ite	cs
    4800:	18ed      	addcs	r5, r5, r3
    4802:	19ed      	addcc	r5, r5, r7
		cc &= HAL_TICKER_CNTR_MASK;
    4804:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		instance->trigger_set_cb(cc);
    4808:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		ctr = cntr_cnt_get();
    480a:	4683      	mov	fp, r0
		instance->trigger_set_cb(cc);
    480c:	4628      	mov	r0, r5
    480e:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
    4810:	f007 fa7e 	bl	bd10 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4814:	eba0 030b 	sub.w	r3, r0, fp
    4818:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    481c:	eba5 050b 	sub.w	r5, r5, fp
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
    4820:	3303      	adds	r3, #3
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    4822:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		  ticker_ticks_diff_get(cc, ctr));
    4826:	42ab      	cmp	r3, r5
		i--;
    4828:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
		  ticker_ticks_diff_get(cc, ctr));
    482c:	f67f af54 	bls.w	46d8 <ticker_job+0x518>
		LL_ASSERT(i);
    4830:	2e00      	cmp	r6, #0
    4832:	d1dc      	bne.n	47ee <ticker_job+0x62e>
    4834:	f640 133e 	movw	r3, #2366	; 0x93e
    4838:	4642      	mov	r2, r8
    483a:	4649      	mov	r1, r9
    483c:	4650      	mov	r0, sl
    483e:	f00a fe42 	bl	f4c6 <printk>
    4842:	4040      	eors	r0, r0
    4844:	f380 8811 	msr	BASEPRI, r0
    4848:	f04f 0003 	mov.w	r0, #3
    484c:	df02      	svc	2
    484e:	e7ce      	b.n	47ee <ticker_job+0x62e>
	if (!pending) {
    4850:	2b00      	cmp	r3, #0
    4852:	f47f af37 	bne.w	46c4 <ticker_job+0x504>
		flag_compare_update = 1U;
    4856:	2301      	movs	r3, #1
    4858:	9302      	str	r3, [sp, #8]
    485a:	e729      	b.n	46b0 <ticker_job+0x4f0>
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
    485c:	7f23      	ldrb	r3, [r4, #28]
    485e:	2bff      	cmp	r3, #255	; 0xff
    4860:	f47f ae9c 	bne.w	459c <ticker_job+0x3dc>
		window_start_ticks = 0U;
    4864:	2300      	movs	r3, #0
    4866:	e69f      	b.n	45a8 <ticker_job+0x3e8>
			if (state == 1U) {
    4868:	2b01      	cmp	r3, #1
    486a:	f43f ada6 	beq.w	43ba <ticker_job+0x1fa>
				instance->sched_cb(TICKER_CALL_ID_JOB,
    486e:	2104      	movs	r1, #4
    4870:	4623      	mov	r3, r4
    4872:	6a65      	ldr	r5, [r4, #36]	; 0x24
    4874:	2201      	movs	r2, #1
    4876:	4608      	mov	r0, r1
    4878:	47a8      	blx	r5
				pending = 1U;
    487a:	2301      	movs	r3, #1
				user->middle = prev;
    487c:	f888 7002 	strb.w	r7, [r8, #2]
				pending = 1U;
    4880:	9305      	str	r3, [sp, #20]
    4882:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    4886:	fa5f fb83 	uxtb.w	fp, r3
    488a:	e4d4      	b.n	4236 <ticker_job+0x76>
			if (state == 1U) {
    488c:	2b01      	cmp	r3, #1
    488e:	d1ee      	bne.n	486e <ticker_job+0x6ae>
		ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
    4890:	4620      	mov	r0, r4
    4892:	f00b ff46 	bl	10722 <ticker_dequeue>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
    4896:	6963      	ldr	r3, [r4, #20]
		ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
    4898:	60a8      	str	r0, [r5, #8]
    489a:	4607      	mov	r7, r0
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
    489c:	9307      	str	r3, [sp, #28]
	ticks_now = cntr_cnt_get();
    489e:	f007 fa37 	bl	bd10 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    48a2:	9b07      	ldr	r3, [sp, #28]
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
    48a4:	9900      	ldr	r1, [sp, #0]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
    48a6:	1ac3      	subs	r3, r0, r3
    48a8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
    48ac:	440b      	add	r3, r1
	if (ticks_to_expire > ticks_elapsed) {
    48ae:	429f      	cmp	r7, r3
		ticker->ticks_to_expire_minus += ticks_elapsed -
    48b0:	bf98      	it	ls
    48b2:	6969      	ldrls	r1, [r5, #20]
	ticks_now = cntr_cnt_get();
    48b4:	4602      	mov	r2, r0
		ticker->ticks_to_expire_minus += ticks_elapsed -
    48b6:	bf98      	it	ls
    48b8:	1bc9      	subls	r1, r1, r7
	if ((ticker->ticks_periodic != 0U) &&
    48ba:	6868      	ldr	r0, [r5, #4]
		ticker->ticks_to_expire_minus += ticks_elapsed -
    48bc:	bf9b      	ittet	ls
    48be:	185b      	addls	r3, r3, r1
    48c0:	616b      	strls	r3, [r5, #20]
		ticks_to_expire -= ticks_elapsed;
    48c2:	1afb      	subhi	r3, r7, r3
		ticks_to_expire = 0U;
    48c4:	2300      	movls	r3, #0
	if ((ticker->ticks_periodic != 0U) &&
    48c6:	b1a8      	cbz	r0, 48f4 <ticker_job+0x734>
	    (user_op->params.update.lazy != 0U)) {
    48c8:	8ab1      	ldrh	r1, [r6, #20]
	if ((ticker->ticks_periodic != 0U) &&
    48ca:	b199      	cbz	r1, 48f4 <ticker_job+0x734>
		user_op->params.update.lazy--;
    48cc:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
    48d0:	fa1f fc8c 	uxth.w	ip, ip
    48d4:	f8a6 c014 	strh.w	ip, [r6, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
    48d8:	4298      	cmp	r0, r3
		       (ticker->lazy_current > user_op->params.update.lazy)) {
    48da:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
    48de:	d202      	bcs.n	48e6 <ticker_job+0x726>
    48e0:	45f4      	cmp	ip, lr
    48e2:	f4ff ad30 	bcc.w	4346 <ticker_job+0x186>
		while (ticker->lazy_current < user_op->params.update.lazy) {
    48e6:	f8b5 e01e 	ldrh.w	lr, [r5, #30]
    48ea:	45f4      	cmp	ip, lr
    48ec:	f63f ad4a 	bhi.w	4384 <ticker_job+0x1c4>
		ticker->lazy_periodic = user_op->params.update.lazy;
    48f0:	f8a5 c01c 	strh.w	ip, [r5, #28]
				  user_op->params.update.ticks_drift_plus;
    48f4:	6871      	ldr	r1, [r6, #4]
				user_op->params.update.ticks_drift_minus;
    48f6:	68b0      	ldr	r0, [r6, #8]
	struct ticker_ext *ext_data = ticker->ext_data;
    48f8:	6aaf      	ldr	r7, [r5, #40]	; 0x28
	ticker->ticks_to_expire = ticks_to_expire +
    48fa:	440b      	add	r3, r1
    48fc:	60ab      	str	r3, [r5, #8]
	ticker->ticks_to_expire_minus +=
    48fe:	696b      	ldr	r3, [r5, #20]
    4900:	4403      	add	r3, r0
    4902:	616b      	str	r3, [r5, #20]
	if (ext_data && ext_data->ticks_slot_window != 0U) {
    4904:	b11f      	cbz	r7, 490e <ticker_job+0x74e>
    4906:	683b      	ldr	r3, [r7, #0]
    4908:	b10b      	cbz	r3, 490e <ticker_job+0x74e>
			user_op->params.update.ticks_drift_plus -
    490a:	1a09      	subs	r1, r1, r0
		ext_data->ticks_drift =
    490c:	6079      	str	r1, [r7, #4]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
    490e:	9907      	ldr	r1, [sp, #28]
    4910:	4628      	mov	r0, r5
    4912:	f00b ff31 	bl	10778 <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
    4916:	68f2      	ldr	r2, [r6, #12]
    4918:	69ab      	ldr	r3, [r5, #24]
    491a:	4413      	add	r3, r2
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
    491c:	6932      	ldr	r2, [r6, #16]
    491e:	4293      	cmp	r3, r2
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
    4920:	bf8c      	ite	hi
    4922:	1a9b      	subhi	r3, r3, r2
		ticker->ticks_slot = 0U;
    4924:	2300      	movls	r3, #0
    4926:	61ab      	str	r3, [r5, #24]
	if (user_op->params.update.force != 0U) {
    4928:	7db3      	ldrb	r3, [r6, #22]
    492a:	b103      	cbz	r3, 492e <ticker_job+0x76e>
		ticker->force = user_op->params.update.force;
    492c:	70eb      	strb	r3, [r5, #3]
	if (user_op->params.update.must_expire) {
    492e:	7df3      	ldrb	r3, [r6, #23]
    4930:	b113      	cbz	r3, 4938 <ticker_job+0x778>
		ticker->must_expire = (user_op->params.update.must_expire - 1);
    4932:	3b01      	subs	r3, #1
    4934:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
	ticker->next = *insert_head;
    4938:	9b02      	ldr	r3, [sp, #8]
    493a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    493c:	f803 9002 	strb.w	r9, [r3, r2]
		ticker->req++;
    4940:	786b      	ldrb	r3, [r5, #1]
	*insert_head = user_op->id;
    4942:	f896 9001 	ldrb.w	r9, [r6, #1]
		ticker->req++;
    4946:	3301      	adds	r3, #1
    4948:	706b      	strb	r3, [r5, #1]
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
    494a:	2100      	movs	r1, #0
    494c:	e4f7      	b.n	433e <ticker_job+0x17e>
}
    494e:	b00b      	add	sp, #44	; 0x2c
    4950:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4954:	00013499 	.word	0x00013499
    4958:	00013520 	.word	0x00013520
    495c:	000133b6 	.word	0x000133b6

00004960 <ticker_init>:
{
    4960:	b5f0      	push	{r4, r5, r6, r7, lr}
    4962:	9f05      	ldr	r7, [sp, #20]
    4964:	f89d 5018 	ldrb.w	r5, [sp, #24]
    4968:	f8dd c01c 	ldr.w	ip, [sp, #28]
	if (instance_index >= TICKER_INSTANCE_MAX) {
    496c:	b108      	cbz	r0, 4972 <ticker_init+0x12>
		return TICKER_STATUS_FAILURE;
    496e:	2001      	movs	r0, #1
}
    4970:	bdf0      	pop	{r4, r5, r6, r7, pc}
	instance->count_node = count_node;
    4972:	4c18      	ldr	r4, [pc, #96]	; (49d4 <ticker_init+0x74>)
    4974:	7221      	strb	r1, [r4, #8]
	instance->nodes = node;
    4976:	6022      	str	r2, [r4, #0]
	while (count_node--) {
    4978:	3901      	subs	r1, #1
    497a:	b2c9      	uxtb	r1, r1
    497c:	29ff      	cmp	r1, #255	; 0xff
    497e:	d116      	bne.n	49ae <ticker_init+0x4e>
	instance->count_user = count_user;
    4980:	7263      	strb	r3, [r4, #9]
	instance->users = user;
    4982:	6067      	str	r7, [r4, #4]
		user_op_ += users[count_user].count_user_op;
    4984:	2234      	movs	r2, #52	; 0x34
	while (count_user--) {
    4986:	3b01      	subs	r3, #1
    4988:	b2db      	uxtb	r3, r3
    498a:	2bff      	cmp	r3, #255	; 0xff
    498c:	d116      	bne.n	49bc <ticker_init+0x5c>
	if (count_op) {
    498e:	2d00      	cmp	r5, #0
    4990:	d1ed      	bne.n	496e <ticker_init+0xe>
	instance->caller_id_get_cb = caller_id_get_cb;
    4992:	9b08      	ldr	r3, [sp, #32]
    4994:	6223      	str	r3, [r4, #32]
	instance->sched_cb = sched_cb;
    4996:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4998:	6263      	str	r3, [r4, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
    499a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    499c:	62a3      	str	r3, [r4, #40]	; 0x28
	instance->ticker_id_slot_previous = TICKER_NULL;
    499e:	f64f 73ff 	movw	r3, #65535	; 0xffff
	instance->ticks_slot_previous = 0U;
    49a2:	e9c4 5505 	strd	r5, r5, [r4, #20]
	instance->ticker_id_slot_previous = TICKER_NULL;
    49a6:	83a3      	strh	r3, [r4, #28]
	instance->ticks_elapsed_first = 0U;
    49a8:	8165      	strh	r5, [r4, #10]
	return TICKER_STATUS_SUCCESS;
    49aa:	4628      	mov	r0, r5
    49ac:	e7e0      	b.n	4970 <ticker_init+0x10>
		instance->nodes[count_node].priority = 0;
    49ae:	eb01 0641 	add.w	r6, r1, r1, lsl #1
    49b2:	eb02 1606 	add.w	r6, r2, r6, lsl #4
    49b6:	f886 002d 	strb.w	r0, [r6, #45]	; 0x2d
    49ba:	e7dd      	b.n	4978 <ticker_init+0x18>
		users[count_user].user_op = user_op_;
    49bc:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
    49c0:	f8c1 c004 	str.w	ip, [r1, #4]
		user_op_ += users[count_user].count_user_op;
    49c4:	f817 0033 	ldrb.w	r0, [r7, r3, lsl #3]
		count_op -= users[count_user].count_user_op;
    49c8:	1a2d      	subs	r5, r5, r0
		user_op_ += users[count_user].count_user_op;
    49ca:	fb00 cc02 	mla	ip, r0, r2, ip
		count_op -= users[count_user].count_user_op;
    49ce:	b2ed      	uxtb	r5, r5
    49d0:	e7d9      	b.n	4986 <ticker_init+0x26>
    49d2:	bf00      	nop
    49d4:	20000b98 	.word	0x20000b98

000049d8 <ticker_trigger>:
	if (instance->sched_cb) {
    49d8:	4b07      	ldr	r3, [pc, #28]	; (49f8 <ticker_trigger+0x20>)
    49da:	222c      	movs	r2, #44	; 0x2c
    49dc:	fb02 3100 	mla	r1, r2, r0, r3
{
    49e0:	b410      	push	{r4}
	if (instance->sched_cb) {
    49e2:	6a4c      	ldr	r4, [r1, #36]	; 0x24
    49e4:	b134      	cbz	r4, 49f4 <ticker_trigger+0x1c>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
    49e6:	460b      	mov	r3, r1
    49e8:	46a4      	mov	ip, r4
    49ea:	2201      	movs	r2, #1
}
    49ec:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
    49ee:	2103      	movs	r1, #3
    49f0:	2002      	movs	r0, #2
    49f2:	4760      	bx	ip
}
    49f4:	bc10      	pop	{r4}
    49f6:	4770      	bx	lr
    49f8:	20000b98 	.word	0x20000b98

000049fc <ticker_start_ext>:
{
    49fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4a00:	4606      	mov	r6, r0
    4a02:	4608      	mov	r0, r1
    4a04:	4611      	mov	r1, r2
    4a06:	461a      	mov	r2, r3
	struct ticker_instance *instance = &_instance[instance_index];
    4a08:	4b22      	ldr	r3, [pc, #136]	; (4a94 <ticker_start_ext+0x98>)
    4a0a:	242c      	movs	r4, #44	; 0x2c
    4a0c:	fb06 3904 	mla	r9, r6, r4, r3
	user = &instance->users[user_id];
    4a10:	f8d9 3004 	ldr.w	r3, [r9, #4]
    4a14:	eb03 0cc0 	add.w	ip, r3, r0, lsl #3
	if (last >= user->count_user_op) {
    4a18:	f813 3030 	ldrb.w	r3, [r3, r0, lsl #3]
	last = user->last + 1;
    4a1c:	f89c 7003 	ldrb.w	r7, [ip, #3]
    4a20:	1c7d      	adds	r5, r7, #1
    4a22:	b2ed      	uxtb	r5, r5
		last = 0U;
    4a24:	42ab      	cmp	r3, r5
    4a26:	bf98      	it	ls
    4a28:	2500      	movls	r5, #0
	if (last == user->first) {
    4a2a:	f89c 3001 	ldrb.w	r3, [ip, #1]
    4a2e:	42ab      	cmp	r3, r5
    4a30:	d02e      	beq.n	4a90 <ticker_start_ext+0x94>
	user_op = &user->user_op[user->last];
    4a32:	2334      	movs	r3, #52	; 0x34
    4a34:	fb17 f703 	smulbb	r7, r7, r3
    4a38:	f8dc 3004 	ldr.w	r3, [ip, #4]
	user_op->op = TICKER_USER_OP_TYPE_START;
    4a3c:	f04f 0804 	mov.w	r8, #4
	user_op = &user->user_op[user->last];
    4a40:	19dc      	adds	r4, r3, r7
	user_op->op = TICKER_USER_OP_TYPE_START;
    4a42:	f803 8007 	strb.w	r8, [r3, r7]
	user_op->params.start.ticks_first = ticks_first;
    4a46:	9b08      	ldr	r3, [sp, #32]
    4a48:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
    4a4a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4a4c:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
    4a4e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4a50:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
    4a52:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4a54:	61a3      	str	r3, [r4, #24]
	user_op->params.start.lazy = lazy;
    4a56:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
    4a5a:	82a3      	strh	r3, [r4, #20]
	user_op->params.start.ext_data = ext_data;
    4a5c:	9b11      	ldr	r3, [sp, #68]	; 0x44
    4a5e:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->params.start.fp_timeout_func = fp_timeout_func;
    4a60:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4a62:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
    4a64:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    4a66:	6223      	str	r3, [r4, #32]
	user_op->status = TICKER_STATUS_BUSY;
    4a68:	2302      	movs	r3, #2
    4a6a:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
    4a6c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    4a6e:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
    4a70:	9b10      	ldr	r3, [sp, #64]	; 0x40
	user_op->id = ticker_id;
    4a72:	7061      	strb	r1, [r4, #1]
	user_op->params.start.ticks_at_start = ticks_anchor;
    4a74:	6062      	str	r2, [r4, #4]
	user_op->op_context = op_context;
    4a76:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
    4a78:	f88c 5003 	strb.w	r5, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    4a7c:	e9d9 3508 	ldrd	r3, r5, [r9, #32]
    4a80:	4798      	blx	r3
    4a82:	464b      	mov	r3, r9
    4a84:	2200      	movs	r2, #0
    4a86:	4641      	mov	r1, r8
    4a88:	47a8      	blx	r5
	return user_op->status;
    4a8a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
    4a8c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
    4a90:	2001      	movs	r0, #1
    4a92:	e7fb      	b.n	4a8c <ticker_start_ext+0x90>
    4a94:	20000b98 	.word	0x20000b98

00004a98 <ticker_update_ext>:
{
    4a98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
    4a9c:	4c23      	ldr	r4, [pc, #140]	; (4b2c <ticker_update_ext+0x94>)
{
    4a9e:	4606      	mov	r6, r0
    4aa0:	4608      	mov	r0, r1
    4aa2:	4611      	mov	r1, r2
	struct ticker_instance *instance = &_instance[instance_index];
    4aa4:	222c      	movs	r2, #44	; 0x2c
    4aa6:	fb06 4802 	mla	r8, r6, r2, r4
	user = &instance->users[user_id];
    4aaa:	f8d8 4004 	ldr.w	r4, [r8, #4]
    4aae:	eb04 0cc0 	add.w	ip, r4, r0, lsl #3
	if (last >= user->count_user_op) {
    4ab2:	f814 2030 	ldrb.w	r2, [r4, r0, lsl #3]
	last = user->last + 1;
    4ab6:	f89c 7003 	ldrb.w	r7, [ip, #3]
    4aba:	1c7d      	adds	r5, r7, #1
    4abc:	b2ed      	uxtb	r5, r5
		last = 0U;
    4abe:	42aa      	cmp	r2, r5
    4ac0:	bf98      	it	ls
    4ac2:	2500      	movls	r5, #0
	if (last == user->first) {
    4ac4:	f89c 2001 	ldrb.w	r2, [ip, #1]
    4ac8:	42aa      	cmp	r2, r5
    4aca:	d02c      	beq.n	4b26 <ticker_update_ext+0x8e>
	user_op = &user->user_op[user->last];
    4acc:	2234      	movs	r2, #52	; 0x34
    4ace:	fb17 f702 	smulbb	r7, r7, r2
    4ad2:	f8dc 2004 	ldr.w	r2, [ip, #4]
    4ad6:	19d4      	adds	r4, r2, r7
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
    4ad8:	f04f 0e05 	mov.w	lr, #5
    4adc:	f802 e007 	strb.w	lr, [r2, r7]
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
    4ae0:	6063      	str	r3, [r4, #4]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
    4ae2:	9b06      	ldr	r3, [sp, #24]
    4ae4:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
    4ae6:	9b07      	ldr	r3, [sp, #28]
    4ae8:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
    4aea:	9b08      	ldr	r3, [sp, #32]
    4aec:	6123      	str	r3, [r4, #16]
	user_op->params.update.lazy = lazy;
    4aee:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    4af2:	82a3      	strh	r3, [r4, #20]
	user_op->params.update.force = force;
    4af4:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    4af8:	75a3      	strb	r3, [r4, #22]
	user_op->params.update.must_expire = must_expire;
    4afa:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
    4afe:	75e3      	strb	r3, [r4, #23]
	user_op->status = TICKER_STATUS_BUSY;
    4b00:	2302      	movs	r3, #2
    4b02:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
    4b04:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4b06:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
    4b08:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	user_op->id = ticker_id;
    4b0a:	7061      	strb	r1, [r4, #1]
	user_op->op_context = op_context;
    4b0c:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
    4b0e:	f88c 5003 	strb.w	r5, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    4b12:	e9d8 3508 	ldrd	r3, r5, [r8, #32]
    4b16:	4798      	blx	r3
    4b18:	4643      	mov	r3, r8
    4b1a:	2200      	movs	r2, #0
    4b1c:	2104      	movs	r1, #4
    4b1e:	47a8      	blx	r5
	return user_op->status;
    4b20:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
    4b22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
    4b26:	2001      	movs	r0, #1
    4b28:	e7fb      	b.n	4b22 <ticker_update_ext+0x8a>
    4b2a:	bf00      	nop
    4b2c:	20000b98 	.word	0x20000b98

00004b30 <ticker_yield_abs>:
{
    4b30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
    4b34:	4c1b      	ldr	r4, [pc, #108]	; (4ba4 <ticker_yield_abs+0x74>)
{
    4b36:	4606      	mov	r6, r0
    4b38:	4608      	mov	r0, r1
    4b3a:	4611      	mov	r1, r2
	struct ticker_instance *instance = &_instance[instance_index];
    4b3c:	222c      	movs	r2, #44	; 0x2c
    4b3e:	fb06 4802 	mla	r8, r6, r2, r4
	user = &instance->users[user_id];
    4b42:	f8d8 5004 	ldr.w	r5, [r8, #4]
    4b46:	eb05 0cc0 	add.w	ip, r5, r0, lsl #3
	if (last >= user->count_user_op) {
    4b4a:	f815 2030 	ldrb.w	r2, [r5, r0, lsl #3]
	last = user->last + 1;
    4b4e:	f89c 7003 	ldrb.w	r7, [ip, #3]
    4b52:	1c7c      	adds	r4, r7, #1
    4b54:	b2e4      	uxtb	r4, r4
		last = 0U;
    4b56:	42a2      	cmp	r2, r4
    4b58:	bf98      	it	ls
    4b5a:	2400      	movls	r4, #0
	if (last == user->first) {
    4b5c:	f89c 2001 	ldrb.w	r2, [ip, #1]
    4b60:	42a2      	cmp	r2, r4
    4b62:	d01d      	beq.n	4ba0 <ticker_yield_abs+0x70>
	user_op = &user->user_op[user->last];
    4b64:	2234      	movs	r2, #52	; 0x34
    4b66:	fb17 f702 	smulbb	r7, r7, r2
    4b6a:	f8dc 2004 	ldr.w	r2, [ip, #4]
    4b6e:	19d5      	adds	r5, r2, r7
	user_op->op = TICKER_USER_OP_TYPE_YIELD_ABS;
    4b70:	f04f 0e06 	mov.w	lr, #6
    4b74:	f802 e007 	strb.w	lr, [r2, r7]
	user_op->params.yield.ticks_at_yield = ticks_at_yield;
    4b78:	606b      	str	r3, [r5, #4]
	user_op->status = TICKER_STATUS_BUSY;
    4b7a:	2302      	movs	r3, #2
    4b7c:	62ab      	str	r3, [r5, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
    4b7e:	9b06      	ldr	r3, [sp, #24]
    4b80:	62eb      	str	r3, [r5, #44]	; 0x2c
	user_op->op_context = op_context;
    4b82:	9b07      	ldr	r3, [sp, #28]
	user_op->id = ticker_id;
    4b84:	7069      	strb	r1, [r5, #1]
	user_op->op_context = op_context;
    4b86:	632b      	str	r3, [r5, #48]	; 0x30
	user->last = last;
    4b88:	f88c 4003 	strb.w	r4, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    4b8c:	e9d8 3408 	ldrd	r3, r4, [r8, #32]
    4b90:	4798      	blx	r3
    4b92:	4643      	mov	r3, r8
    4b94:	2200      	movs	r2, #0
    4b96:	2104      	movs	r1, #4
    4b98:	47a0      	blx	r4
	return user_op->status;
    4b9a:	6aa8      	ldr	r0, [r5, #40]	; 0x28
}
    4b9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
    4ba0:	2001      	movs	r0, #1
    4ba2:	e7fb      	b.n	4b9c <ticker_yield_abs+0x6c>
    4ba4:	20000b98 	.word	0x20000b98

00004ba8 <ticker_stop>:
{
    4ba8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct ticker_instance *instance = &_instance[instance_index];
    4bac:	4c1a      	ldr	r4, [pc, #104]	; (4c18 <ticker_stop+0x70>)
{
    4bae:	4605      	mov	r5, r0
    4bb0:	4608      	mov	r0, r1
    4bb2:	4611      	mov	r1, r2
	struct ticker_instance *instance = &_instance[instance_index];
    4bb4:	222c      	movs	r2, #44	; 0x2c
    4bb6:	fb05 4902 	mla	r9, r5, r2, r4
	user = &instance->users[user_id];
    4bba:	f8d9 2004 	ldr.w	r2, [r9, #4]
    4bbe:	eb02 07c0 	add.w	r7, r2, r0, lsl #3
	if (last >= user->count_user_op) {
    4bc2:	f812 2030 	ldrb.w	r2, [r2, r0, lsl #3]
	last = user->last + 1;
    4bc6:	78fe      	ldrb	r6, [r7, #3]
    4bc8:	1c74      	adds	r4, r6, #1
    4bca:	b2e4      	uxtb	r4, r4
		last = 0U;
    4bcc:	42a2      	cmp	r2, r4
    4bce:	bf98      	it	ls
    4bd0:	2400      	movls	r4, #0
	if (last == user->first) {
    4bd2:	787a      	ldrb	r2, [r7, #1]
    4bd4:	42a2      	cmp	r2, r4
    4bd6:	d01d      	beq.n	4c14 <ticker_stop+0x6c>
	user_op = &user->user_op[user->last];
    4bd8:	2234      	movs	r2, #52	; 0x34
    4bda:	fb16 f602 	smulbb	r6, r6, r2
    4bde:	687a      	ldr	r2, [r7, #4]
	user_op->op = TICKER_USER_OP_TYPE_STOP;
    4be0:	f04f 0c07 	mov.w	ip, #7
    4be4:	f802 c006 	strb.w	ip, [r2, r6]
	user_op = &user->user_op[user->last];
    4be8:	eb02 0806 	add.w	r8, r2, r6
	user_op->status = TICKER_STATUS_BUSY;
    4bec:	2202      	movs	r2, #2
	user_op->fp_op_func = fp_op_func;
    4bee:	e9c8 230a 	strd	r2, r3, [r8, #40]	; 0x28
	user_op->op_context = op_context;
    4bf2:	9b08      	ldr	r3, [sp, #32]
	user_op->id = ticker_id;
    4bf4:	f888 1001 	strb.w	r1, [r8, #1]
	user_op->op_context = op_context;
    4bf8:	f8c8 3030 	str.w	r3, [r8, #48]	; 0x30
	user->last = last;
    4bfc:	70fc      	strb	r4, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    4bfe:	e9d9 3408 	ldrd	r3, r4, [r9, #32]
    4c02:	4798      	blx	r3
    4c04:	464b      	mov	r3, r9
    4c06:	2200      	movs	r2, #0
    4c08:	2104      	movs	r1, #4
    4c0a:	47a0      	blx	r4
	return user_op->status;
    4c0c:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
}
    4c10:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
    4c14:	2001      	movs	r0, #1
    4c16:	e7fb      	b.n	4c10 <ticker_stop+0x68>
    4c18:	20000b98 	.word	0x20000b98

00004c1c <ticker_next_slot_get>:
{
    4c1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
    4c20:	4c1c      	ldr	r4, [pc, #112]	; (4c94 <ticker_next_slot_get+0x78>)
{
    4c22:	4606      	mov	r6, r0
    4c24:	4608      	mov	r0, r1
    4c26:	4611      	mov	r1, r2
	struct ticker_instance *instance = &_instance[instance_index];
    4c28:	222c      	movs	r2, #44	; 0x2c
    4c2a:	fb06 4802 	mla	r8, r6, r2, r4
	user = &instance->users[user_id];
    4c2e:	f8d8 4004 	ldr.w	r4, [r8, #4]
    4c32:	eb04 0cc0 	add.w	ip, r4, r0, lsl #3
	if (last >= user->count_user_op) {
    4c36:	f814 2030 	ldrb.w	r2, [r4, r0, lsl #3]
	last = user->last + 1;
    4c3a:	f89c 7003 	ldrb.w	r7, [ip, #3]
    4c3e:	1c7d      	adds	r5, r7, #1
    4c40:	b2ed      	uxtb	r5, r5
		last = 0U;
    4c42:	42aa      	cmp	r2, r5
    4c44:	bf98      	it	ls
    4c46:	2500      	movls	r5, #0
	if (last == user->first) {
    4c48:	f89c 2001 	ldrb.w	r2, [ip, #1]
    4c4c:	42aa      	cmp	r2, r5
    4c4e:	d01f      	beq.n	4c90 <ticker_next_slot_get+0x74>
	user_op = &user->user_op[user->last];
    4c50:	2234      	movs	r2, #52	; 0x34
    4c52:	fb17 f702 	smulbb	r7, r7, r2
    4c56:	f8dc 2004 	ldr.w	r2, [ip, #4]
	user_op->op = TICKER_USER_OP_TYPE_SLOT_GET;
    4c5a:	f64f 7e02 	movw	lr, #65282	; 0xff02
	user_op = &user->user_op[user->last];
    4c5e:	19d4      	adds	r4, r2, r7
	user_op->op = TICKER_USER_OP_TYPE_SLOT_GET;
    4c60:	f822 e007 	strh.w	lr, [r2, r7]
	user_op->params.slot_get.ticks_current = ticks_current;
    4c64:	e9c4 1301 	strd	r1, r3, [r4, #4]
	user_op->params.slot_get.ticks_to_expire = ticks_to_expire;
    4c68:	9b06      	ldr	r3, [sp, #24]
    4c6a:	60e3      	str	r3, [r4, #12]
	user_op->status = TICKER_STATUS_BUSY;
    4c6c:	2302      	movs	r3, #2
    4c6e:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
    4c70:	9b07      	ldr	r3, [sp, #28]
    4c72:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
    4c74:	9b08      	ldr	r3, [sp, #32]
    4c76:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
    4c78:	f88c 5003 	strb.w	r5, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    4c7c:	e9d8 3508 	ldrd	r3, r5, [r8, #32]
    4c80:	4798      	blx	r3
    4c82:	4643      	mov	r3, r8
    4c84:	2200      	movs	r2, #0
    4c86:	2104      	movs	r1, #4
    4c88:	47a8      	blx	r5
	return user_op->status;
    4c8a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
    4c8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
    4c90:	2001      	movs	r0, #1
    4c92:	e7fb      	b.n	4c8c <ticker_next_slot_get+0x70>
    4c94:	20000b98 	.word	0x20000b98

00004c98 <ticker_job_sched>:
{
    4c98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    4c9c:	4d08      	ldr	r5, [pc, #32]	; (4cc0 <ticker_job_sched+0x28>)
    4c9e:	262c      	movs	r6, #44	; 0x2c
    4ca0:	fb06 5300 	mla	r3, r6, r0, r5
    4ca4:	e9d3 3708 	ldrd	r3, r7, [r3, #32]
{
    4ca8:	4604      	mov	r4, r0
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    4caa:	4608      	mov	r0, r1
    4cac:	4798      	blx	r3
    4cae:	fb04 5306 	mla	r3, r4, r6, r5
    4cb2:	46bc      	mov	ip, r7
    4cb4:	2200      	movs	r2, #0
}
    4cb6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	instance->sched_cb(instance->caller_id_get_cb(user_id),
    4cba:	2104      	movs	r1, #4
    4cbc:	4760      	bx	ip
    4cbe:	bf00      	nop
    4cc0:	20000b98 	.word	0x20000b98

00004cc4 <ll_addr_set>:

static uint8_t pub_addr[BDADDR_SIZE];
static uint8_t rnd_addr[BDADDR_SIZE];

uint8_t ll_addr_set(uint8_t addr_type, uint8_t const *const bdaddr)
{
    4cc4:	b570      	push	{r4, r5, r6, lr}
    4cc6:	4604      	mov	r4, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER)) {
#if defined(CONFIG_BT_CTLR_ADV_EXT)
		if (ull_adv_is_enabled(0) && !ll_adv_cmds_is_ext()) {
    4cc8:	2000      	movs	r0, #0
{
    4cca:	460d      	mov	r5, r1
		if (ull_adv_is_enabled(0) && !ll_adv_cmds_is_ext()) {
    4ccc:	f00c fa3e 	bl	1114c <ull_adv_is_enabled>
			return BT_HCI_ERR_CMD_DISALLOWED;
		}
	}

	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
    4cd0:	2000      	movs	r0, #0
    4cd2:	f00c fcc3 	bl	1165c <ull_scan_is_enabled>
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
    4cd6:	f010 0606 	ands.w	r6, r0, #6
    4cda:	d10c      	bne.n	4cf6 <ll_addr_set+0x32>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (addr_type) {
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
    4cdc:	2206      	movs	r2, #6
    4cde:	4629      	mov	r1, r5
	if (addr_type) {
    4ce0:	b12c      	cbz	r4, 4cee <ll_addr_set+0x2a>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
    4ce2:	4806      	ldr	r0, [pc, #24]	; (4cfc <ll_addr_set+0x38>)
    4ce4:	f00a ff5f 	bl	fba6 <memcpy>
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
	}

	return 0;
    4ce8:	4634      	mov	r4, r6
}
    4cea:	4620      	mov	r0, r4
    4cec:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
    4cee:	4804      	ldr	r0, [pc, #16]	; (4d00 <ll_addr_set+0x3c>)
    4cf0:	f00a ff59 	bl	fba6 <memcpy>
    4cf4:	e7f9      	b.n	4cea <ll_addr_set+0x26>
		return BT_HCI_ERR_CMD_DISALLOWED;
    4cf6:	240c      	movs	r4, #12
    4cf8:	e7f7      	b.n	4cea <ll_addr_set+0x26>
    4cfa:	bf00      	nop
    4cfc:	2000290f 	.word	0x2000290f
    4d00:	20002909 	.word	0x20002909

00004d04 <ll_addr_get>:

uint8_t *ll_addr_get(uint8_t addr_type)
{
	if (addr_type > BT_ADDR_LE_RANDOM) {
    4d04:	2801      	cmp	r0, #1
{
    4d06:	4602      	mov	r2, r0
	if (addr_type > BT_ADDR_LE_RANDOM) {
    4d08:	d805      	bhi.n	4d16 <ll_addr_get+0x12>
		return NULL;
	}

	if (addr_type) {
		return rnd_addr;
    4d0a:	4b04      	ldr	r3, [pc, #16]	; (4d1c <ll_addr_get+0x18>)
    4d0c:	4804      	ldr	r0, [pc, #16]	; (4d20 <ll_addr_get+0x1c>)
    4d0e:	2a00      	cmp	r2, #0
    4d10:	bf08      	it	eq
    4d12:	4618      	moveq	r0, r3
    4d14:	4770      	bx	lr
		return NULL;
    4d16:	2000      	movs	r0, #0
	}

	return pub_addr;
}
    4d18:	4770      	bx	lr
    4d1a:	bf00      	nop
    4d1c:	20002909 	.word	0x20002909
    4d20:	2000290f 	.word	0x2000290f

00004d24 <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(const struct device *unused)
{
    4d24:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
    4d26:	4802      	ldr	r0, [pc, #8]	; (4d30 <hci_driver_init+0xc>)
    4d28:	f7fe fbce 	bl	34c8 <bt_hci_driver_register>

	return 0;
}
    4d2c:	2000      	movs	r0, #0
    4d2e:	bd08      	pop	{r3, pc}
    4d30:	000130cc 	.word	0x000130cc

00004d34 <hci_driver_send>:
	if (!buf->len) {
    4d34:	8983      	ldrh	r3, [r0, #12]
{
    4d36:	b537      	push	{r0, r1, r2, r4, r5, lr}
    4d38:	4604      	mov	r4, r0
	if (!buf->len) {
    4d3a:	b1c3      	cbz	r3, 4d6e <hci_driver_send+0x3a>
	switch (type) {
    4d3c:	7d03      	ldrb	r3, [r0, #20]
    4d3e:	b9b3      	cbnz	r3, 4d6e <hci_driver_send+0x3a>
	evt = hci_cmd_handle(buf, (void **) &node_rx);
    4d40:	a901      	add	r1, sp, #4
	struct node_rx_pdu *node_rx = NULL;
    4d42:	9301      	str	r3, [sp, #4]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
    4d44:	f000 fd0e 	bl	5764 <hci_cmd_handle>
	if (evt) {
    4d48:	b158      	cbz	r0, 4d62 <hci_driver_send+0x2e>
		bt_recv_prio(evt);
    4d4a:	f7fe fb9f 	bl	348c <bt_recv_prio>
		if (node_rx) {
    4d4e:	9d01      	ldr	r5, [sp, #4]
    4d50:	b13d      	cbz	r5, 4d62 <hci_driver_send+0x2e>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    4d52:	4628      	mov	r0, r5
    4d54:	f00c f90c 	bl	10f70 <hci_get_class>
			k_fifo_put(&recv_fifo, node_rx);
    4d58:	9901      	ldr	r1, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    4d5a:	7168      	strb	r0, [r5, #5]
			k_fifo_put(&recv_fifo, node_rx);
    4d5c:	4805      	ldr	r0, [pc, #20]	; (4d74 <hci_driver_send+0x40>)
    4d5e:	f00d fc3c 	bl	125da <k_queue_append>
		net_buf_unref(buf);
    4d62:	4620      	mov	r0, r4
    4d64:	f007 fd78 	bl	c858 <net_buf_unref>
	return err;
    4d68:	2000      	movs	r0, #0
}
    4d6a:	b003      	add	sp, #12
    4d6c:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
    4d6e:	f06f 0015 	mvn.w	r0, #21
    4d72:	e7fa      	b.n	4d6a <hci_driver_send+0x36>
    4d74:	200005b8 	.word	0x200005b8

00004d78 <recv_thread>:
{
    4d78:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_queue_get(queue, timeout);
    4d7a:	4e28      	ldr	r6, [pc, #160]	; (4e1c <recv_thread+0xa4>)
	struct net_buf *buf = NULL;
    4d7c:	2700      	movs	r7, #0
    4d7e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    4d82:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4d86:	4630      	mov	r0, r6
    4d88:	f009 fc44 	bl	e614 <z_impl_k_queue_get>
		if (node_rx && !buf) {
    4d8c:	2800      	cmp	r0, #0
    4d8e:	d0f6      	beq.n	4d7e <recv_thread+0x6>
	buf = encode_node(node_rx, class);
    4d90:	f990 3005 	ldrsb.w	r3, [r0, #5]
    4d94:	9001      	str	r0, [sp, #4]
	switch (class) {
    4d96:	1e5a      	subs	r2, r3, #1
    4d98:	2a03      	cmp	r2, #3
    4d9a:	d82d      	bhi.n	4df8 <recv_thread+0x80>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
    4d9c:	2b02      	cmp	r3, #2
    4d9e:	d123      	bne.n	4de8 <recv_thread+0x70>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
    4da0:	2200      	movs	r2, #0
    4da2:	2300      	movs	r3, #0
    4da4:	2101      	movs	r1, #1
    4da6:	2000      	movs	r0, #0
    4da8:	f7fd ff6c 	bl	2c84 <bt_buf_get_evt>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    4dac:	4604      	mov	r4, r0
		if (buf) {
    4dae:	b118      	cbz	r0, 4db8 <recv_thread+0x40>
			hci_evt_encode(node_rx, buf);
    4db0:	4601      	mov	r1, r0
    4db2:	9801      	ldr	r0, [sp, #4]
    4db4:	f000 fff4 	bl	5da0 <hci_evt_encode>
	node_rx->hdr.next = NULL;
    4db8:	9b01      	ldr	r3, [sp, #4]
	ll_rx_mem_release((void **)&node_rx);
    4dba:	a801      	add	r0, sp, #4
	node_rx->hdr.next = NULL;
    4dbc:	601f      	str	r7, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
    4dbe:	f001 fae9 	bl	6394 <ll_rx_mem_release>
		while (buf) {
    4dc2:	2c00      	cmp	r4, #0
    4dc4:	d0db      	beq.n	4d7e <recv_thread+0x6>
			frag = net_buf_ref(buf);
    4dc6:	4620      	mov	r0, r4
    4dc8:	f00d f869 	bl	11e9e <net_buf_ref>
			buf = net_buf_frag_del(NULL, buf);
    4dcc:	4621      	mov	r1, r4
			frag = net_buf_ref(buf);
    4dce:	4605      	mov	r5, r0
			buf = net_buf_frag_del(NULL, buf);
    4dd0:	2000      	movs	r0, #0
    4dd2:	f00d f884 	bl	11ede <net_buf_frag_del>
			if (frag->len) {
    4dd6:	89ab      	ldrh	r3, [r5, #12]
			buf = net_buf_frag_del(NULL, buf);
    4dd8:	4604      	mov	r4, r0
				bt_recv(frag);
    4dda:	4628      	mov	r0, r5
			if (frag->len) {
    4ddc:	b1db      	cbz	r3, 4e16 <recv_thread+0x9e>
				bt_recv(frag);
    4dde:	f7fe fb07 	bl	33f0 <bt_recv>
	z_impl_k_yield();
    4de2:	f009 fff3 	bl	edcc <z_impl_k_yield>
}
    4de6:	e7ec      	b.n	4dc2 <recv_thread+0x4a>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    4de8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    4dec:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4df0:	2001      	movs	r0, #1
    4df2:	f7fd ff1d 	bl	2c30 <bt_buf_get_rx>
    4df6:	e7d9      	b.n	4dac <recv_thread+0x34>
		LL_ASSERT(0);
    4df8:	4a09      	ldr	r2, [pc, #36]	; (4e20 <recv_thread+0xa8>)
    4dfa:	490a      	ldr	r1, [pc, #40]	; (4e24 <recv_thread+0xac>)
    4dfc:	480a      	ldr	r0, [pc, #40]	; (4e28 <recv_thread+0xb0>)
    4dfe:	f240 1379 	movw	r3, #377	; 0x179
    4e02:	f00a fb60 	bl	f4c6 <printk>
    4e06:	4040      	eors	r0, r0
    4e08:	f380 8811 	msr	BASEPRI, r0
    4e0c:	f04f 0003 	mov.w	r0, #3
    4e10:	df02      	svc	2
	struct net_buf *buf = NULL;
    4e12:	2400      	movs	r4, #0
		break;
    4e14:	e7d0      	b.n	4db8 <recv_thread+0x40>
				net_buf_unref(frag);
    4e16:	f007 fd1f 	bl	c858 <net_buf_unref>
    4e1a:	e7e2      	b.n	4de2 <recv_thread+0x6a>
    4e1c:	200005b8 	.word	0x200005b8
    4e20:	000134d8 	.word	0x000134d8
    4e24:	00014086 	.word	0x00014086
    4e28:	000133b6 	.word	0x000133b6

00004e2c <prio_recv_thread>:
{
    4e2c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return z_impl_k_sem_take(sem, timeout);
    4e2e:	4d0f      	ldr	r5, [pc, #60]	; (4e6c <prio_recv_thread+0x40>)
				k_fifo_put(&recv_fifo, node_rx);
    4e30:	4e0f      	ldr	r6, [pc, #60]	; (4e70 <prio_recv_thread+0x44>)
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
    4e32:	f10d 0102 	add.w	r1, sp, #2
    4e36:	a801      	add	r0, sp, #4
    4e38:	f001 f9ec 	bl	6214 <ll_rx_get>
    4e3c:	2800      	cmp	r0, #0
    4e3e:	d1f8      	bne.n	4e32 <prio_recv_thread+0x6>
		if (node_rx) {
    4e40:	9b01      	ldr	r3, [sp, #4]
    4e42:	b15b      	cbz	r3, 4e5c <prio_recv_thread+0x30>
			ll_rx_dequeue();
    4e44:	f001 fa1c 	bl	6280 <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    4e48:	9c01      	ldr	r4, [sp, #4]
    4e4a:	4620      	mov	r0, r4
    4e4c:	f00c f890 	bl	10f70 <hci_get_class>
				k_fifo_put(&recv_fifo, node_rx);
    4e50:	9901      	ldr	r1, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
    4e52:	7160      	strb	r0, [r4, #5]
				k_fifo_put(&recv_fifo, node_rx);
    4e54:	4630      	mov	r0, r6
    4e56:	f00d fbc0 	bl	125da <k_queue_append>
			continue;
    4e5a:	e7ea      	b.n	4e32 <prio_recv_thread+0x6>
    4e5c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    4e60:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4e64:	4628      	mov	r0, r5
    4e66:	f009 fc2f 	bl	e6c8 <z_impl_k_sem_take>
		BT_DBG("sem taken");
    4e6a:	e7e2      	b.n	4e32 <prio_recv_thread+0x6>
    4e6c:	200005a0 	.word	0x200005a0
    4e70:	200005b8 	.word	0x200005b8

00004e74 <hci_driver_open>:
{
    4e74:	b5d0      	push	{r4, r6, r7, lr}
	err = ll_init(&sem_prio_recv);
    4e76:	481a      	ldr	r0, [pc, #104]	; (4ee0 <hci_driver_open+0x6c>)
{
    4e78:	b088      	sub	sp, #32
	err = ll_init(&sem_prio_recv);
    4e7a:	f001 fdd1 	bl	6a20 <ll_init>
	if (err) {
    4e7e:	4604      	mov	r4, r0
    4e80:	bb58      	cbnz	r0, 4eda <hci_driver_open+0x66>
	hci_init(NULL);
    4e82:	f001 f907 	bl	6094 <hci_init>
	k_thread_create(&prio_recv_thread_data, prio_recv_thread_stack,
    4e86:	2600      	movs	r6, #0
    4e88:	2700      	movs	r7, #0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    4e8a:	f06f 0309 	mvn.w	r3, #9
    4e8e:	e9cd 4302 	strd	r4, r3, [sp, #8]
    4e92:	e9cd 6706 	strd	r6, r7, [sp, #24]
    4e96:	e9cd 4400 	strd	r4, r4, [sp]
    4e9a:	4b12      	ldr	r3, [pc, #72]	; (4ee4 <hci_driver_open+0x70>)
    4e9c:	4912      	ldr	r1, [pc, #72]	; (4ee8 <hci_driver_open+0x74>)
    4e9e:	9404      	str	r4, [sp, #16]
    4ea0:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
    4ea4:	4811      	ldr	r0, [pc, #68]	; (4eec <hci_driver_open+0x78>)
    4ea6:	f009 fb17 	bl	e4d8 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    4eaa:	4911      	ldr	r1, [pc, #68]	; (4ef0 <hci_driver_open+0x7c>)
    4eac:	480f      	ldr	r0, [pc, #60]	; (4eec <hci_driver_open+0x78>)
    4eae:	f00d fb18 	bl	124e2 <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    4eb2:	f06f 0307 	mvn.w	r3, #7
    4eb6:	e9cd 4302 	strd	r4, r3, [sp, #8]
    4eba:	e9cd 6706 	strd	r6, r7, [sp, #24]
    4ebe:	e9cd 4400 	strd	r4, r4, [sp]
    4ec2:	4b0c      	ldr	r3, [pc, #48]	; (4ef4 <hci_driver_open+0x80>)
    4ec4:	490c      	ldr	r1, [pc, #48]	; (4ef8 <hci_driver_open+0x84>)
    4ec6:	9404      	str	r4, [sp, #16]
    4ec8:	f44f 6280 	mov.w	r2, #1024	; 0x400
    4ecc:	480b      	ldr	r0, [pc, #44]	; (4efc <hci_driver_open+0x88>)
    4ece:	f009 fb03 	bl	e4d8 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    4ed2:	490b      	ldr	r1, [pc, #44]	; (4f00 <hci_driver_open+0x8c>)
    4ed4:	4809      	ldr	r0, [pc, #36]	; (4efc <hci_driver_open+0x88>)
    4ed6:	f00d fb04 	bl	124e2 <z_impl_k_thread_name_set>
}
    4eda:	4620      	mov	r0, r4
    4edc:	b008      	add	sp, #32
    4ede:	bdd0      	pop	{r4, r6, r7, pc}
    4ee0:	200005a0 	.word	0x200005a0
    4ee4:	00004e2d 	.word	0x00004e2d
    4ee8:	20003140 	.word	0x20003140
    4eec:	20000728 	.word	0x20000728
    4ef0:	00013518 	.word	0x00013518
    4ef4:	00004d79 	.word	0x00004d79
    4ef8:	20003320 	.word	0x20003320
    4efc:	200007a8 	.word	0x200007a8
    4f00:	00013522 	.word	0x00013522

00004f04 <cmd_complete_status>:
{
	return bt_hci_cmd_status_create(_opcode, status);
}

static struct net_buf *cmd_complete_status(uint8_t status)
{
    4f04:	b538      	push	{r3, r4, r5, lr}
	struct net_buf *buf;
	struct bt_hci_evt_cc_status *ccst;

	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
    4f06:	4b07      	ldr	r3, [pc, #28]	; (4f24 <cmd_complete_status+0x20>)
{
    4f08:	4605      	mov	r5, r0
	buf = bt_hci_cmd_complete_create(_opcode, sizeof(*ccst));
    4f0a:	2101      	movs	r1, #1
    4f0c:	8818      	ldrh	r0, [r3, #0]
    4f0e:	f00a ff00 	bl	fd12 <bt_hci_cmd_complete_create>
	return net_buf_simple_add(&buf->b, len);
    4f12:	2101      	movs	r1, #1
    4f14:	4604      	mov	r4, r0
    4f16:	3008      	adds	r0, #8
    4f18:	f00c ffed 	bl	11ef6 <net_buf_simple_add>
	ccst = net_buf_add(buf, sizeof(*ccst));
	ccst->status = status;
    4f1c:	7005      	strb	r5, [r0, #0]

	return buf;
}
    4f1e:	4620      	mov	r0, r4
    4f20:	bd38      	pop	{r3, r4, r5, pc}
    4f22:	bf00      	nop
    4f24:	200026e0 	.word	0x200026e0

00004f28 <dup_found>:
}

static bool dup_found(uint8_t adv_type, uint8_t addr_type, const uint8_t *addr,
		      uint8_t adv_mode, const struct pdu_adv_adi *adi,
		      uint8_t data_status)
{
    4f28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	/* check for duplicate filtering */
	if (dup_count >= 0) {
    4f2c:	f8df b180 	ldr.w	fp, [pc, #384]	; 50b0 <dup_found+0x188>
{
    4f30:	461e      	mov	r6, r3
	if (dup_count >= 0) {
    4f32:	f8db 3000 	ldr.w	r3, [fp]
{
    4f36:	b085      	sub	sp, #20
	if (dup_count >= 0) {
    4f38:	2b00      	cmp	r3, #0
{
    4f3a:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    4f3c:	f89d 803c 	ldrb.w	r8, [sp, #60]	; 0x3c
    4f40:	9101      	str	r1, [sp, #4]
    4f42:	4681      	mov	r9, r0
    4f44:	4692      	mov	sl, r2
	if (dup_count >= 0) {
    4f46:	db6a      	blt.n	501e <dup_found+0xf6>
    4f48:	495a      	ldr	r1, [pc, #360]	; (50b4 <dup_found+0x18c>)
		__ASSERT((adv_mode < ARRAY_SIZE(dup_filter[0].adv_mode)),
			 "adv_mode index out-of-bound");
#endif /* CONFIG_BT_CTLR_ADV_EXT */

		/* find for existing entry and update if changed */
		for (i = 0; i < dup_count; i++) {
    4f4a:	2300      	movs	r3, #0
    4f4c:	f8db 2000 	ldr.w	r2, [fp]
    4f50:	4293      	cmp	r3, r2
    4f52:	db3a      	blt.n	4fca <dup_found+0xa2>
			return is_dup_or_update(dup, adv_type, adv_mode, adi,
						data_status);
		}

		/* insert into the duplicate filter */
		dup = &dup_filter[dup_curr];
    4f54:	4b58      	ldr	r3, [pc, #352]	; (50b8 <dup_found+0x190>)
		(void)memcpy(&dup->addr.a.val[0], addr, sizeof(bt_addr_t));
    4f56:	4c59      	ldr	r4, [pc, #356]	; (50bc <dup_found+0x194>)
		dup = &dup_filter[dup_curr];
    4f58:	681d      	ldr	r5, [r3, #0]
		(void)memcpy(&dup->addr.a.val[0], addr, sizeof(bt_addr_t));
    4f5a:	016d      	lsls	r5, r5, #5
    4f5c:	1c68      	adds	r0, r5, #1
    4f5e:	2206      	movs	r2, #6
    4f60:	4651      	mov	r1, sl
    4f62:	4420      	add	r0, r4
    4f64:	f00a fe1f 	bl	fba6 <memcpy>
		dup->addr.type = addr_type;
    4f68:	9b01      	ldr	r3, [sp, #4]
    4f6a:	5563      	strb	r3, [r4, r5]
    4f6c:	1962      	adds	r2, r4, r5
		dup->mask = BIT(adv_type);
    4f6e:	2001      	movs	r0, #1
    4f70:	3508      	adds	r5, #8
    4f72:	fa00 f909 	lsl.w	r9, r0, r9
    4f76:	f882 9007 	strb.w	r9, [r2, #7]
		dup_mode->set_count = 0U;
    4f7a:	5b60      	ldrh	r0, [r4, r5]
    4f7c:	4950      	ldr	r1, [pc, #320]	; (50c0 <dup_found+0x198>)
    4f7e:	4008      	ands	r0, r1
    4f80:	5360      	strh	r0, [r4, r5]

#if defined(CONFIG_BT_CTLR_ADV_EXT)
		dup_ext_adv_mode_reset(dup->adv_mode);
    4f82:	1962      	adds	r2, r4, r5
		dup_mode->set_count = 0U;
    4f84:	88d0      	ldrh	r0, [r2, #6]
    4f86:	4008      	ands	r0, r1
    4f88:	80d0      	strh	r0, [r2, #6]
    4f8a:	8990      	ldrh	r0, [r2, #12]
    4f8c:	4008      	ands	r0, r1
    4f8e:	8190      	strh	r0, [r2, #12]
    4f90:	8a50      	ldrh	r0, [r2, #18]
    4f92:	4001      	ands	r1, r0
		dup_ext_adv_adi_store(&dup->adv_mode[adv_mode], adi,
    4f94:	2006      	movs	r0, #6
    4f96:	fb10 5006 	smlabb	r0, r0, r6, r5
		dup_mode->set_count = 0U;
    4f9a:	8251      	strh	r1, [r2, #18]
		dup_ext_adv_adi_store(&dup->adv_mode[adv_mode], adi,
    4f9c:	4420      	add	r0, r4
    4f9e:	4642      	mov	r2, r8
    4fa0:	4639      	mov	r1, r7
    4fa2:	f00b fe68 	bl	10c76 <dup_ext_adv_adi_store>
				      data_status);
#endif /* CONFIG_BT_CTLR_ADV_EXT */

		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
    4fa6:	f8db 2000 	ldr.w	r2, [fp]
    4faa:	4b43      	ldr	r3, [pc, #268]	; (50b8 <dup_found+0x190>)
    4fac:	2a0f      	cmp	r2, #15
			dup_count++;
			dup_curr = dup_count;
		} else {
			dup_curr++;
    4fae:	bfca      	itet	gt
    4fb0:	681a      	ldrgt	r2, [r3, #0]
			dup_count++;
    4fb2:	3201      	addle	r2, #1
			dup_curr++;
    4fb4:	3201      	addgt	r2, #1
    4fb6:	601a      	str	r2, [r3, #0]
			dup_count++;
    4fb8:	bfd8      	it	le
    4fba:	f8cb 2000 	strle.w	r2, [fp]
		}

		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
    4fbe:	681a      	ldr	r2, [r3, #0]
    4fc0:	2a10      	cmp	r2, #16
    4fc2:	d12c      	bne.n	501e <dup_found+0xf6>
			dup_curr = 0U;
    4fc4:	2400      	movs	r4, #0
    4fc6:	601c      	str	r4, [r3, #0]
    4fc8:	e02a      	b.n	5020 <dup_found+0xf8>
			if (memcmp(addr, &dup->addr.a.val[0],
    4fca:	2206      	movs	r2, #6
    4fcc:	4650      	mov	r0, sl
    4fce:	015d      	lsls	r5, r3, #5
    4fd0:	9303      	str	r3, [sp, #12]
    4fd2:	9102      	str	r1, [sp, #8]
    4fd4:	f00a fdbe 	bl	fb54 <memcmp>
    4fd8:	e9dd 1302 	ldrd	r1, r3, [sp, #8]
    4fdc:	4604      	mov	r4, r0
    4fde:	b920      	cbnz	r0, 4fea <dup_found+0xc2>
				   sizeof(bt_addr_t)) ||
    4fe0:	f811 2c01 	ldrb.w	r2, [r1, #-1]
    4fe4:	9801      	ldr	r0, [sp, #4]
    4fe6:	4282      	cmp	r2, r0
    4fe8:	d002      	beq.n	4ff0 <dup_found+0xc8>
		for (i = 0; i < dup_count; i++) {
    4fea:	3301      	adds	r3, #1
    4fec:	3120      	adds	r1, #32
    4fee:	e7ad      	b.n	4f4c <dup_found+0x24>
	if (!(dup->mask & BIT(adv_type))) {
    4ff0:	4832      	ldr	r0, [pc, #200]	; (50bc <dup_found+0x194>)
    4ff2:	1941      	adds	r1, r0, r5
    4ff4:	79cb      	ldrb	r3, [r1, #7]
    4ff6:	fa23 fa09 	lsr.w	sl, r3, r9
    4ffa:	f01a 0a01 	ands.w	sl, sl, #1
    4ffe:	d113      	bne.n	5028 <dup_found+0x100>
		dup->mask |= BIT(adv_type);
    5000:	2201      	movs	r2, #1
    5002:	fa02 f909 	lsl.w	r9, r2, r9
    5006:	ea43 0309 	orr.w	r3, r3, r9
    500a:	71cb      	strb	r3, [r1, #7]
		dup_ext_adv_adi_store(&dup->adv_mode[adv_mode], adi,
    500c:	2306      	movs	r3, #6
		dup_ext_adv_adi_store(&dup->adv_mode[adv_mode], adi,
    500e:	fb03 5506 	mla	r5, r3, r6, r5
    5012:	3508      	adds	r5, #8
    5014:	4642      	mov	r2, r8
    5016:	4639      	mov	r1, r7
    5018:	4428      	add	r0, r5
    501a:	f00b fe2c 	bl	10c76 <dup_ext_adv_adi_store>
		}
	}

	return false;
    501e:	2400      	movs	r4, #0
}
    5020:	4620      	mov	r0, r4
    5022:	b005      	add	sp, #20
    5024:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (adv_type != PDU_ADV_TYPE_EXT_IND) {
    5028:	f1b9 0f07 	cmp.w	r9, #7
    502c:	d13e      	bne.n	50ac <dup_found+0x184>
	} else if (dup->adv_mode[adv_mode].set_count == 0U) {
    502e:	2306      	movs	r3, #6
    5030:	fb03 5206 	mla	r2, r3, r6, r5
    5034:	4402      	add	r2, r0
    5036:	f102 0108 	add.w	r1, r2, #8
    503a:	f892 9008 	ldrb.w	r9, [r2, #8]
    503e:	f019 091f 	ands.w	r9, r9, #31
    5042:	d0e4      	beq.n	500e <dup_found+0xe6>
	} else if (adi) {
    5044:	b397      	cbz	r7, 50ac <dup_found+0x184>
			if (adv_set->adi.sid != adi->sid) {
    5046:	790a      	ldrb	r2, [r1, #4]
    5048:	f897 c001 	ldrb.w	ip, [r7, #1]
    504c:	ea4f 1e12 	mov.w	lr, r2, lsr #4
    5050:	ebbe 1f1c 	cmp.w	lr, ip, lsr #4
    5054:	d121      	bne.n	509a <dup_found+0x172>
			if (adv_set->adi.did != adi->did) {
    5056:	783b      	ldrb	r3, [r7, #0]
    5058:	78cf      	ldrb	r7, [r1, #3]
    505a:	f00c 0c0f 	and.w	ip, ip, #15
    505e:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
    5062:	f002 0c0f 	and.w	ip, r2, #15
    5066:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
    506a:	429f      	cmp	r7, r3
    506c:	d006      	beq.n	507c <dup_found+0x154>
				adv_set->adi.did = adi->did;
    506e:	f022 020f 	bic.w	r2, r2, #15
    5072:	ea42 2213 	orr.w	r2, r2, r3, lsr #8
    5076:	70cb      	strb	r3, [r1, #3]
    5078:	710a      	strb	r2, [r1, #4]
				return false;
    507a:	e7d1      	b.n	5020 <dup_found+0xf8>
			} else if (!adv_set->data_cmplt &&
    507c:	788b      	ldrb	r3, [r1, #2]
    507e:	07db      	lsls	r3, r3, #31
    5080:	d414      	bmi.n	50ac <dup_found+0x184>
    5082:	f1b8 0f00 	cmp.w	r8, #0
    5086:	d1ca      	bne.n	501e <dup_found+0xf6>
				adv_set->data_cmplt = 1U;
    5088:	2306      	movs	r3, #6
    508a:	fb03 5506 	mla	r5, r3, r6, r5
    508e:	4428      	add	r0, r5
    5090:	7a83      	ldrb	r3, [r0, #10]
    5092:	f043 0301 	orr.w	r3, r3, #1
    5096:	7283      	strb	r3, [r0, #10]
				return false;
    5098:	e7c1      	b.n	501e <dup_found+0xf6>
		dup_ext_adv_adi_store(&dup->adv_mode[adv_mode], adi,
    509a:	fb03 5506 	mla	r5, r3, r6, r5
    509e:	3508      	adds	r5, #8
    50a0:	4642      	mov	r2, r8
    50a2:	4639      	mov	r1, r7
    50a4:	4428      	add	r0, r5
    50a6:	f00b fde6 	bl	10c76 <dup_ext_adv_adi_store>
		return false;
    50aa:	e7b9      	b.n	5020 <dup_found+0xf8>
		return true;
    50ac:	2401      	movs	r4, #1
    50ae:	e7b7      	b.n	5020 <dup_found+0xf8>
    50b0:	20000bc4 	.word	0x20000bc4
    50b4:	200026e3 	.word	0x200026e3
    50b8:	20000bc8 	.word	0x20000bc8
    50bc:	200026e2 	.word	0x200026e2
    50c0:	fffffc00 	.word	0xfffffc00

000050c4 <le_adv_ext_report>:
}

static void le_adv_ext_report(struct pdu_data *pdu_data,
			      struct node_rx_pdu *node_rx,
			      struct net_buf *buf, uint8_t phy)
{
    50c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    50c8:	b0a9      	sub	sp, #164	; 0xa4
    50ca:	4688      	mov	r8, r1
    50cc:	931b      	str	r3, [sp, #108]	; 0x6c
	struct pdu_adv *adv = (void *)pdu_data;

	if ((adv->type == PDU_ADV_TYPE_EXT_IND) && adv->len) {
    50ce:	7801      	ldrb	r1, [r0, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    50d0:	4ba9      	ldr	r3, [pc, #676]	; (5378 <le_adv_ext_report+0x2b4>)
{
    50d2:	9219      	str	r2, [sp, #100]	; 0x64
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    50d4:	685b      	ldr	r3, [r3, #4]
	if ((adv->type == PDU_ADV_TYPE_EXT_IND) && adv->len) {
    50d6:	f001 020f 	and.w	r2, r1, #15
    50da:	2a07      	cmp	r2, #7
{
    50dc:	4604      	mov	r4, r0
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    50de:	f04f 0500 	mov.w	r5, #0
    50e2:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
	if ((adv->type == PDU_ADV_TYPE_EXT_IND) && adv->len) {
    50e6:	f040 8212 	bne.w	550e <le_adv_ext_report+0x44a>
    50ea:	7842      	ldrb	r2, [r0, #1]
    50ec:	2a00      	cmp	r2, #0
    50ee:	f000 820e 	beq.w	550e <le_adv_ext_report+0x44a>
	const uint8_t *data = NULL;
    50f2:	e9cd 5524 	strd	r5, r5, [sp, #144]	; 0x90
	uint8_t scan_data_len = 0U;
    50f6:	f88d 508c 	strb.w	r5, [sp, #140]	; 0x8c
	uint8_t sec_phy_scan = 0U;
    50fa:	f88d 508d 	strb.w	r5, [sp, #141]	; 0x8d
	uint8_t data_len = 0U;
    50fe:	f88d 508e 	strb.w	r5, [sp, #142]	; 0x8e
	uint8_t sec_phy = 0U;
    5102:	f88d 508f 	strb.w	r5, [sp, #143]	; 0x8f
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5106:	b11b      	cbz	r3, 5110 <le_adv_ext_report+0x4c>
	    !(le_event_mask & BT_EVT_MASK_LE_EXT_ADVERTISING_REPORT)) {
    5108:	4b9c      	ldr	r3, [pc, #624]	; (537c <le_adv_ext_report+0x2b8>)
    510a:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    510c:	04d9      	lsls	r1, r3, #19
    510e:	d406      	bmi.n	511e <le_adv_ext_report+0x5a>
	node_rx_extra_list_release(node_rx->hdr.rx_ftr.extra);
    5110:	f8d8 000c 	ldr.w	r0, [r8, #12]
    5114:	f00b fde4 	bl	10ce0 <node_rx_extra_list_release>
		le_ext_adv_report(pdu_data, node_rx, buf, phy);
	} else {
		le_ext_adv_legacy_report(pdu_data, node_rx, buf);
	}
}
    5118:	b029      	add	sp, #164	; 0xa4
    511a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	rl_idx = ll_rl_size_get();
    511e:	f00c faea 	bl	116f6 <ll_rl_size_get>
	node_rx_next = node_rx_curr->hdr.rx_ftr.extra;
    5122:	f8d8 300c 	ldr.w	r3, [r8, #12]
    5126:	9313      	str	r3, [sp, #76]	; 0x4c
	uint8_t direct_addr_type = 0U;
    5128:	e9cd 5515 	strd	r5, r5, [sp, #84]	; 0x54
	int8_t tx_pwr = BT_HCI_LE_ADV_TX_POWER_NO_PREF;
    512c:	237f      	movs	r3, #127	; 0x7f
	rl_idx = ll_rl_size_get();
    512e:	9011      	str	r0, [sp, #68]	; 0x44
	node_rx_next = node_rx_curr->hdr.rx_ftr.extra;
    5130:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
	uint8_t *adv_addr = NULL;
    5134:	46aa      	mov	sl, r5
	uint8_t adv_addr_type = 0U;
    5136:	46ab      	mov	fp, r5
	uint16_t interval_le16 = 0U;
    5138:	9518      	str	r5, [sp, #96]	; 0x60
	uint8_t *direct_addr = NULL;
    513a:	9510      	str	r5, [sp, #64]	; 0x40
	uint8_t scan_data_len_total = 0U;
    513c:	9517      	str	r5, [sp, #92]	; 0x5c
	const struct pdu_adv_adi *adi = NULL;
    513e:	9512      	str	r5, [sp, #72]	; 0x48
	struct node_rx_pdu *node_rx_data = NULL;
    5140:	951c      	str	r5, [sp, #112]	; 0x70
	struct node_rx_pdu *node_rx_scan_data = NULL;
    5142:	951e      	str	r5, [sp, #120]	; 0x78
	int8_t tx_pwr = BT_HCI_LE_ADV_TX_POWER_NO_PREF;
    5144:	9314      	str	r3, [sp, #80]	; 0x50
		uint8_t rl_idx_curr = node_rx_curr->hdr.rx_ftr.rl_idx;
    5146:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
		bool direct_report_curr = node_rx_curr->hdr.rx_ftr.direct;
    5148:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
		uint8_t rl_idx_curr = node_rx_curr->hdr.rx_ftr.rl_idx;
    514a:	7e52      	ldrb	r2, [r2, #25]
    514c:	921d      	str	r2, [sp, #116]	; 0x74
		rssi = -(node_rx_curr->hdr.rx_ftr.rssi);
    514e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
		evt_type_curr = p->adv_mode;
    5150:	78a6      	ldrb	r6, [r4, #2]
		rssi = -(node_rx_curr->hdr.rx_ftr.rssi);
    5152:	7e12      	ldrb	r2, [r2, #24]
		bool direct_report_curr = node_rx_curr->hdr.rx_ftr.direct;
    5154:	f893 901a 	ldrb.w	r9, [r3, #26]
		rssi = -(node_rx_curr->hdr.rx_ftr.rssi);
    5158:	921f      	str	r2, [sp, #124]	; 0x7c
		evt_type_curr = p->adv_mode;
    515a:	09b2      	lsrs	r2, r6, #6
		if (!p->ext_hdr_len) {
    515c:	f016 063f 	ands.w	r6, r6, #63	; 0x3f
		bool direct_report_curr = node_rx_curr->hdr.rx_ftr.direct;
    5160:	f3c9 0340 	ubfx	r3, r9, #1, #1
		evt_type_curr = p->adv_mode;
    5164:	9220      	str	r2, [sp, #128]	; 0x80
		if (!p->ext_hdr_len) {
    5166:	d13b      	bne.n	51e0 <le_adv_ext_report+0x11c>
		h = (void *)p->ext_hdr_adv_data;
    5168:	1ce1      	adds	r1, r4, #3
		uint8_t sec_phy_curr = 0U;
    516a:	46b1      	mov	r9, r6
		uint8_t direct_addr_type_curr = 0U;
    516c:	4637      	mov	r7, r6
			hdr_len = PDU_AC_EXT_HEADER_SIZE_MIN;
    516e:	2301      	movs	r3, #1
		uint8_t *adv_addr_curr = NULL;
    5170:	961a      	str	r6, [sp, #104]	; 0x68
		uint8_t *direct_addr_curr = NULL;
    5172:	46b6      	mov	lr, r6
		struct pdu_adv_adi *adi_curr = NULL;
    5174:	46b4      	mov	ip, r6
		if (hdr_len < adv->len) {
    5176:	7862      	ldrb	r2, [r4, #1]
    5178:	429a      	cmp	r2, r3
			data_len_curr = adv->len - hdr_len;
    517a:	bf88      	it	hi
    517c:	1ad3      	subhi	r3, r2, r3
		if (node_rx_curr == node_rx) {
    517e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
		uint8_t *data_curr = NULL;
    5180:	bf96      	itet	ls
    5182:	2100      	movls	r1, #0
			data_len_curr = adv->len - hdr_len;
    5184:	b2db      	uxtbhi	r3, r3
		uint8_t data_len_curr = 0U;
    5186:	460b      	movls	r3, r1
		if (node_rx_curr == node_rx) {
    5188:	4590      	cmp	r8, r2
    518a:	f040 80ad 	bne.w	52e8 <le_adv_ext_report+0x224>
			data_len = data_len_curr;
    518e:	f88d 308e 	strb.w	r3, [sp, #142]	; 0x8e
			data_len_total = data_len;
    5192:	b29b      	uxth	r3, r3
    5194:	9316      	str	r3, [sp, #88]	; 0x58
			rl_idx = rl_idx_curr;
    5196:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5198:	9311      	str	r3, [sp, #68]	; 0x44
		evt_type_curr = p->adv_mode;
    519a:	9d20      	ldr	r5, [sp, #128]	; 0x80
			adv_addr = adv_addr_curr;
    519c:	f8dd a068 	ldr.w	sl, [sp, #104]	; 0x68
			sec_phy = sec_phy_curr;
    51a0:	f88d 908f 	strb.w	r9, [sp, #143]	; 0x8f
			scan_data_len_total = 0U;
    51a4:	2300      	movs	r3, #0
			data = data_curr;
    51a6:	9125      	str	r1, [sp, #148]	; 0x94
			adv_addr_type = adv_addr_type_curr;
    51a8:	46b3      	mov	fp, r6
			direct_addr = direct_addr_curr;
    51aa:	f8cd e040 	str.w	lr, [sp, #64]	; 0x40
			direct_addr_type = direct_addr_type_curr;
    51ae:	9715      	str	r7, [sp, #84]	; 0x54
			adi = adi_curr;
    51b0:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
    51b4:	f8cd 8070 	str.w	r8, [sp, #112]	; 0x70
			scan_data_len_total = 0U;
    51b8:	9317      	str	r3, [sp, #92]	; 0x5c
		if (!node_rx_next) {
    51ba:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    51bc:	2b00      	cmp	r3, #0
    51be:	f040 80d3 	bne.w	5368 <le_adv_ext_report+0x2a4>
			if (scan_data) {
    51c2:	9b24      	ldr	r3, [sp, #144]	; 0x90
    51c4:	2b00      	cmp	r3, #0
    51c6:	f000 80c3 	beq.w	5350 <le_adv_ext_report+0x28c>
					scan_data_status =
    51ca:	f1b9 0f00 	cmp.w	r9, #0
    51ce:	bf18      	it	ne
    51d0:	f04f 0902 	movne.w	r9, #2
	if (adv_addr) {
    51d4:	f1ba 0f00 	cmp.w	sl, #0
    51d8:	f040 80d2 	bne.w	5380 <le_adv_ext_report+0x2bc>
    51dc:	4654      	mov	r4, sl
    51de:	e0dc      	b.n	539a <le_adv_ext_report+0x2d6>
		if (h->adv_addr) {
    51e0:	78e6      	ldrb	r6, [r4, #3]
    51e2:	f016 0601 	ands.w	r6, r6, #1
		direct_resolved_curr = node_rx_curr->hdr.rx_ftr.direct_resolved;
    51e6:	f3c9 0980 	ubfx	r9, r9, #2, #1
		ptr = h->data;
    51ea:	f104 0104 	add.w	r1, r4, #4
		if (h->adv_addr) {
    51ee:	d02f      	beq.n	5250 <le_adv_ext_report+0x18c>
			adv_addr_type_curr = adv->tx_addr;
    51f0:	4627      	mov	r7, r4
			(void)memcpy(addr.a.val, ptr, sizeof(bt_addr_t));
    51f2:	f10d 0099 	add.w	r0, sp, #153	; 0x99
			adv_addr_type_curr = adv->tx_addr;
    51f6:	f817 6b0a 	ldrb.w	r6, [r7], #10
    51fa:	9321      	str	r3, [sp, #132]	; 0x84
    51fc:	f3c6 1280 	ubfx	r2, r6, #6, #1
			addr.type = adv->tx_addr;
    5200:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
			adv_addr_type_curr = adv->tx_addr;
    5204:	4616      	mov	r6, r2
			(void)memcpy(addr.a.val, ptr, sizeof(bt_addr_t));
    5206:	2206      	movs	r2, #6
    5208:	911a      	str	r1, [sp, #104]	; 0x68
    520a:	f00a fccc 	bl	fba6 <memcpy>
			BT_DBG("    AdvA: %s", bt_addr_le_str(&addr));
    520e:	9b21      	ldr	r3, [sp, #132]	; 0x84
			ptr += BDADDR_SIZE;
    5210:	4639      	mov	r1, r7
		if (h->tgt_addr) {
    5212:	78e7      	ldrb	r7, [r4, #3]
    5214:	f017 0702 	ands.w	r7, r7, #2
    5218:	d064      	beq.n	52e4 <le_adv_ext_report+0x220>
	if (direct_report) {
    521a:	2b00      	cmp	r3, #0
    521c:	d160      	bne.n	52e0 <le_adv_ext_report+0x21c>
			lll = node_rx->hdr.rx_ftr.param;
    521e:	f8d8 0008 	ldr.w	r0, [r8, #8]
		scan = HDR_LLL2ULL(lll);
    5222:	6807      	ldr	r7, [r0, #0]
	} else if (peer_resolved) {
    5224:	f1b9 0f00 	cmp.w	r9, #0
    5228:	d00d      	beq.n	5246 <le_adv_ext_report+0x182>
		if ((rx_addr_type == lll->init_addr_type) &&
    522a:	7903      	ldrb	r3, [r0, #4]
							 adv->rx_addr, ptr);
    522c:	7822      	ldrb	r2, [r4, #0]
		if ((rx_addr_type == lll->init_addr_type) &&
    522e:	f3c3 1380 	ubfx	r3, r3, #6, #1
    5232:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
    5236:	d10d      	bne.n	5254 <le_adv_ext_report+0x190>
		    !memcmp(lll->init_addr, rx_addr, BDADDR_SIZE)) {
    5238:	2206      	movs	r2, #6
    523a:	3012      	adds	r0, #18
    523c:	9121      	str	r1, [sp, #132]	; 0x84
    523e:	f00a fc89 	bl	fb54 <memcmp>
		if ((rx_addr_type == lll->init_addr_type) &&
    5242:	9921      	ldr	r1, [sp, #132]	; 0x84
    5244:	b930      	cbnz	r0, 5254 <le_adv_ext_report+0x190>
		return scan->own_addr_type;
    5246:	f897 7044 	ldrb.w	r7, [r7, #68]	; 0x44
    524a:	f3c7 0741 	ubfx	r7, r7, #1, #2
    524e:	e007      	b.n	5260 <le_adv_ext_report+0x19c>
		uint8_t *adv_addr_curr = NULL;
    5250:	961a      	str	r6, [sp, #104]	; 0x68
    5252:	e7de      	b.n	5212 <le_adv_ext_report+0x14e>
		return scan->own_addr_type | BIT(1);
    5254:	f897 7044 	ldrb.w	r7, [r7, #68]	; 0x44
    5258:	f3c7 0741 	ubfx	r7, r7, #1, #2
    525c:	f047 0702 	orr.w	r7, r7, #2
			addr.type = adv->rx_addr;
    5260:	7823      	ldrb	r3, [r4, #0]
			(void)memcpy(addr.a.val, direct_addr_curr,
    5262:	9121      	str	r1, [sp, #132]	; 0x84
			addr.type = adv->rx_addr;
    5264:	f3c3 13c0 	ubfx	r3, r3, #7, #1
			(void)memcpy(addr.a.val, direct_addr_curr,
    5268:	2206      	movs	r2, #6
    526a:	f10d 0099 	add.w	r0, sp, #153	; 0x99
			ptr += BDADDR_SIZE;
    526e:	f101 0906 	add.w	r9, r1, #6
			addr.type = adv->rx_addr;
    5272:	f88d 3098 	strb.w	r3, [sp, #152]	; 0x98
			(void)memcpy(addr.a.val, direct_addr_curr,
    5276:	f00a fc96 	bl	fba6 <memcpy>
			direct_addr_curr = ptr;
    527a:	9921      	ldr	r1, [sp, #132]	; 0x84
    527c:	468e      	mov	lr, r1
			ptr += BDADDR_SIZE;
    527e:	4649      	mov	r1, r9
		if (h->adi) {
    5280:	78e3      	ldrb	r3, [r4, #3]
    5282:	f013 0c08 	ands.w	ip, r3, #8
			adi_curr = (void *)ptr;
    5286:	bf1c      	itt	ne
    5288:	468c      	movne	ip, r1
			ptr += sizeof(*adi);
    528a:	3102      	addne	r1, #2
		if (h->aux_ptr) {
    528c:	f013 0910 	ands.w	r9, r3, #16
    5290:	d00a      	beq.n	52a8 <le_adv_ext_report+0x1e4>
			if (aux_ptr->phy > EXT_ADV_AUX_PHY_LE_CODED) {
    5292:	788a      	ldrb	r2, [r1, #2]
    5294:	2a5f      	cmp	r2, #95	; 0x5f
    5296:	ea4f 1952 	mov.w	r9, r2, lsr #5
    529a:	f63f af39 	bhi.w	5110 <le_adv_ext_report+0x4c>
			sec_phy_curr = HCI_AUX_PHY_TO_HCI_PHY(aux_ptr->phy);
    529e:	f109 0901 	add.w	r9, r9, #1
			ptr += sizeof(*aux_ptr);
    52a2:	3103      	adds	r1, #3
			sec_phy_curr = HCI_AUX_PHY_TO_HCI_PHY(aux_ptr->phy);
    52a4:	f009 0907 	and.w	r9, r9, #7
		if (h->sync_info) {
    52a8:	069a      	lsls	r2, r3, #26
			interval_le16 = si->interval;
    52aa:	bf42      	ittt	mi
    52ac:	884a      	ldrhmi	r2, [r1, #2]
    52ae:	9218      	strmi	r2, [sp, #96]	; 0x60
			ptr += sizeof(*si);
    52b0:	3112      	addmi	r1, #18
		hdr_buf_len = PDU_AC_EXT_HEADER_SIZE_MIN + p->ext_hdr_len;
    52b2:	78a2      	ldrb	r2, [r4, #2]
		if (h->tx_pwr) {
    52b4:	065b      	lsls	r3, r3, #25
			tx_pwr = *(int8_t *)ptr;
    52b6:	bf44      	itt	mi
    52b8:	f911 3b01 	ldrsbmi.w	r3, [r1], #1
    52bc:	9314      	strmi	r3, [sp, #80]	; 0x50
		hdr_buf_len = PDU_AC_EXT_HEADER_SIZE_MIN + p->ext_hdr_len;
    52be:	f3c2 0205 	ubfx	r2, r2, #0, #6
		p = (void *)&adv->adv_ext_ind;
    52c2:	1ca3      	adds	r3, r4, #2
		hdr_len = ptr - (uint8_t *)p;
    52c4:	1acb      	subs	r3, r1, r3
		hdr_buf_len = PDU_AC_EXT_HEADER_SIZE_MIN + p->ext_hdr_len;
    52c6:	3201      	adds	r2, #1
		hdr_len = ptr - (uint8_t *)p;
    52c8:	b2db      	uxtb	r3, r3
		hdr_buf_len = PDU_AC_EXT_HEADER_SIZE_MIN + p->ext_hdr_len;
    52ca:	b2d2      	uxtb	r2, r2
		if (hdr_len > hdr_buf_len) {
    52cc:	4293      	cmp	r3, r2
    52ce:	f63f af52 	bhi.w	5176 <le_adv_ext_report+0xb2>
			uint8_t acad_len = hdr_buf_len - hdr_len;
    52d2:	1ad0      	subs	r0, r2, r3
			if (acad_len) {
    52d4:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
				ptr += acad_len;
    52d8:	bf1c      	itt	ne
    52da:	1809      	addne	r1, r1, r0
    52dc:	4613      	movne	r3, r2
    52de:	e74a      	b.n	5176 <le_adv_ext_report+0xb2>
		return BT_ADDR_LE_UNRESOLVED;
    52e0:	27fe      	movs	r7, #254	; 0xfe
    52e2:	e7bd      	b.n	5260 <le_adv_ext_report+0x19c>
		uint8_t *direct_addr_curr = NULL;
    52e4:	46be      	mov	lr, r7
    52e6:	e7cb      	b.n	5280 <le_adv_ext_report+0x1bc>
			if (node_rx_curr->hdr.rx_ftr.scan_rsp) {
    52e8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    52ea:	7ed2      	ldrb	r2, [r2, #27]
    52ec:	07d0      	lsls	r0, r2, #31
    52ee:	d506      	bpl.n	52fe <le_adv_ext_report+0x23a>
				scan_data = data_curr;
    52f0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
				sec_phy_scan = sec_phy_curr;
    52f2:	f88d 908d 	strb.w	r9, [sp, #141]	; 0x8d
				scan_data_len = data_len_curr;
    52f6:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
				scan_data = data_curr;
    52fa:	9124      	str	r1, [sp, #144]	; 0x90
    52fc:	921e      	str	r2, [sp, #120]	; 0x78
			if (!adv_addr) {
    52fe:	f1ba 0f00 	cmp.w	sl, #0
    5302:	d102      	bne.n	530a <le_adv_ext_report+0x246>
				adv_addr = adv_addr_curr;
    5304:	f8dd a068 	ldr.w	sl, [sp, #104]	; 0x68
				adv_addr_type = adv_addr_type_curr;
    5308:	46b3      	mov	fp, r6
			if (!direct_addr) {
    530a:	9a10      	ldr	r2, [sp, #64]	; 0x40
    530c:	b912      	cbnz	r2, 5314 <le_adv_ext_report+0x250>
				direct_addr = direct_addr_curr;
    530e:	f8cd e040 	str.w	lr, [sp, #64]	; 0x40
				direct_addr_type = direct_addr_type_curr;
    5312:	9715      	str	r7, [sp, #84]	; 0x54
			if (scan_data) {
    5314:	9a24      	ldr	r2, [sp, #144]	; 0x90
    5316:	b162      	cbz	r2, 5332 <le_adv_ext_report+0x26e>
				scan_data_len_total += data_len_curr;
    5318:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    531a:	4413      	add	r3, r2
    531c:	b2db      	uxtb	r3, r3
    531e:	9317      	str	r3, [sp, #92]	; 0x5c
			if (rl_idx >= ll_rl_size_get()) {
    5320:	f00c f9e9 	bl	116f6 <ll_rl_size_get>
				rl_idx = rl_idx_curr;
    5324:	9b11      	ldr	r3, [sp, #68]	; 0x44
    5326:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    5328:	4298      	cmp	r0, r3
    532a:	bf98      	it	ls
    532c:	4613      	movls	r3, r2
    532e:	9311      	str	r3, [sp, #68]	; 0x44
			if (!direct_report) {
    5330:	e743      	b.n	51ba <le_adv_ext_report+0xf6>
			} else if (!data) {
    5332:	9a25      	ldr	r2, [sp, #148]	; 0x94
			data_len_total = data_len;
    5334:	b298      	uxth	r0, r3
			} else if (!data) {
    5336:	b932      	cbnz	r2, 5346 <le_adv_ext_report+0x282>
				data_len = data_len_curr;
    5338:	f88d 308e 	strb.w	r3, [sp, #142]	; 0x8e
				data = data_curr;
    533c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    533e:	9125      	str	r1, [sp, #148]	; 0x94
				data_len_total = data_len;
    5340:	9016      	str	r0, [sp, #88]	; 0x58
    5342:	931c      	str	r3, [sp, #112]	; 0x70
    5344:	e7ec      	b.n	5320 <le_adv_ext_report+0x25c>
				data_len_total += data_len_curr;
    5346:	9b16      	ldr	r3, [sp, #88]	; 0x58
    5348:	4403      	add	r3, r0
    534a:	b29b      	uxth	r3, r3
    534c:	9316      	str	r3, [sp, #88]	; 0x58
    534e:	e7e7      	b.n	5320 <le_adv_ext_report+0x25c>
			} else if (has_aux_ptr) {
    5350:	f1b9 0f00 	cmp.w	r9, #0
    5354:	f43f af3e 	beq.w	51d4 <le_adv_ext_report+0x110>
	if (adv_addr) {
    5358:	f1ba 0f00 	cmp.w	sl, #0
    535c:	f000 80c9 	beq.w	54f2 <le_adv_ext_report+0x42e>
	uint8_t scan_data_status = 0U;
    5360:	f8dd 904c 	ldr.w	r9, [sp, #76]	; 0x4c
				data_status =
    5364:	2402      	movs	r4, #2
    5366:	e00c      	b.n	5382 <le_adv_ext_report+0x2be>
		adv = (void *)node_rx_curr->pdu;
    5368:	9b13      	ldr	r3, [sp, #76]	; 0x4c
	do {
    536a:	930f      	str	r3, [sp, #60]	; 0x3c
		adv = (void *)node_rx_curr->pdu;
    536c:	f103 041c 	add.w	r4, r3, #28
		node_rx_next = node_rx_curr->hdr.rx_ftr.extra;
    5370:	68db      	ldr	r3, [r3, #12]
    5372:	9313      	str	r3, [sp, #76]	; 0x4c
	do {
    5374:	e6e7      	b.n	5146 <le_adv_ext_report+0x82>
    5376:	bf00      	nop
    5378:	200000e8 	.word	0x200000e8
    537c:	200000f0 	.word	0x200000f0
	if (adv_addr) {
    5380:	2400      	movs	r4, #0
		    dup_found(PDU_ADV_TYPE_EXT_IND, adv_addr_type, adv_addr,
    5382:	9b12      	ldr	r3, [sp, #72]	; 0x48
    5384:	9300      	str	r3, [sp, #0]
    5386:	9401      	str	r4, [sp, #4]
    5388:	462b      	mov	r3, r5
    538a:	4652      	mov	r2, sl
    538c:	4659      	mov	r1, fp
    538e:	2007      	movs	r0, #7
    5390:	f7ff fdca 	bl	4f28 <dup_found>
		if (dup_scan &&
    5394:	2800      	cmp	r0, #0
    5396:	f47f aebb 	bne.w	5110 <le_adv_ext_report+0x4c>
	if (direct_addr) {
    539a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    539c:	b10b      	cbz	r3, 53a2 <le_adv_ext_report+0x2de>
		evt_type |= BT_HCI_LE_ADV_EVT_TYPE_DIRECT;
    539e:	f045 0504 	orr.w	r5, r5, #4
		rssi = -(node_rx_curr->hdr.rx_ftr.rssi);
    53a2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
	if ((data_len < data_len_total) || (data_len > data_len_max)) {
    53a4:	9916      	ldr	r1, [sp, #88]	; 0x58
		rssi = -(node_rx_curr->hdr.rx_ftr.rssi);
    53a6:	425e      	negs	r6, r3
	evt_buf = buf;
    53a8:	9b19      	ldr	r3, [sp, #100]	; 0x64
    53aa:	9326      	str	r3, [sp, #152]	; 0x98
	if ((data_len < data_len_total) || (data_len > data_len_max)) {
    53ac:	f89d 308e 	ldrb.w	r3, [sp, #142]	; 0x8e
    53b0:	428b      	cmp	r3, r1
		rssi = -(node_rx_curr->hdr.rx_ftr.rssi);
    53b2:	b276      	sxtb	r6, r6
	if ((data_len < data_len_total) || (data_len > data_len_max)) {
    53b4:	d301      	bcc.n	53ba <le_adv_ext_report+0x2f6>
    53b6:	2be5      	cmp	r3, #229	; 0xe5
    53b8:	d922      	bls.n	5400 <le_adv_ext_report+0x33c>
		ext_adv_data_frag(node_rx_data, evt_type, phy, &sec_phy,
    53ba:	ab26      	add	r3, sp, #152	; 0x98
    53bc:	930d      	str	r3, [sp, #52]	; 0x34
    53be:	9b19      	ldr	r3, [sp, #100]	; 0x64
    53c0:	930c      	str	r3, [sp, #48]	; 0x30
    53c2:	ab25      	add	r3, sp, #148	; 0x94
    53c4:	930b      	str	r3, [sp, #44]	; 0x2c
    53c6:	f10d 038e 	add.w	r3, sp, #142	; 0x8e
    53ca:	930a      	str	r3, [sp, #40]	; 0x28
    53cc:	f89d 3058 	ldrb.w	r3, [sp, #88]	; 0x58
    53d0:	9309      	str	r3, [sp, #36]	; 0x24
    53d2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    53d4:	9308      	str	r3, [sp, #32]
    53d6:	9b18      	ldr	r3, [sp, #96]	; 0x60
    53d8:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    53da:	981c      	ldr	r0, [sp, #112]	; 0x70
    53dc:	f8cd b000 	str.w	fp, [sp]
    53e0:	e9cd 6306 	strd	r6, r3, [sp, #24]
    53e4:	9b14      	ldr	r3, [sp, #80]	; 0x50
    53e6:	9305      	str	r3, [sp, #20]
    53e8:	9b11      	ldr	r3, [sp, #68]	; 0x44
    53ea:	9304      	str	r3, [sp, #16]
    53ec:	9b10      	ldr	r3, [sp, #64]	; 0x40
    53ee:	9303      	str	r3, [sp, #12]
    53f0:	9b15      	ldr	r3, [sp, #84]	; 0x54
    53f2:	4629      	mov	r1, r5
    53f4:	e9cd a301 	strd	sl, r3, [sp, #4]
    53f8:	f10d 038f 	add.w	r3, sp, #143	; 0x8f
    53fc:	f00b fd13 	bl	10e26 <ext_adv_data_frag.constprop.0>
	ext_adv_info_fill(evt_type, phy, sec_phy, adv_addr_type, adv_addr,
    5400:	9b26      	ldr	r3, [sp, #152]	; 0x98
    5402:	930a      	str	r3, [sp, #40]	; 0x28
    5404:	9b25      	ldr	r3, [sp, #148]	; 0x94
    5406:	9309      	str	r3, [sp, #36]	; 0x24
    5408:	f89d 308e 	ldrb.w	r3, [sp, #142]	; 0x8e
    540c:	9308      	str	r3, [sp, #32]
    540e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    5410:	9307      	str	r3, [sp, #28]
    5412:	9b18      	ldr	r3, [sp, #96]	; 0x60
    5414:	f89d 208f 	ldrb.w	r2, [sp, #143]	; 0x8f
    5418:	991b      	ldr	r1, [sp, #108]	; 0x6c
    541a:	e9cd 6305 	strd	r6, r3, [sp, #20]
    541e:	9b14      	ldr	r3, [sp, #80]	; 0x50
    5420:	9304      	str	r3, [sp, #16]
    5422:	9b11      	ldr	r3, [sp, #68]	; 0x44
    5424:	9303      	str	r3, [sp, #12]
    5426:	9b10      	ldr	r3, [sp, #64]	; 0x40
    5428:	9302      	str	r3, [sp, #8]
    542a:	9b15      	ldr	r3, [sp, #84]	; 0x54
	evt_type |= (data_status << 5);
    542c:	ea45 1444 	orr.w	r4, r5, r4, lsl #5
	ext_adv_info_fill(evt_type, phy, sec_phy, adv_addr_type, adv_addr,
    5430:	e9cd a300 	strd	sl, r3, [sp]
    5434:	4620      	mov	r0, r4
    5436:	465b      	mov	r3, fp
    5438:	f00b fc77 	bl	10d2a <ext_adv_info_fill>
	if (!scan_data) {
    543c:	9b24      	ldr	r3, [sp, #144]	; 0x90
    543e:	2b00      	cmp	r3, #0
    5440:	f43f ae66 	beq.w	5110 <le_adv_ext_report+0x4c>
	evt_buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
    5444:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5448:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    544c:	2001      	movs	r0, #1
    544e:	f7fd fbef 	bl	2c30 <bt_buf_get_rx>
    5452:	4601      	mov	r1, r0
    5454:	9026      	str	r0, [sp, #152]	; 0x98
	net_buf_frag_add(buf, evt_buf);
    5456:	9819      	ldr	r0, [sp, #100]	; 0x64
    5458:	f00c fd30 	bl	11ebc <net_buf_frag_add>
	if ((scan_data_len < scan_data_len_total) ||
    545c:	f89d 308c 	ldrb.w	r3, [sp, #140]	; 0x8c
    5460:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    5462:	f004 049f 	and.w	r4, r4, #159	; 0x9f
    5466:	4293      	cmp	r3, r2
	evt_type &= ~(BIT_MASK(2) << 5);
    5468:	f044 0408 	orr.w	r4, r4, #8
	if ((scan_data_len < scan_data_len_total) ||
    546c:	d301      	bcc.n	5472 <le_adv_ext_report+0x3ae>
    546e:	2be5      	cmp	r3, #229	; 0xe5
    5470:	d920      	bls.n	54b4 <le_adv_ext_report+0x3f0>
		ext_adv_data_frag(node_rx_scan_data, evt_type, phy,
    5472:	ab26      	add	r3, sp, #152	; 0x98
    5474:	930d      	str	r3, [sp, #52]	; 0x34
    5476:	9b19      	ldr	r3, [sp, #100]	; 0x64
    5478:	930c      	str	r3, [sp, #48]	; 0x30
    547a:	ab24      	add	r3, sp, #144	; 0x90
    547c:	930b      	str	r3, [sp, #44]	; 0x2c
    547e:	ab23      	add	r3, sp, #140	; 0x8c
    5480:	930a      	str	r3, [sp, #40]	; 0x28
    5482:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    5484:	9309      	str	r3, [sp, #36]	; 0x24
    5486:	9b12      	ldr	r3, [sp, #72]	; 0x48
    5488:	9308      	str	r3, [sp, #32]
    548a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    548c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    548e:	981e      	ldr	r0, [sp, #120]	; 0x78
    5490:	f8cd b000 	str.w	fp, [sp]
    5494:	e9cd 6306 	strd	r6, r3, [sp, #24]
    5498:	9b14      	ldr	r3, [sp, #80]	; 0x50
    549a:	9305      	str	r3, [sp, #20]
    549c:	9b11      	ldr	r3, [sp, #68]	; 0x44
    549e:	9304      	str	r3, [sp, #16]
    54a0:	9b10      	ldr	r3, [sp, #64]	; 0x40
    54a2:	9303      	str	r3, [sp, #12]
    54a4:	9b15      	ldr	r3, [sp, #84]	; 0x54
    54a6:	4621      	mov	r1, r4
    54a8:	e9cd a301 	strd	sl, r3, [sp, #4]
    54ac:	f10d 038d 	add.w	r3, sp, #141	; 0x8d
    54b0:	f00b fcb9 	bl	10e26 <ext_adv_data_frag.constprop.0>
	ext_adv_info_fill(evt_type, phy, sec_phy_scan, adv_addr_type, adv_addr,
    54b4:	9b26      	ldr	r3, [sp, #152]	; 0x98
    54b6:	930a      	str	r3, [sp, #40]	; 0x28
    54b8:	9b24      	ldr	r3, [sp, #144]	; 0x90
    54ba:	9309      	str	r3, [sp, #36]	; 0x24
    54bc:	f89d 308c 	ldrb.w	r3, [sp, #140]	; 0x8c
    54c0:	9308      	str	r3, [sp, #32]
    54c2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    54c4:	9307      	str	r3, [sp, #28]
    54c6:	9b18      	ldr	r3, [sp, #96]	; 0x60
    54c8:	f89d 208d 	ldrb.w	r2, [sp, #141]	; 0x8d
    54cc:	991b      	ldr	r1, [sp, #108]	; 0x6c
    54ce:	e9cd 6305 	strd	r6, r3, [sp, #20]
    54d2:	9b14      	ldr	r3, [sp, #80]	; 0x50
    54d4:	9304      	str	r3, [sp, #16]
    54d6:	9b11      	ldr	r3, [sp, #68]	; 0x44
    54d8:	9303      	str	r3, [sp, #12]
    54da:	9b10      	ldr	r3, [sp, #64]	; 0x40
    54dc:	9302      	str	r3, [sp, #8]
    54de:	9b15      	ldr	r3, [sp, #84]	; 0x54
	evt_type |= (scan_data_status << 5);
    54e0:	ea44 1049 	orr.w	r0, r4, r9, lsl #5
	ext_adv_info_fill(evt_type, phy, sec_phy_scan, adv_addr_type, adv_addr,
    54e4:	e9cd a300 	strd	sl, r3, [sp]
    54e8:	b2c0      	uxtb	r0, r0
    54ea:	465b      	mov	r3, fp
    54ec:	f00b fc1d 	bl	10d2a <ext_adv_info_fill>
    54f0:	e60e      	b.n	5110 <le_adv_ext_report+0x4c>
		if (!(adv_addr ||
    54f2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    54f4:	2b00      	cmp	r3, #0
    54f6:	f43f ae0b 	beq.w	5110 <le_adv_ext_report+0x4c>
		      (adi && ((tx_pwr != BT_HCI_LE_ADV_TX_POWER_NO_PREF) ||
    54fa:	9b14      	ldr	r3, [sp, #80]	; 0x50
    54fc:	2b7f      	cmp	r3, #127	; 0x7f
    54fe:	d103      	bne.n	5508 <le_adv_ext_report+0x444>
    5500:	9b25      	ldr	r3, [sp, #148]	; 0x94
    5502:	2b00      	cmp	r3, #0
    5504:	f43f ae04 	beq.w	5110 <le_adv_ext_report+0x4c>
	uint8_t scan_data_status = 0U;
    5508:	46d1      	mov	r9, sl
				data_status =
    550a:	2402      	movs	r4, #2
    550c:	e745      	b.n	539a <le_adv_ext_report+0x2d6>
	const uint8_t evt_type_lookup[] = {
    550e:	4a46      	ldr	r2, [pc, #280]	; (5628 <le_adv_ext_report+0x564>)
    5510:	6810      	ldr	r0, [r2, #0]
    5512:	9026      	str	r0, [sp, #152]	; 0x98
    5514:	8890      	ldrh	r0, [r2, #4]
    5516:	7992      	ldrb	r2, [r2, #6]
    5518:	f8ad 009c 	strh.w	r0, [sp, #156]	; 0x9c
    551c:	f88d 209e 	strb.w	r2, [sp, #158]	; 0x9e
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5520:	2b00      	cmp	r3, #0
    5522:	f43f adf9 	beq.w	5118 <le_adv_ext_report+0x54>
	    !(le_event_mask & BT_EVT_MASK_LE_EXT_ADVERTISING_REPORT)) {
    5526:	4b41      	ldr	r3, [pc, #260]	; (562c <le_adv_ext_report+0x568>)
    5528:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    552a:	04da      	lsls	r2, r3, #19
    552c:	f57f adf4 	bpl.w	5118 <le_adv_ext_report+0x54>
	direct_report = node_rx->hdr.rx_ftr.direct;
    5530:	f898 701a 	ldrb.w	r7, [r8, #26]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
    5534:	f898 9018 	ldrb.w	r9, [r8, #24]
	rl_idx = node_rx->hdr.rx_ftr.rl_idx;
    5538:	f898 a019 	ldrb.w	sl, [r8, #25]
	if (adv->tx_addr) {
    553c:	064b      	lsls	r3, r1, #25
	direct_report = node_rx->hdr.rx_ftr.direct;
    553e:	f3c7 0740 	ubfx	r7, r7, #1, #1
		ll_rl_crpa_set(0x00, NULL, rl_idx, &adv->adv_ind.addr[0]);
    5542:	f104 0802 	add.w	r8, r4, #2
	if (adv->tx_addr) {
    5546:	d505      	bpl.n	5554 <le_adv_ext_report+0x490>
		ll_rl_crpa_set(0x00, NULL, rl_idx, &adv->adv_ind.addr[0]);
    5548:	2100      	movs	r1, #0
    554a:	4643      	mov	r3, r8
    554c:	4652      	mov	r2, sl
    554e:	4608      	mov	r0, r1
    5550:	f003 fc2e 	bl	8db0 <ll_rl_crpa_set>
	    dup_found(adv->type, adv->tx_addr, adv->adv_ind.addr, 0, NULL, 0)) {
    5554:	7820      	ldrb	r0, [r4, #0]
    5556:	2300      	movs	r3, #0
    5558:	f3c0 1180 	ubfx	r1, r0, #6, #1
    555c:	e9cd 3300 	strd	r3, r3, [sp]
    5560:	4642      	mov	r2, r8
    5562:	f000 000f 	and.w	r0, r0, #15
    5566:	f7ff fcdf 	bl	4f28 <dup_found>
	if (dup_scan &&
    556a:	4606      	mov	r6, r0
    556c:	2800      	cmp	r0, #0
    556e:	f47f add3 	bne.w	5118 <le_adv_ext_report+0x54>
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
    5572:	7823      	ldrb	r3, [r4, #0]
	sep = meta_evt(buf, BT_HCI_EVT_LE_EXT_ADVERTISING_REPORT,
    5574:	9819      	ldr	r0, [sp, #100]	; 0x64
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
    5576:	f003 030f 	and.w	r3, r3, #15
    557a:	2b01      	cmp	r3, #1
		data_len = (adv->len - BDADDR_SIZE);
    557c:	bf1e      	ittt	ne
    557e:	7866      	ldrbne	r6, [r4, #1]
    5580:	3e06      	subne	r6, #6
    5582:	b2f6      	uxtbne	r6, r6
	sep = meta_evt(buf, BT_HCI_EVT_LE_EXT_ADVERTISING_REPORT,
    5584:	f106 0219 	add.w	r2, r6, #25
    5588:	b2d2      	uxtb	r2, r2
    558a:	210d      	movs	r1, #13
    558c:	f00b fbb5 	bl	10cfa <meta_evt>
	sep->num_reports = 1U;
    5590:	2301      	movs	r3, #1
    5592:	7003      	strb	r3, [r0, #0]
	adv_info->evt_type = evt_type_lookup[adv->type];
    5594:	7823      	ldrb	r3, [r4, #0]
    5596:	aa28      	add	r2, sp, #160	; 0xa0
    5598:	f003 030f 	and.w	r3, r3, #15
    559c:	4413      	add	r3, r2
	sep = meta_evt(buf, BT_HCI_EVT_LE_EXT_ADVERTISING_REPORT,
    559e:	4605      	mov	r5, r0
	adv_info->evt_type = evt_type_lookup[adv->type];
    55a0:	f813 3c08 	ldrb.w	r3, [r3, #-8]
    55a4:	f8a0 3001 	strh.w	r3, [r0, #1]
	if (rl_idx < ll_rl_size_get()) {
    55a8:	f00c f8a5 	bl	116f6 <ll_rl_size_get>
    55ac:	4582      	cmp	sl, r0
    55ae:	f105 0004 	add.w	r0, r5, #4
    55b2:	d22b      	bcs.n	560c <le_adv_ext_report+0x548>
		ll_rl_id_addr_get(rl_idx, &adv_info->addr.type,
    55b4:	4602      	mov	r2, r0
    55b6:	1ce9      	adds	r1, r5, #3
    55b8:	4650      	mov	r0, sl
    55ba:	f003 f82f 	bl	861c <ll_rl_id_addr_get>
		adv_info->addr.type += 2U;
    55be:	78eb      	ldrb	r3, [r5, #3]
    55c0:	3302      	adds	r3, #2
    55c2:	70eb      	strb	r3, [r5, #3]
	adv_info->prim_phy = BT_HCI_LE_EXT_SCAN_PHY_1M;
    55c4:	2301      	movs	r3, #1
	adv_info->sid = 0xff;
    55c6:	22ff      	movs	r2, #255	; 0xff
	adv_info->prim_phy = BT_HCI_LE_EXT_SCAN_PHY_1M;
    55c8:	72ab      	strb	r3, [r5, #10]
	adv_info->sid = 0xff;
    55ca:	732a      	strb	r2, [r5, #12]
	adv_info->sec_phy = 0U;
    55cc:	2300      	movs	r3, #0
	adv_info->tx_power = BT_HCI_LE_ADV_TX_POWER_NO_PREF;
    55ce:	227f      	movs	r2, #127	; 0x7f
	rssi = -(node_rx->hdr.rx_ftr.rssi);
    55d0:	f1c9 0900 	rsb	r9, r9, #0
	adv_info->tx_power = BT_HCI_LE_ADV_TX_POWER_NO_PREF;
    55d4:	736a      	strb	r2, [r5, #13]
	adv_info->sec_phy = 0U;
    55d6:	72eb      	strb	r3, [r5, #11]
	adv_info->rssi = rssi;
    55d8:	f885 900e 	strb.w	r9, [r5, #14]
	adv_info->interval = 0U;
    55dc:	73eb      	strb	r3, [r5, #15]
    55de:	742b      	strb	r3, [r5, #16]
	adv_info->direct_addr.type = adv->rx_addr;
    55e0:	f814 3b08 	ldrb.w	r3, [r4], #8
    55e4:	f3c3 13c0 	ubfx	r3, r3, #7, #1
    55e8:	746b      	strb	r3, [r5, #17]
		memcpy(&adv_info->direct_addr.a.val[0],
    55ea:	f105 0012 	add.w	r0, r5, #18
    55ee:	2206      	movs	r2, #6
	if (direct_report) {
    55f0:	b1af      	cbz	r7, 561e <le_adv_ext_report+0x55a>
		memcpy(&adv_info->direct_addr.a.val[0],
    55f2:	4621      	mov	r1, r4
    55f4:	f00a fad7 	bl	fba6 <memcpy>
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
    55f8:	4632      	mov	r2, r6
    55fa:	4621      	mov	r1, r4
    55fc:	f105 0019 	add.w	r0, r5, #25
	adv_info->length = data_len;
    5600:	762e      	strb	r6, [r5, #24]
}
    5602:	b029      	add	sp, #164	; 0xa4
    5604:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
    5608:	f00a bacd 	b.w	fba6 <memcpy>
		adv_info->addr.type = adv->tx_addr;
    560c:	7823      	ldrb	r3, [r4, #0]
    560e:	f3c3 1380 	ubfx	r3, r3, #6, #1
    5612:	70eb      	strb	r3, [r5, #3]
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
    5614:	2206      	movs	r2, #6
    5616:	4641      	mov	r1, r8
    5618:	f00a fac5 	bl	fba6 <memcpy>
    561c:	e7d2      	b.n	55c4 <le_adv_ext_report+0x500>
		memset(&adv_info->direct_addr.a.val[0], 0, sizeof(bt_addr_t));
    561e:	4639      	mov	r1, r7
    5620:	f00a facc 	bl	fbbc <memset>
    5624:	e7e8      	b.n	55f8 <le_adv_ext_report+0x534>
    5626:	bf00      	nop
    5628:	00013533 	.word	0x00013533
    562c:	200000f0 	.word	0x200000f0

00005630 <hci_cmd_complete>:
{
    5630:	b538      	push	{r3, r4, r5, lr}
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    5632:	4b06      	ldr	r3, [pc, #24]	; (564c <hci_cmd_complete+0x1c>)
{
    5634:	4605      	mov	r5, r0
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    5636:	8818      	ldrh	r0, [r3, #0]
{
    5638:	460c      	mov	r4, r1
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
    563a:	f00a fb6a 	bl	fd12 <bt_hci_cmd_complete_create>
    563e:	4621      	mov	r1, r4
    5640:	6028      	str	r0, [r5, #0]
}
    5642:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5646:	3008      	adds	r0, #8
    5648:	f00c bc55 	b.w	11ef6 <net_buf_simple_add>
    564c:	200026e0 	.word	0x200026e0

00005650 <hci_vendor_cmd_handle_common>:
{
    5650:	b5f0      	push	{r4, r5, r6, r7, lr}
	switch (ocf) {
    5652:	3801      	subs	r0, #1
{
    5654:	b087      	sub	sp, #28
    5656:	4614      	mov	r4, r2
	switch (ocf) {
    5658:	2809      	cmp	r0, #9
    565a:	d87d      	bhi.n	5758 <hci_vendor_cmd_handle_common+0x108>
    565c:	e8df f000 	tbb	[pc, r0]
    5660:	7c331c05 	.word	0x7c331c05
    5664:	3f7c5a7c 	.word	0x3f7c5a7c
    5668:	7063      	.short	0x7063
	rp = hci_cmd_complete(evt, sizeof(*rp));
    566a:	210d      	movs	r1, #13
    566c:	4610      	mov	r0, r2
    566e:	f7ff ffdf 	bl	5630 <hci_cmd_complete>
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    5672:	2302      	movs	r3, #2
    5674:	7043      	strb	r3, [r0, #1]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
    5676:	70c3      	strb	r3, [r0, #3]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
    5678:	7183      	strb	r3, [r0, #6]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
    567a:	2307      	movs	r3, #7
	rp->status = 0x00;
    567c:	2100      	movs	r1, #0
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
    567e:	71c3      	strb	r3, [r0, #7]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
    5680:	2363      	movs	r3, #99	; 0x63
	rp->status = 0x00;
    5682:	7001      	strb	r1, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
    5684:	7081      	strb	r1, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
    5686:	7101      	strb	r1, [r0, #4]
	rp->fw_variant = 0U;
    5688:	7141      	strb	r1, [r0, #5]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
    568a:	7201      	strb	r1, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
    568c:	7243      	strb	r3, [r0, #9]
    568e:	7281      	strb	r1, [r0, #10]
    5690:	72c1      	strb	r1, [r0, #11]
    5692:	7301      	strb	r1, [r0, #12]
	return 0;
    5694:	2400      	movs	r4, #0
}
    5696:	e013      	b.n	56c0 <hci_vendor_cmd_handle_common+0x70>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5698:	2141      	movs	r1, #65	; 0x41
    569a:	4610      	mov	r0, r2
    569c:	f7ff ffc8 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    56a0:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    56a2:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    56a4:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
    56a6:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    56aa:	4621      	mov	r1, r4
    56ac:	f00a fa86 	bl	fbbc <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
    56b0:	786b      	ldrb	r3, [r5, #1]
    56b2:	f063 0358 	orn	r3, r3, #88	; 0x58
    56b6:	706b      	strb	r3, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
    56b8:	78ab      	ldrb	r3, [r5, #2]
    56ba:	f043 0303 	orr.w	r3, r3, #3
    56be:	70ab      	strb	r3, [r5, #2]
}
    56c0:	4620      	mov	r0, r4
    56c2:	b007      	add	sp, #28
    56c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
    56c6:	2109      	movs	r1, #9
    56c8:	4610      	mov	r0, r2
    56ca:	f7ff ffb1 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    56ce:	2400      	movs	r4, #0
    56d0:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    56d4:	2208      	movs	r2, #8
    56d6:	4621      	mov	r1, r4
    56d8:	f00a fa70 	bl	fbbc <memset>
}
    56dc:	e7f0      	b.n	56c0 <hci_vendor_cmd_handle_common+0x70>
	const char build_info[] = HCI_VS_BUILD_INFO;
    56de:	4b20      	ldr	r3, [pc, #128]	; (5760 <hci_vendor_cmd_handle_common+0x110>)
    56e0:	aa01      	add	r2, sp, #4
    56e2:	f103 0710 	add.w	r7, r3, #16
    56e6:	4616      	mov	r6, r2
    56e8:	6818      	ldr	r0, [r3, #0]
    56ea:	6859      	ldr	r1, [r3, #4]
    56ec:	4615      	mov	r5, r2
    56ee:	c503      	stmia	r5!, {r0, r1}
    56f0:	3308      	adds	r3, #8
    56f2:	42bb      	cmp	r3, r7
    56f4:	462a      	mov	r2, r5
    56f6:	d1f7      	bne.n	56e8 <hci_vendor_cmd_handle_common+0x98>
    56f8:	881b      	ldrh	r3, [r3, #0]
    56fa:	802b      	strh	r3, [r5, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
    56fc:	2113      	movs	r1, #19
    56fe:	4620      	mov	r0, r4
    5700:	f7ff ff96 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5704:	2400      	movs	r4, #0
    5706:	f800 4b01 	strb.w	r4, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
    570a:	2212      	movs	r2, #18
    570c:	4631      	mov	r1, r6
    570e:	f00a fa4a 	bl	fba6 <memcpy>
}
    5712:	e7d5      	b.n	56c0 <hci_vendor_cmd_handle_common+0x70>
	ll_addr_set(0, &cmd->bdaddr.val[0]);
    5714:	6889      	ldr	r1, [r1, #8]
    5716:	2000      	movs	r0, #0
    5718:	f7ff fad4 	bl	4cc4 <ll_addr_set>
	*evt = cmd_complete_status(0x00);
    571c:	2000      	movs	r0, #0
    571e:	f7ff fbf1 	bl	4f04 <cmd_complete_status>
    5722:	6020      	str	r0, [r4, #0]
    5724:	e7b6      	b.n	5694 <hci_vendor_cmd_handle_common+0x44>
	rp = hci_cmd_complete(evt, sizeof(*rp) +
    5726:	2118      	movs	r1, #24
    5728:	4610      	mov	r0, r2
    572a:	f7ff ff81 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    572e:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp) +
    5730:	4605      	mov	r5, r0
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
    5732:	2101      	movs	r1, #1
	rp->status = 0x00;
    5734:	f800 4b02 	strb.w	r4, [r0], #2
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
    5738:	f00c faf3 	bl	11d22 <hci_vendor_read_static_addr>
    573c:	7068      	strb	r0, [r5, #1]
}
    573e:	e7bf      	b.n	56c0 <hci_vendor_cmd_handle_common+0x70>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5740:	2121      	movs	r1, #33	; 0x21
    5742:	4610      	mov	r0, r2
    5744:	f7ff ff74 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5748:	4601      	mov	r1, r0
    574a:	2400      	movs	r4, #0
    574c:	f801 4b11 	strb.w	r4, [r1], #17
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
    5750:	3001      	adds	r0, #1
    5752:	f00c fb3c 	bl	11dce <hci_vendor_read_key_hierarchy_roots>
}
    5756:	e7b3      	b.n	56c0 <hci_vendor_cmd_handle_common+0x70>
	switch (ocf) {
    5758:	f06f 0415 	mvn.w	r4, #21
    575c:	e7b0      	b.n	56c0 <hci_vendor_cmd_handle_common+0x70>
    575e:	bf00      	nop
    5760:	0001353b 	.word	0x0001353b

00005764 <hci_cmd_handle>:
{
    5764:	b570      	push	{r4, r5, r6, lr}
	if (cmd->len < sizeof(*chdr)) {
    5766:	8983      	ldrh	r3, [r0, #12]
{
    5768:	b092      	sub	sp, #72	; 0x48
	struct net_buf *evt = NULL;
    576a:	2500      	movs	r5, #0
	if (cmd->len < sizeof(*chdr)) {
    576c:	2b02      	cmp	r3, #2
{
    576e:	4604      	mov	r4, r0
	struct net_buf *evt = NULL;
    5770:	950d      	str	r5, [sp, #52]	; 0x34
	if (cmd->len < sizeof(*chdr)) {
    5772:	d802      	bhi.n	577a <hci_cmd_handle+0x16>
		return NULL;
    5774:	2000      	movs	r0, #0
}
    5776:	b012      	add	sp, #72	; 0x48
    5778:	bd70      	pop	{r4, r5, r6, pc}
	return net_buf_simple_pull_mem(&buf->b, len);
    577a:	2103      	movs	r1, #3
    577c:	3008      	adds	r0, #8
    577e:	f00c fbe3 	bl	11f48 <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
    5782:	89a2      	ldrh	r2, [r4, #12]
    5784:	7883      	ldrb	r3, [r0, #2]
    5786:	429a      	cmp	r2, r3
    5788:	d3f4      	bcc.n	5774 <hci_cmd_handle+0x10>
	_opcode = sys_le16_to_cpu(chdr->opcode);
    578a:	8803      	ldrh	r3, [r0, #0]
    578c:	4ed8      	ldr	r6, [pc, #864]	; (5af0 <hci_cmd_handle+0x38c>)
	ocf = BT_OCF(_opcode);
    578e:	f3c3 0009 	ubfx	r0, r3, #0, #10
	_opcode = sys_le16_to_cpu(chdr->opcode);
    5792:	8033      	strh	r3, [r6, #0]
	switch (BT_OGF(_opcode)) {
    5794:	f3c3 2385 	ubfx	r3, r3, #10, #6
    5798:	2b08      	cmp	r3, #8
    579a:	f000 80d2 	beq.w	5942 <hci_cmd_handle+0x1de>
    579e:	d808      	bhi.n	57b2 <hci_cmd_handle+0x4e>
    57a0:	2b03      	cmp	r3, #3
    57a2:	d00f      	beq.n	57c4 <hci_cmd_handle+0x60>
    57a4:	2b04      	cmp	r3, #4
    57a6:	d031      	beq.n	580c <hci_cmd_handle+0xa8>
	return bt_hci_cmd_status_create(_opcode, status);
    57a8:	8830      	ldrh	r0, [r6, #0]
    57aa:	2101      	movs	r1, #1
    57ac:	f00a fac3 	bl	fd36 <bt_hci_cmd_status_create>
    57b0:	e02a      	b.n	5808 <hci_cmd_handle+0xa4>
	switch (BT_OGF(_opcode)) {
    57b2:	2b3f      	cmp	r3, #63	; 0x3f
    57b4:	d1f8      	bne.n	57a8 <hci_cmd_handle+0x44>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(uint16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
    57b6:	aa0d      	add	r2, sp, #52	; 0x34
    57b8:	4621      	mov	r1, r4
    57ba:	f7ff ff49 	bl	5650 <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
    57be:	3016      	adds	r0, #22
    57c0:	d0f2      	beq.n	57a8 <hci_cmd_handle+0x44>
    57c2:	e0a3      	b.n	590c <hci_cmd_handle+0x1a8>
	switch (ocf) {
    57c4:	2803      	cmp	r0, #3
    57c6:	d00a      	beq.n	57de <hci_cmd_handle+0x7a>
    57c8:	2863      	cmp	r0, #99	; 0x63
    57ca:	d01a      	beq.n	5802 <hci_cmd_handle+0x9e>
    57cc:	2801      	cmp	r0, #1
    57ce:	d1eb      	bne.n	57a8 <hci_cmd_handle+0x44>
	event_mask = sys_get_le64(cmd->events);
    57d0:	68a0      	ldr	r0, [r4, #8]
    57d2:	f00b fbc9 	bl	10f68 <sys_get_le64>
    57d6:	4bc7      	ldr	r3, [pc, #796]	; (5af4 <hci_cmd_handle+0x390>)
	le_event_mask = sys_get_le64(cmd->events);
    57d8:	e9c3 0100 	strd	r0, r1, [r3]
    57dc:	e011      	b.n	5802 <hci_cmd_handle+0x9e>
	dup_count = DUP_FILTER_DISABLED;
    57de:	4bc6      	ldr	r3, [pc, #792]	; (5af8 <hci_cmd_handle+0x394>)
    57e0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    57e4:	601a      	str	r2, [r3, #0]
	event_mask = DEFAULT_EVENT_MASK;
    57e6:	4bc3      	ldr	r3, [pc, #780]	; (5af4 <hci_cmd_handle+0x390>)
    57e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    57ec:	f641 71ff 	movw	r1, #8191	; 0x1fff
    57f0:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
    57f4:	4bc1      	ldr	r3, [pc, #772]	; (5afc <hci_cmd_handle+0x398>)
    57f6:	201f      	movs	r0, #31
    57f8:	2100      	movs	r1, #0
    57fa:	e9c3 0100 	strd	r0, r1, [r3]
		ll_reset();
    57fe:	f001 f975 	bl	6aec <ll_reset>
	*evt = cmd_complete_status(0x00);
    5802:	2000      	movs	r0, #0
	*evt = cmd_complete_status(status);
    5804:	f7ff fb7e 	bl	4f04 <cmd_complete_status>
		evt = cmd_status(BT_HCI_ERR_UNKNOWN_CMD);
    5808:	900d      	str	r0, [sp, #52]	; 0x34
    580a:	e07f      	b.n	590c <hci_cmd_handle+0x1a8>
	switch (ocf) {
    580c:	3801      	subs	r0, #1
    580e:	2808      	cmp	r0, #8
    5810:	d8ca      	bhi.n	57a8 <hci_cmd_handle+0x44>
    5812:	a301      	add	r3, pc, #4	; (adr r3, 5818 <hci_cmd_handle+0xb4>)
    5814:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
    5818:	0000583d 	.word	0x0000583d
    581c:	00005867 	.word	0x00005867
    5820:	00005911 	.word	0x00005911
    5824:	000057a9 	.word	0x000057a9
    5828:	000057a9 	.word	0x000057a9
    582c:	000057a9 	.word	0x000057a9
    5830:	000057a9 	.word	0x000057a9
    5834:	000057a9 	.word	0x000057a9
    5838:	0000592d 	.word	0x0000592d
	rp = hci_cmd_complete(evt, sizeof(*rp));
    583c:	2109      	movs	r1, #9
    583e:	a80d      	add	r0, sp, #52	; 0x34
    5840:	f7ff fef6 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5844:	2300      	movs	r3, #0
    5846:	7003      	strb	r3, [r0, #0]
	rp->hci_revision = sys_cpu_to_le16(0);
    5848:	7083      	strb	r3, [r0, #2]
    584a:	70c3      	strb	r3, [r0, #3]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
    584c:	f06f 030e 	mvn.w	r3, #14
	rp->hci_version = LL_VERSION_NUMBER;
    5850:	220c      	movs	r2, #12
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
    5852:	7143      	strb	r3, [r0, #5]
    5854:	2305      	movs	r3, #5
    5856:	7183      	strb	r3, [r0, #6]
	rp->hci_version = LL_VERSION_NUMBER;
    5858:	7042      	strb	r2, [r0, #1]
	rp->lmp_version = LL_VERSION_NUMBER;
    585a:	7102      	strb	r2, [r0, #4]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
    585c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	dst[0] = val;
    5860:	71c3      	strb	r3, [r0, #7]
	dst[1] = val >> 8;
    5862:	7203      	strb	r3, [r0, #8]
	if (err == -EINVAL) {
    5864:	e052      	b.n	590c <hci_cmd_handle+0x1a8>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5866:	2141      	movs	r1, #65	; 0x41
    5868:	a80d      	add	r0, sp, #52	; 0x34
    586a:	f7ff fee1 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    586e:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5870:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    5872:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
    5874:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
    5878:	f00a f9a0 	bl	fbbc <memset>
	rp->commands[5] |= BIT(6) | BIT(7);
    587c:	79a3      	ldrb	r3, [r4, #6]
	rp->commands[27] |= BIT(6) | BIT(7);
    587e:	7f21      	ldrb	r1, [r4, #28]
	rp->commands[26] |= BIT(6) | BIT(7);
    5880:	7ee2      	ldrb	r2, [r4, #27]
	rp->commands[5] |= BIT(6) | BIT(7);
    5882:	f063 033f 	orn	r3, r3, #63	; 0x3f
    5886:	71a3      	strb	r3, [r4, #6]
	rp->commands[10] |= BIT(2);
    5888:	7ae3      	ldrb	r3, [r4, #11]
    588a:	f043 0304 	orr.w	r3, r3, #4
    588e:	72e3      	strb	r3, [r4, #11]
	rp->commands[14] |= BIT(3) | BIT(5);
    5890:	7be3      	ldrb	r3, [r4, #15]
    5892:	f043 0328 	orr.w	r3, r3, #40	; 0x28
    5896:	73e3      	strb	r3, [r4, #15]
	rp->commands[15] |= BIT(1);
    5898:	7c23      	ldrb	r3, [r4, #16]
    589a:	f043 0302 	orr.w	r3, r3, #2
    589e:	7423      	strb	r3, [r4, #16]
	rp->commands[22] |= BIT(2);
    58a0:	7de3      	ldrb	r3, [r4, #23]
    58a2:	f043 0304 	orr.w	r3, r3, #4
    58a6:	75e3      	strb	r3, [r4, #23]
	rp->commands[25] |= BIT(0) | BIT(1) | BIT(2) | BIT(4);
    58a8:	7ea3      	ldrb	r3, [r4, #26]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
    58aa:	f063 0308 	orn	r3, r3, #8
    58ae:	76a3      	strb	r3, [r4, #26]
	rp->commands[36] |= BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) |
    58b0:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    58b4:	f063 0301 	orn	r3, r3, #1
    58b8:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
	rp->commands[37] |= BIT(0) | BIT(1);
    58bc:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
	rp->commands[37] |= BIT(5) | BIT(6);
    58c0:	f043 0363 	orr.w	r3, r3, #99	; 0x63
    58c4:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
	rp->commands[34] |= BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7);
    58c8:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    58cc:	f063 0307 	orn	r3, r3, #7
    58d0:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
    58d4:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    58d8:	f043 0307 	orr.w	r3, r3, #7
    58dc:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	rp->commands[39] |= BIT(2);
    58e0:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
	rp->commands[27] |= BIT(6) | BIT(7);
    58e4:	f061 013c 	orn	r1, r1, #60	; 0x3c
	rp->commands[39] |= BIT(2);
    58e8:	f043 0304 	orr.w	r3, r3, #4
	rp->commands[27] |= BIT(6) | BIT(7);
    58ec:	7721      	strb	r1, [r4, #28]
	rp->commands[39] |= BIT(2);
    58ee:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	rp->commands[28] |= BIT(3);
    58f2:	7f61      	ldrb	r1, [r4, #29]
	rp->commands[38] |= BIT(7);
    58f4:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
	rp->commands[28] |= BIT(3);
    58f8:	f041 0108 	orr.w	r1, r1, #8
	rp->commands[26] |= BIT(2) | BIT(3);
    58fc:	f062 0230 	orn	r2, r2, #48	; 0x30
	rp->commands[38] |= BIT(7);
    5900:	f063 037f 	orn	r3, r3, #127	; 0x7f
	rp->commands[28] |= BIT(3);
    5904:	7761      	strb	r1, [r4, #29]
	rp->commands[26] |= BIT(2) | BIT(3);
    5906:	76e2      	strb	r2, [r4, #27]
	rp->commands[38] |= BIT(7);
    5908:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
	return evt;
    590c:	980d      	ldr	r0, [sp, #52]	; 0x34
    590e:	e732      	b.n	5776 <hci_cmd_handle+0x12>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5910:	2109      	movs	r1, #9
    5912:	a80d      	add	r0, sp, #52	; 0x34
    5914:	f7ff fe8c 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5918:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    591a:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    591c:	2208      	movs	r2, #8
	rp->status = 0x00;
    591e:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    5922:	f00a f94b 	bl	fbbc <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
    5926:	2360      	movs	r3, #96	; 0x60
    5928:	7163      	strb	r3, [r4, #5]
	if (err == -EINVAL) {
    592a:	e7ef      	b.n	590c <hci_cmd_handle+0x1a8>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    592c:	2107      	movs	r1, #7
    592e:	a80d      	add	r0, sp, #52	; 0x34
    5930:	f7ff fe7e 	bl	5630 <hci_cmd_complete>
    5934:	4601      	mov	r1, r0
	rp->status = 0x00;
    5936:	2000      	movs	r0, #0
    5938:	f801 0b01 	strb.w	r0, [r1], #1
	(void)ll_addr_read(0, &rp->bdaddr.val[0]);
    593c:	f00b f98a 	bl	10c54 <ll_addr_read>
	if (err == -EINVAL) {
    5940:	e7e4      	b.n	590c <hci_cmd_handle+0x1a8>
	switch (ocf) {
    5942:	3801      	subs	r0, #1
    5944:	284d      	cmp	r0, #77	; 0x4d
    5946:	f63f af2f 	bhi.w	57a8 <hci_cmd_handle+0x44>
    594a:	a301      	add	r3, pc, #4	; (adr r3, 5950 <hci_cmd_handle+0x1ec>)
    594c:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
    5950:	00005a89 	.word	0x00005a89
    5954:	00005a93 	.word	0x00005a93
    5958:	00005aab 	.word	0x00005aab
    595c:	000057a9 	.word	0x000057a9
    5960:	00005ae7 	.word	0x00005ae7
    5964:	00005b85 	.word	0x00005b85
    5968:	00005b85 	.word	0x00005b85
    596c:	00005b85 	.word	0x00005b85
    5970:	00005b85 	.word	0x00005b85
    5974:	00005b85 	.word	0x00005b85
    5978:	00005b85 	.word	0x00005b85
    597c:	00005b85 	.word	0x00005b85
    5980:	000057a9 	.word	0x000057a9
    5984:	000057a9 	.word	0x000057a9
    5988:	00005b01 	.word	0x00005b01
    598c:	00005b17 	.word	0x00005b17
    5990:	00005b1d 	.word	0x00005b1d
    5994:	00005b25 	.word	0x00005b25
    5998:	000057a9 	.word	0x000057a9
    599c:	000057a9 	.word	0x000057a9
    59a0:	000057a9 	.word	0x000057a9
    59a4:	000057a9 	.word	0x000057a9
    59a8:	00005b2d 	.word	0x00005b2d
    59ac:	00005b53 	.word	0x00005b53
    59b0:	000057a9 	.word	0x000057a9
    59b4:	000057a9 	.word	0x000057a9
    59b8:	000057a9 	.word	0x000057a9
    59bc:	00005b69 	.word	0x00005b69
    59c0:	000057a9 	.word	0x000057a9
    59c4:	000057a9 	.word	0x000057a9
    59c8:	000057a9 	.word	0x000057a9
    59cc:	000057a9 	.word	0x000057a9
    59d0:	000057a9 	.word	0x000057a9
    59d4:	000057a9 	.word	0x000057a9
    59d8:	000057a9 	.word	0x000057a9
    59dc:	000057a9 	.word	0x000057a9
    59e0:	000057a9 	.word	0x000057a9
    59e4:	000057a9 	.word	0x000057a9
    59e8:	00005cf9 	.word	0x00005cf9
    59ec:	00005d07 	.word	0x00005d07
    59f0:	00005d0f 	.word	0x00005d0f
    59f4:	00005d15 	.word	0x00005d15
    59f8:	00005d25 	.word	0x00005d25
    59fc:	00005d45 	.word	0x00005d45
    5a00:	00005d63 	.word	0x00005d63
    5a04:	00005d6d 	.word	0x00005d6d
    5a08:	000057a9 	.word	0x000057a9
    5a0c:	000057a9 	.word	0x000057a9
    5a10:	000057a9 	.word	0x000057a9
    5a14:	000057a9 	.word	0x000057a9
    5a18:	000057a9 	.word	0x000057a9
    5a1c:	000057a9 	.word	0x000057a9
    5a20:	00005b89 	.word	0x00005b89
    5a24:	00005b95 	.word	0x00005b95
    5a28:	00005c0d 	.word	0x00005c0d
    5a2c:	00005c21 	.word	0x00005c21
    5a30:	00005c35 	.word	0x00005c35
    5a34:	00005c6b 	.word	0x00005c6b
    5a38:	00005c83 	.word	0x00005c83
    5a3c:	00005c95 	.word	0x00005c95
    5a40:	00005c9f 	.word	0x00005c9f
    5a44:	000057a9 	.word	0x000057a9
    5a48:	000057a9 	.word	0x000057a9
    5a4c:	000057a9 	.word	0x000057a9
    5a50:	00005ca5 	.word	0x00005ca5
    5a54:	00005ccf 	.word	0x00005ccf
    5a58:	000057a9 	.word	0x000057a9
    5a5c:	000057a9 	.word	0x000057a9
    5a60:	000057a9 	.word	0x000057a9
    5a64:	000057a9 	.word	0x000057a9
    5a68:	000057a9 	.word	0x000057a9
    5a6c:	000057a9 	.word	0x000057a9
    5a70:	000057a9 	.word	0x000057a9
    5a74:	000057a9 	.word	0x000057a9
    5a78:	00005d81 	.word	0x00005d81
    5a7c:	000057a9 	.word	0x000057a9
    5a80:	000057a9 	.word	0x000057a9
    5a84:	00005d77 	.word	0x00005d77
	le_event_mask = sys_get_le64(cmd->events);
    5a88:	68a0      	ldr	r0, [r4, #8]
    5a8a:	f00b fa6d 	bl	10f68 <sys_get_le64>
    5a8e:	4b1b      	ldr	r3, [pc, #108]	; (5afc <hci_cmd_handle+0x398>)
    5a90:	e6a2      	b.n	57d8 <hci_cmd_handle+0x74>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5a92:	2104      	movs	r1, #4
    5a94:	a80d      	add	r0, sp, #52	; 0x34
    5a96:	f7ff fdcb 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5a9a:	2300      	movs	r3, #0
    5a9c:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(LL_LENGTH_OCTETS_TX_MAX);
    5a9e:	221b      	movs	r2, #27
    5aa0:	7083      	strb	r3, [r0, #2]
	rp->le_max_num = CONFIG_BT_BUF_ACL_TX_COUNT;
    5aa2:	2303      	movs	r3, #3
	rp->le_max_len = sys_cpu_to_le16(LL_LENGTH_OCTETS_TX_MAX);
    5aa4:	7042      	strb	r2, [r0, #1]
	rp->le_max_num = CONFIG_BT_BUF_ACL_TX_COUNT;
    5aa6:	70c3      	strb	r3, [r0, #3]
	if (err == -EINVAL) {
    5aa8:	e730      	b.n	590c <hci_cmd_handle+0x1a8>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5aaa:	2109      	movs	r1, #9
    5aac:	a80d      	add	r0, sp, #52	; 0x34
    5aae:	f7ff fdbf 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5ab2:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5ab4:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    5ab6:	2208      	movs	r2, #8
	rp->status = 0x00;
    5ab8:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
    5abc:	f00a f87e 	bl	fbbc <memset>
	sys_put_le64(ll_feat_get(), rp->features);
    5ac0:	f00b fa79 	bl	10fb6 <ll_feat_get>
    5ac4:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
    5ac8:	7060      	strb	r0, [r4, #1]
	dst[1] = val >> 8;
    5aca:	70a3      	strb	r3, [r4, #2]
	sys_put_le16(val >> 16, &dst[2]);
    5acc:	0c00      	lsrs	r0, r0, #16
	dst[1] = val >> 8;
    5ace:	f3c1 2307 	ubfx	r3, r1, #8, #8
	dst[0] = val;
    5ad2:	7161      	strb	r1, [r4, #5]
	sys_put_le16(val >> 16, &dst[2]);
    5ad4:	0c09      	lsrs	r1, r1, #16
	dst[0] = val;
    5ad6:	70e0      	strb	r0, [r4, #3]
    5ad8:	71e1      	strb	r1, [r4, #7]
	dst[1] = val >> 8;
    5ada:	0a00      	lsrs	r0, r0, #8
    5adc:	0a09      	lsrs	r1, r1, #8
    5ade:	7120      	strb	r0, [r4, #4]
    5ae0:	71a3      	strb	r3, [r4, #6]
    5ae2:	7221      	strb	r1, [r4, #8]
	if (err == -EINVAL) {
    5ae4:	e712      	b.n	590c <hci_cmd_handle+0x1a8>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
    5ae6:	68a1      	ldr	r1, [r4, #8]
    5ae8:	2001      	movs	r0, #1
    5aea:	f7ff f8eb 	bl	4cc4 <ll_addr_set>
	*evt = cmd_complete_status(status);
    5aee:	e689      	b.n	5804 <hci_cmd_handle+0xa0>
    5af0:	200026e0 	.word	0x200026e0
    5af4:	200000e8 	.word	0x200000e8
    5af8:	20000bc4 	.word	0x20000bc4
    5afc:	200000f0 	.word	0x200000f0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5b00:	2102      	movs	r1, #2
    5b02:	a80d      	add	r0, sp, #52	; 0x34
    5b04:	f7ff fd94 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5b08:	2300      	movs	r3, #0
    5b0a:	7003      	strb	r3, [r0, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5b0c:	4604      	mov	r4, r0
	rp->fal_size = ll_fal_size_get();
    5b0e:	f00b fde0 	bl	116d2 <ll_fal_size_get>
    5b12:	7060      	strb	r0, [r4, #1]
	if (err == -EINVAL) {
    5b14:	e6fa      	b.n	590c <hci_cmd_handle+0x1a8>
	status = ll_fal_clear();
    5b16:	f00b fdde 	bl	116d6 <ll_fal_clear>
	*evt = cmd_complete_status(status);
    5b1a:	e673      	b.n	5804 <hci_cmd_handle+0xa0>
	status = ll_fal_add(&cmd->addr);
    5b1c:	68a0      	ldr	r0, [r4, #8]
    5b1e:	f002 ffe3 	bl	8ae8 <ll_fal_add>
	*evt = cmd_complete_status(status);
    5b22:	e66f      	b.n	5804 <hci_cmd_handle+0xa0>
	status = ll_fal_remove(&cmd->addr);
    5b24:	68a0      	ldr	r0, [r4, #8]
    5b26:	f002 fd45 	bl	85b4 <ll_fal_remove>
	*evt = cmd_complete_status(status);
    5b2a:	e66b      	b.n	5804 <hci_cmd_handle+0xa0>
	struct bt_hci_cp_le_encrypt *cmd = (void *)buf->data;
    5b2c:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
    5b2e:	aa0e      	add	r2, sp, #56	; 0x38
    5b30:	2300      	movs	r3, #0
    5b32:	f100 0110 	add.w	r1, r0, #16
    5b36:	f00c f888 	bl	11c4a <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5b3a:	2111      	movs	r1, #17
    5b3c:	a80d      	add	r0, sp, #52	; 0x34
    5b3e:	f7ff fd77 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5b42:	2300      	movs	r3, #0
    5b44:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
    5b48:	2210      	movs	r2, #16
    5b4a:	a90e      	add	r1, sp, #56	; 0x38
    5b4c:	f00a f82b 	bl	fba6 <memcpy>
	if (err == -EINVAL) {
    5b50:	e6dc      	b.n	590c <hci_cmd_handle+0x1a8>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5b52:	2109      	movs	r1, #9
    5b54:	a80d      	add	r0, sp, #52	; 0x34
    5b56:	f7ff fd6b 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5b5a:	2300      	movs	r3, #0
    5b5c:	f800 3b01 	strb.w	r3, [r0], #1
	lll_csrand_get(rp->rand, count);
    5b60:	2108      	movs	r1, #8
    5b62:	f003 fd53 	bl	960c <lll_csrand_get>
	if (err == -EINVAL) {
    5b66:	e6d1      	b.n	590c <hci_cmd_handle+0x1a8>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5b68:	2109      	movs	r1, #9
    5b6a:	a80d      	add	r0, sp, #52	; 0x34
    5b6c:	f7ff fd60 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5b70:	2300      	movs	r3, #0
	dst[0] = val;
    5b72:	2233      	movs	r2, #51	; 0x33
    5b74:	7003      	strb	r3, [r0, #0]
    5b76:	7042      	strb	r2, [r0, #1]
	dst[1] = val >> 8;
    5b78:	7082      	strb	r2, [r0, #2]
	dst[0] = val;
    5b7a:	70c3      	strb	r3, [r0, #3]
	dst[1] = val >> 8;
    5b7c:	7103      	strb	r3, [r0, #4]
	dst[0] = val;
    5b7e:	7143      	strb	r3, [r0, #5]
	dst[1] = val >> 8;
    5b80:	7183      	strb	r3, [r0, #6]
    5b82:	e66d      	b.n	5860 <hci_cmd_handle+0xfc>
		*cc_evt = cmd_complete_status(BT_HCI_ERR_CMD_DISALLOWED);
    5b84:	200c      	movs	r0, #12
    5b86:	e63d      	b.n	5804 <hci_cmd_handle+0xa0>
	status = ll_adv_aux_random_addr_set(handle, &cmd->bdaddr.val[0]);
    5b88:	68a1      	ldr	r1, [r4, #8]
    5b8a:	f811 0b01 	ldrb.w	r0, [r1], #1
    5b8e:	f00b fc49 	bl	11424 <ll_adv_aux_random_addr_set>
    5b92:	e637      	b.n	5804 <hci_cmd_handle+0xa0>
	struct bt_hci_cp_le_set_ext_adv_param *cmd = (void *)buf->data;
    5b94:	68a3      	ldr	r3, [r4, #8]
	if (cmd->handle > BT_HCI_LE_ADV_HANDLE_MAX) {
    5b96:	7818      	ldrb	r0, [r3, #0]
    5b98:	28ef      	cmp	r0, #239	; 0xef
    5b9a:	d901      	bls.n	5ba0 <hci_cmd_handle+0x43c>
			*evt = cmd_complete_status(BT_HCI_ERR_INVALID_PARAM);
    5b9c:	2012      	movs	r0, #18
    5b9e:	e631      	b.n	5804 <hci_cmd_handle+0xa0>
	tx_pwr = cmd->tx_power;
    5ba0:	7cdc      	ldrb	r4, [r3, #19]
	evt_prop = sys_le16_to_cpu(cmd->props);
    5ba2:	f8b3 1001 	ldrh.w	r1, [r3, #1]
	return ((uint32_t)src[2] << 16) | sys_get_le16(&src[0]);
    5ba6:	795e      	ldrb	r6, [r3, #5]
    5ba8:	f8b3 2003 	ldrh.w	r2, [r3, #3]
	tx_pwr = cmd->tx_power;
    5bac:	f88d 4038 	strb.w	r4, [sp, #56]	; 0x38
	status = ll_adv_params_set(handle, evt_prop, min_interval,
    5bb0:	7e1c      	ldrb	r4, [r3, #24]
    5bb2:	940a      	str	r4, [sp, #40]	; 0x28
    5bb4:	7ddc      	ldrb	r4, [r3, #23]
    5bb6:	9409      	str	r4, [sp, #36]	; 0x24
	phy_s = BIT(cmd->sec_adv_phy - 1);
    5bb8:	7d9c      	ldrb	r4, [r3, #22]
    5bba:	2501      	movs	r5, #1
    5bbc:	3c01      	subs	r4, #1
    5bbe:	fa05 f404 	lsl.w	r4, r5, r4
	status = ll_adv_params_set(handle, evt_prop, min_interval,
    5bc2:	b2e4      	uxtb	r4, r4
    5bc4:	9408      	str	r4, [sp, #32]
    5bc6:	7d5c      	ldrb	r4, [r3, #21]
    5bc8:	9407      	str	r4, [sp, #28]
	phy_p = BIT(cmd->prim_adv_phy - 1);
    5bca:	7d1c      	ldrb	r4, [r3, #20]
    5bcc:	3c01      	subs	r4, #1
    5bce:	40a5      	lsls	r5, r4
	status = ll_adv_params_set(handle, evt_prop, min_interval,
    5bd0:	b2ed      	uxtb	r5, r5
    5bd2:	ac0e      	add	r4, sp, #56	; 0x38
    5bd4:	9506      	str	r5, [sp, #24]
    5bd6:	9405      	str	r4, [sp, #20]
    5bd8:	7c9c      	ldrb	r4, [r3, #18]
    5bda:	9404      	str	r4, [sp, #16]
    5bdc:	7a5c      	ldrb	r4, [r3, #9]
    5bde:	9403      	str	r4, [sp, #12]
				   cmd->peer_addr.type, cmd->peer_addr.a.val,
    5be0:	f103 040c 	add.w	r4, r3, #12
	status = ll_adv_params_set(handle, evt_prop, min_interval,
    5be4:	9402      	str	r4, [sp, #8]
    5be6:	7adc      	ldrb	r4, [r3, #11]
    5be8:	9401      	str	r4, [sp, #4]
    5bea:	7a9b      	ldrb	r3, [r3, #10]
    5bec:	9300      	str	r3, [sp, #0]
    5bee:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
    5bf2:	2307      	movs	r3, #7
    5bf4:	f001 f9f8 	bl	6fe8 <ll_adv_params_set>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5bf8:	2102      	movs	r1, #2
	status = ll_adv_params_set(handle, evt_prop, min_interval,
    5bfa:	4604      	mov	r4, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5bfc:	a80d      	add	r0, sp, #52	; 0x34
    5bfe:	f7ff fd17 	bl	5630 <hci_cmd_complete>
	rp->status = status;
    5c02:	7004      	strb	r4, [r0, #0]
	rp->tx_power = tx_pwr;
    5c04:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    5c08:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
    5c0a:	e67f      	b.n	590c <hci_cmd_handle+0x1a8>
	struct bt_hci_cp_le_set_ext_adv_data *cmd = (void *)buf->data;
    5c0c:	68a4      	ldr	r4, [r4, #8]
	status = ll_adv_aux_ad_data_set(handle, cmd->op, cmd->frag_pref,
    5c0e:	78e3      	ldrb	r3, [r4, #3]
    5c10:	78a2      	ldrb	r2, [r4, #2]
    5c12:	7861      	ldrb	r1, [r4, #1]
    5c14:	f814 0b04 	ldrb.w	r0, [r4], #4
    5c18:	9400      	str	r4, [sp, #0]
    5c1a:	f00b fc58 	bl	114ce <ll_adv_aux_ad_data_set>
	*evt = cmd_complete_status(status);
    5c1e:	e5f1      	b.n	5804 <hci_cmd_handle+0xa0>
	struct bt_hci_cp_le_set_ext_scan_rsp_data *cmd = (void *)buf->data;
    5c20:	68a4      	ldr	r4, [r4, #8]
	status = ll_adv_aux_sr_data_set(handle, cmd->op, cmd->frag_pref,
    5c22:	78e3      	ldrb	r3, [r4, #3]
    5c24:	78a2      	ldrb	r2, [r4, #2]
    5c26:	7861      	ldrb	r1, [r4, #1]
    5c28:	f814 0b04 	ldrb.w	r0, [r4], #4
    5c2c:	9400      	str	r4, [sp, #0]
    5c2e:	f001 fdf3 	bl	7818 <ll_adv_aux_sr_data_set>
	*evt = cmd_complete_status(status);
    5c32:	e5e7      	b.n	5804 <hci_cmd_handle+0xa0>
	struct bt_hci_cp_le_set_ext_adv_enable *cmd = (void *)buf->data;
    5c34:	68a6      	ldr	r6, [r4, #8]
	set_num = cmd->set_num;
    5c36:	7874      	ldrb	r4, [r6, #1]
	if (!set_num) {
    5c38:	b924      	cbnz	r4, 5c44 <hci_cmd_handle+0x4e0>
		if (cmd->enable) {
    5c3a:	7833      	ldrb	r3, [r6, #0]
    5c3c:	2b00      	cmp	r3, #0
    5c3e:	d1ad      	bne.n	5b9c <hci_cmd_handle+0x438>
		*evt = cmd_complete_status(BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL);
    5c40:	2011      	movs	r0, #17
    5c42:	e5df      	b.n	5804 <hci_cmd_handle+0xa0>
	s = (void *) cmd->s;
    5c44:	1cb5      	adds	r5, r6, #2
		status = ll_adv_enable(handle, cmd->enable,
    5c46:	78eb      	ldrb	r3, [r5, #3]
    5c48:	f8b5 2001 	ldrh.w	r2, [r5, #1]
    5c4c:	7831      	ldrb	r1, [r6, #0]
    5c4e:	7828      	ldrb	r0, [r5, #0]
    5c50:	f7fa fcf2 	bl	638 <ll_adv_enable>
		if (status) {
    5c54:	b938      	cbnz	r0, 5c66 <hci_cmd_handle+0x502>
	} while (--set_num);
    5c56:	3c01      	subs	r4, #1
    5c58:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
		s++;
    5c5c:	f105 0504 	add.w	r5, r5, #4
	} while (--set_num);
    5c60:	d1f1      	bne.n	5c46 <hci_cmd_handle+0x4e2>
	*evt = cmd_complete_status(status);
    5c62:	4620      	mov	r0, r4
    5c64:	e5ce      	b.n	5804 <hci_cmd_handle+0xa0>
    5c66:	4604      	mov	r4, r0
    5c68:	e7fb      	b.n	5c62 <hci_cmd_handle+0x4fe>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5c6a:	2103      	movs	r1, #3
    5c6c:	a80d      	add	r0, sp, #52	; 0x34
    5c6e:	f7ff fcdf 	bl	5630 <hci_cmd_complete>
    5c72:	4604      	mov	r4, r0
	max_adv_data_len = ll_adv_aux_max_data_length_get();
    5c74:	f00b fbe4 	bl	11440 <ll_adv_aux_max_data_length_get>
	rp->max_adv_data_len = sys_cpu_to_le16(max_adv_data_len);
    5c78:	f8a4 0001 	strh.w	r0, [r4, #1]
	rp->status = 0x00;
    5c7c:	2300      	movs	r3, #0
    5c7e:	7023      	strb	r3, [r4, #0]
	if (err == -EINVAL) {
    5c80:	e644      	b.n	590c <hci_cmd_handle+0x1a8>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5c82:	2102      	movs	r1, #2
    5c84:	a80d      	add	r0, sp, #52	; 0x34
    5c86:	f7ff fcd3 	bl	5630 <hci_cmd_complete>
    5c8a:	4604      	mov	r4, r0
	rp->num_sets = ll_adv_aux_set_count_get();
    5c8c:	f00b fbda 	bl	11444 <ll_adv_aux_set_count_get>
	rp->rl_size = ll_rl_size_get();
    5c90:	7060      	strb	r0, [r4, #1]
    5c92:	e7f3      	b.n	5c7c <hci_cmd_handle+0x518>
	status = ll_adv_set_by_hci_handle_get(cmd->handle, &handle);
    5c94:	68a3      	ldr	r3, [r4, #8]
	status = ll_adv_aux_set_remove(handle);
    5c96:	7818      	ldrb	r0, [r3, #0]
    5c98:	f00b fc74 	bl	11584 <ll_adv_aux_set_remove>
	*evt = cmd_complete_status(status);
    5c9c:	e5b2      	b.n	5804 <hci_cmd_handle+0xa0>
	status = ll_adv_aux_set_clear();
    5c9e:	f00b fc95 	bl	115cc <ll_adv_aux_set_clear>
	*evt = cmd_complete_status(status);
    5ca2:	e5af      	b.n	5804 <hci_cmd_handle+0xa0>
	struct bt_hci_cp_le_set_ext_scan_param *cmd = (void *)buf->data;
    5ca4:	68a4      	ldr	r4, [r4, #8]
		if (phys & phy) {
    5ca6:	78a2      	ldrb	r2, [r4, #2]
	filter_policy = cmd->filter_policy;
    5ca8:	7865      	ldrb	r5, [r4, #1]
	own_addr_type = cmd->own_addr_type;
    5caa:	7823      	ldrb	r3, [r4, #0]
		if (phys & phy) {
    5cac:	f012 0201 	ands.w	r2, r2, #1
			type |= (p->type & 0x01);
    5cb0:	bf1e      	ittt	ne
    5cb2:	78e0      	ldrbne	r0, [r4, #3]
			interval = sys_le16_to_cpu(p->interval);
    5cb4:	88a1      	ldrhne	r1, [r4, #4]
			window = sys_le16_to_cpu(p->window);
    5cb6:	88e2      	ldrhne	r2, [r4, #6]
		status = ll_scan_params_set(type, interval, window,
    5cb8:	9500      	str	r5, [sp, #0]
			type |= (p->type & 0x01);
    5cba:	bf19      	ittee	ne
    5cbc:	f000 0001 	andne.w	r0, r0, #1
    5cc0:	f040 0002 	orrne.w	r0, r0, #2
		type = (phy << 1);
    5cc4:	2002      	moveq	r0, #2
			interval = 0U;
    5cc6:	4611      	moveq	r1, r2
		status = ll_scan_params_set(type, interval, window,
    5cc8:	f7fb fa7e 	bl	11c8 <ll_scan_params_set>
	*evt = cmd_complete_status(status);
    5ccc:	e59a      	b.n	5804 <hci_cmd_handle+0xa0>
	struct bt_hci_cp_le_set_ext_scan_enable *cmd = (void *)buf->data;
    5cce:	68a3      	ldr	r3, [r4, #8]
	if (cmd->enable && cmd->filter_dup) {
    5cd0:	4a31      	ldr	r2, [pc, #196]	; (5d98 <hci_cmd_handle+0x634>)
    5cd2:	7818      	ldrb	r0, [r3, #0]
    5cd4:	b168      	cbz	r0, 5cf2 <hci_cmd_handle+0x58e>
    5cd6:	7859      	ldrb	r1, [r3, #1]
    5cd8:	b159      	cbz	r1, 5cf2 <hci_cmd_handle+0x58e>
			dup_count = 0;
    5cda:	2100      	movs	r1, #0
    5cdc:	6011      	str	r1, [r2, #0]
			dup_curr = 0U;
    5cde:	4a2f      	ldr	r2, [pc, #188]	; (5d9c <hci_cmd_handle+0x638>)
		dup_count = DUP_FILTER_DISABLED;
    5ce0:	6011      	str	r1, [r2, #0]
	status = ll_scan_enable(cmd->enable, cmd->duration, cmd->period);
    5ce2:	889a      	ldrh	r2, [r3, #4]
    5ce4:	8859      	ldrh	r1, [r3, #2]
    5ce6:	f002 f913 	bl	7f10 <ll_scan_enable>
		status = BT_HCI_ERR_SUCCESS;
    5cea:	280c      	cmp	r0, #12
	*evt = cmd_complete_status(status);
    5cec:	bf08      	it	eq
    5cee:	2000      	moveq	r0, #0
    5cf0:	e588      	b.n	5804 <hci_cmd_handle+0xa0>
		dup_count = DUP_FILTER_DISABLED;
    5cf2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    5cf6:	e7f3      	b.n	5ce0 <hci_cmd_handle+0x57c>
	struct bt_hci_cp_le_add_dev_to_rl *cmd = (void *)buf->data;
    5cf8:	68a0      	ldr	r0, [r4, #8]
	status = ll_rl_add(&cmd->peer_id_addr, cmd->peer_irk, cmd->local_irk);
    5cfa:	f100 0217 	add.w	r2, r0, #23
    5cfe:	1dc1      	adds	r1, r0, #7
    5d00:	f002 ff46 	bl	8b90 <ll_rl_add>
	*evt = cmd_complete_status(status);
    5d04:	e57e      	b.n	5804 <hci_cmd_handle+0xa0>
	status = ll_rl_remove(&cmd->peer_id_addr);
    5d06:	68a0      	ldr	r0, [r4, #8]
    5d08:	f002 ffe0 	bl	8ccc <ll_rl_remove>
	*evt = cmd_complete_status(status);
    5d0c:	e57a      	b.n	5804 <hci_cmd_handle+0xa0>
	status = ll_rl_clear();
    5d0e:	f00b fcf4 	bl	116fa <ll_rl_clear>
	*evt = cmd_complete_status(status);
    5d12:	e577      	b.n	5804 <hci_cmd_handle+0xa0>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5d14:	2102      	movs	r1, #2
    5d16:	a80d      	add	r0, sp, #52	; 0x34
    5d18:	f7ff fc8a 	bl	5630 <hci_cmd_complete>
    5d1c:	4604      	mov	r4, r0
	rp->rl_size = ll_rl_size_get();
    5d1e:	f00b fcea 	bl	116f6 <ll_rl_size_get>
    5d22:	e7b5      	b.n	5c90 <hci_cmd_handle+0x52c>
    5d24:	68a1      	ldr	r1, [r4, #8]
    5d26:	2207      	movs	r2, #7
    5d28:	a80e      	add	r0, sp, #56	; 0x38
    5d2a:	f009 ff3c 	bl	fba6 <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5d2e:	2107      	movs	r1, #7
    5d30:	a80d      	add	r0, sp, #52	; 0x34
    5d32:	f7ff fc7d 	bl	5630 <hci_cmd_complete>
    5d36:	4604      	mov	r4, r0
	rp->status = ll_rl_crpa_get(&peer_id_addr, &rp->peer_rpa);
    5d38:	1c41      	adds	r1, r0, #1
    5d3a:	a80e      	add	r0, sp, #56	; 0x38
    5d3c:	f003 f85a 	bl	8df4 <ll_rl_crpa_get>
	rp->status = ll_rl_lrpa_get(&peer_id_addr, &rp->local_rpa);
    5d40:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
    5d42:	e5e3      	b.n	590c <hci_cmd_handle+0x1a8>
    5d44:	68a1      	ldr	r1, [r4, #8]
    5d46:	2207      	movs	r2, #7
    5d48:	a80e      	add	r0, sp, #56	; 0x38
    5d4a:	f009 ff2c 	bl	fba6 <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5d4e:	2107      	movs	r1, #7
    5d50:	a80d      	add	r0, sp, #52	; 0x34
    5d52:	f7ff fc6d 	bl	5630 <hci_cmd_complete>
    5d56:	4604      	mov	r4, r0
	rp->status = ll_rl_lrpa_get(&peer_id_addr, &rp->local_rpa);
    5d58:	1c41      	adds	r1, r0, #1
    5d5a:	a80e      	add	r0, sp, #56	; 0x38
    5d5c:	f003 f86c 	bl	8e38 <ll_rl_lrpa_get>
    5d60:	e7ee      	b.n	5d40 <hci_cmd_handle+0x5dc>
	status = ll_rl_enable(cmd->enable);
    5d62:	68a3      	ldr	r3, [r4, #8]
    5d64:	7818      	ldrb	r0, [r3, #0]
    5d66:	f002 fc99 	bl	869c <ll_rl_enable>
	*evt = cmd_complete_status(status);
    5d6a:	e54b      	b.n	5804 <hci_cmd_handle+0xa0>
	uint16_t timeout = sys_le16_to_cpu(cmd->rpa_timeout);
    5d6c:	68a3      	ldr	r3, [r4, #8]
	ll_rl_timeout_set(timeout);
    5d6e:	8818      	ldrh	r0, [r3, #0]
    5d70:	f002 fcaa 	bl	86c8 <ll_rl_timeout_set>
	*evt = cmd_complete_status(0x00);
    5d74:	e545      	b.n	5802 <hci_cmd_handle+0x9e>
	struct bt_hci_cp_le_set_privacy_mode *cmd = (void *)buf->data;
    5d76:	68a0      	ldr	r0, [r4, #8]
	status = ll_priv_mode_set(&cmd->id_addr, cmd->mode);
    5d78:	79c1      	ldrb	r1, [r0, #7]
    5d7a:	f003 f877 	bl	8e6c <ll_priv_mode_set>
	*evt = cmd_complete_status(status);
    5d7e:	e541      	b.n	5804 <hci_cmd_handle+0xa0>
	rp = hci_cmd_complete(evt, sizeof(*rp));
    5d80:	2103      	movs	r1, #3
    5d82:	a80d      	add	r0, sp, #52	; 0x34
    5d84:	f7ff fc54 	bl	5630 <hci_cmd_complete>
	rp->status = 0x00;
    5d88:	4601      	mov	r1, r0
    5d8a:	2300      	movs	r3, #0
    5d8c:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
    5d90:	3001      	adds	r0, #1
    5d92:	f00a ff6c 	bl	10c6e <ll_tx_pwr_get>
	if (err == -EINVAL) {
    5d96:	e5b9      	b.n	590c <hci_cmd_handle+0x1a8>
    5d98:	20000bc4 	.word	0x20000bc4
    5d9c:	20000bc8 	.word	0x20000bc8

00005da0 <hci_evt_encode>:
	}
}
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
    5da0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct pdu_data *pdu_data = (void *)node_rx->pdu;

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
    5da4:	7903      	ldrb	r3, [r0, #4]
    5da6:	2b03      	cmp	r3, #3
{
    5da8:	b085      	sub	sp, #20
    5daa:	4604      	mov	r4, r0
    5dac:	460e      	mov	r6, r1
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
    5dae:	f000 8082 	beq.w	5eb6 <hci_evt_encode+0x116>
	switch (node_rx->hdr.type) {
    5db2:	3b05      	subs	r3, #5
	struct pdu_data *pdu_data = (void *)node_rx->pdu;
    5db4:	301c      	adds	r0, #28
	switch (node_rx->hdr.type) {
    5db6:	2b10      	cmp	r3, #16
    5db8:	f200 814f 	bhi.w	605a <hci_evt_encode+0x2ba>
    5dbc:	e8df f013 	tbh	[pc, r3, lsl #1]
    5dc0:	00d70011 	.word	0x00d70011
    5dc4:	00e100df 	.word	0x00e100df
    5dc8:	014d014d 	.word	0x014d014d
    5dcc:	014d00e3 	.word	0x014d00e3
    5dd0:	014d014d 	.word	0x014d014d
    5dd4:	014d014d 	.word	0x014d014d
    5dd8:	00f3014d 	.word	0x00f3014d
    5ddc:	014d014d 	.word	0x014d014d
    5de0:	010a      	.short	0x010a
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
    5de2:	4ba5      	ldr	r3, [pc, #660]	; (6078 <hci_evt_encode+0x2d8>)
	rssi = -(node_rx->hdr.rx_ftr.rssi);
    5de4:	7e27      	ldrb	r7, [r4, #24]
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
    5de6:	6818      	ldr	r0, [r3, #0]
    5de8:	889a      	ldrh	r2, [r3, #4]
    5dea:	799b      	ldrb	r3, [r3, #6]
    5dec:	f88d 300e 	strb.w	r3, [sp, #14]
	if (adv->tx_addr) {
    5df0:	7f23      	ldrb	r3, [r4, #28]
	direct_report = node_rx->hdr.rx_ftr.direct;
    5df2:	7ea5      	ldrb	r5, [r4, #26]
	rl_idx = node_rx->hdr.rx_ftr.rl_idx;
    5df4:	f894 8019 	ldrb.w	r8, [r4, #25]
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
    5df8:	9002      	str	r0, [sp, #8]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
    5dfa:	427f      	negs	r7, r7
	if (adv->tx_addr) {
    5dfc:	0659      	lsls	r1, r3, #25
	const uint8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
    5dfe:	f8ad 200c 	strh.w	r2, [sp, #12]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
    5e02:	b27f      	sxtb	r7, r7
	direct_report = node_rx->hdr.rx_ftr.direct;
    5e04:	f3c5 0540 	ubfx	r5, r5, #1, #1
	if (adv->tx_addr) {
    5e08:	d506      	bpl.n	5e18 <hci_evt_encode+0x78>
		ll_rl_crpa_set(0x00, NULL, rl_idx, &adv->adv_ind.addr[0]);
    5e0a:	2100      	movs	r1, #0
    5e0c:	f104 031e 	add.w	r3, r4, #30
    5e10:	4642      	mov	r2, r8
    5e12:	4608      	mov	r0, r1
    5e14:	f002 ffcc 	bl	8db0 <ll_rl_crpa_set>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5e18:	4b98      	ldr	r3, [pc, #608]	; (607c <hci_evt_encode+0x2dc>)
    5e1a:	685b      	ldr	r3, [r3, #4]
    5e1c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
	if (direct_report) {
    5e20:	2d00      	cmp	r5, #0
    5e22:	d054      	beq.n	5ece <hci_evt_encode+0x12e>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5e24:	2b00      	cmp	r3, #0
    5e26:	d046      	beq.n	5eb6 <hci_evt_encode+0x116>
	    !(le_event_mask & BT_EVT_MASK_LE_DIRECT_ADV_REPORT)) {
    5e28:	4b95      	ldr	r3, [pc, #596]	; (6080 <hci_evt_encode+0x2e0>)
    5e2a:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5e2c:	055a      	lsls	r2, r3, #21
    5e2e:	d542      	bpl.n	5eb6 <hci_evt_encode+0x116>
	LL_ASSERT(adv->type == PDU_ADV_TYPE_DIRECT_IND);
    5e30:	7f23      	ldrb	r3, [r4, #28]
    5e32:	f003 030f 	and.w	r3, r3, #15
    5e36:	2b01      	cmp	r3, #1
    5e38:	d00c      	beq.n	5e54 <hci_evt_encode+0xb4>
    5e3a:	4a92      	ldr	r2, [pc, #584]	; (6084 <hci_evt_encode+0x2e4>)
    5e3c:	4992      	ldr	r1, [pc, #584]	; (6088 <hci_evt_encode+0x2e8>)
    5e3e:	4893      	ldr	r0, [pc, #588]	; (608c <hci_evt_encode+0x2ec>)
    5e40:	f241 33af 	movw	r3, #5039	; 0x13af
    5e44:	f009 fb3f 	bl	f4c6 <printk>
    5e48:	4040      	eors	r0, r0
    5e4a:	f380 8811 	msr	BASEPRI, r0
    5e4e:	f04f 0003 	mov.w	r0, #3
    5e52:	df02      	svc	2
	    dup_found(adv->type, adv->tx_addr, adv->adv_ind.addr, 0, NULL, 0)) {
    5e54:	7f20      	ldrb	r0, [r4, #28]
    5e56:	f104 091e 	add.w	r9, r4, #30
    5e5a:	2300      	movs	r3, #0
    5e5c:	f3c0 1180 	ubfx	r1, r0, #6, #1
    5e60:	e9cd 3300 	strd	r3, r3, [sp]
    5e64:	464a      	mov	r2, r9
    5e66:	f000 000f 	and.w	r0, r0, #15
    5e6a:	f7ff f85d 	bl	4f28 <dup_found>
	if (dup_scan &&
    5e6e:	bb10      	cbnz	r0, 5eb6 <hci_evt_encode+0x116>
	drp = meta_evt(buf, BT_HCI_EVT_LE_DIRECT_ADV_REPORT,
    5e70:	2211      	movs	r2, #17
    5e72:	210b      	movs	r1, #11
    5e74:	4630      	mov	r0, r6
    5e76:	f00a ff40 	bl	10cfa <meta_evt>
	drp->num_reports = 1U;
    5e7a:	2301      	movs	r3, #1
    5e7c:	7003      	strb	r3, [r0, #0]
	dir_info->evt_type = BT_HCI_ADV_DIRECT_IND;
    5e7e:	7043      	strb	r3, [r0, #1]
	drp = meta_evt(buf, BT_HCI_EVT_LE_DIRECT_ADV_REPORT,
    5e80:	4605      	mov	r5, r0
	if (rl_idx < ll_rl_size_get()) {
    5e82:	f00b fc38 	bl	116f6 <ll_rl_size_get>
    5e86:	4580      	cmp	r8, r0
    5e88:	f105 0003 	add.w	r0, r5, #3
    5e8c:	d216      	bcs.n	5ebc <hci_evt_encode+0x11c>
		ll_rl_id_addr_get(rl_idx, &dir_info->addr.type,
    5e8e:	4602      	mov	r2, r0
    5e90:	1ca9      	adds	r1, r5, #2
    5e92:	4640      	mov	r0, r8
    5e94:	f002 fbc2 	bl	861c <ll_rl_id_addr_get>
		dir_info->addr.type += 2U;
    5e98:	78ab      	ldrb	r3, [r5, #2]
    5e9a:	3302      	adds	r3, #2
    5e9c:	70ab      	strb	r3, [r5, #2]
	dir_info->dir_addr.type = adv->rx_addr;
    5e9e:	7f23      	ldrb	r3, [r4, #28]
    5ea0:	f3c3 13c0 	ubfx	r3, r3, #7, #1
    5ea4:	726b      	strb	r3, [r5, #9]
	memcpy(&dir_info->dir_addr.a.val[0],
    5ea6:	2206      	movs	r2, #6
    5ea8:	f104 0124 	add.w	r1, r4, #36	; 0x24
    5eac:	f105 000a 	add.w	r0, r5, #10
    5eb0:	f009 fe79 	bl	fba6 <memcpy>
	dir_info->rssi = rssi;
    5eb4:	742f      	strb	r7, [r5, #16]
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
    5eb6:	b005      	add	sp, #20
    5eb8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		dir_info->addr.type = adv->tx_addr;
    5ebc:	7f23      	ldrb	r3, [r4, #28]
    5ebe:	f3c3 1380 	ubfx	r3, r3, #6, #1
    5ec2:	70ab      	strb	r3, [r5, #2]
		memcpy(&dir_info->addr.a.val[0], &adv->direct_ind.adv_addr[0],
    5ec4:	2206      	movs	r2, #6
    5ec6:	4649      	mov	r1, r9
    5ec8:	f009 fe6d 	bl	fba6 <memcpy>
    5ecc:	e7e7      	b.n	5e9e <hci_evt_encode+0xfe>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5ece:	2b00      	cmp	r3, #0
    5ed0:	d0f1      	beq.n	5eb6 <hci_evt_encode+0x116>
	    !(le_event_mask & BT_EVT_MASK_LE_ADVERTISING_REPORT)) {
    5ed2:	4b6b      	ldr	r3, [pc, #428]	; (6080 <hci_evt_encode+0x2e0>)
    5ed4:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5ed6:	079b      	lsls	r3, r3, #30
    5ed8:	d5ed      	bpl.n	5eb6 <hci_evt_encode+0x116>
	    dup_found(adv->type, adv->tx_addr, adv->adv_ind.addr, 0, NULL, 0)) {
    5eda:	7f20      	ldrb	r0, [r4, #28]
    5edc:	f104 091e 	add.w	r9, r4, #30
    5ee0:	f3c0 1180 	ubfx	r1, r0, #6, #1
    5ee4:	e9cd 5500 	strd	r5, r5, [sp]
    5ee8:	462b      	mov	r3, r5
    5eea:	464a      	mov	r2, r9
    5eec:	f000 000f 	and.w	r0, r0, #15
    5ef0:	f7ff f81a 	bl	4f28 <dup_found>
	if (dup_scan &&
    5ef4:	2800      	cmp	r0, #0
    5ef6:	d1de      	bne.n	5eb6 <hci_evt_encode+0x116>
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
    5ef8:	7f23      	ldrb	r3, [r4, #28]
    5efa:	f003 030f 	and.w	r3, r3, #15
    5efe:	2b01      	cmp	r3, #1
		data_len = (adv->len - BDADDR_SIZE);
    5f00:	bf1e      	ittt	ne
    5f02:	7f65      	ldrbne	r5, [r4, #29]
    5f04:	3d06      	subne	r5, #6
    5f06:	b2ed      	uxtbne	r5, r5
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
    5f08:	f105 020b 	add.w	r2, r5, #11
    5f0c:	b2d2      	uxtb	r2, r2
    5f0e:	2102      	movs	r1, #2
    5f10:	4630      	mov	r0, r6
    5f12:	f00a fef2 	bl	10cfa <meta_evt>
	sep->num_reports = 1U;
    5f16:	2301      	movs	r3, #1
    5f18:	7003      	strb	r3, [r0, #0]
	adv_info->evt_type = c_adv_type[adv->type];
    5f1a:	7f23      	ldrb	r3, [r4, #28]
    5f1c:	aa04      	add	r2, sp, #16
    5f1e:	f003 030f 	and.w	r3, r3, #15
    5f22:	4413      	add	r3, r2
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
    5f24:	4606      	mov	r6, r0
	adv_info->evt_type = c_adv_type[adv->type];
    5f26:	f813 3c08 	ldrb.w	r3, [r3, #-8]
    5f2a:	7043      	strb	r3, [r0, #1]
	if (rl_idx < ll_rl_size_get()) {
    5f2c:	f00b fbe3 	bl	116f6 <ll_rl_size_get>
    5f30:	4580      	cmp	r8, r0
    5f32:	f106 0003 	add.w	r0, r6, #3
    5f36:	d211      	bcs.n	5f5c <hci_evt_encode+0x1bc>
		ll_rl_id_addr_get(rl_idx, &adv_info->addr.type,
    5f38:	4602      	mov	r2, r0
    5f3a:	1cb1      	adds	r1, r6, #2
    5f3c:	4640      	mov	r0, r8
    5f3e:	f002 fb6d 	bl	861c <ll_rl_id_addr_get>
		adv_info->addr.type += 2U;
    5f42:	78b3      	ldrb	r3, [r6, #2]
    5f44:	3302      	adds	r3, #2
    5f46:	70b3      	strb	r3, [r6, #2]
	adv_info->length = data_len;
    5f48:	7275      	strb	r5, [r6, #9]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
    5f4a:	360a      	adds	r6, #10
    5f4c:	462a      	mov	r2, r5
    5f4e:	f104 0124 	add.w	r1, r4, #36	; 0x24
    5f52:	4630      	mov	r0, r6
    5f54:	f009 fe27 	bl	fba6 <memcpy>
	*prssi = rssi;
    5f58:	5577      	strb	r7, [r6, r5]
    5f5a:	e7ac      	b.n	5eb6 <hci_evt_encode+0x116>
		adv_info->addr.type = adv->tx_addr;
    5f5c:	7f23      	ldrb	r3, [r4, #28]
    5f5e:	f3c3 1380 	ubfx	r3, r3, #6, #1
    5f62:	70b3      	strb	r3, [r6, #2]
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
    5f64:	2206      	movs	r2, #6
    5f66:	4649      	mov	r1, r9
    5f68:	f009 fe1d 	bl	fba6 <memcpy>
    5f6c:	e7ec      	b.n	5f48 <hci_evt_encode+0x1a8>
	le_adv_ext_report(pdu_data, node_rx, buf, BT_HCI_LE_EXT_SCAN_PHY_1M);
    5f6e:	2301      	movs	r3, #1
	le_adv_ext_report(pdu_data, node_rx, buf, BT_HCI_LE_EXT_SCAN_PHY_2M);
    5f70:	4632      	mov	r2, r6
    5f72:	4621      	mov	r1, r4
}
    5f74:	b005      	add	sp, #20
    5f76:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	le_adv_ext_report(pdu_data, node_rx, buf, BT_HCI_LE_EXT_SCAN_PHY_2M);
    5f7a:	f7ff b8a3 	b.w	50c4 <le_adv_ext_report>
    5f7e:	2302      	movs	r3, #2
    5f80:	e7f6      	b.n	5f70 <hci_evt_encode+0x1d0>
	le_adv_ext_report(pdu_data, node_rx, buf, BT_HCI_LE_EXT_SCAN_PHY_CODED);
    5f82:	2304      	movs	r3, #4
    5f84:	e7f4      	b.n	5f70 <hci_evt_encode+0x1d0>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5f86:	4b3d      	ldr	r3, [pc, #244]	; (607c <hci_evt_encode+0x2dc>)
    5f88:	685b      	ldr	r3, [r3, #4]
    5f8a:	009d      	lsls	r5, r3, #2
    5f8c:	d593      	bpl.n	5eb6 <hci_evt_encode+0x116>
	    !(le_event_mask & BT_EVT_MASK_LE_SCAN_TIMEOUT)) {
    5f8e:	4b3c      	ldr	r3, [pc, #240]	; (6080 <hci_evt_encode+0x2e0>)
    5f90:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5f92:	03dc      	lsls	r4, r3, #15
    5f94:	d58f      	bpl.n	5eb6 <hci_evt_encode+0x116>
	meta_evt(buf, BT_HCI_EVT_LE_SCAN_TIMEOUT, 0U);
    5f96:	2200      	movs	r2, #0
    5f98:	2111      	movs	r1, #17
    5f9a:	4630      	mov	r0, r6
}
    5f9c:	b005      	add	sp, #20
    5f9e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	meta_evt(buf, BT_HCI_EVT_LE_SCAN_TIMEOUT, 0U);
    5fa2:	f00a beaa 	b.w	10cfa <meta_evt>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5fa6:	4b35      	ldr	r3, [pc, #212]	; (607c <hci_evt_encode+0x2dc>)
    5fa8:	685b      	ldr	r3, [r3, #4]
    5faa:	0098      	lsls	r0, r3, #2
    5fac:	d583      	bpl.n	5eb6 <hci_evt_encode+0x116>
	    !(le_event_mask & BT_EVT_MASK_LE_ADV_SET_TERMINATED)) {
    5fae:	4b34      	ldr	r3, [pc, #208]	; (6080 <hci_evt_encode+0x2e0>)
    5fb0:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5fb2:	0399      	lsls	r1, r3, #14
    5fb4:	f57f af7f 	bpl.w	5eb6 <hci_evt_encode+0x116>
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADV_SET_TERMINATED, sizeof(*sep));
    5fb8:	2205      	movs	r2, #5
    5fba:	2112      	movs	r1, #18
    5fbc:	4630      	mov	r0, r6
    5fbe:	f00a fe9c 	bl	10cfa <meta_evt>
	sep->status = node_rx->hdr.rx_ftr.param_adv_term.status;
    5fc2:	7a23      	ldrb	r3, [r4, #8]
    5fc4:	7003      	strb	r3, [r0, #0]
	sep->adv_handle = ll_adv_set_hci_handle_get(node_rx->hdr.handle & 0xff);
    5fc6:	88e3      	ldrh	r3, [r4, #6]
    5fc8:	7043      	strb	r3, [r0, #1]
	sep->conn_handle =
    5fca:	8963      	ldrh	r3, [r4, #10]
    5fcc:	8043      	strh	r3, [r0, #2]
	sep->num_completed_ext_adv_evts =
    5fce:	7a63      	ldrb	r3, [r4, #9]
    5fd0:	7103      	strb	r3, [r0, #4]
    5fd2:	e770      	b.n	5eb6 <hci_evt_encode+0x116>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5fd4:	4b29      	ldr	r3, [pc, #164]	; (607c <hci_evt_encode+0x2dc>)
    5fd6:	685b      	ldr	r3, [r3, #4]
    5fd8:	009a      	lsls	r2, r3, #2
		ll_rl_crpa_set(0x00, NULL, rl_idx, &adv->adv_ind.addr[0]);
    5fda:	f104 071e 	add.w	r7, r4, #30
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5fde:	d503      	bpl.n	5fe8 <hci_evt_encode+0x248>
	    !(le_event_mask & BT_EVT_MASK_LE_SCAN_REQ_RECEIVED)) {
    5fe0:	4b27      	ldr	r3, [pc, #156]	; (6080 <hci_evt_encode+0x2e0>)
    5fe2:	681b      	ldr	r3, [r3, #0]
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
    5fe4:	035b      	lsls	r3, r3, #13
    5fe6:	d40b      	bmi.n	6000 <hci_evt_encode+0x260>
		addr.type = adv->tx_addr;
    5fe8:	7f23      	ldrb	r3, [r4, #28]
		memcpy(&addr.a.val[0], &adv->scan_req.scan_addr[0],
    5fea:	2206      	movs	r2, #6
		addr.type = adv->tx_addr;
    5fec:	f3c3 1380 	ubfx	r3, r3, #6, #1
		memcpy(&addr.a.val[0], &adv->scan_req.scan_addr[0],
    5ff0:	4639      	mov	r1, r7
    5ff2:	f10d 0009 	add.w	r0, sp, #9
		addr.type = adv->tx_addr;
    5ff6:	f88d 3008 	strb.w	r3, [sp, #8]
		memcpy(&addr.a.val[0], &adv->scan_req.scan_addr[0],
    5ffa:	f009 fdd4 	bl	fba6 <memcpy>
		return;
    5ffe:	e75a      	b.n	5eb6 <hci_evt_encode+0x116>
	sep = meta_evt(buf, BT_HCI_EVT_LE_SCAN_REQ_RECEIVED, sizeof(*sep));
    6000:	2208      	movs	r2, #8
    6002:	2113      	movs	r1, #19
    6004:	4630      	mov	r0, r6
    6006:	f00a fe78 	bl	10cfa <meta_evt>
	sep->handle = ll_adv_set_hci_handle_get(node_rx->hdr.handle & 0xff);
    600a:	88e3      	ldrh	r3, [r4, #6]
    600c:	7003      	strb	r3, [r0, #0]
	sep->addr.type = adv->tx_addr;
    600e:	7f23      	ldrb	r3, [r4, #28]
	memcpy(&sep->addr.a.val[0], &adv->scan_req.scan_addr[0],
    6010:	1c86      	adds	r6, r0, #2
	sep->addr.type = adv->tx_addr;
    6012:	f3c3 1380 	ubfx	r3, r3, #6, #1
    6016:	7043      	strb	r3, [r0, #1]
	memcpy(&sep->addr.a.val[0], &adv->scan_req.scan_addr[0],
    6018:	2206      	movs	r2, #6
    601a:	4639      	mov	r1, r7
	sep = meta_evt(buf, BT_HCI_EVT_LE_SCAN_REQ_RECEIVED, sizeof(*sep));
    601c:	4605      	mov	r5, r0
	memcpy(&sep->addr.a.val[0], &adv->scan_req.scan_addr[0],
    601e:	4630      	mov	r0, r6
    6020:	f009 fdc1 	bl	fba6 <memcpy>
	rl_idx = node_rx->hdr.rx_ftr.rl_idx;
    6024:	f894 8019 	ldrb.w	r8, [r4, #25]
	if (rl_idx < ll_rl_size_get()) {
    6028:	f00b fb65 	bl	116f6 <ll_rl_size_get>
    602c:	4580      	cmp	r8, r0
    602e:	d208      	bcs.n	6042 <hci_evt_encode+0x2a2>
		ll_rl_id_addr_get(rl_idx, &sep->addr.type,
    6030:	4632      	mov	r2, r6
    6032:	1c69      	adds	r1, r5, #1
    6034:	4640      	mov	r0, r8
    6036:	f002 faf1 	bl	861c <ll_rl_id_addr_get>
		sep->addr.type += 2U;
    603a:	786b      	ldrb	r3, [r5, #1]
    603c:	3302      	adds	r3, #2
    603e:	706b      	strb	r3, [r5, #1]
    6040:	e739      	b.n	5eb6 <hci_evt_encode+0x116>
		sep->addr.type = adv->tx_addr;
    6042:	7f23      	ldrb	r3, [r4, #28]
		memcpy(&sep->addr.a.val[0], &adv->adv_ind.addr[0],
    6044:	2206      	movs	r2, #6
		sep->addr.type = adv->tx_addr;
    6046:	f3c3 1380 	ubfx	r3, r3, #6, #1
		memcpy(&sep->addr.a.val[0], &adv->adv_ind.addr[0],
    604a:	4639      	mov	r1, r7
    604c:	4630      	mov	r0, r6
		sep->addr.type = adv->tx_addr;
    604e:	706b      	strb	r3, [r5, #1]
}
    6050:	b005      	add	sp, #20
    6052:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		memcpy(&sep->addr.a.val[0], &adv->adv_ind.addr[0],
    6056:	f009 bda6 	b.w	fba6 <memcpy>
		LL_ASSERT(0);
    605a:	4a0a      	ldr	r2, [pc, #40]	; (6084 <hci_evt_encode+0x2e4>)
    605c:	490c      	ldr	r1, [pc, #48]	; (6090 <hci_evt_encode+0x2f0>)
    605e:	480b      	ldr	r0, [pc, #44]	; (608c <hci_evt_encode+0x2ec>)
    6060:	f641 33b1 	movw	r3, #7089	; 0x1bb1
    6064:	f009 fa2f 	bl	f4c6 <printk>
    6068:	4040      	eors	r0, r0
    606a:	f380 8811 	msr	BASEPRI, r0
    606e:	f04f 0003 	mov.w	r0, #3
    6072:	df02      	svc	2
}
    6074:	e71f      	b.n	5eb6 <hci_evt_encode+0x116>
    6076:	bf00      	nop
    6078:	00012ff6 	.word	0x00012ff6
    607c:	200000e8 	.word	0x200000e8
    6080:	200000f0 	.word	0x200000f0
    6084:	0001354d 	.word	0x0001354d
    6088:	00013586 	.word	0x00013586
    608c:	000133b6 	.word	0x000133b6
    6090:	00014086 	.word	0x00014086

00006094 <hci_init>:
	dup_count = DUP_FILTER_DISABLED;
    6094:	4b08      	ldr	r3, [pc, #32]	; (60b8 <hci_init+0x24>)
    6096:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    609a:	601a      	str	r2, [r3, #0]
	event_mask = DEFAULT_EVENT_MASK;
    609c:	4b07      	ldr	r3, [pc, #28]	; (60bc <hci_init+0x28>)
    609e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    60a2:	f641 71ff 	movw	r1, #8191	; 0x1fff
    60a6:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
    60aa:	4b05      	ldr	r3, [pc, #20]	; (60c0 <hci_init+0x2c>)
    60ac:	201f      	movs	r0, #31
    60ae:	2100      	movs	r1, #0
    60b0:	e9c3 0100 	strd	r0, r1, [r3]
{
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
}
    60b4:	4770      	bx	lr
    60b6:	bf00      	nop
    60b8:	20000bc4 	.word	0x20000bc4
    60bc:	200000e8 	.word	0x200000e8
    60c0:	200000f0 	.word	0x200000f0

000060c4 <ll_rx_link_inc_quota>:
	rx_alloc(UINT8_MAX);
}

static inline void ll_rx_link_inc_quota(int8_t delta)
{
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
    60c4:	2801      	cmp	r0, #1
{
    60c6:	b538      	push	{r3, r4, r5, lr}
    60c8:	4d0b      	ldr	r5, [pc, #44]	; (60f8 <ll_rx_link_inc_quota+0x34>)
    60ca:	4604      	mov	r4, r0
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
    60cc:	d10f      	bne.n	60ee <ll_rx_link_inc_quota+0x2a>
    60ce:	782b      	ldrb	r3, [r5, #0]
    60d0:	2b0a      	cmp	r3, #10
    60d2:	d90c      	bls.n	60ee <ll_rx_link_inc_quota+0x2a>
    60d4:	4a09      	ldr	r2, [pc, #36]	; (60fc <ll_rx_link_inc_quota+0x38>)
    60d6:	490a      	ldr	r1, [pc, #40]	; (6100 <ll_rx_link_inc_quota+0x3c>)
    60d8:	480a      	ldr	r0, [pc, #40]	; (6104 <ll_rx_link_inc_quota+0x40>)
    60da:	f240 53f4 	movw	r3, #1524	; 0x5f4
    60de:	f009 f9f2 	bl	f4c6 <printk>
    60e2:	4040      	eors	r0, r0
    60e4:	f380 8811 	msr	BASEPRI, r0
    60e8:	f04f 0003 	mov.w	r0, #3
    60ec:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
    60ee:	7828      	ldrb	r0, [r5, #0]
    60f0:	4404      	add	r4, r0
    60f2:	702c      	strb	r4, [r5, #0]
}
    60f4:	bd38      	pop	{r3, r4, r5, pc}
    60f6:	bf00      	nop
    60f8:	20000c2c 	.word	0x20000c2c
    60fc:	000135ab 	.word	0x000135ab
    6100:	000135e6 	.word	0x000135e6
    6104:	000133b6 	.word	0x000133b6

00006108 <rx_alloc>:
{
	return m;
}

static inline void rx_alloc(uint8_t max)
{
    6108:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    610c:	4f1b      	ldr	r7, [pc, #108]	; (617c <rx_alloc+0x74>)

	if (max > mem_link_rx.quota_pdu) {
		max = mem_link_rx.quota_pdu;
	}

	while (max && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
    610e:	f8df 8070 	ldr.w	r8, [pc, #112]	; 6180 <rx_alloc+0x78>
    6112:	f817 6b04 	ldrb.w	r6, [r7], #4
    6116:	4286      	cmp	r6, r0
    6118:	bf28      	it	cs
    611a:	4606      	movcs	r6, r0
    611c:	b18e      	cbz	r6, 6142 <rx_alloc+0x3a>
 */
static inline bool mfifo_enqueue_idx_get(uint8_t count, uint8_t first, uint8_t last,
					 uint8_t *idx)
{
	/* Non-destructive: Advance write-index modulo 'count' */
	last = last + 1;
    611e:	f898 4003 	ldrb.w	r4, [r8, #3]
	if (last == count) {
    6122:	f898 2001 	ldrb.w	r2, [r8, #1]
    6126:	f898 3002 	ldrb.w	r3, [r8, #2]
	last = last + 1;
    612a:	3401      	adds	r4, #1
    612c:	b2e4      	uxtb	r4, r4
		last = 0U;
    612e:	42a2      	cmp	r2, r4
    6130:	bf08      	it	eq
    6132:	2400      	moveq	r4, #0
	 * We want to maintain the invariant of emptiness defined by
	 * first == last, but we just advanced a copy of the write-index before
	 * and may have wrapped. So if first == last the queue is full and we
	 * can not continue
	 */
	if (last == first) {
    6134:	42a3      	cmp	r3, r4
    6136:	d004      	beq.n	6142 <rx_alloc+0x3a>
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
    6138:	4638      	mov	r0, r7
    613a:	f00a fa71 	bl	10620 <mem_acquire>
		if (!link) {
    613e:	4605      	mov	r5, r0
    6140:	b908      	cbnz	r0, 6146 <rx_alloc+0x3e>
		MFIFO_BY_IDX_ENQUEUE(ll_pdu_rx_free, idx, rx);

		ll_rx_link_inc_quota(-1);
	}
#endif /* CONFIG_BT_CONN */
}
    6142:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx = mem_acquire(&mem_pdu_rx.free);
    6146:	480f      	ldr	r0, [pc, #60]	; (6184 <rx_alloc+0x7c>)
    6148:	f00a fa6a 	bl	10620 <mem_acquire>
		if (!rx) {
    614c:	b928      	cbnz	r0, 615a <rx_alloc+0x52>
			mem_release(link, &mem_link_rx.free);
    614e:	4628      	mov	r0, r5
    6150:	490d      	ldr	r1, [pc, #52]	; (6188 <rx_alloc+0x80>)
}
    6152:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			mem_release(link, &mem_link_rx.free);
    6156:	f00a ba7c 	b.w	10652 <mem_release>
		rx->link = link;
    615a:	6005      	str	r5, [r0, #0]
 */
static inline void mfifo_by_idx_enqueue(uint8_t *fifo, uint8_t size, uint8_t idx,
					void *mem, uint8_t *last)
{
	/* API 2: fifo is array of void-ptrs */
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    615c:	f898 2003 	ldrb.w	r2, [r8, #3]
    6160:	f898 3000 	ldrb.w	r3, [r8]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    6164:	fb02 8303 	mla	r3, r2, r3, r8
    6168:	6058      	str	r0, [r3, #4]
		ll_rx_link_inc_quota(-1);
    616a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		max--;
    616e:	3e01      	subs	r6, #1

	cpu_dmb(); /* Ensure data accesses are synchronized */
	*last = idx; /* Commit: Update write index */
    6170:	f888 4003 	strb.w	r4, [r8, #3]
    6174:	b2f6      	uxtb	r6, r6
		ll_rx_link_inc_quota(-1);
    6176:	f7ff ffa5 	bl	60c4 <ll_rx_link_inc_quota>
		max--;
    617a:	e7cf      	b.n	611c <rx_alloc+0x14>
    617c:	20000c2c 	.word	0x20000c2c
    6180:	20000200 	.word	0x20000200
    6184:	20000ca4 	.word	0x20000ca4
    6188:	20000c30 	.word	0x20000c30

0000618c <perform_lll_reset>:
{
    618c:	b510      	push	{r4, lr}
    618e:	4604      	mov	r4, r0
	err = lll_reset();
    6190:	f00b fb00 	bl	11794 <lll_reset>
	LL_ASSERT(!err);
    6194:	b160      	cbz	r0, 61b0 <perform_lll_reset+0x24>
    6196:	4a19      	ldr	r2, [pc, #100]	; (61fc <perform_lll_reset+0x70>)
    6198:	4919      	ldr	r1, [pc, #100]	; (6200 <perform_lll_reset+0x74>)
    619a:	481a      	ldr	r0, [pc, #104]	; (6204 <perform_lll_reset+0x78>)
    619c:	f44f 6301 	mov.w	r3, #2064	; 0x810
    61a0:	f009 f991 	bl	f4c6 <printk>
    61a4:	4040      	eors	r0, r0
    61a6:	f380 8811 	msr	BASEPRI, r0
    61aa:	f04f 0003 	mov.w	r0, #3
    61ae:	df02      	svc	2
	err = lll_adv_reset();
    61b0:	f00b fb57 	bl	11862 <lll_adv_reset>
	LL_ASSERT(!err);
    61b4:	b160      	cbz	r0, 61d0 <perform_lll_reset+0x44>
    61b6:	4a11      	ldr	r2, [pc, #68]	; (61fc <perform_lll_reset+0x70>)
    61b8:	4911      	ldr	r1, [pc, #68]	; (6200 <perform_lll_reset+0x74>)
    61ba:	4812      	ldr	r0, [pc, #72]	; (6204 <perform_lll_reset+0x78>)
    61bc:	f640 0315 	movw	r3, #2069	; 0x815
    61c0:	f009 f981 	bl	f4c6 <printk>
    61c4:	4040      	eors	r0, r0
    61c6:	f380 8811 	msr	BASEPRI, r0
    61ca:	f04f 0003 	mov.w	r0, #3
    61ce:	df02      	svc	2
	err = lll_scan_reset();
    61d0:	f00b fc6c 	bl	11aac <lll_scan_reset>
	LL_ASSERT(!err);
    61d4:	b160      	cbz	r0, 61f0 <perform_lll_reset+0x64>
    61d6:	4a09      	ldr	r2, [pc, #36]	; (61fc <perform_lll_reset+0x70>)
    61d8:	4909      	ldr	r1, [pc, #36]	; (6200 <perform_lll_reset+0x74>)
    61da:	480a      	ldr	r0, [pc, #40]	; (6204 <perform_lll_reset+0x78>)
    61dc:	f640 031b 	movw	r3, #2075	; 0x81b
    61e0:	f009 f971 	bl	f4c6 <printk>
    61e4:	4040      	eors	r0, r0
    61e6:	f380 8811 	msr	BASEPRI, r0
    61ea:	f04f 0003 	mov.w	r0, #3
    61ee:	df02      	svc	2
	z_impl_k_sem_give(sem);
    61f0:	4620      	mov	r0, r4
}
    61f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    61f6:	f008 ba41 	b.w	e67c <z_impl_k_sem_give>
    61fa:	bf00      	nop
    61fc:	000135ab 	.word	0x000135ab
    6200:	00013624 	.word	0x00013624
    6204:	000133b6 	.word	0x000133b6

00006208 <ull_ticker_status_give>:
	*((uint32_t volatile *)param) = status;
    6208:	6008      	str	r0, [r1, #0]
    620a:	4801      	ldr	r0, [pc, #4]	; (6210 <ull_ticker_status_give+0x8>)
    620c:	f008 ba36 	b.w	e67c <z_impl_k_sem_give>
    6210:	20001a44 	.word	0x20001a44

00006214 <ll_rx_get>:
{
    6214:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
    6218:	4e16      	ldr	r6, [pc, #88]	; (6274 <ll_rx_get+0x60>)
				mem_release(link, &mem_link_rx.free);
    621a:	f8df 905c 	ldr.w	r9, [pc, #92]	; 6278 <ll_rx_get+0x64>
				mem_release(rx, &mem_pdu_rx.free);
    621e:	f8df 805c 	ldr.w	r8, [pc, #92]	; 627c <ll_rx_get+0x68>
{
    6222:	4604      	mov	r4, r0
	*node_rx = NULL;
    6224:	f04f 0a00 	mov.w	sl, #0
    6228:	f8c4 a000 	str.w	sl, [r4]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
    622c:	e9d6 0100 	ldrd	r0, r1, [r6]
    6230:	aa01      	add	r2, sp, #4
    6232:	f00a fa4c 	bl	106ce <memq_peek>
	if (link) {
    6236:	4605      	mov	r5, r0
    6238:	b1c0      	cbz	r0, 626c <ll_rx_get+0x58>
			} else if (rx->type == NODE_RX_TYPE_RELEASE) {
    623a:	9b01      	ldr	r3, [sp, #4]
    623c:	791f      	ldrb	r7, [r3, #4]
    623e:	2f01      	cmp	r7, #1
    6240:	d113      	bne.n	626a <ll_rx_get+0x56>
				(void)memq_dequeue(memq_ll_rx.tail,
    6242:	4652      	mov	r2, sl
    6244:	4631      	mov	r1, r6
    6246:	6870      	ldr	r0, [r6, #4]
    6248:	f00a fa49 	bl	106de <memq_dequeue>
				mem_release(link, &mem_link_rx.free);
    624c:	4649      	mov	r1, r9
    624e:	4628      	mov	r0, r5
    6250:	f00a f9ff 	bl	10652 <mem_release>
				ll_rx_link_inc_quota(1);
    6254:	4638      	mov	r0, r7
    6256:	f7ff ff35 	bl	60c4 <ll_rx_link_inc_quota>
				mem_release(rx, &mem_pdu_rx.free);
    625a:	9801      	ldr	r0, [sp, #4]
    625c:	4641      	mov	r1, r8
    625e:	f00a f9f8 	bl	10652 <mem_release>
				rx_alloc(1);
    6262:	4638      	mov	r0, r7
    6264:	f7ff ff50 	bl	6108 <rx_alloc>
				goto ll_rx_get_again;
    6268:	e7dc      	b.n	6224 <ll_rx_get+0x10>
			*node_rx = rx;
    626a:	6023      	str	r3, [r4, #0]
}
    626c:	2000      	movs	r0, #0
    626e:	b002      	add	sp, #8
    6270:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6274:	20001a28 	.word	0x20001a28
    6278:	20000c30 	.word	0x20000c30
    627c:	20000ca4 	.word	0x20000ca4

00006280 <ll_rx_dequeue>:
{
    6280:	b537      	push	{r0, r1, r2, r4, r5, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
    6282:	493c      	ldr	r1, [pc, #240]	; (6374 <ll_rx_dequeue+0xf4>)
	struct node_rx_hdr *rx = NULL;
    6284:	2300      	movs	r3, #0
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
    6286:	6848      	ldr	r0, [r1, #4]
	struct node_rx_hdr *rx = NULL;
    6288:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
    628a:	aa01      	add	r2, sp, #4
    628c:	f00a fa27 	bl	106de <memq_dequeue>
	LL_ASSERT(link);
    6290:	4604      	mov	r4, r0
    6292:	b960      	cbnz	r0, 62ae <ll_rx_dequeue+0x2e>
    6294:	4a38      	ldr	r2, [pc, #224]	; (6378 <ll_rx_dequeue+0xf8>)
    6296:	4939      	ldr	r1, [pc, #228]	; (637c <ll_rx_dequeue+0xfc>)
    6298:	4839      	ldr	r0, [pc, #228]	; (6380 <ll_rx_dequeue+0x100>)
    629a:	f240 339a 	movw	r3, #922	; 0x39a
    629e:	f009 f912 	bl	f4c6 <printk>
    62a2:	4040      	eors	r0, r0
    62a4:	f380 8811 	msr	BASEPRI, r0
    62a8:	f04f 0003 	mov.w	r0, #3
    62ac:	df02      	svc	2
	mem_release(link, &mem_link_rx.free);
    62ae:	4935      	ldr	r1, [pc, #212]	; (6384 <ll_rx_dequeue+0x104>)
    62b0:	4620      	mov	r0, r4
    62b2:	f00a f9ce 	bl	10652 <mem_release>
	switch (rx->type) {
    62b6:	9a01      	ldr	r2, [sp, #4]
    62b8:	7913      	ldrb	r3, [r2, #4]
    62ba:	2b00      	cmp	r3, #0
    62bc:	d046      	beq.n	634c <ll_rx_dequeue+0xcc>
    62be:	3b05      	subs	r3, #5
    62c0:	b2d9      	uxtb	r1, r3
    62c2:	2910      	cmp	r1, #16
    62c4:	d850      	bhi.n	6368 <ll_rx_dequeue+0xe8>
    62c6:	2b10      	cmp	r3, #16
    62c8:	d84e      	bhi.n	6368 <ll_rx_dequeue+0xe8>
    62ca:	e8df f003 	tbb	[pc, r3]
    62ce:	0911      	.short	0x0911
    62d0:	4d4d0909 	.word	0x4d4d0909
    62d4:	4d4d4d19 	.word	0x4d4d4d19
    62d8:	1d4d4d4d 	.word	0x1d4d4d4d
    62dc:	4d4d      	.short	0x4d4d
    62de:	11          	.byte	0x11
    62df:	00          	.byte	0x00
		if (adv->type != PDU_ADV_TYPE_EXT_IND) {
    62e0:	7f13      	ldrb	r3, [r2, #28]
    62e2:	f003 030f 	and.w	r3, r3, #15
    62e6:	2b07      	cmp	r3, #7
    62e8:	d102      	bne.n	62f0 <ll_rx_dequeue+0x70>
		rx_curr = rx->rx_ftr.extra;
    62ea:	68d4      	ldr	r4, [r2, #12]
			mem_release(link_free, &mem_link_rx.free);
    62ec:	4d25      	ldr	r5, [pc, #148]	; (6384 <ll_rx_dequeue+0x104>)
		while (rx_curr) {
    62ee:	b90c      	cbnz	r4, 62f4 <ll_rx_dequeue+0x74>
}
    62f0:	b003      	add	sp, #12
    62f2:	bd30      	pop	{r4, r5, pc}
			link_free = rx_curr->link;
    62f4:	6820      	ldr	r0, [r4, #0]
			rx_curr = rx_curr->rx_ftr.extra;
    62f6:	68e4      	ldr	r4, [r4, #12]
			mem_release(link_free, &mem_link_rx.free);
    62f8:	4629      	mov	r1, r5
    62fa:	f00a f9aa 	bl	10652 <mem_release>
    62fe:	e7f6      	b.n	62ee <ll_rx_dequeue+0x6e>
		ull_scan_term_dequeue(rx->handle);
    6300:	7990      	ldrb	r0, [r2, #6]
    6302:	f001 fda7 	bl	7e54 <ull_scan_term_dequeue>
	break;
    6306:	e7f3      	b.n	62f0 <ll_rx_dequeue+0x70>
		adv = ull_adv_set_get(rx->handle);
    6308:	7990      	ldrb	r0, [r2, #6]
    630a:	f001 f8e3 	bl	74d4 <ull_adv_set_get>
		LL_ASSERT(adv);
    630e:	4604      	mov	r4, r0
    6310:	b960      	cbnz	r0, 632c <ll_rx_dequeue+0xac>
    6312:	4a19      	ldr	r2, [pc, #100]	; (6378 <ll_rx_dequeue+0xf8>)
    6314:	491c      	ldr	r1, [pc, #112]	; (6388 <ll_rx_dequeue+0x108>)
    6316:	481a      	ldr	r0, [pc, #104]	; (6380 <ll_rx_dequeue+0x100>)
    6318:	f240 33cb 	movw	r3, #971	; 0x3cb
    631c:	f009 f8d3 	bl	f4c6 <printk>
    6320:	4040      	eors	r0, r0
    6322:	f380 8811 	msr	BASEPRI, r0
    6326:	f04f 0003 	mov.w	r0, #3
    632a:	df02      	svc	2
		lll_aux = adv->lll.aux;
    632c:	6c23      	ldr	r3, [r4, #64]	; 0x40
		if (lll_aux) {
    632e:	b133      	cbz	r3, 633e <ll_rx_dequeue+0xbe>
			aux = HDR_LLL2ULL(lll_aux);
    6330:	681b      	ldr	r3, [r3, #0]
			aux->is_started = 0U;
    6332:	f893 204a 	ldrb.w	r2, [r3, #74]	; 0x4a
    6336:	f36f 0200 	bfc	r2, #0, #1
    633a:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a
		adv->is_enabled = 0U;
    633e:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    6342:	f36f 0300 	bfc	r3, #0, #1
    6346:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
	break;
    634a:	e7d1      	b.n	62f0 <ll_rx_dequeue+0x70>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
    634c:	4a0a      	ldr	r2, [pc, #40]	; (6378 <ll_rx_dequeue+0xf8>)
    634e:	490f      	ldr	r1, [pc, #60]	; (638c <ll_rx_dequeue+0x10c>)
    6350:	f240 43bc 	movw	r3, #1212	; 0x4bc
		LL_ASSERT(0);
    6354:	480a      	ldr	r0, [pc, #40]	; (6380 <ll_rx_dequeue+0x100>)
    6356:	f009 f8b6 	bl	f4c6 <printk>
    635a:	4040      	eors	r0, r0
    635c:	f380 8811 	msr	BASEPRI, r0
    6360:	f04f 0003 	mov.w	r0, #3
    6364:	df02      	svc	2
}
    6366:	e7c3      	b.n	62f0 <ll_rx_dequeue+0x70>
		LL_ASSERT(0);
    6368:	4a03      	ldr	r2, [pc, #12]	; (6378 <ll_rx_dequeue+0xf8>)
    636a:	4909      	ldr	r1, [pc, #36]	; (6390 <ll_rx_dequeue+0x110>)
    636c:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
    6370:	e7f0      	b.n	6354 <ll_rx_dequeue+0xd4>
    6372:	bf00      	nop
    6374:	20001a28 	.word	0x20001a28
    6378:	000135ab 	.word	0x000135ab
    637c:	00013629 	.word	0x00013629
    6380:	000133b6 	.word	0x000133b6
    6384:	20000c30 	.word	0x20000c30
    6388:	00013816 	.word	0x00013816
    638c:	0001362e 	.word	0x0001362e
    6390:	00014086 	.word	0x00014086

00006394 <ll_rx_mem_release>:
{
    6394:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	rx = *node_rx;
    6398:	6804      	ldr	r4, [r0, #0]
			mem_release(rx_free, &mem_pdu_rx.free);
    639a:	4e1f      	ldr	r6, [pc, #124]	; (6418 <ll_rx_mem_release+0x84>)
			LL_ASSERT(0);
    639c:	4f1f      	ldr	r7, [pc, #124]	; (641c <ll_rx_mem_release+0x88>)
    639e:	f8df 8080 	ldr.w	r8, [pc, #128]	; 6420 <ll_rx_mem_release+0x8c>
{
    63a2:	4605      	mov	r5, r0
	while (rx) {
    63a4:	b92c      	cbnz	r4, 63b2 <ll_rx_mem_release+0x1e>
	*node_rx = rx;
    63a6:	602c      	str	r4, [r5, #0]
	rx_alloc(UINT8_MAX);
    63a8:	20ff      	movs	r0, #255	; 0xff
}
    63aa:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	rx_alloc(UINT8_MAX);
    63ae:	f7ff beab 	b.w	6108 <rx_alloc>
		switch (rx_free->type) {
    63b2:	7923      	ldrb	r3, [r4, #4]
		rx = rx->next;
    63b4:	f8d4 9000 	ldr.w	r9, [r4]
		switch (rx_free->type) {
    63b8:	2b0b      	cmp	r3, #11
    63ba:	d019      	beq.n	63f0 <ll_rx_mem_release+0x5c>
    63bc:	d811      	bhi.n	63e2 <ll_rx_mem_release+0x4e>
    63be:	b1eb      	cbz	r3, 63fc <ll_rx_mem_release+0x68>
    63c0:	3b05      	subs	r3, #5
    63c2:	2b03      	cmp	r3, #3
    63c4:	d911      	bls.n	63ea <ll_rx_mem_release+0x56>
			LL_ASSERT(0);
    63c6:	4817      	ldr	r0, [pc, #92]	; (6424 <ll_rx_mem_release+0x90>)
    63c8:	f44f 63bd 	mov.w	r3, #1512	; 0x5e8
    63cc:	463a      	mov	r2, r7
    63ce:	4641      	mov	r1, r8
    63d0:	f009 f879 	bl	f4c6 <printk>
    63d4:	4040      	eors	r0, r0
    63d6:	f380 8811 	msr	BASEPRI, r0
    63da:	f04f 0003 	mov.w	r0, #3
    63de:	df02      	svc	2
			break;
    63e0:	e00a      	b.n	63f8 <ll_rx_mem_release+0x64>
		switch (rx_free->type) {
    63e2:	2b12      	cmp	r3, #18
    63e4:	d004      	beq.n	63f0 <ll_rx_mem_release+0x5c>
    63e6:	2b15      	cmp	r3, #21
    63e8:	d1ed      	bne.n	63c6 <ll_rx_mem_release+0x32>
			ll_rx_link_inc_quota(1);
    63ea:	2001      	movs	r0, #1
    63ec:	f7ff fe6a 	bl	60c4 <ll_rx_link_inc_quota>
			mem_release(rx_free, &mem_pdu_rx.free);
    63f0:	4631      	mov	r1, r6
    63f2:	4620      	mov	r0, r4
    63f4:	f00a f92d 	bl	10652 <mem_release>
{
    63f8:	464c      	mov	r4, r9
    63fa:	e7d3      	b.n	63a4 <ll_rx_mem_release+0x10>
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
    63fc:	490a      	ldr	r1, [pc, #40]	; (6428 <ll_rx_mem_release+0x94>)
    63fe:	4809      	ldr	r0, [pc, #36]	; (6424 <ll_rx_mem_release+0x90>)
    6400:	f240 5374 	movw	r3, #1396	; 0x574
    6404:	463a      	mov	r2, r7
    6406:	f009 f85e 	bl	f4c6 <printk>
    640a:	4040      	eors	r0, r0
    640c:	f380 8811 	msr	BASEPRI, r0
    6410:	f04f 0003 	mov.w	r0, #3
    6414:	df02      	svc	2
    6416:	e7e8      	b.n	63ea <ll_rx_mem_release+0x56>
    6418:	20000ca4 	.word	0x20000ca4
    641c:	000135ab 	.word	0x000135ab
    6420:	00014086 	.word	0x00014086
    6424:	000133b6 	.word	0x000133b6
    6428:	0001364c 	.word	0x0001364c

0000642c <ll_rx_link_alloc>:
	return mem_acquire(&mem_link_rx.free);
    642c:	4801      	ldr	r0, [pc, #4]	; (6434 <ll_rx_link_alloc+0x8>)
    642e:	f00a b8f7 	b.w	10620 <mem_acquire>
    6432:	bf00      	nop
    6434:	20000c30 	.word	0x20000c30

00006438 <ll_rx_link_release>:
	mem_release(link, &mem_link_rx.free);
    6438:	4901      	ldr	r1, [pc, #4]	; (6440 <ll_rx_link_release+0x8>)
    643a:	f00a b90a 	b.w	10652 <mem_release>
    643e:	bf00      	nop
    6440:	20000c30 	.word	0x20000c30

00006444 <ll_rx_alloc>:
	return mem_acquire(&mem_pdu_rx.free);
    6444:	4801      	ldr	r0, [pc, #4]	; (644c <ll_rx_alloc+0x8>)
    6446:	f00a b8eb 	b.w	10620 <mem_acquire>
    644a:	bf00      	nop
    644c:	20000ca4 	.word	0x20000ca4

00006450 <ll_rx_release>:
	mem_release(node_rx, &mem_pdu_rx.free);
    6450:	4901      	ldr	r1, [pc, #4]	; (6458 <ll_rx_release+0x8>)
    6452:	f00a b8fe 	b.w	10652 <mem_release>
    6456:	bf00      	nop
    6458:	20000ca4 	.word	0x20000ca4

0000645c <ll_rx_put>:
	memq_enqueue(link, rx, &memq_ll_rx.tail);
    645c:	4a01      	ldr	r2, [pc, #4]	; (6464 <ll_rx_put+0x8>)
    645e:	f00a b92f 	b.w	106c0 <memq_enqueue>
    6462:	bf00      	nop
    6464:	20001a2c 	.word	0x20001a2c

00006468 <ll_rx_sched>:
	k_sem_give(sem_recv);
    6468:	4b01      	ldr	r3, [pc, #4]	; (6470 <ll_rx_sched+0x8>)
    646a:	6818      	ldr	r0, [r3, #0]
    646c:	f008 b906 	b.w	e67c <z_impl_k_sem_give>
    6470:	20001a40 	.word	0x20001a40

00006474 <rx_demux>:

static void rx_demux(void *param)
{
    6474:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if !defined(CONFIG_BT_CTLR_LOW_LAT_ULL)
	do {
#endif /* CONFIG_BT_CTLR_LOW_LAT_ULL */
		struct node_rx_hdr *rx;

		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
    6476:	4c30      	ldr	r4, [pc, #192]	; (6538 <rx_demux+0xc4>)
			memq_link_t *link_tx;
			uint16_t handle; /* Handle to Ack TX */
#endif /* CONFIG_BT_CONN */
			int nack = 0;

			LL_ASSERT(rx);
    6478:	4f30      	ldr	r7, [pc, #192]	; (653c <rx_demux+0xc8>)
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
    647a:	e9d4 0100 	ldrd	r0, r1, [r4]
    647e:	aa01      	add	r2, sp, #4
    6480:	f00a f925 	bl	106ce <memq_peek>
		if (link) {
    6484:	4605      	mov	r5, r0
    6486:	2800      	cmp	r0, #0
    6488:	d054      	beq.n	6534 <rx_demux+0xc0>
			LL_ASSERT(rx);
    648a:	9b01      	ldr	r3, [sp, #4]
    648c:	b963      	cbnz	r3, 64a8 <rx_demux+0x34>
    648e:	492c      	ldr	r1, [pc, #176]	; (6540 <rx_demux+0xcc>)
    6490:	482c      	ldr	r0, [pc, #176]	; (6544 <rx_demux+0xd0>)
    6492:	f640 039c 	movw	r3, #2204	; 0x89c
    6496:	463a      	mov	r2, r7
    6498:	f009 f815 	bl	f4c6 <printk>
    649c:	4040      	eors	r0, r0
    649e:	f380 8811 	msr	BASEPRI, r0
    64a2:	f04f 0003 	mov.w	r0, #3
    64a6:	df02      	svc	2
				rx_demux_conn_tx_ack(rx->ack_last, handle,
						     link_tx, node_tx);
			} else
#endif /* CONFIG_BT_CONN */
			{
				nack = rx_demux_rx(link, rx);
    64a8:	9e01      	ldr	r6, [sp, #4]
 *   Execution context: ULL high priority Mayfly
 */
static inline int rx_demux_rx(memq_link_t *link, struct node_rx_hdr *rx)
{
	/* Demux Rx objects */
	switch (rx->type) {
    64aa:	7933      	ldrb	r3, [r6, #4]
    64ac:	3b01      	subs	r3, #1
    64ae:	2b14      	cmp	r3, #20
    64b0:	d832      	bhi.n	6518 <rx_demux+0xa4>
    64b2:	e8df f003 	tbb	[pc, r3]
    64b6:	312b      	.short	0x312b
    64b8:	0b2b3131 	.word	0x0b2b3131
    64bc:	210b0b31 	.word	0x210b0b31
    64c0:	31313131 	.word	0x31313131
    64c4:	31313131 	.word	0x31313131
    64c8:	3131      	.short	0x3131
    64ca:	2b          	.byte	0x2b
    64cb:	00          	.byte	0x00
	case NODE_RX_TYPE_SYNC_REPORT:
#endif /* CONFIG_BT_CTLR_SYNC_PERIODIC */
	{
		struct pdu_adv *adv;

		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
    64cc:	6860      	ldr	r0, [r4, #4]
    64ce:	2200      	movs	r2, #0
    64d0:	4621      	mov	r1, r4
    64d2:	f00a f904 	bl	106de <memq_dequeue>

		adv = (void *)((struct node_rx_pdu *)rx)->pdu;
		if (adv->type != PDU_ADV_TYPE_EXT_IND) {
    64d6:	7f33      	ldrb	r3, [r6, #28]
    64d8:	f003 030f 	and.w	r3, r3, #15
    64dc:	2b07      	cmp	r3, #7
    64de:	d006      	beq.n	64ee <rx_demux+0x7a>
#endif /* CONFIG_BT_CTLR_SCAN_INDICATION */

	case NODE_RX_TYPE_RELEASE:
	{
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
		ll_rx_put(link, rx);
    64e0:	4631      	mov	r1, r6
    64e2:	4628      	mov	r0, r5
    64e4:	f7ff ffba 	bl	645c <ll_rx_put>
		ll_rx_sched();
    64e8:	f7ff ffbe 	bl	6468 <ll_rx_sched>
	}
	break;
    64ec:	e7c5      	b.n	647a <rx_demux+0x6>
		ull_scan_aux_setup(link, rx);
    64ee:	4631      	mov	r1, r6
    64f0:	4628      	mov	r0, r5
    64f2:	f7fa feb5 	bl	1260 <ull_scan_aux_setup>
	break;
    64f6:	e7c0      	b.n	647a <rx_demux+0x6>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
    64f8:	4621      	mov	r1, r4
    64fa:	6860      	ldr	r0, [r4, #4]
    64fc:	2200      	movs	r2, #0
    64fe:	f00a f8ee 	bl	106de <memq_dequeue>
		ull_scan_aux_release(link, rx);
    6502:	4631      	mov	r1, r6
    6504:	4628      	mov	r0, r5
    6506:	f001 fe89 	bl	821c <ull_scan_aux_release>
	break;
    650a:	e7b6      	b.n	647a <rx_demux+0x6>
		(void)memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
    650c:	6860      	ldr	r0, [r4, #4]
    650e:	2200      	movs	r2, #0
    6510:	4621      	mov	r1, r4
    6512:	f00a f8e4 	bl	106de <memq_dequeue>
    6516:	e7e3      	b.n	64e0 <rx_demux+0x6c>
#if defined(CONFIG_BT_CTLR_USER_EXT)
		/* Try proprietary demuxing */
		rx_demux_rx_proprietary(link, rx, memq_ull_rx.tail,
					&memq_ull_rx.head);
#else
		LL_ASSERT(0);
    6518:	490b      	ldr	r1, [pc, #44]	; (6548 <rx_demux+0xd4>)
    651a:	480a      	ldr	r0, [pc, #40]	; (6544 <rx_demux+0xd0>)
    651c:	f640 230e 	movw	r3, #2574	; 0xa0e
    6520:	463a      	mov	r2, r7
    6522:	f008 ffd0 	bl	f4c6 <printk>
    6526:	4040      	eors	r0, r0
    6528:	f380 8811 	msr	BASEPRI, r0
    652c:	f04f 0003 	mov.w	r0, #3
    6530:	df02      	svc	2
#endif /* CONFIG_BT_CTLR_USER_EXT */
	}
	break;
    6532:	e7a2      	b.n	647a <rx_demux+0x6>
}
    6534:	b003      	add	sp, #12
    6536:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6538:	20001a38 	.word	0x20001a38
    653c:	000135ab 	.word	0x000135ab
    6540:	00013de2 	.word	0x00013de2
    6544:	000133b6 	.word	0x000133b6
    6548:	00014086 	.word	0x00014086

0000654c <ull_ticker_status_take>:
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    654c:	f030 0302 	bics.w	r3, r0, #2
{
    6550:	b510      	push	{r4, lr}
    6552:	460c      	mov	r4, r1
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    6554:	d00f      	beq.n	6576 <ull_ticker_status_take+0x2a>
    6556:	680b      	ldr	r3, [r1, #0]
    6558:	2b02      	cmp	r3, #2
    655a:	d10c      	bne.n	6576 <ull_ticker_status_take+0x2a>
    655c:	4a0a      	ldr	r2, [pc, #40]	; (6588 <ull_ticker_status_take+0x3c>)
    655e:	490b      	ldr	r1, [pc, #44]	; (658c <ull_ticker_status_take+0x40>)
    6560:	480b      	ldr	r0, [pc, #44]	; (6590 <ull_ticker_status_take+0x44>)
    6562:	f44f 63ce 	mov.w	r3, #1648	; 0x670
    6566:	f008 ffae 	bl	f4c6 <printk>
    656a:	4040      	eors	r0, r0
    656c:	f380 8811 	msr	BASEPRI, r0
    6570:	f04f 0003 	mov.w	r0, #3
    6574:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    6576:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    657a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    657e:	4805      	ldr	r0, [pc, #20]	; (6594 <ull_ticker_status_take+0x48>)
    6580:	f008 f8a2 	bl	e6c8 <z_impl_k_sem_take>
	return *ret_cb;
    6584:	6820      	ldr	r0, [r4, #0]
}
    6586:	bd10      	pop	{r4, pc}
    6588:	000135ab 	.word	0x000135ab
    658c:	00013674 	.word	0x00013674
    6590:	000133b6 	.word	0x000133b6
    6594:	20001a44 	.word	0x20001a44

00006598 <ull_disable_mark>:
	if (!*m) {
    6598:	4b02      	ldr	r3, [pc, #8]	; (65a4 <ull_disable_mark+0xc>)
    659a:	681a      	ldr	r2, [r3, #0]
    659c:	b902      	cbnz	r2, 65a0 <ull_disable_mark+0x8>
		*m = param;
    659e:	6018      	str	r0, [r3, #0]
}
    65a0:	6818      	ldr	r0, [r3, #0]
    65a2:	4770      	bx	lr
    65a4:	20000bf4 	.word	0x20000bf4

000065a8 <ull_disable_unmark>:
	if (*m && *m == param) {
    65a8:	4a05      	ldr	r2, [pc, #20]	; (65c0 <ull_disable_unmark+0x18>)
{
    65aa:	4603      	mov	r3, r0
	if (*m && *m == param) {
    65ac:	6810      	ldr	r0, [r2, #0]
    65ae:	b130      	cbz	r0, 65be <ull_disable_unmark+0x16>
    65b0:	4283      	cmp	r3, r0
    65b2:	f04f 0300 	mov.w	r3, #0
    65b6:	d101      	bne.n	65bc <ull_disable_unmark+0x14>
		*m = NULL;
    65b8:	6013      	str	r3, [r2, #0]
		return param;
    65ba:	4770      	bx	lr
	return NULL;
    65bc:	4618      	mov	r0, r3
}
    65be:	4770      	bx	lr
    65c0:	20000bf4 	.word	0x20000bf4

000065c4 <ull_disable_mark_get>:
}
    65c4:	4b01      	ldr	r3, [pc, #4]	; (65cc <ull_disable_mark_get+0x8>)
    65c6:	6818      	ldr	r0, [r3, #0]
    65c8:	4770      	bx	lr
    65ca:	bf00      	nop
    65cc:	20000bf4 	.word	0x20000bf4

000065d0 <ull_disable>:
{
    65d0:	b530      	push	{r4, r5, lr}
	hdr = HDR_LLL2ULL(lll);
    65d2:	6804      	ldr	r4, [r0, #0]
{
    65d4:	b087      	sub	sp, #28
    65d6:	4605      	mov	r5, r0
	if (!hdr || !ull_ref_get(hdr)) {
    65d8:	b914      	cbnz	r4, 65e0 <ull_disable+0x10>
		return 0;
    65da:	2000      	movs	r0, #0
}
    65dc:	b007      	add	sp, #28
    65de:	bd30      	pop	{r4, r5, pc}
    65e0:	7823      	ldrb	r3, [r4, #0]
	if (!hdr || !ull_ref_get(hdr)) {
    65e2:	2b00      	cmp	r3, #0
    65e4:	d0f9      	beq.n	65da <ull_disable+0xa>
	return z_impl_k_sem_init(sem, initial_count, limit);
    65e6:	2201      	movs	r2, #1
    65e8:	2100      	movs	r1, #0
    65ea:	4668      	mov	r0, sp
    65ec:	f00c f846 	bl	1267c <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
    65f0:	4b11      	ldr	r3, [pc, #68]	; (6638 <ull_disable+0x68>)
    65f2:	6163      	str	r3, [r4, #20]
    65f4:	7823      	ldrb	r3, [r4, #0]
	hdr->disabled_param = &sem;
    65f6:	f8c4 d018 	str.w	sp, [r4, #24]
	if (!ull_ref_get(hdr)) {
    65fa:	2b00      	cmp	r3, #0
    65fc:	d0ed      	beq.n	65da <ull_disable+0xa>
	mfy.param = lll;
    65fe:	4b0f      	ldr	r3, [pc, #60]	; (663c <ull_disable+0x6c>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
    6600:	2200      	movs	r2, #0
    6602:	4611      	mov	r1, r2
    6604:	2003      	movs	r0, #3
	mfy.param = lll;
    6606:	609d      	str	r5, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
    6608:	f7fd fcd8 	bl	3fbc <mayfly_enqueue>
	LL_ASSERT(!ret);
    660c:	b160      	cbz	r0, 6628 <ull_disable+0x58>
    660e:	4a0c      	ldr	r2, [pc, #48]	; (6640 <ull_disable+0x70>)
    6610:	490c      	ldr	r1, [pc, #48]	; (6644 <ull_disable+0x74>)
    6612:	480d      	ldr	r0, [pc, #52]	; (6648 <ull_disable+0x78>)
    6614:	f240 63eb 	movw	r3, #1771	; 0x6eb
    6618:	f008 ff55 	bl	f4c6 <printk>
    661c:	4040      	eors	r0, r0
    661e:	f380 8811 	msr	BASEPRI, r0
    6622:	f04f 0003 	mov.w	r0, #3
    6626:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    6628:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    662c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6630:	4668      	mov	r0, sp
    6632:	f008 f849 	bl	e6c8 <z_impl_k_sem_take>
	return k_sem_take(&sem, K_FOREVER);
    6636:	e7d1      	b.n	65dc <ull_disable+0xc>
    6638:	00010fbf 	.word	0x00010fbf
    663c:	20000378 	.word	0x20000378
    6640:	000135ab 	.word	0x000135ab
    6644:	0001366f 	.word	0x0001366f
    6648:	000133b6 	.word	0x000133b6

0000664c <ull_ticker_stop_with_mark>:
{
    664c:	b5f0      	push	{r4, r5, r6, r7, lr}
    664e:	4606      	mov	r6, r0
    6650:	b085      	sub	sp, #20
	mark = ull_disable_mark(param);
    6652:	4608      	mov	r0, r1
{
    6654:	4615      	mov	r5, r2
	mark = ull_disable_mark(param);
    6656:	f7ff ff9f 	bl	6598 <ull_disable_mark>
	if (mark != param) {
    665a:	4281      	cmp	r1, r0
{
    665c:	460c      	mov	r4, r1
	if (mark != param) {
    665e:	d121      	bne.n	66a4 <ull_ticker_stop_with_mark+0x58>
	ret_cb = TICKER_STATUS_BUSY;
    6660:	2302      	movs	r3, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
    6662:	af03      	add	r7, sp, #12
	ret_cb = TICKER_STATUS_BUSY;
    6664:	9303      	str	r3, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
    6666:	2103      	movs	r1, #3
    6668:	4b11      	ldr	r3, [pc, #68]	; (66b0 <ull_ticker_stop_with_mark+0x64>)
    666a:	9700      	str	r7, [sp, #0]
    666c:	4632      	mov	r2, r6
    666e:	2000      	movs	r0, #0
    6670:	f7fe fa9a 	bl	4ba8 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
    6674:	4639      	mov	r1, r7
    6676:	f7ff ff69 	bl	654c <ull_ticker_status_take>
	if (ret) {
    667a:	b148      	cbz	r0, 6690 <ull_ticker_stop_with_mark+0x44>
		mark = ull_disable_unmark(param);
    667c:	4620      	mov	r0, r4
    667e:	f7ff ff93 	bl	65a8 <ull_disable_unmark>
		if (mark != param) {
    6682:	4284      	cmp	r4, r0
    6684:	d10e      	bne.n	66a4 <ull_ticker_stop_with_mark+0x58>
		return -EALREADY;
    6686:	f06f 0177 	mvn.w	r1, #119	; 0x77
}
    668a:	4608      	mov	r0, r1
    668c:	b005      	add	sp, #20
    668e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ret = ull_disable(lll_disable);
    6690:	4628      	mov	r0, r5
    6692:	f7ff ff9d 	bl	65d0 <ull_disable>
	if (ret) {
    6696:	4601      	mov	r1, r0
    6698:	b938      	cbnz	r0, 66aa <ull_ticker_stop_with_mark+0x5e>
	mark = ull_disable_unmark(param);
    669a:	4620      	mov	r0, r4
    669c:	f7ff ff84 	bl	65a8 <ull_disable_unmark>
	if (mark != param) {
    66a0:	4284      	cmp	r4, r0
    66a2:	d0f2      	beq.n	668a <ull_ticker_stop_with_mark+0x3e>
		return -ENOLCK;
    66a4:	f06f 012d 	mvn.w	r1, #45	; 0x2d
    66a8:	e7ef      	b.n	668a <ull_ticker_stop_with_mark+0x3e>
		return -EBUSY;
    66aa:	f06f 010f 	mvn.w	r1, #15
    66ae:	e7ec      	b.n	668a <ull_ticker_stop_with_mark+0x3e>
    66b0:	00006209 	.word	0x00006209

000066b4 <ull_pdu_rx_alloc_peek>:
{
    66b4:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
    66b6:	4a0a      	ldr	r2, [pc, #40]	; (66e0 <ull_pdu_rx_alloc_peek+0x2c>)
    66b8:	7891      	ldrb	r1, [r2, #2]
    66ba:	78d4      	ldrb	r4, [r2, #3]
    66bc:	7853      	ldrb	r3, [r2, #1]
 * @details API 1 and 2
 *   Empty if first == last
 */
static inline uint8_t mfifo_avail_count_get(uint8_t count, uint8_t first, uint8_t last)
{
	if (last >= first) {
    66be:	42a1      	cmp	r1, r4
		return last - first;
	} else {
		return count - first + last;
    66c0:	bf8a      	itet	hi
    66c2:	1a5b      	subhi	r3, r3, r1
		return last - first;
    66c4:	1a63      	subls	r3, r4, r1
		return count - first + last;
    66c6:	191b      	addhi	r3, r3, r4
    66c8:	b2db      	uxtb	r3, r3
    66ca:	4298      	cmp	r0, r3
    66cc:	d806      	bhi.n	66dc <ull_pdu_rx_alloc_peek+0x28>
 * @details API 2
 */
static inline void *mfifo_dequeue_peek(uint8_t *fifo, uint8_t size, uint8_t first,
				       uint8_t last)
{
	if (first == last) {
    66ce:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
    66d0:	7813      	ldrb	r3, [r2, #0]
    66d2:	d003      	beq.n	66dc <ull_pdu_rx_alloc_peek+0x28>
		return NULL; /* Queue is empty */
	}

	/* API 2: fifo is array of void-ptrs */
	return *((void **)(fifo + first * size));
    66d4:	fb01 2203 	mla	r2, r1, r3, r2
    66d8:	6850      	ldr	r0, [r2, #4]
}
    66da:	bd10      	pop	{r4, pc}
		return NULL;
    66dc:	2000      	movs	r0, #0
    66de:	e7fc      	b.n	66da <ull_pdu_rx_alloc_peek+0x26>
    66e0:	20000200 	.word	0x20000200

000066e4 <ull_pdu_rx_alloc>:
{
    66e4:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(pdu_rx_free);
    66e6:	4a09      	ldr	r2, [pc, #36]	; (670c <ull_pdu_rx_alloc+0x28>)
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(uint8_t *fifo, uint8_t size, uint8_t count,
				  uint8_t last, uint8_t *first)
{
	uint8_t _first = *first; /* Copy read-index */
    66e8:	7893      	ldrb	r3, [r2, #2]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
    66ea:	78d0      	ldrb	r0, [r2, #3]
    66ec:	7811      	ldrb	r1, [r2, #0]
    66ee:	7854      	ldrb	r4, [r2, #1]
    66f0:	4298      	cmp	r0, r3
    66f2:	d009      	beq.n	6708 <ull_pdu_rx_alloc+0x24>
	}

	/* Obtain address of head buffer.
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));
    66f4:	fb03 2101 	mla	r1, r3, r1, r2

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
    66f8:	3301      	adds	r3, #1
    66fa:	b2db      	uxtb	r3, r3
	if (_first == count) {
		_first = 0U;
    66fc:	429c      	cmp	r4, r3
    66fe:	bf08      	it	eq
    6700:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
    6702:	6848      	ldr	r0, [r1, #4]
	}

	*first = _first; /* Write back read-index */
    6704:	7093      	strb	r3, [r2, #2]
}
    6706:	bd10      	pop	{r4, pc}
		return NULL;
    6708:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(pdu_rx_free);
    670a:	e7fc      	b.n	6706 <ull_pdu_rx_alloc+0x22>
    670c:	20000200 	.word	0x20000200

00006710 <ull_rx_put>:
	memq_enqueue(link, rx, &memq_ull_rx.tail);
    6710:	4a01      	ldr	r2, [pc, #4]	; (6718 <ull_rx_put+0x8>)
    6712:	f009 bfd5 	b.w	106c0 <memq_enqueue>
    6716:	bf00      	nop
    6718:	20001a3c 	.word	0x20001a3c

0000671c <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
    671c:	2201      	movs	r2, #1
    671e:	4b02      	ldr	r3, [pc, #8]	; (6728 <ull_rx_sched+0xc>)
    6720:	4611      	mov	r1, r2
    6722:	2000      	movs	r0, #0
    6724:	f7fd bc4a 	b.w	3fbc <mayfly_enqueue>
    6728:	20000368 	.word	0x20000368

0000672c <ull_rx_put_done>:
	memq_enqueue(link, done, &memq_ull_done.tail);
    672c:	4a01      	ldr	r2, [pc, #4]	; (6734 <ull_rx_put_done+0x8>)
    672e:	f009 bfc7 	b.w	106c0 <memq_enqueue>
    6732:	bf00      	nop
    6734:	20001a34 	.word	0x20001a34

00006738 <ull_rx_sched_done>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
    6738:	2201      	movs	r2, #1
    673a:	4b02      	ldr	r3, [pc, #8]	; (6744 <ull_rx_sched_done+0xc>)
    673c:	4611      	mov	r1, r2
    673e:	2000      	movs	r0, #0
    6740:	f7fd bc3c 	b.w	3fbc <mayfly_enqueue>
    6744:	20000358 	.word	0x20000358

00006748 <ull_prepare_enqueue>:
{
    6748:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    674c:	4e14      	ldr	r6, [pc, #80]	; (67a0 <ull_prepare_enqueue+0x58>)
{
    674e:	4699      	mov	r9, r3
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    6750:	78f3      	ldrb	r3, [r6, #3]
	if (last == count) {
    6752:	7874      	ldrb	r4, [r6, #1]
	last = last + 1;
    6754:	1c5d      	adds	r5, r3, #1
{
    6756:	4680      	mov	r8, r0
    6758:	b2ed      	uxtb	r5, r5
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    675a:	78b0      	ldrb	r0, [r6, #2]
		last = 0U;
    675c:	42ac      	cmp	r4, r5
    675e:	bf08      	it	eq
    6760:	2500      	moveq	r5, #0
	if (last == first) {
    6762:	42a8      	cmp	r0, r5
{
    6764:	460f      	mov	r7, r1
    6766:	4611      	mov	r1, r2
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
    6768:	7832      	ldrb	r2, [r6, #0]
    676a:	d017      	beq.n	679c <ull_prepare_enqueue+0x54>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
    676c:	1d34      	adds	r4, r6, #4
    676e:	fb03 4402 	mla	r4, r3, r2, r4
	if (!e) {
    6772:	b184      	cbz	r4, 6796 <ull_prepare_enqueue+0x4e>
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
    6774:	2210      	movs	r2, #16
    6776:	4620      	mov	r0, r4
    6778:	f009 fa15 	bl	fba6 <memcpy>
	e->is_resume = is_resume;
    677c:	7f23      	ldrb	r3, [r4, #28]
    677e:	f89d 2020 	ldrb.w	r2, [sp, #32]
	e->abort_cb = abort_cb;
    6782:	61a7      	str	r7, [r4, #24]
	e->is_resume = is_resume;
    6784:	f002 0201 	and.w	r2, r2, #1
    6788:	f023 0303 	bic.w	r3, r3, #3
    678c:	4313      	orrs	r3, r2
	e->is_abort_cb = is_abort_cb;
    678e:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->is_resume = is_resume;
    6792:	7723      	strb	r3, [r4, #28]
	*last = idx; /* Commit: Update write index */
    6794:	70f5      	strb	r5, [r6, #3]
}
    6796:	4620      	mov	r0, r4
    6798:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return NULL;
    679c:	2400      	movs	r4, #0
    679e:	e7fa      	b.n	6796 <ull_prepare_enqueue+0x4e>
    67a0:	20000234 	.word	0x20000234

000067a4 <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
    67a4:	4b05      	ldr	r3, [pc, #20]	; (67bc <ull_prepare_dequeue_get+0x18>)
    67a6:	7898      	ldrb	r0, [r3, #2]
	if (first == last) {
    67a8:	78d9      	ldrb	r1, [r3, #3]
    67aa:	781a      	ldrb	r2, [r3, #0]
    67ac:	4281      	cmp	r1, r0
	return (void *)(fifo + first * size);
    67ae:	bf1a      	itte	ne
    67b0:	3304      	addne	r3, #4
    67b2:	fb00 3002 	mlane	r0, r0, r2, r3
		return NULL;
    67b6:	2000      	moveq	r0, #0
}
    67b8:	4770      	bx	lr
    67ba:	bf00      	nop
    67bc:	20000234 	.word	0x20000234

000067c0 <ull_prepare_dequeue_iter>:
{
    67c0:	b530      	push	{r4, r5, lr}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    67c2:	4a0c      	ldr	r2, [pc, #48]	; (67f4 <ull_prepare_dequeue_iter+0x34>)
{
    67c4:	4603      	mov	r3, r0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    67c6:	7854      	ldrb	r4, [r2, #1]
	if (*idx >= count) {
    67c8:	7819      	ldrb	r1, [r3, #0]
    67ca:	78d0      	ldrb	r0, [r2, #3]
    67cc:	7815      	ldrb	r5, [r2, #0]
    67ce:	42a1      	cmp	r1, r4
    67d0:	bf24      	itt	cs
    67d2:	7892      	ldrbcs	r2, [r2, #2]
		*idx = first;
    67d4:	701a      	strbcs	r2, [r3, #0]
	if (*idx == last) {
    67d6:	7819      	ldrb	r1, [r3, #0]
    67d8:	4288      	cmp	r0, r1
    67da:	d009      	beq.n	67f0 <ull_prepare_dequeue_iter+0x30>
	i = *idx + 1;
    67dc:	1c4a      	adds	r2, r1, #1
	p = (void *)(fifo + (*idx) * size);
    67de:	4806      	ldr	r0, [pc, #24]	; (67f8 <ull_prepare_dequeue_iter+0x38>)
	i = *idx + 1;
    67e0:	b2d2      	uxtb	r2, r2
		i = 0U;
    67e2:	4294      	cmp	r4, r2
    67e4:	bf08      	it	eq
    67e6:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
    67e8:	fb01 0005 	mla	r0, r1, r5, r0
	*idx = i;
    67ec:	701a      	strb	r2, [r3, #0]
}
    67ee:	bd30      	pop	{r4, r5, pc}
		return NULL;
    67f0:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
    67f2:	e7fc      	b.n	67ee <ull_prepare_dequeue_iter+0x2e>
    67f4:	20000234 	.word	0x20000234
    67f8:	20000238 	.word	0x20000238

000067fc <ull_prepare_dequeue>:
{
    67fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6800:	4605      	mov	r5, r0
	next = ull_prepare_dequeue_get();
    6802:	f7ff ffcf 	bl	67a4 <ull_prepare_dequeue_get>
			mfy.param = next;
    6806:	4f1c      	ldr	r7, [pc, #112]	; (6878 <ull_prepare_dequeue+0x7c>)
		MFIFO_DEQUEUE(prep);
    6808:	4c1c      	ldr	r4, [pc, #112]	; (687c <ull_prepare_dequeue+0x80>)
	while (next) {
    680a:	2800      	cmp	r0, #0
    680c:	d031      	beq.n	6872 <ull_prepare_dequeue+0x76>
		uint8_t is_aborted = next->is_aborted;
    680e:	7f03      	ldrb	r3, [r0, #28]
		if (!is_aborted) {
    6810:	079a      	lsls	r2, r3, #30
		uint8_t is_aborted = next->is_aborted;
    6812:	f3c3 0640 	ubfx	r6, r3, #1, #1
		uint8_t is_resume = next->is_resume;
    6816:	f003 0801 	and.w	r8, r3, #1
		if (!is_aborted) {
    681a:	d414      	bmi.n	6846 <ull_prepare_dequeue+0x4a>
			mfy.param = next;
    681c:	60b8      	str	r0, [r7, #8]
			ret = mayfly_enqueue(caller_id, TICKER_USER_ID_LLL, 0,
    681e:	4b16      	ldr	r3, [pc, #88]	; (6878 <ull_prepare_dequeue+0x7c>)
    6820:	4632      	mov	r2, r6
    6822:	4631      	mov	r1, r6
    6824:	4628      	mov	r0, r5
    6826:	f7fd fbc9 	bl	3fbc <mayfly_enqueue>
			LL_ASSERT(!ret);
    682a:	b160      	cbz	r0, 6846 <ull_prepare_dequeue+0x4a>
    682c:	4a14      	ldr	r2, [pc, #80]	; (6880 <ull_prepare_dequeue+0x84>)
    682e:	4915      	ldr	r1, [pc, #84]	; (6884 <ull_prepare_dequeue+0x88>)
    6830:	4815      	ldr	r0, [pc, #84]	; (6888 <ull_prepare_dequeue+0x8c>)
    6832:	f240 7362 	movw	r3, #1890	; 0x762
    6836:	f008 fe46 	bl	f4c6 <printk>
    683a:	4040      	eors	r0, r0
    683c:	f380 8811 	msr	BASEPRI, r0
    6840:	f04f 0003 	mov.w	r0, #3
    6844:	df02      	svc	2
	uint8_t _first = *first; /* Copy read-index */
    6846:	78a3      	ldrb	r3, [r4, #2]
	if (_first == last) {
    6848:	78e1      	ldrb	r1, [r4, #3]
		MFIFO_DEQUEUE(prep);
    684a:	7862      	ldrb	r2, [r4, #1]
    684c:	4299      	cmp	r1, r3
    684e:	d005      	beq.n	685c <ull_prepare_dequeue+0x60>
	_first += 1U;
    6850:	3301      	adds	r3, #1
    6852:	b2db      	uxtb	r3, r3
		_first = 0U;
    6854:	429a      	cmp	r2, r3
    6856:	bf08      	it	eq
    6858:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
    685a:	70a3      	strb	r3, [r4, #2]
		next = ull_prepare_dequeue_get();
    685c:	f7ff ffa2 	bl	67a4 <ull_prepare_dequeue_get>
		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
    6860:	b138      	cbz	r0, 6872 <ull_prepare_dequeue+0x76>
    6862:	2e00      	cmp	r6, #0
    6864:	d1d1      	bne.n	680a <ull_prepare_dequeue+0xe>
    6866:	f1b8 0f00 	cmp.w	r8, #0
    686a:	d002      	beq.n	6872 <ull_prepare_dequeue+0x76>
    686c:	7f03      	ldrb	r3, [r0, #28]
    686e:	07db      	lsls	r3, r3, #31
    6870:	d5cb      	bpl.n	680a <ull_prepare_dequeue+0xe>
}
    6872:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6876:	bf00      	nop
    6878:	20000338 	.word	0x20000338
    687c:	20000234 	.word	0x20000234
    6880:	000135ab 	.word	0x000135ab
    6884:	0001366f 	.word	0x0001366f
    6888:	000133b6 	.word	0x000133b6

0000688c <ull_event_done_extra_get>:
	evdone = MFIFO_DEQUEUE_PEEK(done);
    688c:	4b06      	ldr	r3, [pc, #24]	; (68a8 <ull_event_done_extra_get+0x1c>)
    688e:	789a      	ldrb	r2, [r3, #2]
	if (first == last) {
    6890:	78d8      	ldrb	r0, [r3, #3]
    6892:	7819      	ldrb	r1, [r3, #0]
    6894:	4290      	cmp	r0, r2
    6896:	d005      	beq.n	68a4 <ull_event_done_extra_get+0x18>
	return *((void **)(fifo + first * size));
    6898:	fb02 3301 	mla	r3, r2, r1, r3
    689c:	6858      	ldr	r0, [r3, #4]
	if (!evdone) {
    689e:	b110      	cbz	r0, 68a6 <ull_event_done_extra_get+0x1a>
	return &evdone->extra;
    68a0:	3020      	adds	r0, #32
    68a2:	4770      	bx	lr
		return NULL;
    68a4:	2000      	movs	r0, #0
}
    68a6:	4770      	bx	lr
    68a8:	200001e4 	.word	0x200001e4

000068ac <ull_event_done>:
{
    68ac:	b538      	push	{r3, r4, r5, lr}
	evdone = MFIFO_DEQUEUE(done);
    68ae:	4a10      	ldr	r2, [pc, #64]	; (68f0 <ull_event_done+0x44>)
	uint8_t _first = *first; /* Copy read-index */
    68b0:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
    68b2:	78d4      	ldrb	r4, [r2, #3]
    68b4:	7855      	ldrb	r5, [r2, #1]
    68b6:	429c      	cmp	r4, r3
{
    68b8:	4601      	mov	r1, r0
	evdone = MFIFO_DEQUEUE(done);
    68ba:	7810      	ldrb	r0, [r2, #0]
    68bc:	d016      	beq.n	68ec <ull_event_done+0x40>
	mem = *((void **)(fifo + _first * size));
    68be:	fb03 2000 	mla	r0, r3, r0, r2
	_first += 1U;
    68c2:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
    68c4:	6844      	ldr	r4, [r0, #4]
	_first += 1U;
    68c6:	b2db      	uxtb	r3, r3
		_first = 0U;
    68c8:	429d      	cmp	r5, r3
    68ca:	bf08      	it	eq
    68cc:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
    68ce:	7093      	strb	r3, [r2, #2]
	if (!evdone) {
    68d0:	b154      	cbz	r4, 68e8 <ull_event_done+0x3c>
	evdone->hdr.link = NULL;
    68d2:	2300      	movs	r3, #0
	link = evdone->hdr.link;
    68d4:	6820      	ldr	r0, [r4, #0]
	evdone->hdr.link = NULL;
    68d6:	6023      	str	r3, [r4, #0]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
    68d8:	2302      	movs	r3, #2
    68da:	7123      	strb	r3, [r4, #4]
	evdone->param = param;
    68dc:	61e1      	str	r1, [r4, #28]
	ull_rx_put_done(link, evdone);
    68de:	4621      	mov	r1, r4
    68e0:	f7ff ff24 	bl	672c <ull_rx_put_done>
	ull_rx_sched_done();
    68e4:	f7ff ff28 	bl	6738 <ull_rx_sched_done>
}
    68e8:	4620      	mov	r0, r4
    68ea:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
    68ec:	2400      	movs	r4, #0
    68ee:	e7fb      	b.n	68e8 <ull_event_done+0x3c>
    68f0:	200001e4 	.word	0x200001e4

000068f4 <init_reset>:
{
    68f4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	RXFIFO_INIT_ALLOC(done);
    68f6:	4c3e      	ldr	r4, [pc, #248]	; (69f0 <init_reset+0xfc>)
    68f8:	4d3e      	ldr	r5, [pc, #248]	; (69f4 <init_reset+0x100>)
    68fa:	79a2      	ldrb	r2, [r4, #6]
    68fc:	88a1      	ldrh	r1, [r4, #4]
    68fe:	4e3e      	ldr	r6, [pc, #248]	; (69f8 <init_reset+0x104>)
    6900:	2300      	movs	r3, #0
    6902:	f104 0008 	add.w	r0, r4, #8
    6906:	806b      	strh	r3, [r5, #2]
    6908:	4623      	mov	r3, r4
    690a:	f009 fe61 	bl	105d0 <mem_init>
    690e:	79a1      	ldrb	r1, [r4, #6]
    6910:	79e2      	ldrb	r2, [r4, #7]
    6912:	4633      	mov	r3, r6
    6914:	440a      	add	r2, r1
    6916:	1d30      	adds	r0, r6, #4
    6918:	2108      	movs	r1, #8
    691a:	f009 fe59 	bl	105d0 <mem_init>
    691e:	462a      	mov	r2, r5
    6920:	79a3      	ldrb	r3, [r4, #6]
    6922:	f812 0b04 	ldrb.w	r0, [r2], #4
    6926:	7869      	ldrb	r1, [r5, #1]
    6928:	e9cd 2400 	strd	r2, r4, [sp]
    692c:	e9cd 6302 	strd	r6, r3, [sp, #8]
    6930:	78aa      	ldrb	r2, [r5, #2]
    6932:	1ceb      	adds	r3, r5, #3
    6934:	f00a fb4c 	bl	10fd0 <ull_rxfifo_alloc>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
    6938:	4b30      	ldr	r3, [pc, #192]	; (69fc <init_reset+0x108>)
    693a:	220c      	movs	r2, #12
    693c:	1d18      	adds	r0, r3, #4
    693e:	f44f 7190 	mov.w	r1, #288	; 0x120
    6942:	f009 fe45 	bl	105d0 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
    6946:	4b2e      	ldr	r3, [pc, #184]	; (6a00 <init_reset+0x10c>)
    6948:	220e      	movs	r2, #14
    694a:	1d18      	adds	r0, r3, #4
    694c:	2108      	movs	r1, #8
    694e:	f009 fe3f 	bl	105d0 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
    6952:	482b      	ldr	r0, [pc, #172]	; (6a00 <init_reset+0x10c>)
    6954:	f009 fe64 	bl	10620 <mem_acquire>
	LL_ASSERT(link);
    6958:	4604      	mov	r4, r0
    695a:	b960      	cbnz	r0, 6976 <init_reset+0x82>
    695c:	4a29      	ldr	r2, [pc, #164]	; (6a04 <init_reset+0x110>)
    695e:	492a      	ldr	r1, [pc, #168]	; (6a08 <init_reset+0x114>)
    6960:	482a      	ldr	r0, [pc, #168]	; (6a0c <init_reset+0x118>)
    6962:	f240 73ee 	movw	r3, #2030	; 0x7ee
    6966:	f008 fdae 	bl	f4c6 <printk>
    696a:	4040      	eors	r0, r0
    696c:	f380 8811 	msr	BASEPRI, r0
    6970:	f04f 0003 	mov.w	r0, #3
    6974:	df02      	svc	2
	MEMQ_INIT(ull_rx, link);
    6976:	4a26      	ldr	r2, [pc, #152]	; (6a10 <init_reset+0x11c>)
    6978:	4620      	mov	r0, r4
    697a:	1f11      	subs	r1, r2, #4
    697c:	f009 fe9d 	bl	106ba <memq_init>
	link = mem_acquire(&mem_link_done.free);
    6980:	481d      	ldr	r0, [pc, #116]	; (69f8 <init_reset+0x104>)
    6982:	f009 fe4d 	bl	10620 <mem_acquire>
	LL_ASSERT(link);
    6986:	4604      	mov	r4, r0
    6988:	b960      	cbnz	r0, 69a4 <init_reset+0xb0>
    698a:	4a1e      	ldr	r2, [pc, #120]	; (6a04 <init_reset+0x110>)
    698c:	491e      	ldr	r1, [pc, #120]	; (6a08 <init_reset+0x114>)
    698e:	481f      	ldr	r0, [pc, #124]	; (6a0c <init_reset+0x118>)
    6990:	f240 73f6 	movw	r3, #2038	; 0x7f6
    6994:	f008 fd97 	bl	f4c6 <printk>
    6998:	4040      	eors	r0, r0
    699a:	f380 8811 	msr	BASEPRI, r0
    699e:	f04f 0003 	mov.w	r0, #3
    69a2:	df02      	svc	2
	MEMQ_INIT(ull_done, link);
    69a4:	4a1b      	ldr	r2, [pc, #108]	; (6a14 <init_reset+0x120>)
    69a6:	4620      	mov	r0, r4
    69a8:	1f11      	subs	r1, r2, #4
    69aa:	f009 fe86 	bl	106ba <memq_init>
	link = mem_acquire(&mem_link_rx.free);
    69ae:	4814      	ldr	r0, [pc, #80]	; (6a00 <init_reset+0x10c>)
    69b0:	f009 fe36 	bl	10620 <mem_acquire>
	LL_ASSERT(link);
    69b4:	4604      	mov	r4, r0
    69b6:	b960      	cbnz	r0, 69d2 <init_reset+0xde>
    69b8:	4a12      	ldr	r2, [pc, #72]	; (6a04 <init_reset+0x110>)
    69ba:	4913      	ldr	r1, [pc, #76]	; (6a08 <init_reset+0x114>)
    69bc:	4813      	ldr	r0, [pc, #76]	; (6a0c <init_reset+0x118>)
    69be:	f240 73fe 	movw	r3, #2046	; 0x7fe
    69c2:	f008 fd80 	bl	f4c6 <printk>
    69c6:	4040      	eors	r0, r0
    69c8:	f380 8811 	msr	BASEPRI, r0
    69cc:	f04f 0003 	mov.w	r0, #3
    69d0:	df02      	svc	2
	MEMQ_INIT(ll_rx, link);
    69d2:	4a11      	ldr	r2, [pc, #68]	; (6a18 <init_reset+0x124>)
    69d4:	4620      	mov	r0, r4
    69d6:	1f11      	subs	r1, r2, #4
    69d8:	f009 fe6f 	bl	106ba <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
    69dc:	4b0f      	ldr	r3, [pc, #60]	; (6a1c <init_reset+0x128>)
    69de:	220b      	movs	r2, #11
	rx_alloc(UINT8_MAX);
    69e0:	20ff      	movs	r0, #255	; 0xff
	mem_link_rx.quota_pdu = RX_CNT;
    69e2:	701a      	strb	r2, [r3, #0]
	rx_alloc(UINT8_MAX);
    69e4:	f7ff fb90 	bl	6108 <rx_alloc>
}
    69e8:	2000      	movs	r0, #0
    69ea:	b004      	add	sp, #16
    69ec:	bd70      	pop	{r4, r5, r6, pc}
    69ee:	bf00      	nop
    69f0:	20000114 	.word	0x20000114
    69f4:	200001e4 	.word	0x200001e4
    69f8:	20000bf8 	.word	0x20000bf8
    69fc:	20000ca4 	.word	0x20000ca4
    6a00:	20000c30 	.word	0x20000c30
    6a04:	000135ab 	.word	0x000135ab
    6a08:	00013629 	.word	0x00013629
    6a0c:	000133b6 	.word	0x000133b6
    6a10:	20001a3c 	.word	0x20001a3c
    6a14:	20001a34 	.word	0x20001a34
    6a18:	20001a2c 	.word	0x20001a2c
    6a1c:	20000c2c 	.word	0x20000c2c

00006a20 <ll_init>:
{
    6a20:	b510      	push	{r4, lr}
	sem_recv = sem_rx;
    6a22:	4b27      	ldr	r3, [pc, #156]	; (6ac0 <ll_init+0xa0>)
{
    6a24:	b086      	sub	sp, #24
	sem_recv = sem_rx;
    6a26:	6018      	str	r0, [r3, #0]
	cntr_init();
    6a28:	f005 f930 	bl	bc8c <cntr_init>
	mayfly_init();
    6a2c:	f7fd fa9c 	bl	3f68 <mayfly_init>
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
    6a30:	4a24      	ldr	r2, [pc, #144]	; (6ac4 <ll_init+0xa4>)
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
    6a32:	2102      	movs	r1, #2
    6a34:	7411      	strb	r1, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_THREAD_OPS;
    6a36:	7611      	strb	r1, [r2, #24]
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
    6a38:	2304      	movs	r3, #4
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
    6a3a:	4923      	ldr	r1, [pc, #140]	; (6ac8 <ll_init+0xa8>)
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
    6a3c:	7013      	strb	r3, [r2, #0]
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
    6a3e:	7213      	strb	r3, [r2, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
    6a40:	9105      	str	r1, [sp, #20]
    6a42:	4922      	ldr	r1, [pc, #136]	; (6acc <ll_init+0xac>)
    6a44:	9104      	str	r1, [sp, #16]
    6a46:	4922      	ldr	r1, [pc, #136]	; (6ad0 <ll_init+0xb0>)
    6a48:	9103      	str	r1, [sp, #12]
    6a4a:	4922      	ldr	r1, [pc, #136]	; (6ad4 <ll_init+0xb4>)
    6a4c:	9102      	str	r1, [sp, #8]
    6a4e:	210c      	movs	r1, #12
    6a50:	e9cd 2100 	strd	r2, r1, [sp]
    6a54:	2000      	movs	r0, #0
    6a56:	4a20      	ldr	r2, [pc, #128]	; (6ad8 <ll_init+0xb8>)
    6a58:	2107      	movs	r1, #7
    6a5a:	f7fd ff81 	bl	4960 <ticker_init>
	LL_ASSERT(!err);
    6a5e:	b160      	cbz	r0, 6a7a <ll_init+0x5a>
    6a60:	4a1e      	ldr	r2, [pc, #120]	; (6adc <ll_init+0xbc>)
    6a62:	491f      	ldr	r1, [pc, #124]	; (6ae0 <ll_init+0xc0>)
    6a64:	481f      	ldr	r0, [pc, #124]	; (6ae4 <ll_init+0xc4>)
    6a66:	f240 2306 	movw	r3, #518	; 0x206
    6a6a:	f008 fd2c 	bl	f4c6 <printk>
    6a6e:	4040      	eors	r0, r0
    6a70:	f380 8811 	msr	BASEPRI, r0
    6a74:	f04f 0003 	mov.w	r0, #3
    6a78:	df02      	svc	2
	return z_impl_k_sem_init(sem, initial_count, limit);
    6a7a:	2201      	movs	r2, #1
    6a7c:	2100      	movs	r1, #0
    6a7e:	481a      	ldr	r0, [pc, #104]	; (6ae8 <ll_init+0xc8>)
    6a80:	f00b fdfc 	bl	1267c <z_impl_k_sem_init>
	err = lll_init();
    6a84:	f002 fd8e 	bl	95a4 <lll_init>
	if (err) {
    6a88:	4604      	mov	r4, r0
    6a8a:	b9b0      	cbnz	r0, 6aba <ll_init+0x9a>
	err = init_reset();
    6a8c:	f7ff ff32 	bl	68f4 <init_reset>
	if (err) {
    6a90:	4604      	mov	r4, r0
    6a92:	b990      	cbnz	r0, 6aba <ll_init+0x9a>
	err = lll_adv_init();
    6a94:	f00a fedc 	bl	11850 <lll_adv_init>
	if (err) {
    6a98:	4604      	mov	r4, r0
    6a9a:	b970      	cbnz	r0, 6aba <ll_init+0x9a>
	err = ull_adv_init();
    6a9c:	f00a fb47 	bl	1112e <ull_adv_init>
	if (err) {
    6aa0:	4604      	mov	r4, r0
    6aa2:	b950      	cbnz	r0, 6aba <ll_init+0x9a>
	err = lll_scan_init();
    6aa4:	f00b f800 	bl	11aa8 <lll_scan_init>
	if (err) {
    6aa8:	4604      	mov	r4, r0
    6aaa:	b930      	cbnz	r0, 6aba <ll_init+0x9a>
	err = ull_scan_init();
    6aac:	f00a fda8 	bl	11600 <ull_scan_init>
	if (err) {
    6ab0:	4604      	mov	r4, r0
    6ab2:	b910      	cbnz	r0, 6aba <ll_init+0x9a>
		ull_filter_reset(true);
    6ab4:	2001      	movs	r0, #1
    6ab6:	f001 fe0f 	bl	86d8 <ull_filter_reset>
}
    6aba:	4620      	mov	r0, r4
    6abc:	b006      	add	sp, #24
    6abe:	bd10      	pop	{r4, pc}
    6ac0:	20001a40 	.word	0x20001a40
    6ac4:	20001e1c 	.word	0x20001e1c
    6ac8:	00011d09 	.word	0x00011d09
    6acc:	0000c611 	.word	0x0000c611
    6ad0:	0000c5b9 	.word	0x0000c5b9
    6ad4:	20001bac 	.word	0x20001bac
    6ad8:	20001a5c 	.word	0x20001a5c
    6adc:	000135ab 	.word	0x000135ab
    6ae0:	00013624 	.word	0x00013624
    6ae4:	000133b6 	.word	0x000133b6
    6ae8:	20001a44 	.word	0x20001a44

00006aec <ll_reset>:
{
    6aec:	b510      	push	{r4, lr}
    6aee:	b086      	sub	sp, #24
	err = ull_adv_reset();
    6af0:	f00a fb26 	bl	11140 <ull_adv_reset>
	LL_ASSERT(!err);
    6af4:	b160      	cbz	r0, 6b10 <ll_reset+0x24>
    6af6:	4a34      	ldr	r2, [pc, #208]	; (6bc8 <ll_reset+0xdc>)
    6af8:	4934      	ldr	r1, [pc, #208]	; (6bcc <ll_reset+0xe0>)
    6afa:	4835      	ldr	r0, [pc, #212]	; (6bd0 <ll_reset+0xe4>)
    6afc:	f240 23a6 	movw	r3, #678	; 0x2a6
    6b00:	f008 fce1 	bl	f4c6 <printk>
    6b04:	4040      	eors	r0, r0
    6b06:	f380 8811 	msr	BASEPRI, r0
    6b0a:	f04f 0003 	mov.w	r0, #3
    6b0e:	df02      	svc	2
	err = ull_scan_reset();
    6b10:	f00a fd9d 	bl	1164e <ull_scan_reset>
	LL_ASSERT(!err);
    6b14:	b160      	cbz	r0, 6b30 <ll_reset+0x44>
    6b16:	4a2c      	ldr	r2, [pc, #176]	; (6bc8 <ll_reset+0xdc>)
    6b18:	492c      	ldr	r1, [pc, #176]	; (6bcc <ll_reset+0xe0>)
    6b1a:	482d      	ldr	r0, [pc, #180]	; (6bd0 <ll_reset+0xe4>)
    6b1c:	f44f 732b 	mov.w	r3, #684	; 0x2ac
    6b20:	f008 fcd1 	bl	f4c6 <printk>
    6b24:	4040      	eors	r0, r0
    6b26:	f380 8811 	msr	BASEPRI, r0
    6b2a:	f04f 0003 	mov.w	r0, #3
    6b2e:	df02      	svc	2
		ull_filter_reset(false);
    6b30:	2000      	movs	r0, #0
    6b32:	f001 fdd1 	bl	86d8 <ull_filter_reset>
	MFIFO_INIT(prep);
    6b36:	4b27      	ldr	r3, [pc, #156]	; (6bd4 <ll_reset+0xe8>)
    6b38:	2400      	movs	r4, #0
    6b3a:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(pdu_rx_free);
    6b3c:	4b26      	ldr	r3, [pc, #152]	; (6bd8 <ll_reset+0xec>)
    6b3e:	805c      	strh	r4, [r3, #2]
    6b40:	2201      	movs	r2, #1
    6b42:	4621      	mov	r1, r4
    6b44:	4668      	mov	r0, sp
    6b46:	f00b fd99 	bl	1267c <z_impl_k_sem_init>
		mfy.param = &sem;
    6b4a:	4b24      	ldr	r3, [pc, #144]	; (6bdc <ll_reset+0xf0>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
    6b4c:	4622      	mov	r2, r4
    6b4e:	4621      	mov	r1, r4
    6b50:	2003      	movs	r0, #3
		mfy.param = &sem;
    6b52:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
    6b56:	f7fd fa31 	bl	3fbc <mayfly_enqueue>
		LL_ASSERT(!retval);
    6b5a:	b160      	cbz	r0, 6b76 <ll_reset+0x8a>
    6b5c:	4a1a      	ldr	r2, [pc, #104]	; (6bc8 <ll_reset+0xdc>)
    6b5e:	4920      	ldr	r1, [pc, #128]	; (6be0 <ll_reset+0xf4>)
    6b60:	481b      	ldr	r0, [pc, #108]	; (6bd0 <ll_reset+0xe4>)
    6b62:	f240 3306 	movw	r3, #774	; 0x306
    6b66:	f008 fcae 	bl	f4c6 <printk>
    6b6a:	4040      	eors	r0, r0
    6b6c:	f380 8811 	msr	BASEPRI, r0
    6b70:	f04f 0003 	mov.w	r0, #3
    6b74:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    6b76:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6b7a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6b7e:	4668      	mov	r0, sp
    6b80:	f007 fda2 	bl	e6c8 <z_impl_k_sem_take>
	err = ull_adv_reset_finalize();
    6b84:	f000 fc8a 	bl	749c <ull_adv_reset_finalize>
	LL_ASSERT(!err);
    6b88:	b160      	cbz	r0, 6ba4 <ll_reset+0xb8>
    6b8a:	4a0f      	ldr	r2, [pc, #60]	; (6bc8 <ll_reset+0xdc>)
    6b8c:	490f      	ldr	r1, [pc, #60]	; (6bcc <ll_reset+0xe0>)
    6b8e:	4810      	ldr	r0, [pc, #64]	; (6bd0 <ll_reset+0xe4>)
    6b90:	f240 3313 	movw	r3, #787	; 0x313
    6b94:	f008 fc97 	bl	f4c6 <printk>
    6b98:	4040      	eors	r0, r0
    6b9a:	f380 8811 	msr	BASEPRI, r0
    6b9e:	f04f 0003 	mov.w	r0, #3
    6ba2:	df02      	svc	2
	err = init_reset();
    6ba4:	f7ff fea6 	bl	68f4 <init_reset>
	LL_ASSERT(!err);
    6ba8:	b160      	cbz	r0, 6bc4 <ll_reset+0xd8>
    6baa:	4a07      	ldr	r2, [pc, #28]	; (6bc8 <ll_reset+0xdc>)
    6bac:	4907      	ldr	r1, [pc, #28]	; (6bcc <ll_reset+0xe0>)
    6bae:	4808      	ldr	r0, [pc, #32]	; (6bd0 <ll_reset+0xe4>)
    6bb0:	f44f 7348 	mov.w	r3, #800	; 0x320
    6bb4:	f008 fc87 	bl	f4c6 <printk>
    6bb8:	4040      	eors	r0, r0
    6bba:	f380 8811 	msr	BASEPRI, r0
    6bbe:	f04f 0003 	mov.w	r0, #3
    6bc2:	df02      	svc	2
}
    6bc4:	b006      	add	sp, #24
    6bc6:	bd10      	pop	{r4, pc}
    6bc8:	000135ab 	.word	0x000135ab
    6bcc:	00013624 	.word	0x00013624
    6bd0:	000133b6 	.word	0x000133b6
    6bd4:	20000234 	.word	0x20000234
    6bd8:	20000200 	.word	0x20000200
    6bdc:	20000348 	.word	0x20000348
    6be0:	00013691 	.word	0x00013691

00006be4 <ull_done>:
{
    6be4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
		break;
	}

	/* Release done */
	done->extra.type = 0U;
	release = RXFIFO_RELEASE(done, link, done);
    6be8:	4f3b      	ldr	r7, [pc, #236]	; (6cd8 <ull_done+0xf4>)
		link = memq_peek(memq_ull_done.head, memq_ull_done.tail,
    6bea:	4e3c      	ldr	r6, [pc, #240]	; (6cdc <ull_done+0xf8>)
{
    6bec:	b087      	sub	sp, #28
	release = RXFIFO_RELEASE(done, link, done);
    6bee:	f107 0904 	add.w	r9, r7, #4
		link = memq_peek(memq_ull_done.head, memq_ull_done.tail,
    6bf2:	e9d6 0100 	ldrd	r0, r1, [r6]
    6bf6:	aa05      	add	r2, sp, #20
    6bf8:	f009 fd69 	bl	106ce <memq_peek>
		if (link) {
    6bfc:	4680      	mov	r8, r0
    6bfe:	2800      	cmp	r0, #0
    6c00:	d067      	beq.n	6cd2 <ull_done+0xee>
			(void)memq_dequeue(memq_ull_done.tail,
    6c02:	6870      	ldr	r0, [r6, #4]
    6c04:	2200      	movs	r2, #0
    6c06:	4631      	mov	r1, r6
    6c08:	f009 fd69 	bl	106de <memq_dequeue>
			rx_demux_event_done(link, done);
    6c0c:	9c05      	ldr	r4, [sp, #20]
	ull_hdr = done->param;
    6c0e:	69e5      	ldr	r5, [r4, #28]
	if (ull_hdr) {
    6c10:	b195      	cbz	r5, 6c38 <ull_done+0x54>
    6c12:	782b      	ldrb	r3, [r5, #0]
		LL_ASSERT(ull_ref_get(ull_hdr));
    6c14:	b963      	cbnz	r3, 6c30 <ull_done+0x4c>
    6c16:	4a32      	ldr	r2, [pc, #200]	; (6ce0 <ull_done+0xfc>)
    6c18:	4932      	ldr	r1, [pc, #200]	; (6ce4 <ull_done+0x100>)
    6c1a:	4833      	ldr	r0, [pc, #204]	; (6ce8 <ull_done+0x104>)
    6c1c:	f640 2321 	movw	r3, #2593	; 0xa21
    6c20:	f008 fc51 	bl	f4c6 <printk>
    6c24:	4040      	eors	r0, r0
    6c26:	f380 8811 	msr	BASEPRI, r0
    6c2a:	f04f 0003 	mov.w	r0, #3
    6c2e:	df02      	svc	2
	return hdr->ref--;
    6c30:	782b      	ldrb	r3, [r5, #0]
    6c32:	3b01      	subs	r3, #1
    6c34:	b2db      	uxtb	r3, r3
    6c36:	702b      	strb	r3, [r5, #0]
	switch (done->extra.type) {
    6c38:	f894 3020 	ldrb.w	r3, [r4, #32]
    6c3c:	2b04      	cmp	r3, #4
    6c3e:	d83a      	bhi.n	6cb6 <ull_done+0xd2>
    6c40:	e8df f003 	tbb	[pc, r3]
    6c44:	312d0306 	.word	0x312d0306
    6c48:	35          	.byte	0x35
    6c49:	00          	.byte	0x00
		ull_adv_done(done);
    6c4a:	4620      	mov	r0, r4
    6c4c:	f7f9 fc74 	bl	538 <ull_adv_done>
	done->extra.type = 0U;
    6c50:	2300      	movs	r3, #0
    6c52:	f884 3020 	strb.w	r3, [r4, #32]
	release = RXFIFO_RELEASE(done, link, done);
    6c56:	78ba      	ldrb	r2, [r7, #2]
    6c58:	4b24      	ldr	r3, [pc, #144]	; (6cec <ull_done+0x108>)
    6c5a:	7879      	ldrb	r1, [r7, #1]
    6c5c:	7838      	ldrb	r0, [r7, #0]
    6c5e:	f8cd 9000 	str.w	r9, [sp]
    6c62:	e9cd 8401 	strd	r8, r4, [sp, #4]
    6c66:	f00a f9eb 	bl	11040 <ull_rxfifo_release>
	LL_ASSERT(release == done);
    6c6a:	4284      	cmp	r4, r0
    6c6c:	d00c      	beq.n	6c88 <ull_done+0xa4>
    6c6e:	4a1c      	ldr	r2, [pc, #112]	; (6ce0 <ull_done+0xfc>)
    6c70:	491f      	ldr	r1, [pc, #124]	; (6cf0 <ull_done+0x10c>)
    6c72:	481d      	ldr	r0, [pc, #116]	; (6ce8 <ull_done+0x104>)
    6c74:	f640 237f 	movw	r3, #2687	; 0xa7f
    6c78:	f008 fc25 	bl	f4c6 <printk>
    6c7c:	4040      	eors	r0, r0
    6c7e:	f380 8811 	msr	BASEPRI, r0
    6c82:	f04f 0003 	mov.w	r0, #3
    6c86:	df02      	svc	2
	/* LLL done synchronize count */
	lll_done_ull_inc();
#endif /* CONFIG_BT_CTLR_LOW_LAT_ULL_DONE */

	/* If disable initiated, signal the semaphore */
	if (ull_hdr && !ull_ref_get(ull_hdr) && ull_hdr->disabled_cb) {
    6c88:	2d00      	cmp	r5, #0
    6c8a:	d0b2      	beq.n	6bf2 <ull_done+0xe>
	return hdr->ref;
    6c8c:	782b      	ldrb	r3, [r5, #0]
    6c8e:	2b00      	cmp	r3, #0
    6c90:	d1af      	bne.n	6bf2 <ull_done+0xe>
    6c92:	696b      	ldr	r3, [r5, #20]
    6c94:	2b00      	cmp	r3, #0
    6c96:	d0ac      	beq.n	6bf2 <ull_done+0xe>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
    6c98:	69a8      	ldr	r0, [r5, #24]
    6c9a:	4798      	blx	r3
    6c9c:	e7a9      	b.n	6bf2 <ull_done+0xe>
		ull_adv_aux_done(done);
    6c9e:	4620      	mov	r0, r4
    6ca0:	f00a fc9c 	bl	115dc <ull_adv_aux_done>
		break;
    6ca4:	e7d4      	b.n	6c50 <ull_done+0x6c>
		ull_scan_done(done);
    6ca6:	4620      	mov	r0, r4
    6ca8:	f001 f888 	bl	7dbc <ull_scan_done>
		break;
    6cac:	e7d0      	b.n	6c50 <ull_done+0x6c>
		ull_scan_aux_done(done);
    6cae:	4620      	mov	r0, r4
    6cb0:	f001 fa66 	bl	8180 <ull_scan_aux_done>
		break;
    6cb4:	e7cc      	b.n	6c50 <ull_done+0x6c>
		LL_ASSERT(0);
    6cb6:	4a0a      	ldr	r2, [pc, #40]	; (6ce0 <ull_done+0xfc>)
    6cb8:	490e      	ldr	r1, [pc, #56]	; (6cf4 <ull_done+0x110>)
    6cba:	480b      	ldr	r0, [pc, #44]	; (6ce8 <ull_done+0x104>)
    6cbc:	f640 2378 	movw	r3, #2680	; 0xa78
    6cc0:	f008 fc01 	bl	f4c6 <printk>
    6cc4:	4040      	eors	r0, r0
    6cc6:	f380 8811 	msr	BASEPRI, r0
    6cca:	f04f 0003 	mov.w	r0, #3
    6cce:	df02      	svc	2
		break;
    6cd0:	e7be      	b.n	6c50 <ull_done+0x6c>
}
    6cd2:	b007      	add	sp, #28
    6cd4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    6cd8:	200001e4 	.word	0x200001e4
    6cdc:	20001a30 	.word	0x20001a30
    6ce0:	000135ab 	.word	0x000135ab
    6ce4:	00013699 	.word	0x00013699
    6ce8:	000133b6 	.word	0x000133b6
    6cec:	200001e7 	.word	0x200001e7
    6cf0:	000136ae 	.word	0x000136ae
    6cf4:	00014086 	.word	0x00014086

00006cf8 <lll_resume>:
	return lll_prepare_resolve(is_abort_cb, abort_cb, prepare_cb,
				   prepare_param, 0, 0);
}

void lll_resume(void *param)
{
    6cf8:	b507      	push	{r0, r1, r2, lr}
	struct lll_event *next;
	int ret;

	next = param;
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
    6cfa:	2201      	movs	r2, #1
    6cfc:	9201      	str	r2, [sp, #4]
				  next->prepare_cb, &next->prepare_param,
				  next->is_resume, 1);
    6cfe:	7f02      	ldrb	r2, [r0, #28]
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
    6d00:	f002 0201 	and.w	r2, r2, #1
    6d04:	9200      	str	r2, [sp, #0]
    6d06:	6902      	ldr	r2, [r0, #16]
{
    6d08:	4603      	mov	r3, r0
	ret = lll_prepare_resolve(next->is_abort_cb, next->abort_cb,
    6d0a:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
    6d0e:	f002 fddd 	bl	98cc <lll_prepare_resolve>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
    6d12:	b168      	cbz	r0, 6d30 <lll_resume+0x38>
    6d14:	3077      	adds	r0, #119	; 0x77
    6d16:	d00b      	beq.n	6d30 <lll_resume+0x38>
    6d18:	4a07      	ldr	r2, [pc, #28]	; (6d38 <lll_resume+0x40>)
    6d1a:	4908      	ldr	r1, [pc, #32]	; (6d3c <lll_resume+0x44>)
    6d1c:	4808      	ldr	r0, [pc, #32]	; (6d40 <lll_resume+0x48>)
    6d1e:	234f      	movs	r3, #79	; 0x4f
    6d20:	f008 fbd1 	bl	f4c6 <printk>
    6d24:	4040      	eors	r0, r0
    6d26:	f380 8811 	msr	BASEPRI, r0
    6d2a:	f04f 0003 	mov.w	r0, #3
    6d2e:	df02      	svc	2
}
    6d30:	b003      	add	sp, #12
    6d32:	f85d fb04 	ldr.w	pc, [sp], #4
    6d36:	bf00      	nop
    6d38:	000136be 	.word	0x000136be
    6d3c:	00013700 	.word	0x00013700
    6d40:	000133b6 	.word	0x000133b6

00006d44 <adv_pdu_adva_get>:

	return 0;
}

static inline uint8_t *adv_pdu_adva_get(struct pdu_adv *pdu)
{
    6d44:	b510      	push	{r4, lr}
	} else {
		*(uint8_t *)&hdr_flags = 0U;
	}

	/* All extended PDUs have AdvA at the same offset in common header */
	if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
    6d46:	4604      	mov	r4, r0
	if (com_hdr->ext_hdr_len) {
    6d48:	7883      	ldrb	r3, [r0, #2]
	if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
    6d4a:	f814 2b02 	ldrb.w	r2, [r4], #2
	if (com_hdr->ext_hdr_len) {
    6d4e:	f013 033f 	ands.w	r3, r3, #63	; 0x3f
	if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
    6d52:	f002 020f 	and.w	r2, r2, #15
		hdr_flags = *hdr;
    6d56:	bf18      	it	ne
    6d58:	78c3      	ldrbne	r3, [r0, #3]
	if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
    6d5a:	2a07      	cmp	r2, #7
    6d5c:	d110      	bne.n	6d80 <adv_pdu_adva_get+0x3c>
		LL_ASSERT(hdr_flags.adv_addr);
    6d5e:	07db      	lsls	r3, r3, #31
    6d60:	d40c      	bmi.n	6d7c <adv_pdu_adva_get+0x38>
    6d62:	4a08      	ldr	r2, [pc, #32]	; (6d84 <adv_pdu_adva_get+0x40>)
    6d64:	4908      	ldr	r1, [pc, #32]	; (6d88 <adv_pdu_adva_get+0x44>)
    6d66:	4809      	ldr	r0, [pc, #36]	; (6d8c <adv_pdu_adva_get+0x48>)
    6d68:	f640 23b6 	movw	r3, #2742	; 0xab6
    6d6c:	f008 fbab 	bl	f4c6 <printk>
    6d70:	4040      	eors	r0, r0
    6d72:	f380 8811 	msr	BASEPRI, r0
    6d76:	f04f 0003 	mov.w	r0, #3
    6d7a:	df02      	svc	2

		return &com_hdr->ext_hdr_adv_data[1];
    6d7c:	1ca0      	adds	r0, r4, #2
	}
#endif

	/* All legacy PDUs have AdvA at the same offset */
	return pdu->adv_ind.addr;
}
    6d7e:	bd10      	pop	{r4, pc}
	return pdu->adv_ind.addr;
    6d80:	4620      	mov	r0, r4
    6d82:	e7fc      	b.n	6d7e <adv_pdu_adva_get+0x3a>
    6d84:	00013714 	.word	0x00013714
    6d88:	00013753 	.word	0x00013753
    6d8c:	000133b6 	.word	0x000133b6

00006d90 <ticker_stop_ext_op_cb>:
{
    6d90:	b508      	push	{r3, lr}
	if (status != TICKER_STATUS_SUCCESS) {
    6d92:	4602      	mov	r2, r0
    6d94:	b998      	cbnz	r0, 6dbe <ticker_stop_ext_op_cb+0x2e>
	mfy.param = param;
    6d96:	4b0a      	ldr	r3, [pc, #40]	; (6dc0 <ticker_stop_ext_op_cb+0x30>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
    6d98:	2002      	movs	r0, #2
	mfy.param = param;
    6d9a:	6099      	str	r1, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
    6d9c:	2101      	movs	r1, #1
    6d9e:	f7fd f90d 	bl	3fbc <mayfly_enqueue>
	LL_ASSERT(!ret);
    6da2:	b160      	cbz	r0, 6dbe <ticker_stop_ext_op_cb+0x2e>
    6da4:	4a07      	ldr	r2, [pc, #28]	; (6dc4 <ticker_stop_ext_op_cb+0x34>)
    6da6:	4908      	ldr	r1, [pc, #32]	; (6dc8 <ticker_stop_ext_op_cb+0x38>)
    6da8:	4808      	ldr	r0, [pc, #32]	; (6dcc <ticker_stop_ext_op_cb+0x3c>)
    6daa:	f640 139c 	movw	r3, #2460	; 0x99c
    6dae:	f008 fb8a 	bl	f4c6 <printk>
    6db2:	4040      	eors	r0, r0
    6db4:	f380 8811 	msr	BASEPRI, r0
    6db8:	f04f 0003 	mov.w	r0, #3
    6dbc:	df02      	svc	2
}
    6dbe:	bd08      	pop	{r3, pc}
    6dc0:	200003a8 	.word	0x200003a8
    6dc4:	00013714 	.word	0x00013714
    6dc8:	0001366f 	.word	0x0001366f
    6dcc:	000133b6 	.word	0x000133b6

00006dd0 <ticker_stop_aux_op_cb>:
{
    6dd0:	b510      	push	{r4, lr}
    6dd2:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
    6dd4:	b160      	cbz	r0, 6df0 <ticker_stop_aux_op_cb+0x20>
    6dd6:	4a11      	ldr	r2, [pc, #68]	; (6e1c <ticker_stop_aux_op_cb+0x4c>)
    6dd8:	4911      	ldr	r1, [pc, #68]	; (6e20 <ticker_stop_aux_op_cb+0x50>)
    6dda:	4812      	ldr	r0, [pc, #72]	; (6e24 <ticker_stop_aux_op_cb+0x54>)
    6ddc:	f44f 6316 	mov.w	r3, #2400	; 0x960
    6de0:	f008 fb71 	bl	f4c6 <printk>
    6de4:	4040      	eors	r0, r0
    6de6:	f380 8811 	msr	BASEPRI, r0
    6dea:	f04f 0003 	mov.w	r0, #3
    6dee:	df02      	svc	2
	mfy.param = param;
    6df0:	4b0d      	ldr	r3, [pc, #52]	; (6e28 <ticker_stop_aux_op_cb+0x58>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
    6df2:	2200      	movs	r2, #0
    6df4:	2101      	movs	r1, #1
    6df6:	2002      	movs	r0, #2
	mfy.param = param;
    6df8:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
    6dfa:	f7fd f8df 	bl	3fbc <mayfly_enqueue>
	LL_ASSERT(!ret);
    6dfe:	b160      	cbz	r0, 6e1a <ticker_stop_aux_op_cb+0x4a>
    6e00:	4a06      	ldr	r2, [pc, #24]	; (6e1c <ticker_stop_aux_op_cb+0x4c>)
    6e02:	490a      	ldr	r1, [pc, #40]	; (6e2c <ticker_stop_aux_op_cb+0x5c>)
    6e04:	4807      	ldr	r0, [pc, #28]	; (6e24 <ticker_stop_aux_op_cb+0x54>)
    6e06:	f640 1366 	movw	r3, #2406	; 0x966
    6e0a:	f008 fb5c 	bl	f4c6 <printk>
    6e0e:	4040      	eors	r0, r0
    6e10:	f380 8811 	msr	BASEPRI, r0
    6e14:	f04f 0003 	mov.w	r0, #3
    6e18:	df02      	svc	2
}
    6e1a:	bd10      	pop	{r4, pc}
    6e1c:	00013714 	.word	0x00013714
    6e20:	00013766 	.word	0x00013766
    6e24:	000133b6 	.word	0x000133b6
    6e28:	20000388 	.word	0x20000388
    6e2c:	0001366f 	.word	0x0001366f

00006e30 <ticker_update_op_cb>:
{
    6e30:	b510      	push	{r4, lr}
    6e32:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
    6e34:	b180      	cbz	r0, 6e58 <ticker_update_op_cb+0x28>
    6e36:	f7ff fbc5 	bl	65c4 <ull_disable_mark_get>
    6e3a:	4284      	cmp	r4, r0
    6e3c:	d00c      	beq.n	6e58 <ticker_update_op_cb+0x28>
    6e3e:	4a07      	ldr	r2, [pc, #28]	; (6e5c <ticker_update_op_cb+0x2c>)
    6e40:	4907      	ldr	r1, [pc, #28]	; (6e60 <ticker_update_op_cb+0x30>)
    6e42:	4808      	ldr	r0, [pc, #32]	; (6e64 <ticker_update_op_cb+0x34>)
    6e44:	f640 03b7 	movw	r3, #2231	; 0x8b7
    6e48:	f008 fb3d 	bl	f4c6 <printk>
    6e4c:	4040      	eors	r0, r0
    6e4e:	f380 8811 	msr	BASEPRI, r0
    6e52:	f04f 0003 	mov.w	r0, #3
    6e56:	df02      	svc	2
}
    6e58:	bd10      	pop	{r4, pc}
    6e5a:	bf00      	nop
    6e5c:	00013714 	.word	0x00013714
    6e60:	00013772 	.word	0x00013772
    6e64:	000133b6 	.word	0x000133b6

00006e68 <ext_disable>:
{
    6e68:	b538      	push	{r3, r4, r5, lr}
    6e6a:	4604      	mov	r4, r0
    6e6c:	f810 3b1c 	ldrb.w	r3, [r0], #28
	if (ull_ref_get(hdr)) {
    6e70:	b34b      	cbz	r3, 6ec6 <ext_disable+0x5e>
		mfy.param = &adv->lll;
    6e72:	4d17      	ldr	r5, [pc, #92]	; (6ed0 <ext_disable+0x68>)
		LL_ASSERT(!hdr->disabled_cb);
    6e74:	6963      	ldr	r3, [r4, #20]
		mfy.param = &adv->lll;
    6e76:	60a8      	str	r0, [r5, #8]
		LL_ASSERT(!hdr->disabled_cb);
    6e78:	b163      	cbz	r3, 6e94 <ext_disable+0x2c>
    6e7a:	4a16      	ldr	r2, [pc, #88]	; (6ed4 <ext_disable+0x6c>)
    6e7c:	4916      	ldr	r1, [pc, #88]	; (6ed8 <ext_disable+0x70>)
    6e7e:	4817      	ldr	r0, [pc, #92]	; (6edc <ext_disable+0x74>)
    6e80:	f640 13b1 	movw	r3, #2481	; 0x9b1
    6e84:	f008 fb1f 	bl	f4c6 <printk>
    6e88:	4040      	eors	r0, r0
    6e8a:	f380 8811 	msr	BASEPRI, r0
    6e8e:	f04f 0003 	mov.w	r0, #3
    6e92:	df02      	svc	2
		hdr->disabled_param = mfy.param;
    6e94:	68ab      	ldr	r3, [r5, #8]
    6e96:	61a3      	str	r3, [r4, #24]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    6e98:	2200      	movs	r2, #0
		hdr->disabled_cb = ext_disabled_cb;
    6e9a:	4b11      	ldr	r3, [pc, #68]	; (6ee0 <ext_disable+0x78>)
    6e9c:	6163      	str	r3, [r4, #20]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    6e9e:	4611      	mov	r1, r2
    6ea0:	4b0b      	ldr	r3, [pc, #44]	; (6ed0 <ext_disable+0x68>)
    6ea2:	2001      	movs	r0, #1
    6ea4:	f7fd f88a 	bl	3fbc <mayfly_enqueue>
		LL_ASSERT(!ret);
    6ea8:	b160      	cbz	r0, 6ec4 <ext_disable+0x5c>
    6eaa:	4a0a      	ldr	r2, [pc, #40]	; (6ed4 <ext_disable+0x6c>)
    6eac:	490d      	ldr	r1, [pc, #52]	; (6ee4 <ext_disable+0x7c>)
    6eae:	480b      	ldr	r0, [pc, #44]	; (6edc <ext_disable+0x74>)
    6eb0:	f640 13b8 	movw	r3, #2488	; 0x9b8
    6eb4:	f008 fb07 	bl	f4c6 <printk>
    6eb8:	4040      	eors	r0, r0
    6eba:	f380 8811 	msr	BASEPRI, r0
    6ebe:	f04f 0003 	mov.w	r0, #3
    6ec2:	df02      	svc	2
}
    6ec4:	bd38      	pop	{r3, r4, r5, pc}
    6ec6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		ext_disabled_cb(&adv->lll);
    6eca:	f00a b8d9 	b.w	11080 <ext_disabled_cb>
    6ece:	bf00      	nop
    6ed0:	20000398 	.word	0x20000398
    6ed4:	00013714 	.word	0x00013714
    6ed8:	000137a1 	.word	0x000137a1
    6edc:	000133b6 	.word	0x000133b6
    6ee0:	00011081 	.word	0x00011081
    6ee4:	0001366f 	.word	0x0001366f

00006ee8 <aux_disabled_cb>:
{
    6ee8:	b507      	push	{r0, r1, r2, lr}
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
    6eea:	4a0f      	ldr	r2, [pc, #60]	; (6f28 <aux_disabled_cb+0x40>)
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
    6eec:	4b0f      	ldr	r3, [pc, #60]	; (6f2c <aux_disabled_cb+0x44>)
    6eee:	9000      	str	r0, [sp, #0]
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
    6ef0:	1a82      	subs	r2, r0, r2
    6ef2:	09d2      	lsrs	r2, r2, #7
			  (TICKER_ID_ADV_BASE + handle),
    6ef4:	3202      	adds	r2, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
    6ef6:	b2d2      	uxtb	r2, r2
    6ef8:	2101      	movs	r1, #1
    6efa:	2000      	movs	r0, #0
    6efc:	f7fd fe54 	bl	4ba8 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    6f00:	f030 0302 	bics.w	r3, r0, #2
    6f04:	d00c      	beq.n	6f20 <aux_disabled_cb+0x38>
    6f06:	4a0a      	ldr	r2, [pc, #40]	; (6f30 <aux_disabled_cb+0x48>)
    6f08:	490a      	ldr	r1, [pc, #40]	; (6f34 <aux_disabled_cb+0x4c>)
    6f0a:	480b      	ldr	r0, [pc, #44]	; (6f38 <aux_disabled_cb+0x50>)
    6f0c:	f640 1387 	movw	r3, #2439	; 0x987
    6f10:	f008 fad9 	bl	f4c6 <printk>
    6f14:	4040      	eors	r0, r0
    6f16:	f380 8811 	msr	BASEPRI, r0
    6f1a:	f04f 0003 	mov.w	r0, #3
    6f1e:	df02      	svc	2
}
    6f20:	b003      	add	sp, #12
    6f22:	f85d fb04 	ldr.w	pc, [sp], #4
    6f26:	bf00      	nop
    6f28:	20001e5c 	.word	0x20001e5c
    6f2c:	00006d91 	.word	0x00006d91
    6f30:	00013714 	.word	0x00013714
    6f34:	000137b3 	.word	0x000137b3
    6f38:	000133b6 	.word	0x000133b6

00006f3c <aux_disable>:
{
    6f3c:	b538      	push	{r3, r4, r5, lr}
	aux = HDR_LLL2ULL(lll_aux);
    6f3e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    6f40:	681c      	ldr	r4, [r3, #0]
    6f42:	7823      	ldrb	r3, [r4, #0]
{
    6f44:	4605      	mov	r5, r0
	if (ull_ref_get(hdr)) {
    6f46:	b193      	cbz	r3, 6f6e <aux_disable+0x32>
		LL_ASSERT(!hdr->disabled_cb);
    6f48:	6963      	ldr	r3, [r4, #20]
    6f4a:	b163      	cbz	r3, 6f66 <aux_disable+0x2a>
    6f4c:	4a0a      	ldr	r2, [pc, #40]	; (6f78 <aux_disable+0x3c>)
    6f4e:	490b      	ldr	r1, [pc, #44]	; (6f7c <aux_disable+0x40>)
    6f50:	480b      	ldr	r0, [pc, #44]	; (6f80 <aux_disable+0x44>)
    6f52:	f640 1375 	movw	r3, #2421	; 0x975
    6f56:	f008 fab6 	bl	f4c6 <printk>
    6f5a:	4040      	eors	r0, r0
    6f5c:	f380 8811 	msr	BASEPRI, r0
    6f60:	f04f 0003 	mov.w	r0, #3
    6f64:	df02      	svc	2
		hdr->disabled_cb = aux_disabled_cb;
    6f66:	4b07      	ldr	r3, [pc, #28]	; (6f84 <aux_disable+0x48>)
		hdr->disabled_param = adv;
    6f68:	61a5      	str	r5, [r4, #24]
		hdr->disabled_cb = aux_disabled_cb;
    6f6a:	6163      	str	r3, [r4, #20]
}
    6f6c:	bd38      	pop	{r3, r4, r5, pc}
    6f6e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		aux_disabled_cb(param);
    6f72:	f7ff bfb9 	b.w	6ee8 <aux_disabled_cb>
    6f76:	bf00      	nop
    6f78:	00013714 	.word	0x00013714
    6f7c:	000137a1 	.word	0x000137a1
    6f80:	000133b6 	.word	0x000133b6
    6f84:	00006ee9 	.word	0x00006ee9

00006f88 <init_reset>:
{
    6f88:	b510      	push	{r4, lr}
		lll_adv_data_init(&ll_adv[handle].lll.adv_data);
    6f8a:	4c16      	ldr	r4, [pc, #88]	; (6fe4 <init_reset+0x5c>)
    6f8c:	f104 0024 	add.w	r0, r4, #36	; 0x24
    6f90:	f002 fe36 	bl	9c00 <lll_adv_data_init>
		lll_adv_data_init(&ll_adv[handle].lll.scan_rsp);
    6f94:	f104 0030 	add.w	r0, r4, #48	; 0x30
    6f98:	f002 fe32 	bl	9c00 <lll_adv_data_init>
	pdu->len = BDADDR_SIZE;
}

static void init_set(struct ll_adv_set *adv)
{
	adv->interval = BT_LE_ADV_INTERVAL_DEFAULT;
    6f9c:	f44f 6300 	mov.w	r3, #2048	; 0x800
    6fa0:	6663      	str	r3, [r4, #100]	; 0x64
#if defined(CONFIG_BT_CTLR_PRIVACY)
	adv->own_addr_type = BT_ADDR_LE_PUBLIC;
    6fa2:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    6fa6:	f36f 0342 	bfc	r3, #1, #2
    6faa:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
#endif /* CONFIG_BT_CTLR_PRIVACY */
	adv->lll.chan_map = BT_LE_ADV_CHAN_MAP_ALL;
    6fae:	f894 3020 	ldrb.w	r3, [r4, #32]
    6fb2:	f003 0338 	and.w	r3, r3, #56	; 0x38
    6fb6:	f043 0307 	orr.w	r3, r3, #7
    6fba:	f884 3020 	strb.w	r3, [r4, #32]
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    6fbe:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    6fc2:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	pdu->len = BDADDR_SIZE;
    6fc6:	2206      	movs	r2, #6
    6fc8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	pdu->type = pdu_type;
    6fca:	2000      	movs	r0, #0
	pdu->len = BDADDR_SIZE;
    6fcc:	705a      	strb	r2, [r3, #1]
	pdu->type = pdu_type;
    6fce:	7018      	strb	r0, [r3, #0]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    6fd0:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
    6fd4:	eb04 0483 	add.w	r4, r4, r3, lsl #2
    6fd8:	2104      	movs	r1, #4
    6fda:	6b63      	ldr	r3, [r4, #52]	; 0x34
	pdu->len = BDADDR_SIZE;
    6fdc:	705a      	strb	r2, [r3, #1]
	pdu->type = pdu_type;
    6fde:	7019      	strb	r1, [r3, #0]
}
    6fe0:	bd10      	pop	{r4, pc}
    6fe2:	bf00      	nop
    6fe4:	20001e5c 	.word	0x20001e5c

00006fe8 <ll_adv_params_set>:
{
    6fe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6fec:	460d      	mov	r5, r1
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
    6fee:	4980      	ldr	r1, [pc, #512]	; (71f0 <ll_adv_params_set+0x208>)
{
    6ff0:	b087      	sub	sp, #28
    6ff2:	4604      	mov	r4, r0
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
    6ff4:	6808      	ldr	r0, [r1, #0]
    6ff6:	8889      	ldrh	r1, [r1, #4]
    6ff8:	f8ad 1014 	strh.w	r1, [sp, #20]
	if (!adv || adv->is_enabled) {
    6ffc:	497d      	ldr	r1, [pc, #500]	; (71f4 <ll_adv_params_set+0x20c>)
	uint8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
    6ffe:	9004      	str	r0, [sp, #16]
	if (!adv || adv->is_enabled) {
    7000:	f891 0078 	ldrb.w	r0, [r1, #120]	; 0x78
{
    7004:	f89d b044 	ldrb.w	fp, [sp, #68]	; 0x44
    7008:	f89d a058 	ldrb.w	sl, [sp, #88]	; 0x58
    700c:	f89d 9060 	ldrb.w	r9, [sp, #96]	; 0x60
	if (!adv || adv->is_enabled) {
    7010:	f000 0001 	and.w	r0, r0, #1
    7014:	4320      	orrs	r0, r4
    7016:	f040 8234 	bne.w	7482 <ll_adv_params_set+0x49a>
	if (adv_type == PDU_ADV_TYPE_EXT_IND) {
    701a:	2b07      	cmp	r3, #7
    701c:	d113      	bne.n	7046 <ll_adv_params_set+0x5e>
		if (evt_prop & BT_HCI_LE_ADV_PROP_LEGACY) {
    701e:	06ef      	lsls	r7, r5, #27
    7020:	d519      	bpl.n	7056 <ll_adv_params_set+0x6e>
			uint8_t const leg_adv_type[] = {
    7022:	4b75      	ldr	r3, [pc, #468]	; (71f8 <ll_adv_params_set+0x210>)
    7024:	9303      	str	r3, [sp, #12]
			if (evt_prop & BT_HCI_LE_ADV_PROP_ANON) {
    7026:	06ae      	lsls	r6, r5, #26
    7028:	d503      	bpl.n	7032 <ll_adv_params_set+0x4a>
				return BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL;
    702a:	2011      	movs	r0, #17
}
    702c:	b007      	add	sp, #28
    702e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			adv_type = leg_adv_type[evt_prop & 0x03];
    7032:	f005 0303 	and.w	r3, r5, #3
    7036:	a806      	add	r0, sp, #24
    7038:	4403      	add	r3, r0
				adv_type = 0x01; /* PDU_ADV_TYPE_DIRECT_IND */
    703a:	f015 0f08 	tst.w	r5, #8
			adv_type = leg_adv_type[evt_prop & 0x03];
    703e:	f813 3c0c 	ldrb.w	r3, [r3, #-12]
				adv_type = 0x01; /* PDU_ADV_TYPE_DIRECT_IND */
    7042:	bf18      	it	ne
    7044:	2301      	movne	r3, #1
		adv->lll.phy_p = PHY_1M;
    7046:	f891 0021 	ldrb.w	r0, [r1, #33]	; 0x21
    704a:	2401      	movs	r4, #1
    704c:	f364 0002 	bfi	r0, r4, #0, #3
    7050:	f881 0021 	strb.w	r0, [r1, #33]	; 0x21
    7054:	e013      	b.n	707e <ll_adv_params_set+0x96>
			if (((evt_prop & (BT_HCI_LE_ADV_PROP_CONN |
    7056:	f005 0303 	and.w	r3, r5, #3
    705a:	2b03      	cmp	r3, #3
    705c:	f000 8213 	beq.w	7486 <ll_adv_params_set+0x49e>
			      BT_HCI_LE_ADV_PROP_SCAN)) ||
    7060:	072c      	lsls	r4, r5, #28
    7062:	f100 8210 	bmi.w	7486 <ll_adv_params_set+0x49e>
			adv->lll.phy_p = phy_p;
    7066:	f891 0021 	ldrb.w	r0, [r1, #33]	; 0x21
    706a:	f00a 0307 	and.w	r3, sl, #7
    706e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    7072:	f020 0047 	bic.w	r0, r0, #71	; 0x47
    7076:	4303      	orrs	r3, r0
    7078:	f881 3021 	strb.w	r3, [r1, #33]	; 0x21
			adv_type = 0x05; /* PDU_ADV_TYPE_EXT_IND in */
    707c:	2305      	movs	r3, #5
	is_new_set = !adv->is_created;
    707e:	495d      	ldr	r1, [pc, #372]	; (71f4 <ll_adv_params_set+0x20c>)
		adv->interval = 0;
    7080:	2b01      	cmp	r3, #1
	is_new_set = !adv->is_created;
    7082:	f891 606e 	ldrb.w	r6, [r1, #110]	; 0x6e
		adv->interval = 0;
    7086:	bf08      	it	eq
    7088:	2200      	moveq	r2, #0
    708a:	664a      	str	r2, [r1, #100]	; 0x64
	adv->lll.chan_map = chan_map;
    708c:	f89d 2050 	ldrb.w	r2, [sp, #80]	; 0x50
	adv->is_created = 1;
    7090:	f046 0010 	orr.w	r0, r6, #16
    7094:	f881 006e 	strb.w	r0, [r1, #110]	; 0x6e
	adv->lll.chan_map = chan_map;
    7098:	f002 0003 	and.w	r0, r2, #3
    709c:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
    70a0:	f002 0207 	and.w	r2, r2, #7
    70a4:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
    70a8:	f89d 0068 	ldrb.w	r0, [sp, #104]	; 0x68
    70ac:	ea42 32c0 	orr.w	r2, r2, r0, lsl #15
    70b0:	8c08      	ldrh	r0, [r1, #32]
    70b2:	f020 00c7 	bic.w	r0, r0, #199	; 0xc7
    70b6:	0440      	lsls	r0, r0, #17
    70b8:	0c40      	lsrs	r0, r0, #17
    70ba:	4302      	orrs	r2, r0
    70bc:	840a      	strh	r2, [r1, #32]
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    70be:	f891 2025 	ldrb.w	r2, [r1, #37]	; 0x25
    70c2:	eb01 0282 	add.w	r2, r1, r2, lsl #2
		pdu->type = pdu_adv_type[adv_type];
    70c6:	a806      	add	r0, sp, #24
    70c8:	6a94      	ldr	r4, [r2, #40]	; 0x28
    70ca:	4403      	add	r3, r0
	pdu_type_prev = pdu->type;
    70cc:	7822      	ldrb	r2, [r4, #0]
		pdu->type = pdu_adv_type[adv_type];
    70ce:	f813 8c08 	ldrb.w	r8, [r3, #-8]
	if (is_new_set) {
    70d2:	f016 0610 	ands.w	r6, r6, #16
	pdu_type_prev = pdu->type;
    70d6:	f002 070f 	and.w	r7, r2, #15
	if (is_new_set) {
    70da:	d155      	bne.n	7188 <ll_adv_params_set+0x1a0>
		pdu->type = pdu_adv_type[adv_type];
    70dc:	f368 0203 	bfi	r2, r8, #0, #4
    70e0:	7022      	strb	r2, [r4, #0]
		if (pdu->type != PDU_ADV_TYPE_EXT_IND) {
    70e2:	f002 020f 	and.w	r2, r2, #15
    70e6:	2a07      	cmp	r2, #7
    70e8:	d000      	beq.n	70ec <ll_adv_params_set+0x104>
			pdu->len = 0U;
    70ea:	7066      	strb	r6, [r4, #1]
		is_pdu_type_changed = 1;
    70ec:	f04f 0801 	mov.w	r8, #1
	pdu->rfu = 0;
    70f0:	7823      	ldrb	r3, [r4, #0]
	if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2) &&
    70f2:	f003 020e 	and.w	r2, r3, #14
    70f6:	fab2 f282 	clz	r2, r2
    70fa:	0952      	lsrs	r2, r2, #5
    70fc:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    7100:	f362 1345 	bfi	r3, r2, #5, #1
    7104:	7023      	strb	r3, [r4, #0]
	if (((pdu->type == PDU_ADV_TYPE_DIRECT_IND) ||
    7106:	f003 030f 	and.w	r3, r3, #15
    710a:	2b01      	cmp	r3, #1
    710c:	d001      	beq.n	7112 <ll_adv_params_set+0x12a>
    710e:	2b07      	cmp	r3, #7
    7110:	d109      	bne.n	7126 <ll_adv_params_set+0x13e>
	      (pdu->type == PDU_ADV_TYPE_EXT_IND))) &&
    7112:	2f01      	cmp	r7, #1
    7114:	d007      	beq.n	7126 <ll_adv_params_set+0x13e>
	    (pdu_type_prev != PDU_ADV_TYPE_DIRECT_IND) &&
    7116:	2f07      	cmp	r7, #7
    7118:	d005      	beq.n	7126 <ll_adv_params_set+0x13e>
		if (pdu->len == 0U) {
    711a:	7863      	ldrb	r3, [r4, #1]
    711c:	2b00      	cmp	r3, #0
    711e:	d14b      	bne.n	71b8 <ll_adv_params_set+0x1d0>
			adv->ad_data_backup.len = 0U;
    7120:	4a34      	ldr	r2, [pc, #208]	; (71f4 <ll_adv_params_set+0x20c>)
    7122:	f882 3044 	strb.w	r3, [r2, #68]	; 0x44
	adv->own_addr_type = own_addr_type;
    7126:	4b33      	ldr	r3, [pc, #204]	; (71f4 <ll_adv_params_set+0x20c>)
    7128:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
    712c:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
    7130:	f362 0142 	bfi	r1, r2, #1, #2
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
    7134:	0748      	lsls	r0, r1, #29
	adv->own_addr_type = own_addr_type;
    7136:	f883 1078 	strb.w	r1, [r3, #120]	; 0x78
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
    713a:	b2ca      	uxtb	r2, r1
    713c:	d50a      	bpl.n	7154 <ll_adv_params_set+0x16c>
		adv->peer_addr_type = direct_addr_type;
    713e:	f36b 02c3 	bfi	r2, fp, #3, #1
    7142:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
		memcpy(&adv->peer_addr, direct_addr, BDADDR_SIZE);
    7146:	f103 0079 	add.w	r0, r3, #121	; 0x79
    714a:	9912      	ldr	r1, [sp, #72]	; 0x48
    714c:	2206      	movs	r2, #6
    714e:	f008 fd2a 	bl	fba6 <memcpy>
    7152:	4b28      	ldr	r3, [pc, #160]	; (71f4 <ll_adv_params_set+0x20c>)
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
    7154:	7822      	ldrb	r2, [r4, #0]
    7156:	f002 010f 	and.w	r1, r2, #15
    715a:	2901      	cmp	r1, #1
    715c:	d154      	bne.n	7208 <ll_adv_params_set+0x220>
		pdu->tx_addr = own_addr_type & 0x1;
    715e:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
    7162:	9912      	ldr	r1, [sp, #72]	; 0x48
		pdu->tx_addr = own_addr_type & 0x1;
    7164:	019b      	lsls	r3, r3, #6
    7166:	f003 0340 	and.w	r3, r3, #64	; 0x40
    716a:	ea43 1bcb 	orr.w	fp, r3, fp, lsl #7
    716e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    7172:	4620      	mov	r0, r4
    7174:	ea4b 0b02 	orr.w	fp, fp, r2
    7178:	f800 bb08 	strb.w	fp, [r0], #8
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
    717c:	2206      	movs	r2, #6
    717e:	f008 fd12 	bl	fba6 <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
    7182:	230c      	movs	r3, #12
		pdu->len = BDADDR_SIZE;
    7184:	7063      	strb	r3, [r4, #1]
    7186:	e117      	b.n	73b8 <ll_adv_params_set+0x3d0>
	} else if (pdu->type != pdu_adv_type[adv_type]) {
    7188:	4547      	cmp	r7, r8
    718a:	d012      	beq.n	71b2 <ll_adv_params_set+0x1ca>
		if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
    718c:	f002 020f 	and.w	r2, r2, #15
    7190:	2a07      	cmp	r2, #7
    7192:	d107      	bne.n	71a4 <ll_adv_params_set+0x1bc>
			struct lll_adv_aux *lll_aux = adv->lll.aux;
    7194:	6c0b      	ldr	r3, [r1, #64]	; 0x40
			if (lll_aux) {
    7196:	b153      	cbz	r3, 71ae <ll_adv_params_set+0x1c6>
				pdu->len = 0;
    7198:	2200      	movs	r2, #0
    719a:	7062      	strb	r2, [r4, #1]
				aux = HDR_LLL2ULL(lll_aux);
    719c:	6818      	ldr	r0, [r3, #0]
				adv->lll.aux = NULL;
    719e:	640a      	str	r2, [r1, #64]	; 0x40
				ull_adv_aux_release(aux);
    71a0:	f000 fbe6 	bl	7970 <ull_adv_aux_release>
		pdu->type = pdu_adv_type[adv_type];
    71a4:	7823      	ldrb	r3, [r4, #0]
    71a6:	f368 0303 	bfi	r3, r8, #0, #4
    71aa:	7023      	strb	r3, [r4, #0]
    71ac:	e79e      	b.n	70ec <ll_adv_params_set+0x104>
				pdu->len = 0;
    71ae:	7063      	strb	r3, [r4, #1]
    71b0:	e7f8      	b.n	71a4 <ll_adv_params_set+0x1bc>
	uint8_t is_pdu_type_changed = 0;
    71b2:	f04f 0800 	mov.w	r8, #0
    71b6:	e79b      	b.n	70f0 <ll_adv_params_set+0x108>
			LL_ASSERT(pdu->len >=
    71b8:	2b05      	cmp	r3, #5
    71ba:	d80c      	bhi.n	71d6 <ll_adv_params_set+0x1ee>
    71bc:	4a0f      	ldr	r2, [pc, #60]	; (71fc <ll_adv_params_set+0x214>)
    71be:	4910      	ldr	r1, [pc, #64]	; (7200 <ll_adv_params_set+0x218>)
    71c0:	4810      	ldr	r0, [pc, #64]	; (7204 <ll_adv_params_set+0x21c>)
    71c2:	f240 139b 	movw	r3, #411	; 0x19b
    71c6:	f008 f97e 	bl	f4c6 <printk>
    71ca:	4040      	eors	r0, r0
    71cc:	f380 8811 	msr	BASEPRI, r0
    71d0:	f04f 0003 	mov.w	r0, #3
    71d4:	df02      	svc	2
			adv->ad_data_backup.len = pdu->len -
    71d6:	7862      	ldrb	r2, [r4, #1]
    71d8:	4806      	ldr	r0, [pc, #24]	; (71f4 <ll_adv_params_set+0x20c>)
    71da:	3a06      	subs	r2, #6
    71dc:	b2d2      	uxtb	r2, r2
    71de:	f880 2044 	strb.w	r2, [r0, #68]	; 0x44
			memcpy(adv->ad_data_backup.data, pdu->adv_ind.data,
    71e2:	f104 0108 	add.w	r1, r4, #8
    71e6:	3045      	adds	r0, #69	; 0x45
    71e8:	f008 fcdd 	bl	fba6 <memcpy>
    71ec:	e79b      	b.n	7126 <ll_adv_params_set+0x13e>
    71ee:	bf00      	nop
    71f0:	00012ffd 	.word	0x00012ffd
    71f4:	20001e5c 	.word	0x20001e5c
    71f8:	00020403 	.word	0x00020403
    71fc:	00013714 	.word	0x00013714
    7200:	000137d0 	.word	0x000137d0
    7204:	000133b6 	.word	0x000133b6
	} else if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
    7208:	2907      	cmp	r1, #7
    720a:	f040 80e8 	bne.w	73de <ll_adv_params_set+0x3f6>
		pri_com_hdr->adv_mode = evt_prop & 0x03;
    720e:	78a3      	ldrb	r3, [r4, #2]
    7210:	f365 1387 	bfi	r3, r5, #6, #2
		pri_com_hdr = (void *)&pdu->adv_ext_ind;
    7214:	1ca2      	adds	r2, r4, #2
		pri_dptr = pri_hdr->data;
    7216:	1d27      	adds	r7, r4, #4
		pri_com_hdr->adv_mode = evt_prop & 0x03;
    7218:	70a3      	strb	r3, [r4, #2]
		if (is_pdu_type_changed) {
    721a:	2100      	movs	r1, #0
    721c:	f1b8 0f00 	cmp.w	r8, #0
    7220:	f040 80d4 	bne.w	73cc <ll_adv_params_set+0x3e4>
			pri_hdr_prev = *pri_hdr;
    7224:	78e3      	ldrb	r3, [r4, #3]
		if (!pri_com_hdr->adv_mode &&
    7226:	78a0      	ldrb	r0, [r4, #2]
		*(uint8_t *)pri_hdr = 0U;
    7228:	70e1      	strb	r1, [r4, #3]
		if (pri_hdr_prev.adv_addr) {
    722a:	07d9      	lsls	r1, r3, #31
			pri_dptr_prev += BDADDR_SIZE;
    722c:	bf4c      	ite	mi
    722e:	f104 080a 	addmi.w	r8, r4, #10
		pri_dptr_prev = pri_dptr;
    7232:	46b8      	movpl	r8, r7
		if (!pri_com_hdr->adv_mode &&
    7234:	f010 0fc0 	tst.w	r0, #192	; 0xc0
		    (!pri_hdr_prev.aux_ptr ||
    7238:	f003 0110 	and.w	r1, r3, #16
		if (!pri_com_hdr->adv_mode &&
    723c:	f040 80c8 	bne.w	73d0 <ll_adv_params_set+0x3e8>
    7240:	b131      	cbz	r1, 7250 <ll_adv_params_set+0x268>
		    (!pri_hdr_prev.aux_ptr ||
    7242:	06a8      	lsls	r0, r5, #26
    7244:	f100 80c4 	bmi.w	73d0 <ll_adv_params_set+0x3e8>
		     (!(evt_prop & BT_HCI_LE_ADV_PROP_ANON) &&
    7248:	f1ba 0f04 	cmp.w	sl, #4
    724c:	f000 80c0 	beq.w	73d0 <ll_adv_params_set+0x3e8>
			pri_hdr->adv_addr = 1;
    7250:	78e0      	ldrb	r0, [r4, #3]
			pdu->tx_addr = own_addr_type & 0x1;
    7252:	f89d 7040 	ldrb.w	r7, [sp, #64]	; 0x40
			pri_hdr->adv_addr = 1;
    7256:	f040 0001 	orr.w	r0, r0, #1
    725a:	70e0      	strb	r0, [r4, #3]
			pdu->tx_addr = own_addr_type & 0x1;
    725c:	7820      	ldrb	r0, [r4, #0]
    725e:	f367 1086 	bfi	r0, r7, #6, #1
    7262:	4627      	mov	r7, r4
    7264:	f807 0b0a 	strb.w	r0, [r7], #10
		if (pri_hdr_prev.tgt_addr) {
    7268:	0798      	lsls	r0, r3, #30
			pri_dptr_prev += BDADDR_SIZE;
    726a:	bf48      	it	mi
    726c:	f108 0806 	addmi.w	r8, r8, #6
		if (evt_prop & BT_HCI_LE_ADV_PROP_DIRECT) {
    7270:	f015 0c04 	ands.w	ip, r5, #4
    7274:	7820      	ldrb	r0, [r4, #0]
			pri_hdr->tgt_addr = 1;
    7276:	bf1d      	ittte	ne
    7278:	f894 c003 	ldrbne.w	ip, [r4, #3]
			pdu->rx_addr = direct_addr_type;
    727c:	f36b 10c7 	bfine	r0, fp, #7, #1
			pri_hdr->tgt_addr = 1;
    7280:	f04c 0c02 	orrne.w	ip, ip, #2
			pdu->rx_addr = 0;
    7284:	f36c 10c7 	bfieq	r0, ip, #7, #1
			pri_hdr->tgt_addr = 1;
    7288:	bf1d      	ittte	ne
    728a:	f884 c003 	strbne.w	ip, [r4, #3]
			pdu->rx_addr = direct_addr_type;
    728e:	7020      	strbne	r0, [r4, #0]
			pri_dptr += BDADDR_SIZE;
    7290:	3706      	addne	r7, #6
			pdu->rx_addr = 0;
    7292:	7020      	strbeq	r0, [r4, #0]
		if (pri_hdr_prev.adi) {
    7294:	f013 0b08 	ands.w	fp, r3, #8
    7298:	d006      	beq.n	72a8 <ll_adv_params_set+0x2c0>
			pri_hdr->adi = 1;
    729a:	78e0      	ldrb	r0, [r4, #3]
    729c:	f040 0008 	orr.w	r0, r0, #8
			pri_dptr_prev += sizeof(struct pdu_adv_adi);
    72a0:	f108 0802 	add.w	r8, r8, #2
			pri_hdr->adi = 1;
    72a4:	70e0      	strb	r0, [r4, #3]
			pri_dptr += sizeof(struct pdu_adv_adi);
    72a6:	3702      	adds	r7, #2
		if (pri_hdr_prev.aux_ptr) {
    72a8:	2900      	cmp	r1, #0
    72aa:	f000 80ee 	beq.w	748a <ll_adv_params_set+0x4a2>
			pri_dptr_prev += sizeof(struct pdu_adv_aux_ptr);
    72ae:	f108 0803 	add.w	r8, r8, #3
			pri_hdr->aux_ptr = 1;
    72b2:	78e0      	ldrb	r0, [r4, #3]
    72b4:	f040 0010 	orr.w	r0, r0, #16
    72b8:	70e0      	strb	r0, [r4, #3]
			pri_dptr += sizeof(struct pdu_adv_aux_ptr);
    72ba:	3703      	adds	r7, #3
		if (pri_hdr_prev.tx_pwr) {
    72bc:	f013 0340 	ands.w	r3, r3, #64	; 0x40
			pri_dptr_prev += sizeof(uint8_t);
    72c0:	bf18      	it	ne
    72c2:	f108 0801 	addne.w	r8, r8, #1
		if ((evt_prop & BT_HCI_LE_ADV_PROP_TX_POWER) &&
    72c6:	066d      	lsls	r5, r5, #25
    72c8:	d508      	bpl.n	72dc <ll_adv_params_set+0x2f4>
    72ca:	b111      	cbz	r1, 72d2 <ll_adv_params_set+0x2ea>
		    (!pri_hdr_prev.aux_ptr || (phy_p != PHY_CODED))) {
    72cc:	f1ba 0f04 	cmp.w	sl, #4
    72d0:	d004      	beq.n	72dc <ll_adv_params_set+0x2f4>
			pri_hdr->tx_pwr = 1;
    72d2:	78e0      	ldrb	r0, [r4, #3]
    72d4:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    72d8:	70e0      	strb	r0, [r4, #3]
			pri_dptr += sizeof(uint8_t);
    72da:	3701      	adds	r7, #1
	len = *dptr - (uint8_t *)com_hdr;
    72dc:	1aba      	subs	r2, r7, r2
    72de:	b2d2      	uxtb	r2, r2
	if (len <= (PDU_AC_EXT_HEADER_SIZE_MIN +
    72e0:	2a02      	cmp	r2, #2
	com_hdr->ext_hdr_len = len - PDU_AC_EXT_HEADER_SIZE_MIN;
    72e2:	78a0      	ldrb	r0, [r4, #2]
		len = PDU_AC_EXT_HEADER_SIZE_MIN;
    72e4:	bf98      	it	ls
    72e6:	2201      	movls	r2, #1
	com_hdr->ext_hdr_len = len - PDU_AC_EXT_HEADER_SIZE_MIN;
    72e8:	f102 35ff 	add.w	r5, r2, #4294967295	; 0xffffffff
    72ec:	f365 0005 	bfi	r0, r5, #0, #6
		*dptr = (uint8_t *)com_hdr + len;
    72f0:	bf98      	it	ls
    72f2:	1ce7      	addls	r7, r4, #3
	com_hdr->ext_hdr_len = len - PDU_AC_EXT_HEADER_SIZE_MIN;
    72f4:	70a0      	strb	r0, [r4, #2]
		pdu->len = len;
    72f6:	7062      	strb	r2, [r4, #1]
		if (pri_hdr_prev.tx_pwr) {
    72f8:	b10b      	cbz	r3, 72fe <ll_adv_params_set+0x316>
			pri_dptr_prev -= sizeof(uint8_t);
    72fa:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		if (pri_hdr->tx_pwr) {
    72fe:	78e3      	ldrb	r3, [r4, #3]
    7300:	0658      	lsls	r0, r3, #25
    7302:	d50b      	bpl.n	731c <ll_adv_params_set+0x334>
			if (tx_pwr) {
    7304:	9b15      	ldr	r3, [sp, #84]	; 0x54
    7306:	2b00      	cmp	r3, #0
    7308:	d067      	beq.n	73da <ll_adv_params_set+0x3f2>
				if (*tx_pwr != BT_HCI_LE_ADV_TX_POWER_NO_PREF) {
    730a:	781b      	ldrb	r3, [r3, #0]
    730c:	2b7f      	cmp	r3, #127	; 0x7f
    730e:	d102      	bne.n	7316 <ll_adv_params_set+0x32e>
					*tx_pwr = _tx_pwr;
    7310:	9a15      	ldr	r2, [sp, #84]	; 0x54
    7312:	2300      	movs	r3, #0
    7314:	7013      	strb	r3, [r2, #0]
			*pri_dptr = _tx_pwr;
    7316:	f807 3c01 	strb.w	r3, [r7, #-1]
			pri_dptr -= sizeof(uint8_t);
    731a:	3f01      	subs	r7, #1
		if (pri_hdr_prev.aux_ptr) {
    731c:	b109      	cbz	r1, 7322 <ll_adv_params_set+0x33a>
			pri_dptr_prev -= sizeof(struct pdu_adv_aux_ptr);
    731e:	f1a8 0803 	sub.w	r8, r8, #3
		if (pri_hdr->aux_ptr) {
    7322:	78e3      	ldrb	r3, [r4, #3]
    7324:	06d9      	lsls	r1, r3, #27
    7326:	d505      	bpl.n	7334 <ll_adv_params_set+0x34c>
			pri_dptr -= sizeof(struct pdu_adv_aux_ptr);
    7328:	3f03      	subs	r7, #3
			ull_adv_aux_ptr_fill((void *)pri_dptr, 0U, phy_s);
    732a:	464a      	mov	r2, r9
    732c:	2100      	movs	r1, #0
    732e:	4638      	mov	r0, r7
    7330:	f00a f88a 	bl	11448 <ull_adv_aux_ptr_fill>
		adv->lll.phy_s = phy_s;
    7334:	4d57      	ldr	r5, [pc, #348]	; (7494 <ll_adv_params_set+0x4ac>)
    7336:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
    733a:	f369 03c5 	bfi	r3, r9, #3, #3
    733e:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
		if (pri_hdr_prev.adi) {
    7342:	f1bb 0f00 	cmp.w	fp, #0
    7346:	d001      	beq.n	734c <ll_adv_params_set+0x364>
			pri_dptr_prev -= sizeof(struct pdu_adv_adi);
    7348:	f1a8 0802 	sub.w	r8, r8, #2
		if (pri_hdr->adi) {
    734c:	78e3      	ldrb	r3, [r4, #3]
			adi->sid = sid;
    734e:	f89d a064 	ldrb.w	sl, [sp, #100]	; 0x64
		if (pri_hdr->adi) {
    7352:	071a      	lsls	r2, r3, #28
			adi->sid = sid;
    7354:	f00a 0a0f 	and.w	sl, sl, #15
		if (pri_hdr->adi) {
    7358:	d50d      	bpl.n	7376 <ll_adv_params_set+0x38e>
			pri_dptr -= sizeof(struct pdu_adv_adi);
    735a:	f1a7 0b02 	sub.w	fp, r7, #2
			memmove(pri_dptr, pri_dptr_prev,
    735e:	2202      	movs	r2, #2
    7360:	4641      	mov	r1, r8
    7362:	4658      	mov	r0, fp
    7364:	f008 fc07 	bl	fb76 <memmove>
			adi->sid = sid;
    7368:	f817 3c01 	ldrb.w	r3, [r7, #-1]
    736c:	f36a 1307 	bfi	r3, sl, #4, #4
    7370:	f807 3c01 	strb.w	r3, [r7, #-1]
			pri_dptr -= sizeof(struct pdu_adv_adi);
    7374:	465f      	mov	r7, fp
		adv->sid = sid;
    7376:	f895 306e 	ldrb.w	r3, [r5, #110]	; 0x6e
    737a:	f36a 0303 	bfi	r3, sl, #0, #4
    737e:	f885 306e 	strb.w	r3, [r5, #110]	; 0x6e
		if (pri_hdr->tgt_addr) {
    7382:	78e3      	ldrb	r3, [r4, #3]
    7384:	079b      	lsls	r3, r3, #30
    7386:	d504      	bpl.n	7392 <ll_adv_params_set+0x3aa>
			memcpy(pri_dptr, direct_addr, BDADDR_SIZE);
    7388:	9912      	ldr	r1, [sp, #72]	; 0x48
    738a:	2206      	movs	r2, #6
    738c:	1fb8      	subs	r0, r7, #6
    738e:	f008 fc0a 	bl	fba6 <memcpy>
		if (pri_hdr->aux_ptr) {
    7392:	78e3      	ldrb	r3, [r4, #3]
    7394:	06df      	lsls	r7, r3, #27
    7396:	d50f      	bpl.n	73b8 <ll_adv_params_set+0x3d0>
			err = ull_adv_aux_hdr_set_clear(adv,
    7398:	ab03      	add	r3, sp, #12
    739a:	2200      	movs	r2, #0
    739c:	9301      	str	r3, [sp, #4]
    739e:	483d      	ldr	r0, [pc, #244]	; (7494 <ll_adv_params_set+0x4ac>)
    73a0:	9200      	str	r2, [sp, #0]
    73a2:	ab10      	add	r3, sp, #64	; 0x40
    73a4:	2101      	movs	r1, #1
    73a6:	f7f9 fb4f 	bl	a48 <ull_adv_aux_hdr_set_clear>
			if (err) {
    73aa:	2800      	cmp	r0, #0
    73ac:	f47f ae3e 	bne.w	702c <ll_adv_params_set+0x44>
	pdu->last = idx;
    73b0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    73b4:	f885 3025 	strb.w	r3, [r5, #37]	; 0x25
	} else if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
    73b8:	7822      	ldrb	r2, [r4, #0]
    73ba:	4b36      	ldr	r3, [pc, #216]	; (7494 <ll_adv_params_set+0x4ac>)
    73bc:	f002 020f 	and.w	r2, r2, #15
    73c0:	2a07      	cmp	r2, #7
    73c2:	61db      	str	r3, [r3, #28]
    73c4:	d142      	bne.n	744c <ll_adv_params_set+0x464>
		if (is_new_set) {
    73c6:	b3ae      	cbz	r6, 7434 <ll_adv_params_set+0x44c>
	return 0;
    73c8:	2000      	movs	r0, #0
    73ca:	e62f      	b.n	702c <ll_adv_params_set+0x44>
			*(uint8_t *)&pri_hdr_prev = 0U;
    73cc:	460b      	mov	r3, r1
    73ce:	e72a      	b.n	7226 <ll_adv_params_set+0x23e>
			pdu->tx_addr = 0;
    73d0:	7820      	ldrb	r0, [r4, #0]
    73d2:	f36f 1086 	bfc	r0, #6, #1
    73d6:	7020      	strb	r0, [r4, #0]
    73d8:	e746      	b.n	7268 <ll_adv_params_set+0x280>
			_tx_pwr = 0;
    73da:	9b15      	ldr	r3, [sp, #84]	; 0x54
    73dc:	e79b      	b.n	7316 <ll_adv_params_set+0x32e>
	} else if (pdu->len == 0) {
    73de:	7861      	ldrb	r1, [r4, #1]
    73e0:	b969      	cbnz	r1, 73fe <ll_adv_params_set+0x416>
		pdu->tx_addr = own_addr_type & 0x1;
    73e2:	f89d b040 	ldrb.w	fp, [sp, #64]	; 0x40
    73e6:	ea4f 1b8b 	mov.w	fp, fp, lsl #6
    73ea:	f00b 0b40 	and.w	fp, fp, #64	; 0x40
    73ee:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    73f2:	ea4b 0b02 	orr.w	fp, fp, r2
    73f6:	f884 b000 	strb.w	fp, [r4]
		pdu->len = BDADDR_SIZE;
    73fa:	2306      	movs	r3, #6
    73fc:	e6c2      	b.n	7184 <ll_adv_params_set+0x19c>
		if (((pdu_type_prev == PDU_ADV_TYPE_DIRECT_IND) ||
    73fe:	2f01      	cmp	r7, #1
    7400:	d001      	beq.n	7406 <ll_adv_params_set+0x41e>
    7402:	2f07      	cmp	r7, #7
    7404:	d10b      	bne.n	741e <ll_adv_params_set+0x436>
			memcpy(pdu->adv_ind.data, adv->ad_data_backup.data,
    7406:	f893 2044 	ldrb.w	r2, [r3, #68]	; 0x44
    740a:	4923      	ldr	r1, [pc, #140]	; (7498 <ll_adv_params_set+0x4b0>)
    740c:	f104 0008 	add.w	r0, r4, #8
    7410:	f008 fbc9 	bl	fba6 <memcpy>
			pdu->len = offsetof(struct pdu_adv_adv_ind, data) +
    7414:	4b1f      	ldr	r3, [pc, #124]	; (7494 <ll_adv_params_set+0x4ac>)
    7416:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
    741a:	3306      	adds	r3, #6
    741c:	7063      	strb	r3, [r4, #1]
		pdu->tx_addr = own_addr_type & 0x1;
    741e:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
    7422:	7822      	ldrb	r2, [r4, #0]
    7424:	019b      	lsls	r3, r3, #6
    7426:	f003 0340 	and.w	r3, r3, #64	; 0x40
    742a:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    742e:	4313      	orrs	r3, r2
    7430:	7023      	strb	r3, [r4, #0]
    7432:	e7c1      	b.n	73b8 <ll_adv_params_set+0x3d0>
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    7434:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
    7438:	eb03 0382 	add.w	r3, r3, r2, lsl #2
			pdu->type = PDU_ADV_TYPE_AUX_SCAN_REQ;
    743c:	2103      	movs	r1, #3
    743e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7440:	781a      	ldrb	r2, [r3, #0]
			pdu->len = 0;
    7442:	705e      	strb	r6, [r3, #1]
			pdu->type = PDU_ADV_TYPE_AUX_SCAN_REQ;
    7444:	f361 0203 	bfi	r2, r1, #0, #4
    7448:	701a      	strb	r2, [r3, #0]
			pdu->len = 0;
    744a:	e7bd      	b.n	73c8 <ll_adv_params_set+0x3e0>
    744c:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
    7450:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    7454:	6b5a      	ldr	r2, [r3, #52]	; 0x34
		pdu->type = PDU_ADV_TYPE_SCAN_RSP;
    7456:	7813      	ldrb	r3, [r2, #0]
		if (pdu->len == 0) {
    7458:	7850      	ldrb	r0, [r2, #1]
		pdu->type = PDU_ADV_TYPE_SCAN_RSP;
    745a:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    745e:	f043 0304 	orr.w	r3, r3, #4
    7462:	7013      	strb	r3, [r2, #0]
		pdu->tx_addr = own_addr_type & 0x1;
    7464:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
    7468:	7811      	ldrb	r1, [r2, #0]
    746a:	019b      	lsls	r3, r3, #6
    746c:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7470:	f001 013f 	and.w	r1, r1, #63	; 0x3f
    7474:	430b      	orrs	r3, r1
    7476:	7013      	strb	r3, [r2, #0]
		if (pdu->len == 0) {
    7478:	2800      	cmp	r0, #0
    747a:	d1a5      	bne.n	73c8 <ll_adv_params_set+0x3e0>
			pdu->len = BDADDR_SIZE;
    747c:	2306      	movs	r3, #6
    747e:	7053      	strb	r3, [r2, #1]
    7480:	e5d4      	b.n	702c <ll_adv_params_set+0x44>
		return BT_HCI_ERR_CMD_DISALLOWED;
    7482:	200c      	movs	r0, #12
    7484:	e5d2      	b.n	702c <ll_adv_params_set+0x44>
				return BT_HCI_ERR_INVALID_PARAM;
    7486:	2012      	movs	r0, #18
    7488:	e5d0      	b.n	702c <ll_adv_params_set+0x44>
		if (pri_hdr_prev.aux_ptr ||
    748a:	07a8      	lsls	r0, r5, #30
    748c:	f47f af11 	bne.w	72b2 <ll_adv_params_set+0x2ca>
    7490:	e714      	b.n	72bc <ll_adv_params_set+0x2d4>
    7492:	bf00      	nop
    7494:	20001e5c 	.word	0x20001e5c
    7498:	20001ea1 	.word	0x20001ea1

0000749c <ull_adv_reset_finalize>:
{
    749c:	b510      	push	{r4, lr}
		err = ull_adv_aux_reset_finalize();
    749e:	f000 f92d 	bl	76fc <ull_adv_aux_reset_finalize>
		if (err) {
    74a2:	b998      	cbnz	r0, 74cc <ull_adv_reset_finalize+0x30>
		adv->is_created = 0;
    74a4:	4c0a      	ldr	r4, [pc, #40]	; (74d0 <ull_adv_reset_finalize+0x34>)
    74a6:	f894 206e 	ldrb.w	r2, [r4, #110]	; 0x6e
		lll->aux = NULL;
    74aa:	6420      	str	r0, [r4, #64]	; 0x40
		adv->is_created = 0;
    74ac:	f360 1204 	bfi	r2, r0, #4, #1
		lll_adv_data_reset(&lll->adv_data);
    74b0:	f104 0024 	add.w	r0, r4, #36	; 0x24
		adv->is_created = 0;
    74b4:	f884 206e 	strb.w	r2, [r4, #110]	; 0x6e
		lll_adv_data_reset(&lll->adv_data);
    74b8:	f00a f9dc 	bl	11874 <lll_adv_data_reset>
		lll_adv_data_reset(&lll->scan_rsp);
    74bc:	f104 0030 	add.w	r0, r4, #48	; 0x30
    74c0:	f00a f9d8 	bl	11874 <lll_adv_data_reset>
}
    74c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	err = init_reset();
    74c8:	f7ff bd5e 	b.w	6f88 <init_reset>
}
    74cc:	bd10      	pop	{r4, pc}
    74ce:	bf00      	nop
    74d0:	20001e5c 	.word	0x20001e5c

000074d4 <ull_adv_set_get>:
		return NULL;
    74d4:	2800      	cmp	r0, #0
}
    74d6:	4802      	ldr	r0, [pc, #8]	; (74e0 <ull_adv_set_get+0xc>)
    74d8:	bf18      	it	ne
    74da:	2000      	movne	r0, #0
    74dc:	4770      	bx	lr
    74de:	bf00      	nop
    74e0:	20001e5c 	.word	0x20001e5c

000074e4 <ull_adv_lll_handle_get>:
	return ((uint8_t *)adv - (uint8_t *)ll_adv) / sizeof(*adv);
    74e4:	6800      	ldr	r0, [r0, #0]
    74e6:	4b02      	ldr	r3, [pc, #8]	; (74f0 <ull_adv_lll_handle_get+0xc>)
    74e8:	1ac0      	subs	r0, r0, r3
}
    74ea:	f3c0 10cf 	ubfx	r0, r0, #7, #16
    74ee:	4770      	bx	lr
    74f0:	20001e5c 	.word	0x20001e5c

000074f4 <ull_adv_is_enabled_get>:
	if (handle >= BT_CTLR_ADV_SET) {
    74f4:	b938      	cbnz	r0, 7506 <ull_adv_is_enabled_get+0x12>
	if (!adv || !adv->is_enabled) {
    74f6:	4805      	ldr	r0, [pc, #20]	; (750c <ull_adv_is_enabled_get+0x18>)
    74f8:	f890 3078 	ldrb.w	r3, [r0, #120]	; 0x78
	return &ll_adv[handle];
    74fc:	f013 0f01 	tst.w	r3, #1
    7500:	bf08      	it	eq
    7502:	2000      	moveq	r0, #0
    7504:	4770      	bx	lr
		return NULL;
    7506:	2000      	movs	r0, #0
}
    7508:	4770      	bx	lr
    750a:	bf00      	nop
    750c:	20001e5c 	.word	0x20001e5c

00007510 <disable>:
{
    7510:	b530      	push	{r4, r5, lr}
    7512:	b085      	sub	sp, #20
    7514:	4605      	mov	r5, r0
	adv = ull_adv_is_enabled_get(handle);
    7516:	f7ff ffed 	bl	74f4 <ull_adv_is_enabled_get>
	if (!adv) {
    751a:	4604      	mov	r4, r0
    751c:	b910      	cbnz	r0, 7524 <disable+0x14>
			return 0;
    751e:	2000      	movs	r0, #0
}
    7520:	b005      	add	sp, #20
    7522:	bd30      	pop	{r4, r5, pc}
	mark = ull_disable_mark(adv);
    7524:	f7ff f838 	bl	6598 <ull_disable_mark>
	LL_ASSERT(mark == adv);
    7528:	4284      	cmp	r4, r0
    752a:	d00c      	beq.n	7546 <disable+0x36>
    752c:	4a3a      	ldr	r2, [pc, #232]	; (7618 <disable+0x108>)
    752e:	493b      	ldr	r1, [pc, #236]	; (761c <disable+0x10c>)
    7530:	483b      	ldr	r0, [pc, #236]	; (7620 <disable+0x110>)
    7532:	f640 13f6 	movw	r3, #2550	; 0x9f6
    7536:	f007 ffc6 	bl	f4c6 <printk>
    753a:	4040      	eors	r0, r0
    753c:	f380 8811 	msr	BASEPRI, r0
    7540:	f04f 0003 	mov.w	r0, #3
    7544:	df02      	svc	2
	ret_cb = TICKER_STATUS_BUSY;
    7546:	2302      	movs	r3, #2
			  TICKER_ID_ADV_BASE + handle,
    7548:	18ea      	adds	r2, r5, r3
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
    754a:	ad03      	add	r5, sp, #12
	ret_cb = TICKER_STATUS_BUSY;
    754c:	9303      	str	r3, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
    754e:	2103      	movs	r1, #3
    7550:	4b34      	ldr	r3, [pc, #208]	; (7624 <disable+0x114>)
    7552:	9500      	str	r5, [sp, #0]
    7554:	b2d2      	uxtb	r2, r2
    7556:	2000      	movs	r0, #0
    7558:	f7fd fb26 	bl	4ba8 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
    755c:	4629      	mov	r1, r5
    755e:	f7fe fff5 	bl	654c <ull_ticker_status_take>
	if (ret) {
    7562:	b198      	cbz	r0, 758c <disable+0x7c>
		mark = ull_disable_unmark(adv);
    7564:	4620      	mov	r0, r4
    7566:	f7ff f81f 	bl	65a8 <ull_disable_unmark>
		LL_ASSERT(mark == adv);
    756a:	4284      	cmp	r4, r0
    756c:	d00c      	beq.n	7588 <disable+0x78>
    756e:	4a2a      	ldr	r2, [pc, #168]	; (7618 <disable+0x108>)
    7570:	492a      	ldr	r1, [pc, #168]	; (761c <disable+0x10c>)
    7572:	482b      	ldr	r0, [pc, #172]	; (7620 <disable+0x110>)
    7574:	f640 230f 	movw	r3, #2575	; 0xa0f
    7578:	f007 ffa5 	bl	f4c6 <printk>
    757c:	4040      	eors	r0, r0
    757e:	f380 8811 	msr	BASEPRI, r0
    7582:	f04f 0003 	mov.w	r0, #3
    7586:	df02      	svc	2
		return BT_HCI_ERR_CMD_DISALLOWED;
    7588:	200c      	movs	r0, #12
    758a:	e7c9      	b.n	7520 <disable+0x10>
	ret = ull_disable(&adv->lll);
    758c:	f104 001c 	add.w	r0, r4, #28
    7590:	f7ff f81e 	bl	65d0 <ull_disable>
	LL_ASSERT(!ret);
    7594:	b160      	cbz	r0, 75b0 <disable+0xa0>
    7596:	4a20      	ldr	r2, [pc, #128]	; (7618 <disable+0x108>)
    7598:	4923      	ldr	r1, [pc, #140]	; (7628 <disable+0x118>)
    759a:	4821      	ldr	r0, [pc, #132]	; (7620 <disable+0x110>)
    759c:	f640 2315 	movw	r3, #2581	; 0xa15
    75a0:	f007 ff91 	bl	f4c6 <printk>
    75a4:	4040      	eors	r0, r0
    75a6:	f380 8811 	msr	BASEPRI, r0
    75aa:	f04f 0003 	mov.w	r0, #3
    75ae:	df02      	svc	2
	mark = ull_disable_unmark(adv);
    75b0:	4620      	mov	r0, r4
    75b2:	f7fe fff9 	bl	65a8 <ull_disable_unmark>
	LL_ASSERT(mark == adv);
    75b6:	4284      	cmp	r4, r0
    75b8:	d00c      	beq.n	75d4 <disable+0xc4>
    75ba:	4a17      	ldr	r2, [pc, #92]	; (7618 <disable+0x108>)
    75bc:	4917      	ldr	r1, [pc, #92]	; (761c <disable+0x10c>)
    75be:	4818      	ldr	r0, [pc, #96]	; (7620 <disable+0x110>)
    75c0:	f640 2318 	movw	r3, #2584	; 0xa18
    75c4:	f007 ff7f 	bl	f4c6 <printk>
    75c8:	4040      	eors	r0, r0
    75ca:	f380 8811 	msr	BASEPRI, r0
    75ce:	f04f 0003 	mov.w	r0, #3
    75d2:	df02      	svc	2
	struct lll_adv_aux *lll_aux = adv->lll.aux;
    75d4:	6c23      	ldr	r3, [r4, #64]	; 0x40
	if (lll_aux) {
    75d6:	b97b      	cbnz	r3, 75f8 <disable+0xe8>
	if (lll->node_rx_adv_term) {
    75d8:	6be5      	ldr	r5, [r4, #60]	; 0x3c
    75da:	b99d      	cbnz	r5, 7604 <disable+0xf4>
	adv->is_enabled = 0U;
    75dc:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    75e0:	f36f 0300 	bfc	r3, #0, #1
    75e4:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
    75e8:	2000      	movs	r0, #0
    75ea:	f000 fc77 	bl	7edc <ull_scan_is_enabled_get>
    75ee:	2800      	cmp	r0, #0
    75f0:	d195      	bne.n	751e <disable+0xe>
		ull_filter_adv_scan_state_cb(0);
    75f2:	f001 f8a9 	bl	8748 <ull_filter_adv_scan_state_cb>
    75f6:	e792      	b.n	751e <disable+0xe>
		err = ull_adv_aux_stop(aux);
    75f8:	6818      	ldr	r0, [r3, #0]
    75fa:	f000 f8a3 	bl	7744 <ull_adv_aux_stop>
		if (err) {
    75fe:	2800      	cmp	r0, #0
    7600:	d0ea      	beq.n	75d8 <disable+0xc8>
    7602:	e78d      	b.n	7520 <disable+0x10>
		lll->node_rx_adv_term = NULL;
    7604:	2300      	movs	r3, #0
		ll_rx_link_release(node_rx_adv_term->hdr.link);
    7606:	6828      	ldr	r0, [r5, #0]
		lll->node_rx_adv_term = NULL;
    7608:	63e3      	str	r3, [r4, #60]	; 0x3c
		ll_rx_link_release(node_rx_adv_term->hdr.link);
    760a:	f7fe ff15 	bl	6438 <ll_rx_link_release>
		ll_rx_release(node_rx_adv_term);
    760e:	4628      	mov	r0, r5
    7610:	f7fe ff1e 	bl	6450 <ll_rx_release>
    7614:	e7e2      	b.n	75dc <disable+0xcc>
    7616:	bf00      	nop
    7618:	00013714 	.word	0x00013714
    761c:	0001380e 	.word	0x0001380e
    7620:	000133b6 	.word	0x000133b6
    7624:	00006209 	.word	0x00006209
    7628:	0001366f 	.word	0x0001366f

0000762c <ull_adv_is_created_get>:
	if (handle >= BT_CTLR_ADV_SET) {
    762c:	b938      	cbnz	r0, 763e <ull_adv_is_created_get+0x12>
	if (!adv || !adv->is_created) {
    762e:	4805      	ldr	r0, [pc, #20]	; (7644 <ull_adv_is_created_get+0x18>)
    7630:	f890 306e 	ldrb.w	r3, [r0, #110]	; 0x6e
	return &ll_adv[handle];
    7634:	f013 0f10 	tst.w	r3, #16
    7638:	bf08      	it	eq
    763a:	2000      	moveq	r0, #0
    763c:	4770      	bx	lr
		return NULL;
    763e:	2000      	movs	r0, #0
}
    7640:	4770      	bx	lr
    7642:	bf00      	nop
    7644:	20001e5c 	.word	0x20001e5c

00007648 <ticker_cb>:
}

static void ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
		      uint32_t remainder, uint16_t lazy, uint8_t force,
		      void *param)
{
    7648:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    764a:	461d      	mov	r5, r3
    764c:	9b07      	ldr	r3, [sp, #28]
	uint32_t ret;
	uint8_t ref;

	DEBUG_RADIO_PREPARE_A(1);

	lll = &aux->lll;
    764e:	461c      	mov	r4, r3
{
    7650:	4607      	mov	r7, r0
	return ++hdr->ref;
    7652:	f814 1b1c 	ldrb.w	r1, [r4], #28
    7656:	3101      	adds	r1, #1
    7658:	b2c9      	uxtb	r1, r1
    765a:	4616      	mov	r6, r2
    765c:	7019      	strb	r1, [r3, #0]

	/* Increment prepare reference count */
	ref = ull_ref_inc(&aux->ull);
	LL_ASSERT(ref);
    765e:	b961      	cbnz	r1, 767a <ticker_cb+0x32>
    7660:	4a15      	ldr	r2, [pc, #84]	; (76b8 <ticker_cb+0x70>)
    7662:	4916      	ldr	r1, [pc, #88]	; (76bc <ticker_cb+0x74>)
    7664:	4816      	ldr	r0, [pc, #88]	; (76c0 <ticker_cb+0x78>)
    7666:	f240 539d 	movw	r3, #1437	; 0x59d
    766a:	f007 ff2c 	bl	f4c6 <printk>
    766e:	4040      	eors	r0, r0
    7670:	f380 8811 	msr	BASEPRI, r0
    7674:	f04f 0003 	mov.w	r0, #3
    7678:	df02      	svc	2

	/* Append timing parameters */
	p.ticks_at_expire = ticks_at_expire;
    767a:	4912      	ldr	r1, [pc, #72]	; (76c4 <ticker_cb+0x7c>)
	p.remainder = remainder;
	p.lazy = lazy;
	p.force = force;
    767c:	f89d 3018 	ldrb.w	r3, [sp, #24]
    7680:	728b      	strb	r3, [r1, #10]
	p.param = lll;
	mfy.param = &p;
    7682:	4b11      	ldr	r3, [pc, #68]	; (76c8 <ticker_cb+0x80>)
	p.lazy = lazy;
    7684:	810d      	strh	r5, [r1, #8]

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    7686:	2200      	movs	r2, #0
	p.remainder = remainder;
    7688:	e9c1 7600 	strd	r7, r6, [r1]
	p.param = lll;
    768c:	60cc      	str	r4, [r1, #12]
	mfy.param = &p;
    768e:	6099      	str	r1, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    7690:	2001      	movs	r0, #1
    7692:	4611      	mov	r1, r2
    7694:	f7fc fc92 	bl	3fbc <mayfly_enqueue>
			     TICKER_USER_ID_LLL, 0, &mfy);
	LL_ASSERT(!ret);
    7698:	b160      	cbz	r0, 76b4 <ticker_cb+0x6c>
    769a:	4a07      	ldr	r2, [pc, #28]	; (76b8 <ticker_cb+0x70>)
    769c:	490b      	ldr	r1, [pc, #44]	; (76cc <ticker_cb+0x84>)
    769e:	4808      	ldr	r0, [pc, #32]	; (76c0 <ticker_cb+0x78>)
    76a0:	f240 53aa 	movw	r3, #1450	; 0x5aa
    76a4:	f007 ff0f 	bl	f4c6 <printk>
    76a8:	4040      	eors	r0, r0
    76aa:	f380 8811 	msr	BASEPRI, r0
    76ae:	f04f 0003 	mov.w	r0, #3
    76b2:	df02      	svc	2
		}
	}
#endif /* CONFIG_BT_CTLR_ADV_PERIODIC */

	DEBUG_RADIO_PREPARE_A(1);
}
    76b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    76b6:	bf00      	nop
    76b8:	00013825 	.word	0x00013825
    76bc:	000137cc 	.word	0x000137cc
    76c0:	000133b6 	.word	0x000133b6
    76c4:	20001f58 	.word	0x20001f58
    76c8:	200003d8 	.word	0x200003d8
    76cc:	0001366f 	.word	0x0001366f

000076d0 <ull_adv_aux_init>:
{
    76d0:	b510      	push	{r4, lr}
	err = lll_rand_get(&did_unique, sizeof(did_unique));
    76d2:	4807      	ldr	r0, [pc, #28]	; (76f0 <ull_adv_aux_init+0x20>)
    76d4:	2120      	movs	r1, #32
    76d6:	f00a f859 	bl	1178c <lll_rand_get>
	if (err) {
    76da:	4604      	mov	r4, r0
    76dc:	b928      	cbnz	r0, 76ea <ull_adv_aux_init+0x1a>
	mem_init(ll_adv_aux_pool, sizeof(struct ll_adv_aux_set),
    76de:	4b05      	ldr	r3, [pc, #20]	; (76f4 <ull_adv_aux_init+0x24>)
    76e0:	4805      	ldr	r0, [pc, #20]	; (76f8 <ull_adv_aux_init+0x28>)
    76e2:	2201      	movs	r2, #1
    76e4:	214c      	movs	r1, #76	; 0x4c
    76e6:	f008 ff73 	bl	105d0 <mem_init>
}
    76ea:	4620      	mov	r0, r4
    76ec:	bd10      	pop	{r4, pc}
    76ee:	bf00      	nop
    76f0:	200028e2 	.word	0x200028e2
    76f4:	20001ef8 	.word	0x20001ef8
    76f8:	20001f0c 	.word	0x20001f0c

000076fc <ull_adv_aux_reset_finalize>:
{
    76fc:	b508      	push	{r3, lr}
	mem_init(ll_adv_aux_pool, sizeof(struct ll_adv_aux_set),
    76fe:	4804      	ldr	r0, [pc, #16]	; (7710 <ull_adv_aux_reset_finalize+0x14>)
    7700:	4b04      	ldr	r3, [pc, #16]	; (7714 <ull_adv_aux_reset_finalize+0x18>)
    7702:	2201      	movs	r2, #1
    7704:	214c      	movs	r1, #76	; 0x4c
    7706:	f008 ff63 	bl	105d0 <mem_init>
}
    770a:	2000      	movs	r0, #0
    770c:	bd08      	pop	{r3, pc}
    770e:	bf00      	nop
    7710:	20001f0c 	.word	0x20001f0c
    7714:	20001ef8 	.word	0x20001ef8

00007718 <ull_adv_aux_did_next_unique_get>:
	return BIT_MASK(12) & did_unique[sid]++;
    7718:	4a04      	ldr	r2, [pc, #16]	; (772c <ull_adv_aux_did_next_unique_get+0x14>)
    771a:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
    771e:	1c59      	adds	r1, r3, #1
    7720:	f822 1010 	strh.w	r1, [r2, r0, lsl #1]
}
    7724:	f3c3 000b 	ubfx	r0, r3, #0, #12
    7728:	4770      	bx	lr
    772a:	bf00      	nop
    772c:	200028e2 	.word	0x200028e2

00007730 <ull_adv_aux_handle_get>:
{
    7730:	b508      	push	{r3, lr}
	return mem_index_get(aux, ll_adv_aux_pool,
    7732:	4903      	ldr	r1, [pc, #12]	; (7740 <ull_adv_aux_handle_get+0x10>)
    7734:	224c      	movs	r2, #76	; 0x4c
    7736:	f008 ffa1 	bl	1067c <mem_index_get>
}
    773a:	b2c0      	uxtb	r0, r0
    773c:	bd08      	pop	{r3, pc}
    773e:	bf00      	nop
    7740:	20001f0c 	.word	0x20001f0c

00007744 <ull_adv_aux_stop>:
{
    7744:	b510      	push	{r4, lr}
    7746:	4604      	mov	r4, r0
	aux_handle = ull_adv_aux_handle_get(aux);
    7748:	f7ff fff2 	bl	7730 <ull_adv_aux_handle_get>
	err = ull_ticker_stop_with_mark(TICKER_ID_ADV_AUX_BASE + aux_handle,
    774c:	3003      	adds	r0, #3
    774e:	f104 021c 	add.w	r2, r4, #28
    7752:	4621      	mov	r1, r4
    7754:	b2c0      	uxtb	r0, r0
    7756:	f7fe ff79 	bl	664c <ull_ticker_stop_with_mark>
	LL_ASSERT(err == 0 || err == -EALREADY);
    775a:	b180      	cbz	r0, 777e <ull_adv_aux_stop+0x3a>
    775c:	3078      	adds	r0, #120	; 0x78
    775e:	d00c      	beq.n	777a <ull_adv_aux_stop+0x36>
    7760:	4a0a      	ldr	r2, [pc, #40]	; (778c <ull_adv_aux_stop+0x48>)
    7762:	490b      	ldr	r1, [pc, #44]	; (7790 <ull_adv_aux_stop+0x4c>)
    7764:	480b      	ldr	r0, [pc, #44]	; (7794 <ull_adv_aux_stop+0x50>)
    7766:	f240 433c 	movw	r3, #1084	; 0x43c
    776a:	f007 feac 	bl	f4c6 <printk>
    776e:	4040      	eors	r0, r0
    7770:	f380 8811 	msr	BASEPRI, r0
    7774:	f04f 0003 	mov.w	r0, #3
    7778:	df02      	svc	2
		return BT_HCI_ERR_CMD_DISALLOWED;
    777a:	200c      	movs	r0, #12
}
    777c:	bd10      	pop	{r4, pc}
	aux->is_started = 0U;
    777e:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
    7782:	f360 0300 	bfi	r3, r0, #0, #1
    7786:	f884 304a 	strb.w	r3, [r4, #74]	; 0x4a
	return 0;
    778a:	e7f7      	b.n	777c <ull_adv_aux_stop+0x38>
    778c:	00013825 	.word	0x00013825
    7790:	00013868 	.word	0x00013868
    7794:	000133b6 	.word	0x000133b6

00007798 <ull_adv_aux_acquire>:
{
    7798:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    779a:	4605      	mov	r5, r0
	return mem_acquire(&adv_aux_free);
    779c:	481d      	ldr	r0, [pc, #116]	; (7814 <ull_adv_aux_acquire+0x7c>)
    779e:	f008 ff3f 	bl	10620 <mem_acquire>
	if (!aux) {
    77a2:	4604      	mov	r4, r0
    77a4:	b910      	cbnz	r0, 77ac <ull_adv_aux_acquire+0x14>
		return aux;
    77a6:	2400      	movs	r4, #0
}
    77a8:	4620      	mov	r0, r4
    77aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	lll_aux = &aux->lll;
    77ac:	f100 031c 	add.w	r3, r0, #28
	lll->aux = lll_aux;
    77b0:	626b      	str	r3, [r5, #36]	; 0x24
	lll_aux->adv = lll;
    77b2:	6205      	str	r5, [r0, #32]
	lll_adv_data_reset(&lll_aux->data);
    77b4:	f100 052c 	add.w	r5, r0, #44	; 0x2c
    77b8:	4628      	mov	r0, r5
    77ba:	f00a f85b 	bl	11874 <lll_adv_data_reset>
	err = lll_adv_data_init(&lll_aux->data);
    77be:	4628      	mov	r0, r5
    77c0:	f002 fa1e 	bl	9c00 <lll_adv_data_init>
	if (err) {
    77c4:	4606      	mov	r6, r0
    77c6:	2800      	cmp	r0, #0
    77c8:	d1ed      	bne.n	77a6 <ull_adv_aux_acquire+0xe>
	lll_csrand_get(&lll_aux->data_chan_counter,
    77ca:	2102      	movs	r1, #2
    77cc:	f104 0024 	add.w	r0, r4, #36	; 0x24
    77d0:	f001 ff1c 	bl	960c <lll_csrand_get>
	lll_csrand_get(&aux->data_chan_id, sizeof(aux->data_chan_id));
    77d4:	2102      	movs	r1, #2
    77d6:	f104 003a 	add.w	r0, r4, #58	; 0x3a
    77da:	f001 ff17 	bl	960c <lll_csrand_get>
	chm_last = aux->chm_first;
    77de:	f894 5048 	ldrb.w	r5, [r4, #72]	; 0x48
	aux->chm_last = chm_last;
    77e2:	f884 5049 	strb.w	r5, [r4, #73]	; 0x49
		ull_chan_map_get(aux->chm[chm_last].data_chan_map);
    77e6:	2706      	movs	r7, #6
    77e8:	fb07 4005 	mla	r0, r7, r5, r4
    77ec:	303c      	adds	r0, #60	; 0x3c
	aux->chm[chm_last].data_chan_count =
    77ee:	fb07 4505 	mla	r5, r7, r5, r4
		ull_chan_map_get(aux->chm[chm_last].data_chan_map);
    77f2:	f000 fd75 	bl	82e0 <ull_chan_map_get>
	aux->chm[chm_last].data_chan_count =
    77f6:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    77fa:	f360 0305 	bfi	r3, r0, #0, #6
    77fe:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
	aux->is_started = 0U;
    7802:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
    7806:	61e4      	str	r4, [r4, #28]
    7808:	f366 0300 	bfi	r3, r6, #0, #1
    780c:	f884 304a 	strb.w	r3, [r4, #74]	; 0x4a
	return aux;
    7810:	e7ca      	b.n	77a8 <ull_adv_aux_acquire+0x10>
    7812:	bf00      	nop
    7814:	20001ef8 	.word	0x20001ef8

00007818 <ll_adv_aux_sr_data_set>:
{
    7818:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    781c:	461d      	mov	r5, r3
    781e:	b085      	sub	sp, #20
	if ((op != BT_HCI_LE_EXT_ADV_OP_COMPLETE_DATA) &&
    7820:	1ecb      	subs	r3, r1, #3
    7822:	2b01      	cmp	r3, #1
{
    7824:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    7826:	460e      	mov	r6, r1
	if ((op != BT_HCI_LE_EXT_ADV_OP_COMPLETE_DATA) &&
    7828:	f200 8093 	bhi.w	7952 <ll_adv_aux_sr_data_set+0x13a>
	adv = ull_adv_is_created_get(handle);
    782c:	f7ff fefe 	bl	762c <ull_adv_is_created_get>
	if (!adv) {
    7830:	4604      	mov	r4, r0
    7832:	2800      	cmp	r0, #0
    7834:	f000 808f 	beq.w	7956 <ll_adv_aux_sr_data_set+0x13e>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    7838:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
    783c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	if (pri_pdu_prev->type != PDU_ADV_TYPE_EXT_IND) {
    7840:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7842:	781b      	ldrb	r3, [r3, #0]
    7844:	f003 030f 	and.w	r3, r3, #15
    7848:	2b07      	cmp	r3, #7
    784a:	d00e      	beq.n	786a <ll_adv_aux_sr_data_set+0x52>
		if ((op != BT_HCI_LE_EXT_ADV_OP_COMPLETE_DATA) ||
    784c:	2e03      	cmp	r6, #3
    784e:	d003      	beq.n	7858 <ll_adv_aux_sr_data_set+0x40>
			return BT_HCI_ERR_INVALID_PARAM;
    7850:	2012      	movs	r0, #18
}
    7852:	b005      	add	sp, #20
    7854:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if ((op != BT_HCI_LE_EXT_ADV_OP_COMPLETE_DATA) ||
    7858:	2d1f      	cmp	r5, #31
    785a:	d8f9      	bhi.n	7850 <ll_adv_aux_sr_data_set+0x38>
		return ull_scan_rsp_set(adv, len, data);
    785c:	463a      	mov	r2, r7
    785e:	4629      	mov	r1, r5
}
    7860:	b005      	add	sp, #20
    7862:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		return ull_scan_rsp_set(adv, len, data);
    7866:	f009 bd67 	b.w	11338 <ull_scan_rsp_set>
	LL_ASSERT(lll->aux);
    786a:	6c03      	ldr	r3, [r0, #64]	; 0x40
    786c:	b95b      	cbnz	r3, 7886 <ll_adv_aux_sr_data_set+0x6e>
    786e:	4a3d      	ldr	r2, [pc, #244]	; (7964 <ll_adv_aux_sr_data_set+0x14c>)
    7870:	493d      	ldr	r1, [pc, #244]	; (7968 <ll_adv_aux_sr_data_set+0x150>)
    7872:	483e      	ldr	r0, [pc, #248]	; (796c <ll_adv_aux_sr_data_set+0x154>)
    7874:	23e6      	movs	r3, #230	; 0xe6
    7876:	f007 fe26 	bl	f4c6 <printk>
    787a:	4040      	eors	r0, r0
    787c:	f380 8811 	msr	BASEPRI, r0
    7880:	f04f 0003 	mov.w	r0, #3
    7884:	df02      	svc	2
	aux_pdu = lll_adv_aux_data_peek(lll->aux);
    7886:	6c23      	ldr	r3, [r4, #64]	; 0x40
	return (void *)lll->data.pdu[lll->data.last];
    7888:	7c5a      	ldrb	r2, [r3, #17]
    788a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    788e:	f8d3 8014 	ldr.w	r8, [r3, #20]
	if (!(aux_pdu->adv_ext_ind.adv_mode & BT_HCI_LE_ADV_PROP_SCAN) && len) {
    7892:	f898 3002 	ldrb.w	r3, [r8, #2]
    7896:	f3c3 1381 	ubfx	r3, r3, #6, #2
    789a:	f013 0302 	ands.w	r3, r3, #2
    789e:	d104      	bne.n	78aa <ll_adv_aux_sr_data_set+0x92>
    78a0:	2d00      	cmp	r5, #0
    78a2:	d1d5      	bne.n	7850 <ll_adv_aux_sr_data_set+0x38>
	if ((op != BT_HCI_LE_EXT_ADV_OP_COMPLETE_DATA) && !len) {
    78a4:	2e03      	cmp	r6, #3
    78a6:	d004      	beq.n	78b2 <ll_adv_aux_sr_data_set+0x9a>
    78a8:	e7d2      	b.n	7850 <ll_adv_aux_sr_data_set+0x38>
    78aa:	2e03      	cmp	r6, #3
    78ac:	d001      	beq.n	78b2 <ll_adv_aux_sr_data_set+0x9a>
    78ae:	2d00      	cmp	r5, #0
    78b0:	d0ce      	beq.n	7850 <ll_adv_aux_sr_data_set+0x38>
	if (adv->is_enabled && (op != BT_HCI_LE_EXT_ADV_OP_COMPLETE_DATA)) {
    78b2:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
    78b6:	07d2      	lsls	r2, r2, #31
    78b8:	d504      	bpl.n	78c4 <ll_adv_aux_sr_data_set+0xac>
    78ba:	2e03      	cmp	r6, #3
    78bc:	d14d      	bne.n	795a <ll_adv_aux_sr_data_set+0x142>
	if (adv->is_enabled &&
    78be:	b10b      	cbz	r3, 78c4 <ll_adv_aux_sr_data_set+0xac>
	    (aux_pdu->adv_ext_ind.adv_mode & BT_HCI_LE_ADV_PROP_SCAN) && !len) {
    78c0:	2d00      	cmp	r5, #0
    78c2:	d04a      	beq.n	795a <ll_adv_aux_sr_data_set+0x142>
	return lll_adv_pdu_alloc(&lll->scan_rsp, idx);
    78c4:	f10d 010f 	add.w	r1, sp, #15
    78c8:	f104 0030 	add.w	r0, r4, #48	; 0x30
    78cc:	f009 ffd8 	bl	11880 <lll_adv_pdu_alloc>
	sr_pdu->tx_addr = aux_pdu->tx_addr;
    78d0:	f898 3000 	ldrb.w	r3, [r8]
    78d4:	f3c3 1380 	ubfx	r3, r3, #6, #1
	sr_pdu->type = PDU_ADV_TYPE_AUX_SCAN_RSP;
    78d8:	019b      	lsls	r3, r3, #6
    78da:	f043 0307 	orr.w	r3, r3, #7
    78de:	7003      	strb	r3, [r0, #0]
	sr_pdu->len = 0;
    78e0:	2300      	movs	r3, #0
    78e2:	4606      	mov	r6, r0
    78e4:	7043      	strb	r3, [r0, #1]
	if (!len) {
    78e6:	b1fd      	cbz	r5, 7928 <ll_adv_aux_sr_data_set+0x110>
	*sr_dptr = 0;
    78e8:	2301      	movs	r3, #1
    78ea:	70c3      	strb	r3, [r0, #3]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    78ec:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
    78f0:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	(void)memcpy(sr_dptr, &sr_prev->adv_ext_ind.ext_hdr.data[ADVA_OFFSET],
    78f4:	2206      	movs	r2, #6
    78f6:	6b59      	ldr	r1, [r3, #52]	; 0x34
    78f8:	3004      	adds	r0, #4
    78fa:	3104      	adds	r1, #4
    78fc:	f008 f953 	bl	fba6 <memcpy>
	if ((PDU_AC_EXT_HEADER_SIZE_MIN + ext_hdr_len + len) >
    7900:	f105 0308 	add.w	r3, r5, #8
    7904:	2b5f      	cmp	r3, #95	; 0x5f
	sr_hdr = (void *)&sr_com_hdr->ext_hdr_adv_data[0];
    7906:	f106 0902 	add.w	r9, r6, #2
    790a:	f106 080a 	add.w	r8, r6, #10
	if ((PDU_AC_EXT_HEADER_SIZE_MIN + ext_hdr_len + len) >
    790e:	d826      	bhi.n	795e <ll_adv_aux_sr_data_set+0x146>
	(void)memcpy(sr_dptr, data, len);
    7910:	4640      	mov	r0, r8
    7912:	462a      	mov	r2, r5
    7914:	4639      	mov	r1, r7
	sr_dptr += len;
    7916:	44a8      	add	r8, r5
	(void)memcpy(sr_dptr, data, len);
    7918:	f008 f945 	bl	fba6 <memcpy>
	sr_pdu->len = sr_dptr - &sr_pdu->payload[0];
    791c:	eba8 0809 	sub.w	r8, r8, r9
	sr_com_hdr->ext_hdr_len = ext_hdr_len;
    7920:	2307      	movs	r3, #7
    7922:	70b3      	strb	r3, [r6, #2]
	sr_pdu->len = sr_dptr - &sr_pdu->payload[0];
    7924:	f886 8001 	strb.w	r8, [r6, #1]
	err = ull_adv_aux_hdr_set_clear(adv, 0, 0, NULL, sr_adi, &pri_idx);
    7928:	f10d 030e 	add.w	r3, sp, #14
    792c:	9301      	str	r3, [sp, #4]
    792e:	2300      	movs	r3, #0
    7930:	9300      	str	r3, [sp, #0]
    7932:	461a      	mov	r2, r3
    7934:	4619      	mov	r1, r3
    7936:	4620      	mov	r0, r4
    7938:	f7f9 f886 	bl	a48 <ull_adv_aux_hdr_set_clear>
	if (err) {
    793c:	2800      	cmp	r0, #0
    793e:	d188      	bne.n	7852 <ll_adv_aux_sr_data_set+0x3a>
	pdu->last = idx;
    7940:	f89d 300e 	ldrb.w	r3, [sp, #14]
    7944:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
    7948:	f89d 300f 	ldrb.w	r3, [sp, #15]
    794c:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
	return 0;
    7950:	e77f      	b.n	7852 <ll_adv_aux_sr_data_set+0x3a>
		return BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL;
    7952:	2011      	movs	r0, #17
    7954:	e77d      	b.n	7852 <ll_adv_aux_sr_data_set+0x3a>
		return BT_HCI_ERR_UNKNOWN_ADV_IDENTIFIER;
    7956:	2042      	movs	r0, #66	; 0x42
    7958:	e77b      	b.n	7852 <ll_adv_aux_sr_data_set+0x3a>
		return BT_HCI_ERR_CMD_DISALLOWED;
    795a:	200c      	movs	r0, #12
    795c:	e779      	b.n	7852 <ll_adv_aux_sr_data_set+0x3a>
		return BT_HCI_ERR_PACKET_TOO_LONG;
    795e:	2045      	movs	r0, #69	; 0x45
    7960:	e777      	b.n	7852 <ll_adv_aux_sr_data_set+0x3a>
    7962:	bf00      	nop
    7964:	00013825 	.word	0x00013825
    7968:	000138cd 	.word	0x000138cd
    796c:	000133b6 	.word	0x000133b6

00007970 <ull_adv_aux_release>:
{
    7970:	b510      	push	{r4, lr}
    7972:	4604      	mov	r4, r0
	lll_adv_data_release(&aux->lll.data);
    7974:	302c      	adds	r0, #44	; 0x2c
    7976:	f002 f96f 	bl	9c58 <lll_adv_data_release>
	mem_release(aux, &adv_aux_free);
    797a:	4620      	mov	r0, r4
    797c:	4902      	ldr	r1, [pc, #8]	; (7988 <ull_adv_aux_release+0x18>)
}
    797e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	mem_release(aux, &adv_aux_free);
    7982:	f008 be66 	b.w	10652 <mem_release>
    7986:	bf00      	nop
    7988:	20001ef8 	.word	0x20001ef8

0000798c <ull_adv_aux_offset_get>:
{
    798c:	b508      	push	{r3, lr}
	mfy.param = adv;
    798e:	4b0b      	ldr	r3, [pc, #44]	; (79bc <ull_adv_aux_offset_get+0x30>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1,
    7990:	2201      	movs	r2, #1
	mfy.param = adv;
    7992:	6098      	str	r0, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1,
    7994:	2102      	movs	r1, #2
    7996:	4610      	mov	r0, r2
    7998:	f7fc fb10 	bl	3fbc <mayfly_enqueue>
	LL_ASSERT(!ret);
    799c:	b160      	cbz	r0, 79b8 <ull_adv_aux_offset_get+0x2c>
    799e:	4a08      	ldr	r2, [pc, #32]	; (79c0 <ull_adv_aux_offset_get+0x34>)
    79a0:	4908      	ldr	r1, [pc, #32]	; (79c4 <ull_adv_aux_offset_get+0x38>)
    79a2:	4809      	ldr	r0, [pc, #36]	; (79c8 <ull_adv_aux_offset_get+0x3c>)
    79a4:	f240 4384 	movw	r3, #1156	; 0x484
    79a8:	f007 fd8d 	bl	f4c6 <printk>
    79ac:	4040      	eors	r0, r0
    79ae:	f380 8811 	msr	BASEPRI, r0
    79b2:	f04f 0003 	mov.w	r0, #3
    79b6:	df02      	svc	2
}
    79b8:	bd08      	pop	{r3, pc}
    79ba:	bf00      	nop
    79bc:	200003c8 	.word	0x200003c8
    79c0:	00013825 	.word	0x00013825
    79c4:	0001366f 	.word	0x0001366f
    79c8:	000133b6 	.word	0x000133b6

000079cc <mfy_aux_offset_get>:
{
    79cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	lll_aux = adv->lll.aux;
    79d0:	6c07      	ldr	r7, [r0, #64]	; 0x40
		LL_ASSERT(success);
    79d2:	f8df 8138 	ldr.w	r8, [pc, #312]	; 7b0c <mfy_aux_offset_get+0x140>
	aux = HDR_LLL2ULL(lll_aux);
    79d6:	683c      	ldr	r4, [r7, #0]
		LL_ASSERT(success);
    79d8:	f8df a134 	ldr.w	sl, [pc, #308]	; 7b10 <mfy_aux_offset_get+0x144>
{
    79dc:	b089      	sub	sp, #36	; 0x24
    79de:	4605      	mov	r5, r0
	ticker_id = TICKER_ID_ADV_AUX_BASE + ull_adv_aux_handle_get(aux);
    79e0:	4620      	mov	r0, r4
    79e2:	f7ff fea5 	bl	7730 <ull_adv_aux_handle_get>
	id = TICKER_NULL;
    79e6:	23ff      	movs	r3, #255	; 0xff
    79e8:	f88d 3013 	strb.w	r3, [sp, #19]
	ticks_to_expire = 0U;
    79ec:	2300      	movs	r3, #0
	ticks_current = 0U;
    79ee:	e9cd 3305 	strd	r3, r3, [sp, #20]
	ticker_id = TICKER_ID_ADV_AUX_BASE + ull_adv_aux_handle_get(aux);
    79f2:	3003      	adds	r0, #3
    79f4:	fa5f f980 	uxtb.w	r9, r0
	retry = 4U;
    79f8:	2604      	movs	r6, #4
		ret = ticker_next_slot_get(TICKER_INSTANCE_ID_CTLR,
    79fa:	ab07      	add	r3, sp, #28
    79fc:	9302      	str	r3, [sp, #8]
    79fe:	4b45      	ldr	r3, [pc, #276]	; (7b14 <mfy_aux_offset_get+0x148>)
    7a00:	9301      	str	r3, [sp, #4]
    7a02:	ab05      	add	r3, sp, #20
		ret_cb = TICKER_STATUS_BUSY;
    7a04:	2102      	movs	r1, #2
		ret = ticker_next_slot_get(TICKER_INSTANCE_ID_CTLR,
    7a06:	9300      	str	r3, [sp, #0]
    7a08:	f10d 0213 	add.w	r2, sp, #19
    7a0c:	ab06      	add	r3, sp, #24
    7a0e:	2000      	movs	r0, #0
		ticks_previous = ticks_current;
    7a10:	f8dd b018 	ldr.w	fp, [sp, #24]
		ret_cb = TICKER_STATUS_BUSY;
    7a14:	9107      	str	r1, [sp, #28]
		ret = ticker_next_slot_get(TICKER_INSTANCE_ID_CTLR,
    7a16:	f7fd f901 	bl	4c1c <ticker_next_slot_get>
		if (ret == TICKER_STATUS_BUSY) {
    7a1a:	2802      	cmp	r0, #2
    7a1c:	d062      	beq.n	7ae4 <mfy_aux_offset_get+0x118>
		success = (ret_cb == TICKER_STATUS_SUCCESS);
    7a1e:	9b07      	ldr	r3, [sp, #28]
		LL_ASSERT(success);
    7a20:	b163      	cbz	r3, 7a3c <mfy_aux_offset_get+0x70>
    7a22:	483d      	ldr	r0, [pc, #244]	; (7b18 <mfy_aux_offset_get+0x14c>)
    7a24:	f240 5365 	movw	r3, #1381	; 0x565
    7a28:	4642      	mov	r2, r8
    7a2a:	4651      	mov	r1, sl
    7a2c:	f007 fd4b 	bl	f4c6 <printk>
    7a30:	4040      	eors	r0, r0
    7a32:	f380 8811 	msr	BASEPRI, r0
    7a36:	f04f 0003 	mov.w	r0, #3
    7a3a:	df02      	svc	2
		LL_ASSERT((ticks_current == ticks_previous) || retry--);
    7a3c:	9b06      	ldr	r3, [sp, #24]
    7a3e:	455b      	cmp	r3, fp
    7a40:	d003      	beq.n	7a4a <mfy_aux_offset_get+0x7e>
    7a42:	2e00      	cmp	r6, #0
    7a44:	d052      	beq.n	7aec <mfy_aux_offset_get+0x120>
    7a46:	3e01      	subs	r6, #1
    7a48:	b2f6      	uxtb	r6, r6
		LL_ASSERT(id != TICKER_NULL);
    7a4a:	f89d 3013 	ldrb.w	r3, [sp, #19]
    7a4e:	2bff      	cmp	r3, #255	; 0xff
    7a50:	d10c      	bne.n	7a6c <mfy_aux_offset_get+0xa0>
    7a52:	4932      	ldr	r1, [pc, #200]	; (7b1c <mfy_aux_offset_get+0x150>)
    7a54:	4830      	ldr	r0, [pc, #192]	; (7b18 <mfy_aux_offset_get+0x14c>)
    7a56:	f240 5369 	movw	r3, #1385	; 0x569
    7a5a:	4642      	mov	r2, r8
    7a5c:	f007 fd33 	bl	f4c6 <printk>
    7a60:	4040      	eors	r0, r0
    7a62:	f380 8811 	msr	BASEPRI, r0
    7a66:	f04f 0003 	mov.w	r0, #3
    7a6a:	df02      	svc	2
	} while (id != ticker_id);
    7a6c:	f89d 3013 	ldrb.w	r3, [sp, #19]
    7a70:	454b      	cmp	r3, r9
    7a72:	d1c2      	bne.n	79fa <mfy_aux_offset_get+0x2e>
	lll_aux->ticks_offset = ticks_to_expire;
    7a74:	9905      	ldr	r1, [sp, #20]
	lll_aux->ticks_offset +=
    7a76:	1c4b      	adds	r3, r1, #1
    7a78:	60fb      	str	r3, [r7, #12]
	first = pdu->first;
    7a7a:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
	if (first != pdu->last) {
    7a7e:	f895 0025 	ldrb.w	r0, [r5, #37]	; 0x25
    7a82:	4282      	cmp	r2, r0
	first = pdu->first;
    7a84:	b2d3      	uxtb	r3, r2
	if (first != pdu->last) {
    7a86:	d004      	beq.n	7a92 <mfy_aux_offset_get+0xc6>
		first += 1U;
    7a88:	1c58      	adds	r0, r3, #1
    7a8a:	b2c0      	uxtb	r0, r0
			first = 0U;
    7a8c:	2802      	cmp	r0, #2
    7a8e:	bf08      	it	eq
    7a90:	2000      	moveq	r0, #0
	return (void *)pdu->pdu[first];
    7a92:	eb05 0580 	add.w	r5, r5, r0, lsl #2
	aux_ptr = ull_adv_aux_lll_offset_fill(pdu, ticks_to_expire, 0);
    7a96:	2200      	movs	r2, #0
    7a98:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    7a9a:	f7f9 fab5 	bl	1008 <ull_adv_aux_lll_offset_fill>
	if (aux->chm_first != aux->chm_last) {
    7a9e:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
    7aa2:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
    7aa6:	429a      	cmp	r2, r3
		aux->chm_first = aux->chm_last;
    7aa8:	bf18      	it	ne
    7aaa:	f884 3048 	strbne.w	r3, [r4, #72]	; 0x48
	data_chan_map = aux->chm[aux->chm_first].data_chan_map;
    7aae:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
	data_chan_count = aux->chm[aux->chm_first].data_chan_count;
    7ab2:	2106      	movs	r1, #6
    7ab4:	fb01 4302 	mla	r3, r1, r2, r4
	data_chan_map = aux->chm[aux->chm_first].data_chan_map;
    7ab8:	fb01 4202 	mla	r2, r1, r2, r4
	data_chan_count = aux->chm[aux->chm_first].data_chan_count;
    7abc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
	aux_ptr->chan_idx = lll_chan_sel_2(lll_aux->data_chan_counter,
    7ac0:	8f61      	ldrh	r1, [r4, #58]	; 0x3a
	aux_ptr = ull_adv_aux_lll_offset_fill(pdu, ticks_to_expire, 0);
    7ac2:	4605      	mov	r5, r0
	aux_ptr->chan_idx = lll_chan_sel_2(lll_aux->data_chan_counter,
    7ac4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    7ac8:	8938      	ldrh	r0, [r7, #8]
    7aca:	323c      	adds	r2, #60	; 0x3c
    7acc:	f000 fc14 	bl	82f8 <lll_chan_sel_2>
    7ad0:	782b      	ldrb	r3, [r5, #0]
    7ad2:	f360 0305 	bfi	r3, r0, #0, #6
    7ad6:	702b      	strb	r3, [r5, #0]
}
    7ad8:	b009      	add	sp, #36	; 0x24
    7ada:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				ticker_job_sched(TICKER_INSTANCE_ID_CTLR,
    7ade:	2000      	movs	r0, #0
    7ae0:	f7fd f8da 	bl	4c98 <ticker_job_sched>
			while (ret_cb == TICKER_STATUS_BUSY) {
    7ae4:	9907      	ldr	r1, [sp, #28]
    7ae6:	2902      	cmp	r1, #2
    7ae8:	d0f9      	beq.n	7ade <mfy_aux_offset_get+0x112>
    7aea:	e798      	b.n	7a1e <mfy_aux_offset_get+0x52>
		LL_ASSERT((ticks_current == ticks_previous) || retry--);
    7aec:	490c      	ldr	r1, [pc, #48]	; (7b20 <mfy_aux_offset_get+0x154>)
    7aee:	480a      	ldr	r0, [pc, #40]	; (7b18 <mfy_aux_offset_get+0x14c>)
    7af0:	f240 5367 	movw	r3, #1383	; 0x567
    7af4:	4642      	mov	r2, r8
    7af6:	f007 fce6 	bl	f4c6 <printk>
    7afa:	4040      	eors	r0, r0
    7afc:	f380 8811 	msr	BASEPRI, r0
    7b00:	f04f 0003 	mov.w	r0, #3
    7b04:	df02      	svc	2
    7b06:	26ff      	movs	r6, #255	; 0xff
    7b08:	e79f      	b.n	7a4a <mfy_aux_offset_get+0x7e>
    7b0a:	bf00      	nop
    7b0c:	00013825 	.word	0x00013825
    7b10:	000138d6 	.word	0x000138d6
    7b14:	00011421 	.word	0x00011421
    7b18:	000133b6 	.word	0x000133b6
    7b1c:	0001390b 	.word	0x0001390b
    7b20:	000138de 	.word	0x000138de

00007b24 <ticker_cb>:
}

static void ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
		      uint32_t remainder, uint16_t lazy, uint8_t force,
		      void *param)
{
    7b24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7b28:	b088      	sub	sp, #32
    7b2a:	461c      	mov	r4, r3
    7b2c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
	uint8_t ref;

	DEBUG_RADIO_PREPARE_O(1);

	scan = param;
	lll = &scan->lll;
    7b2e:	462e      	mov	r6, r5
{
    7b30:	4680      	mov	r8, r0
    7b32:	f816 3b1c 	ldrb.w	r3, [r6], #28
    7b36:	3301      	adds	r3, #1
    7b38:	b2db      	uxtb	r3, r3
    7b3a:	4617      	mov	r7, r2
    7b3c:	702b      	strb	r3, [r5, #0]

	/* Increment prepare reference count */
	ref = ull_ref_inc(&scan->ull);
	LL_ASSERT(ref);
    7b3e:	b963      	cbnz	r3, 7b5a <ticker_cb+0x36>
    7b40:	4a55      	ldr	r2, [pc, #340]	; (7c98 <ticker_cb+0x174>)
    7b42:	4956      	ldr	r1, [pc, #344]	; (7c9c <ticker_cb+0x178>)
    7b44:	4856      	ldr	r0, [pc, #344]	; (7ca0 <ticker_cb+0x17c>)
    7b46:	f44f 732a 	mov.w	r3, #680	; 0x2a8
    7b4a:	f007 fcbc 	bl	f4c6 <printk>
    7b4e:	4040      	eors	r0, r0
    7b50:	f380 8811 	msr	BASEPRI, r0
    7b54:	f04f 0003 	mov.w	r0, #3
    7b58:	df02      	svc	2

	/* Append timing parameters */
	p.ticks_at_expire = ticks_at_expire;
    7b5a:	4952      	ldr	r1, [pc, #328]	; (7ca4 <ticker_cb+0x180>)
	p.remainder = remainder;
	p.lazy = lazy;
	p.param = lll;
	p.force = force;
    7b5c:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    7b60:	728b      	strb	r3, [r1, #10]
	mfy.param = &p;
    7b62:	4b51      	ldr	r3, [pc, #324]	; (7ca8 <ticker_cb+0x184>)
	p.lazy = lazy;
    7b64:	810c      	strh	r4, [r1, #8]

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
    7b66:	2200      	movs	r2, #0
	p.remainder = remainder;
    7b68:	e9c1 8700 	strd	r8, r7, [r1]
	p.param = lll;
    7b6c:	60ce      	str	r6, [r1, #12]
	mfy.param = &p;
    7b6e:	6099      	str	r1, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
    7b70:	2001      	movs	r0, #1
    7b72:	4611      	mov	r1, r2
    7b74:	f7fc fa22 	bl	3fbc <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
    7b78:	b160      	cbz	r0, 7b94 <ticker_cb+0x70>
    7b7a:	4a47      	ldr	r2, [pc, #284]	; (7c98 <ticker_cb+0x174>)
    7b7c:	494b      	ldr	r1, [pc, #300]	; (7cac <ticker_cb+0x188>)
    7b7e:	4848      	ldr	r0, [pc, #288]	; (7ca0 <ticker_cb+0x17c>)
    7b80:	f240 23b5 	movw	r3, #693	; 0x2b5
    7b84:	f007 fc9f 	bl	f4c6 <printk>
    7b88:	4040      	eors	r0, r0
    7b8a:	f380 8811 	msr	BASEPRI, r0
    7b8e:	f04f 0003 	mov.w	r0, #3
    7b92:	df02      	svc	2

#if defined(CONFIG_BT_CTLR_ADV_EXT)
	if (lll->duration_expire) {
    7b94:	8caa      	ldrh	r2, [r5, #36]	; 0x24
    7b96:	2a00      	cmp	r2, #0
    7b98:	d044      	beq.n	7c24 <ticker_cb+0x100>
		uint16_t elapsed;

		elapsed = lazy + 1;
    7b9a:	1c63      	adds	r3, r4, #1
    7b9c:	b219      	sxth	r1, r3
    7b9e:	b29b      	uxth	r3, r3
		if (lll->duration_expire > elapsed) {
    7ba0:	429a      	cmp	r2, r3
    7ba2:	d904      	bls.n	7bae <ticker_cb+0x8a>
			lll->duration_expire -= elapsed;
    7ba4:	1ad2      	subs	r2, r2, r3
    7ba6:	84aa      	strh	r2, [r5, #36]	; 0x24
			  (ret == TICKER_STATUS_BUSY));
	}
#endif /* CONFIG_BT_CTLR_ADV_EXT */

	DEBUG_RADIO_PREPARE_O(1);
}
    7ba8:	b008      	add	sp, #32
    7baa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (scan->duration_lazy) {
    7bae:	8fac      	ldrh	r4, [r5, #60]	; 0x3c
    7bb0:	2c00      	cmp	r4, #0
    7bb2:	d034      	beq.n	7c1e <ticker_cb+0xfa>
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    7bb4:	4e3e      	ldr	r6, [pc, #248]	; (7cb0 <ticker_cb+0x18c>)
				duration_lazy = lll->duration_expire +
    7bb6:	4414      	add	r4, r2
						scan->duration_lazy - elapsed;
    7bb8:	1a64      	subs	r4, r4, r1
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    7bba:	1bae      	subs	r6, r5, r6
    7bbc:	2248      	movs	r2, #72	; 0x48
    7bbe:	fbb6 f6f2 	udiv	r6, r6, r2
				LL_ASSERT(handle < BT_CTLR_SCAN_SET);
    7bc2:	b2f3      	uxtb	r3, r6
				duration_lazy = lll->duration_expire +
    7bc4:	b2a4      	uxth	r4, r4
				LL_ASSERT(handle < BT_CTLR_SCAN_SET);
    7bc6:	b163      	cbz	r3, 7be2 <ticker_cb+0xbe>
    7bc8:	4a33      	ldr	r2, [pc, #204]	; (7c98 <ticker_cb+0x174>)
    7bca:	493a      	ldr	r1, [pc, #232]	; (7cb4 <ticker_cb+0x190>)
    7bcc:	4834      	ldr	r0, [pc, #208]	; (7ca0 <ticker_cb+0x17c>)
    7bce:	f240 23c7 	movw	r3, #711	; 0x2c7
    7bd2:	f007 fc78 	bl	f4c6 <printk>
    7bd6:	4040      	eors	r0, r0
    7bd8:	f380 8811 	msr	BASEPRI, r0
    7bdc:	f04f 0003 	mov.w	r0, #3
    7be0:	df02      	svc	2
				ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    7be2:	2300      	movs	r3, #0
						    (TICKER_ID_SCAN_BASE +
    7be4:	1d72      	adds	r2, r6, #5
				ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    7be6:	e9cd 3305 	strd	r3, r3, [sp, #20]
    7bea:	e9cd 4303 	strd	r4, r3, [sp, #12]
    7bee:	e9cd 3301 	strd	r3, r3, [sp, #4]
    7bf2:	9300      	str	r3, [sp, #0]
    7bf4:	4618      	mov	r0, r3
    7bf6:	b2d2      	uxtb	r2, r2
    7bf8:	2101      	movs	r1, #1
    7bfa:	f009 f811 	bl	10c20 <ticker_update>
				LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    7bfe:	f030 0302 	bics.w	r3, r0, #2
    7c02:	d00c      	beq.n	7c1e <ticker_cb+0xfa>
    7c04:	4a24      	ldr	r2, [pc, #144]	; (7c98 <ticker_cb+0x174>)
    7c06:	492c      	ldr	r1, [pc, #176]	; (7cb8 <ticker_cb+0x194>)
    7c08:	4825      	ldr	r0, [pc, #148]	; (7ca0 <ticker_cb+0x17c>)
    7c0a:	f240 23cf 	movw	r3, #719	; 0x2cf
    7c0e:	f007 fc5a 	bl	f4c6 <printk>
    7c12:	4040      	eors	r0, r0
    7c14:	f380 8811 	msr	BASEPRI, r0
    7c18:	f04f 0003 	mov.w	r0, #3
    7c1c:	df02      	svc	2
			lll->duration_expire = 0U;
    7c1e:	2300      	movs	r3, #0
    7c20:	84ab      	strh	r3, [r5, #36]	; 0x24
    7c22:	e7c1      	b.n	7ba8 <ticker_cb+0x84>
	} else if (lll->duration_reload && lazy) {
    7c24:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
    7c26:	2b00      	cmp	r3, #0
    7c28:	d0be      	beq.n	7ba8 <ticker_cb+0x84>
    7c2a:	2c00      	cmp	r4, #0
    7c2c:	d0bc      	beq.n	7ba8 <ticker_cb+0x84>
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    7c2e:	4c20      	ldr	r4, [pc, #128]	; (7cb0 <ticker_cb+0x18c>)
    7c30:	2248      	movs	r2, #72	; 0x48
    7c32:	1b2c      	subs	r4, r5, r4
    7c34:	fbb4 f4f2 	udiv	r4, r4, r2
		LL_ASSERT(handle < BT_CTLR_SCAN_SET);
    7c38:	b2e3      	uxtb	r3, r4
    7c3a:	b163      	cbz	r3, 7c56 <ticker_cb+0x132>
    7c3c:	4a16      	ldr	r2, [pc, #88]	; (7c98 <ticker_cb+0x174>)
    7c3e:	491d      	ldr	r1, [pc, #116]	; (7cb4 <ticker_cb+0x190>)
    7c40:	4817      	ldr	r0, [pc, #92]	; (7ca0 <ticker_cb+0x17c>)
    7c42:	f240 23d9 	movw	r3, #729	; 0x2d9
    7c46:	f007 fc3e 	bl	f4c6 <printk>
    7c4a:	4040      	eors	r0, r0
    7c4c:	f380 8811 	msr	BASEPRI, r0
    7c50:	f04f 0003 	mov.w	r0, #3
    7c54:	df02      	svc	2
		lll->duration_expire = lll->duration_reload;
    7c56:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
    7c58:	84ab      	strh	r3, [r5, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    7c5a:	2101      	movs	r1, #1
    7c5c:	2300      	movs	r3, #0
				    (TICKER_ID_SCAN_BASE + handle),
    7c5e:	1d62      	adds	r2, r4, #5
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    7c60:	e9cd 3305 	strd	r3, r3, [sp, #20]
    7c64:	e9cd 3301 	strd	r3, r3, [sp, #4]
    7c68:	9300      	str	r3, [sp, #0]
    7c6a:	4618      	mov	r0, r3
    7c6c:	e9cd 1103 	strd	r1, r1, [sp, #12]
    7c70:	b2d2      	uxtb	r2, r2
    7c72:	f008 ffd5 	bl	10c20 <ticker_update>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    7c76:	f030 0302 	bics.w	r3, r0, #2
    7c7a:	d095      	beq.n	7ba8 <ticker_cb+0x84>
    7c7c:	4a06      	ldr	r2, [pc, #24]	; (7c98 <ticker_cb+0x174>)
    7c7e:	490e      	ldr	r1, [pc, #56]	; (7cb8 <ticker_cb+0x194>)
    7c80:	4807      	ldr	r0, [pc, #28]	; (7ca0 <ticker_cb+0x17c>)
    7c82:	f44f 7338 	mov.w	r3, #736	; 0x2e0
    7c86:	f007 fc1e 	bl	f4c6 <printk>
    7c8a:	4040      	eors	r0, r0
    7c8c:	f380 8811 	msr	BASEPRI, r0
    7c90:	f04f 0003 	mov.w	r0, #3
    7c94:	df02      	svc	2
}
    7c96:	e787      	b.n	7ba8 <ticker_cb+0x84>
    7c98:	0001392d 	.word	0x0001392d
    7c9c:	000137cc 	.word	0x000137cc
    7ca0:	000133b6 	.word	0x000133b6
    7ca4:	20001fc8 	.word	0x20001fc8
    7ca8:	20000408 	.word	0x20000408
    7cac:	0001366f 	.word	0x0001366f
    7cb0:	20001f80 	.word	0x20001f80
    7cb4:	0001381a 	.word	0x0001381a
    7cb8:	000137b3 	.word	0x000137b3

00007cbc <ticker_stop_ext_op_cb>:

	return 0;
}

static void ticker_stop_ext_op_cb(uint32_t status, void *param)
{
    7cbc:	b508      	push	{r3, lr}
	static memq_link_t link;
	static struct mayfly mfy = {0, 0, &link, NULL, ext_disable};
	uint32_t ret;

	/* Ignore if race between thread and ULL */
	if (status != TICKER_STATUS_SUCCESS) {
    7cbe:	4602      	mov	r2, r0
    7cc0:	b998      	cbnz	r0, 7cea <ticker_stop_ext_op_cb+0x2e>

		return;
	}

	/* Check if any pending LLL events that need to be aborted */
	mfy.param = param;
    7cc2:	4b0a      	ldr	r3, [pc, #40]	; (7cec <ticker_stop_ext_op_cb+0x30>)
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
    7cc4:	2002      	movs	r0, #2
	mfy.param = param;
    7cc6:	6099      	str	r1, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
    7cc8:	2101      	movs	r1, #1
    7cca:	f7fc f977 	bl	3fbc <mayfly_enqueue>
			     TICKER_USER_ID_ULL_HIGH, 0, &mfy);
	LL_ASSERT(!ret);
    7cce:	b160      	cbz	r0, 7cea <ticker_stop_ext_op_cb+0x2e>
    7cd0:	4a07      	ldr	r2, [pc, #28]	; (7cf0 <ticker_stop_ext_op_cb+0x34>)
    7cd2:	4908      	ldr	r1, [pc, #32]	; (7cf4 <ticker_stop_ext_op_cb+0x38>)
    7cd4:	4808      	ldr	r0, [pc, #32]	; (7cf8 <ticker_stop_ext_op_cb+0x3c>)
    7cd6:	f240 335e 	movw	r3, #862	; 0x35e
    7cda:	f007 fbf4 	bl	f4c6 <printk>
    7cde:	4040      	eors	r0, r0
    7ce0:	f380 8811 	msr	BASEPRI, r0
    7ce4:	f04f 0003 	mov.w	r0, #3
    7ce8:	df02      	svc	2
}
    7cea:	bd08      	pop	{r3, pc}
    7cec:	200003f8 	.word	0x200003f8
    7cf0:	0001392d 	.word	0x0001392d
    7cf4:	0001366f 	.word	0x0001366f
    7cf8:	000133b6 	.word	0x000133b6

00007cfc <ext_disable>:

static void ext_disable(void *param)
{
    7cfc:	b538      	push	{r3, r4, r5, lr}
    7cfe:	4604      	mov	r4, r0
	return hdr->ref;
    7d00:	f810 3b1c 	ldrb.w	r3, [r0], #28
	struct ull_hdr *hdr;

	/* Check ref count to determine if any pending LLL events in pipeline */
	scan = param;
	hdr = &scan->ull;
	if (ull_ref_get(hdr)) {
    7d04:	b34b      	cbz	r3, 7d5a <ext_disable+0x5e>
		static memq_link_t link;
		static struct mayfly mfy = {0, 0, &link, NULL, lll_disable};
		uint32_t ret;

		mfy.param = &scan->lll;
    7d06:	4d17      	ldr	r5, [pc, #92]	; (7d64 <ext_disable+0x68>)

		/* Setup disabled callback to be called when ref count
		 * returns to zero.
		 */
		LL_ASSERT(!hdr->disabled_cb);
    7d08:	6963      	ldr	r3, [r4, #20]
		mfy.param = &scan->lll;
    7d0a:	60a8      	str	r0, [r5, #8]
		LL_ASSERT(!hdr->disabled_cb);
    7d0c:	b163      	cbz	r3, 7d28 <ext_disable+0x2c>
    7d0e:	4a16      	ldr	r2, [pc, #88]	; (7d68 <ext_disable+0x6c>)
    7d10:	4916      	ldr	r1, [pc, #88]	; (7d6c <ext_disable+0x70>)
    7d12:	4817      	ldr	r0, [pc, #92]	; (7d70 <ext_disable+0x74>)
    7d14:	f240 3373 	movw	r3, #883	; 0x373
    7d18:	f007 fbd5 	bl	f4c6 <printk>
    7d1c:	4040      	eors	r0, r0
    7d1e:	f380 8811 	msr	BASEPRI, r0
    7d22:	f04f 0003 	mov.w	r0, #3
    7d26:	df02      	svc	2
		hdr->disabled_param = mfy.param;
    7d28:	68ab      	ldr	r3, [r5, #8]
    7d2a:	61a3      	str	r3, [r4, #24]
		hdr->disabled_cb = ext_disabled_cb;

		/* Trigger LLL disable */
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    7d2c:	2200      	movs	r2, #0
		hdr->disabled_cb = ext_disabled_cb;
    7d2e:	4b11      	ldr	r3, [pc, #68]	; (7d74 <ext_disable+0x78>)
    7d30:	6163      	str	r3, [r4, #20]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    7d32:	4611      	mov	r1, r2
    7d34:	4b0b      	ldr	r3, [pc, #44]	; (7d64 <ext_disable+0x68>)
    7d36:	2001      	movs	r0, #1
    7d38:	f7fc f940 	bl	3fbc <mayfly_enqueue>
				     TICKER_USER_ID_LLL, 0, &mfy);
		LL_ASSERT(!ret);
    7d3c:	b160      	cbz	r0, 7d58 <ext_disable+0x5c>
    7d3e:	4a0a      	ldr	r2, [pc, #40]	; (7d68 <ext_disable+0x6c>)
    7d40:	490d      	ldr	r1, [pc, #52]	; (7d78 <ext_disable+0x7c>)
    7d42:	480b      	ldr	r0, [pc, #44]	; (7d70 <ext_disable+0x74>)
    7d44:	f240 337a 	movw	r3, #890	; 0x37a
    7d48:	f007 fbbd 	bl	f4c6 <printk>
    7d4c:	4040      	eors	r0, r0
    7d4e:	f380 8811 	msr	BASEPRI, r0
    7d52:	f04f 0003 	mov.w	r0, #3
    7d56:	df02      	svc	2
	} else {
		/* No pending LLL events */
		ext_disabled_cb(&scan->lll);
	}
}
    7d58:	bd38      	pop	{r3, r4, r5, pc}
    7d5a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		ext_disabled_cb(&scan->lll);
    7d5e:	f009 bc43 	b.w	115e8 <ext_disabled_cb>
    7d62:	bf00      	nop
    7d64:	200003e8 	.word	0x200003e8
    7d68:	0001392d 	.word	0x0001392d
    7d6c:	000137a1 	.word	0x000137a1
    7d70:	000133b6 	.word	0x000133b6
    7d74:	000115e9 	.word	0x000115e9
    7d78:	0001366f 	.word	0x0001366f

00007d7c <ull_scan_disable>:
	err = ull_ticker_stop_with_mark(TICKER_ID_SCAN_BASE + handle,
    7d7c:	3005      	adds	r0, #5
{
    7d7e:	b508      	push	{r3, lr}
	err = ull_ticker_stop_with_mark(TICKER_ID_SCAN_BASE + handle,
    7d80:	f101 021c 	add.w	r2, r1, #28
    7d84:	b2c0      	uxtb	r0, r0
    7d86:	f7fe fc61 	bl	664c <ull_ticker_stop_with_mark>
	LL_ASSERT(err == 0 || err == -EALREADY);
    7d8a:	b178      	cbz	r0, 7dac <ull_scan_disable+0x30>
    7d8c:	3078      	adds	r0, #120	; 0x78
    7d8e:	d00c      	beq.n	7daa <ull_scan_disable+0x2e>
    7d90:	4a07      	ldr	r2, [pc, #28]	; (7db0 <ull_scan_disable+0x34>)
    7d92:	4908      	ldr	r1, [pc, #32]	; (7db4 <ull_scan_disable+0x38>)
    7d94:	4808      	ldr	r0, [pc, #32]	; (7db8 <ull_scan_disable+0x3c>)
    7d96:	f44f 73e9 	mov.w	r3, #466	; 0x1d2
    7d9a:	f007 fb94 	bl	f4c6 <printk>
    7d9e:	4040      	eors	r0, r0
    7da0:	f380 8811 	msr	BASEPRI, r0
    7da4:	f04f 0003 	mov.w	r0, #3
    7da8:	df02      	svc	2
		return BT_HCI_ERR_CMD_DISALLOWED;
    7daa:	200c      	movs	r0, #12
}
    7dac:	bd08      	pop	{r3, pc}
    7dae:	bf00      	nop
    7db0:	0001392d 	.word	0x0001392d
    7db4:	00013868 	.word	0x00013868
    7db8:	000133b6 	.word	0x000133b6

00007dbc <ull_scan_done>:
{
    7dbc:	b573      	push	{r0, r1, r4, r5, r6, lr}
	scan = CONTAINER_OF(done->param, struct ll_scan_set, ull);
    7dbe:	69c5      	ldr	r5, [r0, #28]
	if (likely(scan->duration_lazy || !lll->duration_reload ||
    7dc0:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
    7dc2:	2b00      	cmp	r3, #0
    7dc4:	d137      	bne.n	7e36 <ull_scan_done+0x7a>
    7dc6:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
    7dc8:	2b00      	cmp	r3, #0
    7dca:	d034      	beq.n	7e36 <ull_scan_done+0x7a>
    7dcc:	8cab      	ldrh	r3, [r5, #36]	; 0x24
    7dce:	2b00      	cmp	r3, #0
    7dd0:	d131      	bne.n	7e36 <ull_scan_done+0x7a>
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    7dd2:	4c1a      	ldr	r4, [pc, #104]	; (7e3c <ull_scan_done+0x80>)
	lll->duration_reload = 0U;
    7dd4:	846b      	strh	r3, [r5, #34]	; 0x22
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    7dd6:	1b2c      	subs	r4, r5, r4
    7dd8:	2248      	movs	r2, #72	; 0x48
    7dda:	fbb4 f4f2 	udiv	r4, r4, r2
	LL_ASSERT(handle < BT_CTLR_SCAN_SET);
    7dde:	f014 06ff 	ands.w	r6, r4, #255	; 0xff
    7de2:	d00c      	beq.n	7dfe <ull_scan_done+0x42>
    7de4:	4a16      	ldr	r2, [pc, #88]	; (7e40 <ull_scan_done+0x84>)
    7de6:	4917      	ldr	r1, [pc, #92]	; (7e44 <ull_scan_done+0x88>)
    7de8:	4817      	ldr	r0, [pc, #92]	; (7e48 <ull_scan_done+0x8c>)
    7dea:	f44f 73f8 	mov.w	r3, #496	; 0x1f0
    7dee:	f007 fb6a 	bl	f4c6 <printk>
    7df2:	4040      	eors	r0, r0
    7df4:	f380 8811 	msr	BASEPRI, r0
    7df8:	f04f 0003 	mov.w	r0, #3
    7dfc:	df02      	svc	2
	rx_hdr = (void *)scan->node_rx_scan_term;
    7dfe:	6c2b      	ldr	r3, [r5, #64]	; 0x40
	rx_hdr->type = NODE_RX_TYPE_EXT_SCAN_TERMINATE;
    7e00:	220b      	movs	r2, #11
    7e02:	711a      	strb	r2, [r3, #4]
			  (TICKER_ID_SCAN_BASE + handle), ticker_stop_ext_op_cb,
    7e04:	1d62      	adds	r2, r4, #5
	rx_hdr->handle = handle;
    7e06:	80de      	strh	r6, [r3, #6]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
    7e08:	b2d2      	uxtb	r2, r2
    7e0a:	4b10      	ldr	r3, [pc, #64]	; (7e4c <ull_scan_done+0x90>)
    7e0c:	9500      	str	r5, [sp, #0]
    7e0e:	2101      	movs	r1, #1
    7e10:	2000      	movs	r0, #0
    7e12:	f7fc fec9 	bl	4ba8 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    7e16:	f030 0302 	bics.w	r3, r0, #2
    7e1a:	d00c      	beq.n	7e36 <ull_scan_done+0x7a>
    7e1c:	4a08      	ldr	r2, [pc, #32]	; (7e40 <ull_scan_done+0x84>)
    7e1e:	490c      	ldr	r1, [pc, #48]	; (7e50 <ull_scan_done+0x94>)
    7e20:	4809      	ldr	r0, [pc, #36]	; (7e48 <ull_scan_done+0x8c>)
    7e22:	f44f 7302 	mov.w	r3, #520	; 0x208
    7e26:	f007 fb4e 	bl	f4c6 <printk>
    7e2a:	4040      	eors	r0, r0
    7e2c:	f380 8811 	msr	BASEPRI, r0
    7e30:	f04f 0003 	mov.w	r0, #3
    7e34:	df02      	svc	2
}
    7e36:	b002      	add	sp, #8
    7e38:	bd70      	pop	{r4, r5, r6, pc}
    7e3a:	bf00      	nop
    7e3c:	20001f80 	.word	0x20001f80
    7e40:	0001392d 	.word	0x0001392d
    7e44:	0001381a 	.word	0x0001381a
    7e48:	000133b6 	.word	0x000133b6
    7e4c:	00007cbd 	.word	0x00007cbd
    7e50:	000137b3 	.word	0x000137b3

00007e54 <ull_scan_term_dequeue>:
{
    7e54:	b508      	push	{r3, lr}
	if (handle >= BT_CTLR_SCAN_SET) {
    7e56:	b1a0      	cbz	r0, 7e82 <ull_scan_term_dequeue+0x2e>
	LL_ASSERT(scan);
    7e58:	4a0e      	ldr	r2, [pc, #56]	; (7e94 <ull_scan_term_dequeue+0x40>)
    7e5a:	490f      	ldr	r1, [pc, #60]	; (7e98 <ull_scan_term_dequeue+0x44>)
    7e5c:	480f      	ldr	r0, [pc, #60]	; (7e9c <ull_scan_term_dequeue+0x48>)
    7e5e:	f240 2311 	movw	r3, #529	; 0x211
    7e62:	f007 fb30 	bl	f4c6 <printk>
    7e66:	4040      	eors	r0, r0
    7e68:	f380 8811 	msr	BASEPRI, r0
    7e6c:	f04f 0003 	mov.w	r0, #3
    7e70:	df02      	svc	2
	scan->is_enabled = 0U;
    7e72:	2200      	movs	r2, #0
    7e74:	f892 3044 	ldrb.w	r3, [r2, #68]	; 0x44
    7e78:	f362 0300 	bfi	r3, r2, #0, #1
    7e7c:	f882 3044 	strb.w	r3, [r2, #68]	; 0x44
    7e80:	deff      	udf	#255	; 0xff
    7e82:	4b07      	ldr	r3, [pc, #28]	; (7ea0 <ull_scan_term_dequeue+0x4c>)
    7e84:	f893 2044 	ldrb.w	r2, [r3, #68]	; 0x44
    7e88:	f360 0200 	bfi	r2, r0, #0, #1
    7e8c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
}
    7e90:	bd08      	pop	{r3, pc}
    7e92:	bf00      	nop
    7e94:	0001392d 	.word	0x0001392d
    7e98:	0001396d 	.word	0x0001396d
    7e9c:	000133b6 	.word	0x000133b6
    7ea0:	20001f80 	.word	0x20001f80

00007ea4 <ull_scan_handle_get>:
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    7ea4:	4b03      	ldr	r3, [pc, #12]	; (7eb4 <ull_scan_handle_get+0x10>)
    7ea6:	1ac0      	subs	r0, r0, r3
    7ea8:	2348      	movs	r3, #72	; 0x48
    7eaa:	fbb0 f0f3 	udiv	r0, r0, r3
}
    7eae:	b2c0      	uxtb	r0, r0
    7eb0:	4770      	bx	lr
    7eb2:	bf00      	nop
    7eb4:	20001f80 	.word	0x20001f80

00007eb8 <ull_scan_lll_handle_get>:
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    7eb8:	6800      	ldr	r0, [r0, #0]
    7eba:	4b03      	ldr	r3, [pc, #12]	; (7ec8 <ull_scan_lll_handle_get+0x10>)
    7ebc:	1ac0      	subs	r0, r0, r3
    7ebe:	2348      	movs	r3, #72	; 0x48
    7ec0:	fbb0 f0f3 	udiv	r0, r0, r3
}
    7ec4:	b2c0      	uxtb	r0, r0
    7ec6:	4770      	bx	lr
    7ec8:	20001f80 	.word	0x20001f80

00007ecc <ull_scan_is_valid_get>:
}
    7ecc:	4b02      	ldr	r3, [pc, #8]	; (7ed8 <ull_scan_is_valid_get+0xc>)
    7ece:	4283      	cmp	r3, r0
    7ed0:	bf18      	it	ne
    7ed2:	2000      	movne	r0, #0
    7ed4:	4770      	bx	lr
    7ed6:	bf00      	nop
    7ed8:	20001f80 	.word	0x20001f80

00007edc <ull_scan_is_enabled_get>:
	if (handle >= BT_CTLR_SCAN_SET) {
    7edc:	b938      	cbnz	r0, 7eee <ull_scan_is_enabled_get+0x12>
	if (!scan || !scan->is_enabled) {
    7ede:	4805      	ldr	r0, [pc, #20]	; (7ef4 <ull_scan_is_enabled_get+0x18>)
    7ee0:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
	return &ll_scan[handle];
    7ee4:	f013 0f01 	tst.w	r3, #1
    7ee8:	bf08      	it	eq
    7eea:	2000      	moveq	r0, #0
    7eec:	4770      	bx	lr
		return NULL;
    7eee:	2000      	movs	r0, #0
}
    7ef0:	4770      	bx	lr
    7ef2:	bf00      	nop
    7ef4:	20001f80 	.word	0x20001f80

00007ef8 <ull_scan_is_disabled_get>:
	if (!scan || scan->is_enabled) {
    7ef8:	4a04      	ldr	r2, [pc, #16]	; (7f0c <ull_scan_is_disabled_get+0x14>)
    7efa:	f892 3044 	ldrb.w	r3, [r2, #68]	; 0x44
    7efe:	f003 0301 	and.w	r3, r3, #1
		return NULL;
    7f02:	4303      	orrs	r3, r0
}
    7f04:	bf0c      	ite	eq
    7f06:	4610      	moveq	r0, r2
    7f08:	2000      	movne	r0, #0
    7f0a:	4770      	bx	lr
    7f0c:	20001f80 	.word	0x20001f80

00007f10 <ll_scan_enable>:
{
    7f10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7f14:	460e      	mov	r6, r1
    7f16:	b08a      	sub	sp, #40	; 0x28
    7f18:	4617      	mov	r7, r2
	if (!enable) {
    7f1a:	b920      	cbnz	r0, 7f26 <ll_scan_enable+0x16>
}
    7f1c:	b00a      	add	sp, #40	; 0x28
    7f1e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		err = disable(SCAN_HANDLE_1M);
    7f22:	f009 bb6f 	b.w	11604 <disable.constprop.0>
	scan = ull_scan_is_disabled_get(SCAN_HANDLE_1M);
    7f26:	2000      	movs	r0, #0
    7f28:	f7ff ffe6 	bl	7ef8 <ull_scan_is_disabled_get>
	if (!scan) {
    7f2c:	4604      	mov	r4, r0
    7f2e:	b960      	cbnz	r0, 7f4a <ll_scan_enable+0x3a>
	return duration && period && (*scan)->lll.duration_reload &&
    7f30:	b139      	cbz	r1, 7f42 <ll_scan_enable+0x32>
    7f32:	b137      	cbz	r7, 7f42 <ll_scan_enable+0x32>
    7f34:	4c4c      	ldr	r4, [pc, #304]	; (8068 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x68>)
    7f36:	8c63      	ldrh	r3, [r4, #34]	; 0x22
    7f38:	b11b      	cbz	r3, 7f42 <ll_scan_enable+0x32>
    7f3a:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
	*node_rx_scan_term = (void *)(*scan)->node_rx_scan_term;
    7f3c:	f8d4 8040 	ldr.w	r8, [r4, #64]	; 0x40
	return duration && period && (*scan)->lll.duration_reload &&
    7f40:	b97b      	cbnz	r3, 7f62 <ll_scan_enable+0x52>
			return BT_HCI_ERR_CMD_DISALLOWED;
    7f42:	200c      	movs	r0, #12
}
    7f44:	b00a      	add	sp, #40	; 0x28
    7f46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	struct node_rx_pdu *node_rx_scan_term = NULL;
    7f4a:	f04f 0800 	mov.w	r8, #0
	uint8_t is_update_1m = 0U;
    7f4e:	4645      	mov	r5, r8
	    (!is_coded_phy && (scan->own_addr_type & 0x1))) {
    7f50:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    7f54:	079a      	lsls	r2, r3, #30
    7f56:	d406      	bmi.n	7f66 <ll_scan_enable+0x56>
	if (duration) {
    7f58:	b97e      	cbnz	r6, 7f7a <ll_scan_enable+0x6a>
		lll->duration_reload = 0U;
    7f5a:	8466      	strh	r6, [r4, #34]	; 0x22
		scan->duration_lazy = 0U;
    7f5c:	87a6      	strh	r6, [r4, #60]	; 0x3c
		scan->node_rx_scan_term = NULL;
    7f5e:	6426      	str	r6, [r4, #64]	; 0x40
		if (err) {
    7f60:	e023      	b.n	7faa <ll_scan_enable+0x9a>
    7f62:	2501      	movs	r5, #1
    7f64:	e7f4      	b.n	7f50 <ll_scan_enable+0x40>
		if (!mem_nz(ll_addr_get(BT_ADDR_LE_RANDOM), BDADDR_SIZE)) {
    7f66:	2001      	movs	r0, #1
    7f68:	f7fc fecc 	bl	4d04 <ll_addr_get>
    7f6c:	2106      	movs	r1, #6
    7f6e:	f008 fb99 	bl	106a4 <mem_nz>
    7f72:	2800      	cmp	r0, #0
    7f74:	d1f0      	bne.n	7f58 <ll_scan_enable+0x48>
			return BT_HCI_ERR_INVALID_PARAM;
    7f76:	2012      	movs	r0, #18
    7f78:	e7e4      	b.n	7f44 <ll_scan_enable+0x34>
			ULL_SCAN_DURATION_TO_EVENTS(duration,
    7f7a:	f242 7310 	movw	r3, #10000	; 0x2710
    7f7e:	4373      	muls	r3, r6
    7f80:	8ea0      	ldrh	r0, [r4, #52]	; 0x34
    7f82:	f240 2671 	movw	r6, #625	; 0x271
    7f86:	fbb3 f3f6 	udiv	r3, r3, r6
    7f8a:	fbb3 f3f0 	udiv	r3, r3, r0
		lll->duration_reload =
    7f8e:	b29b      	uxth	r3, r3
    7f90:	8463      	strh	r3, [r4, #34]	; 0x22
		if (period) {
    7f92:	2f00      	cmp	r7, #0
    7f94:	d04a      	beq.n	802c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x2c>
				ULL_SCAN_PERIOD_TO_EVENTS(period,
    7f96:	4a35      	ldr	r2, [pc, #212]	; (806c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x6c>)
    7f98:	437a      	muls	r2, r7
    7f9a:	fbb2 f2f6 	udiv	r2, r2, r6
    7f9e:	fbb2 f2f0 	udiv	r2, r2, r0
			scan->duration_lazy -= lll->duration_reload;
    7fa2:	1ad3      	subs	r3, r2, r3
    7fa4:	87a3      	strh	r3, [r4, #60]	; 0x3c
			scan->node_rx_scan_term = NULL;
    7fa6:	2300      	movs	r3, #0
    7fa8:	6423      	str	r3, [r4, #64]	; 0x40
	ull_filter_scan_update(lll->filter_policy);
    7faa:	f894 0020 	ldrb.w	r0, [r4, #32]
		own_addr_type = scan->own_addr_type;
    7fae:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
	ull_filter_scan_update(lll->filter_policy);
    7fb2:	f3c0 00c1 	ubfx	r0, r0, #3, #2
    7fb6:	f000 fc09 	bl	87cc <ull_filter_scan_update>
	lll->rpa_gen = 0;
    7fba:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    7fbc:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    7fc0:	f063 03ff 	orn	r3, r3, #255	; 0xff
    7fc4:	85a3      	strh	r3, [r4, #44]	; 0x2c
	if ((lll->type & 0x1) &&
    7fc6:	f894 3020 	ldrb.w	r3, [r4, #32]
    7fca:	069b      	lsls	r3, r3, #26
		own_addr_type = scan->own_addr_type;
    7fcc:	f3c6 0641 	ubfx	r6, r6, #1, #2
	if ((lll->type & 0x1) &&
    7fd0:	d50b      	bpl.n	7fea <ll_scan_enable+0xda>
    7fd2:	3e02      	subs	r6, #2
    7fd4:	2e01      	cmp	r6, #1
    7fd6:	d808      	bhi.n	7fea <ll_scan_enable+0xda>
		ull_filter_rpa_update(false);
    7fd8:	2000      	movs	r0, #0
    7fda:	f000 fc19 	bl	8810 <ull_filter_rpa_update>
		lll->rpa_gen = 1;
    7fde:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    7fe2:	f043 0301 	orr.w	r3, r3, #1
    7fe6:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	if (is_update) {
    7fea:	2d00      	cmp	r5, #0
    7fec:	d034      	beq.n	8058 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x58>
		ret_cb = TICKER_STATUS_BUSY;
    7fee:	2202      	movs	r2, #2
    7ff0:	9209      	str	r2, [sp, #36]	; 0x24
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    7ff2:	4a1d      	ldr	r2, [pc, #116]	; (8068 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x68>)
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    7ff4:	491e      	ldr	r1, [pc, #120]	; (8070 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x70>)
		scan->lll.duration_expire = 0U;
    7ff6:	2300      	movs	r3, #0
    7ff8:	84a3      	strh	r3, [r4, #36]	; 0x24
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    7ffa:	1aa2      	subs	r2, r4, r2
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    7ffc:	9105      	str	r1, [sp, #20]
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    7ffe:	2448      	movs	r4, #72	; 0x48
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    8000:	2101      	movs	r1, #1
	return ((uint8_t *)scan - (uint8_t *)ll_scan) / sizeof(*scan);
    8002:	fbb2 f2f4 	udiv	r2, r2, r4
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    8006:	ac09      	add	r4, sp, #36	; 0x24
				    (TICKER_ID_SCAN_BASE +
    8008:	3205      	adds	r2, #5
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
    800a:	e9cd 1103 	strd	r1, r1, [sp, #12]
    800e:	e9cd 3301 	strd	r3, r3, [sp, #4]
    8012:	2103      	movs	r1, #3
    8014:	9406      	str	r4, [sp, #24]
    8016:	9300      	str	r3, [sp, #0]
    8018:	b2d2      	uxtb	r2, r2
    801a:	4618      	mov	r0, r3
    801c:	f008 fe00 	bl	10c20 <ticker_update>
		ret = ull_ticker_status_take(ret, &ret_cb);
    8020:	4621      	mov	r1, r4
    8022:	f7fe fa93 	bl	654c <ull_ticker_status_take>
		if (ret != TICKER_STATUS_SUCCESS) {
    8026:	2800      	cmp	r0, #0
    8028:	d08c      	beq.n	7f44 <ll_scan_enable+0x34>
    802a:	e78a      	b.n	7f42 <ll_scan_enable+0x32>
			scan->duration_lazy = 0U;
    802c:	87a7      	strh	r7, [r4, #60]	; 0x3c
			if (*node_rx_scan_term) {
    802e:	f1b8 0f00 	cmp.w	r8, #0
    8032:	d002      	beq.n	803a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3a>
				scan->node_rx_scan_term =
    8034:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
		if (err) {
    8038:	e7b7      	b.n	7faa <ll_scan_enable+0x9a>
			link_scan_term = ll_rx_link_alloc();
    803a:	f7fe f9f7 	bl	642c <ll_rx_link_alloc>
			if (!link_scan_term) {
    803e:	4606      	mov	r6, r0
    8040:	b128      	cbz	r0, 804e <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x4e>
			node_rx = ll_rx_alloc();
    8042:	f7fe f9ff 	bl	6444 <ll_rx_alloc>
			if (!node_rx) {
    8046:	b920      	cbnz	r0, 8052 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x52>
				ll_rx_link_release(link_scan_term);
    8048:	4630      	mov	r0, r6
    804a:	f7fe f9f5 	bl	6438 <ll_rx_link_release>
				return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
    804e:	2007      	movs	r0, #7
    8050:	e778      	b.n	7f44 <ll_scan_enable+0x34>
			node_rx->hdr.link = (void *)link_scan_term;
    8052:	6006      	str	r6, [r0, #0]
			scan->node_rx_scan_term = (void *)node_rx;
    8054:	6420      	str	r0, [r4, #64]	; 0x40
		if (err) {
    8056:	e7a8      	b.n	7faa <ll_scan_enable+0x9a>
		scan->lll.duration_expire = scan->lll.duration_reload;
    8058:	8c63      	ldrh	r3, [r4, #34]	; 0x22
    805a:	84a3      	strh	r3, [r4, #36]	; 0x24
		err = ull_scan_enable(scan);
    805c:	4620      	mov	r0, r4
}
    805e:	b00a      	add	sp, #40	; 0x28
    8060:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		err = ull_scan_enable(scan);
    8064:	f7f9 b818 	b.w	1098 <ull_scan_enable>
    8068:	20001f80 	.word	0x20001f80
    806c:	00138800 	.word	0x00138800
    8070:	00006209 	.word	0x00006209

00008074 <ticker_cb>:
}

static void ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
		      uint32_t remainder, uint16_t lazy, uint8_t force,
		      void *param)
{
    8074:	b570      	push	{r4, r5, r6, lr}
    8076:	9c05      	ldr	r4, [sp, #20]
	return ++hdr->ref;
    8078:	7822      	ldrb	r2, [r4, #0]
    807a:	3201      	adds	r2, #1
    807c:	b2d2      	uxtb	r2, r2
    807e:	4606      	mov	r6, r0
    8080:	461d      	mov	r5, r3
    8082:	7022      	strb	r2, [r4, #0]

	DEBUG_RADIO_PREPARE_O(1);

	/* Increment prepare reference count */
	ref = ull_ref_inc(&aux->ull);
	LL_ASSERT(ref);
    8084:	b962      	cbnz	r2, 80a0 <ticker_cb+0x2c>
    8086:	4a16      	ldr	r2, [pc, #88]	; (80e0 <ticker_cb+0x6c>)
    8088:	4916      	ldr	r1, [pc, #88]	; (80e4 <ticker_cb+0x70>)
    808a:	4817      	ldr	r0, [pc, #92]	; (80e8 <ticker_cb+0x74>)
    808c:	f44f 7354 	mov.w	r3, #848	; 0x350
    8090:	f007 fa19 	bl	f4c6 <printk>
    8094:	4040      	eors	r0, r0
    8096:	f380 8811 	msr	BASEPRI, r0
    809a:	f04f 0003 	mov.w	r0, #3
    809e:	df02      	svc	2

	/* Append timing parameters */
	p.ticks_at_expire = ticks_at_expire;
    80a0:	4912      	ldr	r1, [pc, #72]	; (80ec <ticker_cb+0x78>)
	p.remainder = 0; /* FIXME: remainder; */
	p.lazy = lazy;
	p.force = force;
    80a2:	f89d 3010 	ldrb.w	r3, [sp, #16]
    80a6:	728b      	strb	r3, [r1, #10]
	p.param = &aux->lll;
	mfy.param = &p;
    80a8:	4b11      	ldr	r3, [pc, #68]	; (80f0 <ticker_cb+0x7c>)
	p.ticks_at_expire = ticks_at_expire;
    80aa:	600e      	str	r6, [r1, #0]
	p.remainder = 0; /* FIXME: remainder; */
    80ac:	2200      	movs	r2, #0
	p.param = &aux->lll;
    80ae:	341c      	adds	r4, #28
	p.remainder = 0; /* FIXME: remainder; */
    80b0:	604a      	str	r2, [r1, #4]
	p.lazy = lazy;
    80b2:	810d      	strh	r5, [r1, #8]
	p.param = &aux->lll;
    80b4:	60cc      	str	r4, [r1, #12]
	mfy.param = &p;
    80b6:	6099      	str	r1, [r3, #8]

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
    80b8:	2001      	movs	r0, #1
    80ba:	4611      	mov	r1, r2
    80bc:	f7fb ff7e 	bl	3fbc <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
    80c0:	b160      	cbz	r0, 80dc <ticker_cb+0x68>
    80c2:	4a07      	ldr	r2, [pc, #28]	; (80e0 <ticker_cb+0x6c>)
    80c4:	490b      	ldr	r1, [pc, #44]	; (80f4 <ticker_cb+0x80>)
    80c6:	4808      	ldr	r0, [pc, #32]	; (80e8 <ticker_cb+0x74>)
    80c8:	f240 335d 	movw	r3, #861	; 0x35d
    80cc:	f007 f9fb 	bl	f4c6 <printk>
    80d0:	4040      	eors	r0, r0
    80d2:	f380 8811 	msr	BASEPRI, r0
    80d6:	f04f 0003 	mov.w	r0, #3
    80da:	df02      	svc	2

	DEBUG_RADIO_PREPARE_O(1);
}
    80dc:	bd70      	pop	{r4, r5, r6, pc}
    80de:	bf00      	nop
    80e0:	00013972 	.word	0x00013972
    80e4:	000137cc 	.word	0x000137cc
    80e8:	000133b6 	.word	0x000133b6
    80ec:	2000201c 	.word	0x2000201c
    80f0:	20000418 	.word	0x20000418
    80f4:	0001366f 	.word	0x0001366f

000080f8 <flush>:
		lll = aux->parent;
    80f8:	e9d0 310a 	ldrd	r3, r1, [r0, #40]	; 0x28
{
    80fc:	b510      	push	{r4, lr}
    80fe:	4604      	mov	r4, r0
	if (rx) {
    8100:	b161      	cbz	r1, 811c <flush+0x24>
		lll->lll_aux = NULL;
    8102:	2200      	movs	r2, #0
		ll_rx_put(rx->link, rx);
    8104:	6808      	ldr	r0, [r1, #0]
		lll->lll_aux = NULL;
    8106:	60da      	str	r2, [r3, #12]
		ll_rx_put(rx->link, rx);
    8108:	f7fe f9a8 	bl	645c <ll_rx_put>
		ll_rx_sched();
    810c:	f7fe f9ac 	bl	6468 <ll_rx_sched>
	mem_release(aux, &scan_aux_free);
    8110:	4620      	mov	r0, r4
    8112:	4903      	ldr	r1, [pc, #12]	; (8120 <flush+0x28>)
}
    8114:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	mem_release(aux, &scan_aux_free);
    8118:	f008 ba9b 	b.w	10652 <mem_release>
		lll->lll_aux = NULL;
    811c:	63d9      	str	r1, [r3, #60]	; 0x3c
    811e:	e7f7      	b.n	8110 <flush+0x18>
    8120:	2000202c 	.word	0x2000202c

00008124 <ticker_op_cb>:

static void ticker_op_cb(uint32_t status, void *param)
{
    8124:	b508      	push	{r3, lr}
	static memq_link_t link;
	static struct mayfly mfy = {0, 0, &link, NULL, ticker_op_aux_failure};
	uint32_t ret;

	if (status == TICKER_STATUS_SUCCESS) {
    8126:	b1a0      	cbz	r0, 8152 <ticker_op_cb+0x2e>
		return;
	}

	mfy.param = param;
    8128:	4b0a      	ldr	r3, [pc, #40]	; (8154 <ticker_op_cb+0x30>)

	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_ULL_HIGH,
    812a:	2200      	movs	r2, #0
	mfy.param = param;
    812c:	6099      	str	r1, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_ULL_HIGH,
    812e:	2002      	movs	r0, #2
    8130:	2101      	movs	r1, #1
    8132:	f7fb ff43 	bl	3fbc <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
    8136:	b160      	cbz	r0, 8152 <ticker_op_cb+0x2e>
    8138:	4a07      	ldr	r2, [pc, #28]	; (8158 <ticker_op_cb+0x34>)
    813a:	4908      	ldr	r1, [pc, #32]	; (815c <ticker_op_cb+0x38>)
    813c:	4808      	ldr	r0, [pc, #32]	; (8160 <ticker_op_cb+0x3c>)
    813e:	f44f 735c 	mov.w	r3, #880	; 0x370
    8142:	f007 f9c0 	bl	f4c6 <printk>
    8146:	4040      	eors	r0, r0
    8148:	f380 8811 	msr	BASEPRI, r0
    814c:	f04f 0003 	mov.w	r0, #3
    8150:	df02      	svc	2
}
    8152:	bd08      	pop	{r3, pc}
    8154:	20000428 	.word	0x20000428
    8158:	00013972 	.word	0x00013972
    815c:	0001366f 	.word	0x0001366f
    8160:	000133b6 	.word	0x000133b6

00008164 <ull_scan_aux_init>:
{
    8164:	b508      	push	{r3, lr}
	mem_init(ll_scan_aux_pool, sizeof(struct ll_scan_aux_set),
    8166:	4804      	ldr	r0, [pc, #16]	; (8178 <ull_scan_aux_init+0x14>)
    8168:	4b04      	ldr	r3, [pc, #16]	; (817c <ull_scan_aux_init+0x18>)
    816a:	2201      	movs	r2, #1
    816c:	2134      	movs	r1, #52	; 0x34
    816e:	f008 fa2f 	bl	105d0 <mem_init>
}
    8172:	2000      	movs	r0, #0
    8174:	bd08      	pop	{r3, pc}
    8176:	bf00      	nop
    8178:	20001fe8 	.word	0x20001fe8
    817c:	2000202c 	.word	0x2000202c

00008180 <ull_scan_aux_done>:
{
    8180:	b510      	push	{r4, lr}
	aux = CONTAINER_OF(done->param, struct ll_scan_aux_set, ull);
    8182:	69c4      	ldr	r4, [r0, #28]
	LL_ASSERT(!hdr->disabled_cb);
    8184:	6963      	ldr	r3, [r4, #20]
    8186:	b163      	cbz	r3, 81a2 <ull_scan_aux_done+0x22>
    8188:	4a08      	ldr	r2, [pc, #32]	; (81ac <ull_scan_aux_done+0x2c>)
    818a:	4909      	ldr	r1, [pc, #36]	; (81b0 <ull_scan_aux_done+0x30>)
    818c:	4809      	ldr	r0, [pc, #36]	; (81b4 <ull_scan_aux_done+0x34>)
    818e:	f240 2379 	movw	r3, #633	; 0x279
    8192:	f007 f998 	bl	f4c6 <printk>
    8196:	4040      	eors	r0, r0
    8198:	f380 8811 	msr	BASEPRI, r0
    819c:	f04f 0003 	mov.w	r0, #3
    81a0:	df02      	svc	2
	hdr->disabled_cb = done_disabled_cb;
    81a2:	4b05      	ldr	r3, [pc, #20]	; (81b8 <ull_scan_aux_done+0x38>)
	hdr->disabled_param = aux;
    81a4:	61a4      	str	r4, [r4, #24]
	hdr->disabled_cb = done_disabled_cb;
    81a6:	6163      	str	r3, [r4, #20]
}
    81a8:	bd10      	pop	{r4, pc}
    81aa:	bf00      	nop
    81ac:	00013972 	.word	0x00013972
    81b0:	000137a1 	.word	0x000137a1
    81b4:	000133b6 	.word	0x000133b6
    81b8:	000081e1 	.word	0x000081e1

000081bc <ull_scan_aux_lll_handle_get>:
{
    81bc:	b508      	push	{r3, lr}
	return mem_index_get(aux, ll_scan_aux_pool,
    81be:	4903      	ldr	r1, [pc, #12]	; (81cc <ull_scan_aux_lll_handle_get+0x10>)
    81c0:	6800      	ldr	r0, [r0, #0]
    81c2:	2234      	movs	r2, #52	; 0x34
    81c4:	f008 fa5a 	bl	1067c <mem_index_get>
}
    81c8:	b2c0      	uxtb	r0, r0
    81ca:	bd08      	pop	{r3, pc}
    81cc:	20001fe8 	.word	0x20001fe8

000081d0 <ull_scan_aux_is_valid_get>:
}
    81d0:	4b02      	ldr	r3, [pc, #8]	; (81dc <ull_scan_aux_is_valid_get+0xc>)
    81d2:	4283      	cmp	r3, r0
    81d4:	bf18      	it	ne
    81d6:	2000      	movne	r0, #0
    81d8:	4770      	bx	lr
    81da:	bf00      	nop
    81dc:	20001fe8 	.word	0x20001fe8

000081e0 <done_disabled_cb>:
{
    81e0:	b510      	push	{r4, lr}
	LL_ASSERT(ull_scan_aux_is_valid_get(aux));
    81e2:	f7ff fff5 	bl	81d0 <ull_scan_aux_is_valid_get>
    81e6:	4604      	mov	r4, r0
    81e8:	b960      	cbnz	r0, 8204 <done_disabled_cb+0x24>
    81ea:	4a09      	ldr	r2, [pc, #36]	; (8210 <done_disabled_cb+0x30>)
    81ec:	4909      	ldr	r1, [pc, #36]	; (8214 <done_disabled_cb+0x34>)
    81ee:	480a      	ldr	r0, [pc, #40]	; (8218 <done_disabled_cb+0x38>)
    81f0:	f240 3319 	movw	r3, #793	; 0x319
    81f4:	f007 f967 	bl	f4c6 <printk>
    81f8:	4040      	eors	r0, r0
    81fa:	f380 8811 	msr	BASEPRI, r0
    81fe:	f04f 0003 	mov.w	r0, #3
    8202:	df02      	svc	2
	flush(aux);
    8204:	4620      	mov	r0, r4
}
    8206:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	flush(aux);
    820a:	f7ff bf75 	b.w	80f8 <flush>
    820e:	bf00      	nop
    8210:	00013972 	.word	0x00013972
    8214:	00013a30 	.word	0x00013a30
    8218:	000133b6 	.word	0x000133b6

0000821c <ull_scan_aux_release>:
	param_ull = HDR_LLL2ULL(rx->rx_ftr.param);
    821c:	688b      	ldr	r3, [r1, #8]
{
    821e:	b570      	push	{r4, r5, r6, lr}
	param_ull = HDR_LLL2ULL(rx->rx_ftr.param);
    8220:	681d      	ldr	r5, [r3, #0]
{
    8222:	4606      	mov	r6, r0
	if (ull_scan_is_valid_get(param_ull)) {
    8224:	4628      	mov	r0, r5
{
    8226:	460c      	mov	r4, r1
	if (ull_scan_is_valid_get(param_ull)) {
    8228:	f7ff fe50 	bl	7ecc <ull_scan_is_valid_get>
    822c:	b1d8      	cbz	r0, 8266 <ull_scan_aux_release+0x4a>
		rx->type = NODE_RX_TYPE_RELEASE;
    822e:	2301      	movs	r3, #1
    8230:	7123      	strb	r3, [r4, #4]
		lll_aux = lll->lll_aux;
    8232:	68a3      	ldr	r3, [r4, #8]
    8234:	68db      	ldr	r3, [r3, #12]
	if (lll_aux) {
    8236:	b35b      	cbz	r3, 8290 <ull_scan_aux_release+0x74>
		aux = HDR_LLL2ULL(lll_aux);
    8238:	681d      	ldr	r5, [r3, #0]
	return hdr->ref;
    823a:	782b      	ldrb	r3, [r5, #0]
		LL_ASSERT(ull_ref_get(hdr) < 2);
    823c:	2b01      	cmp	r3, #1
    823e:	d90c      	bls.n	825a <ull_scan_aux_release+0x3e>
    8240:	4a21      	ldr	r2, [pc, #132]	; (82c8 <ull_scan_aux_release+0xac>)
    8242:	4922      	ldr	r1, [pc, #136]	; (82cc <ull_scan_aux_release+0xb0>)
    8244:	4822      	ldr	r0, [pc, #136]	; (82d0 <ull_scan_aux_release+0xb4>)
    8246:	f240 23d1 	movw	r3, #721	; 0x2d1
    824a:	f007 f93c 	bl	f4c6 <printk>
    824e:	4040      	eors	r0, r0
    8250:	f380 8811 	msr	BASEPRI, r0
    8254:	f04f 0003 	mov.w	r0, #3
    8258:	df02      	svc	2
    825a:	782b      	ldrb	r3, [r5, #0]
		if (ull_ref_get(hdr) == 0) {
    825c:	bb03      	cbnz	r3, 82a0 <ull_scan_aux_release+0x84>
			flush(aux);
    825e:	4628      	mov	r0, r5
    8260:	f7ff ff4a 	bl	80f8 <flush>
    8264:	e014      	b.n	8290 <ull_scan_aux_release+0x74>
	} else if (ull_scan_aux_is_valid_get(param_ull)) {
    8266:	4628      	mov	r0, r5
    8268:	f7ff ffb2 	bl	81d0 <ull_scan_aux_is_valid_get>
    826c:	b118      	cbz	r0, 8276 <ull_scan_aux_release+0x5a>
		rx->type = NODE_RX_TYPE_RELEASE;
    826e:	2301      	movs	r3, #1
    8270:	7123      	strb	r3, [r4, #4]
		lll_aux = rx->rx_ftr.param;
    8272:	68a3      	ldr	r3, [r4, #8]
    8274:	e7df      	b.n	8236 <ull_scan_aux_release+0x1a>
		LL_ASSERT(0);
    8276:	4a14      	ldr	r2, [pc, #80]	; (82c8 <ull_scan_aux_release+0xac>)
    8278:	4916      	ldr	r1, [pc, #88]	; (82d4 <ull_scan_aux_release+0xb8>)
    827a:	4815      	ldr	r0, [pc, #84]	; (82d0 <ull_scan_aux_release+0xb4>)
    827c:	f240 23c6 	movw	r3, #710	; 0x2c6
    8280:	f007 f921 	bl	f4c6 <printk>
    8284:	4040      	eors	r0, r0
    8286:	f380 8811 	msr	BASEPRI, r0
    828a:	f04f 0003 	mov.w	r0, #3
    828e:	df02      	svc	2
	ll_rx_put(link, rx);
    8290:	4621      	mov	r1, r4
    8292:	4630      	mov	r0, r6
    8294:	f7fe f8e2 	bl	645c <ll_rx_put>
}
    8298:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ll_rx_sched();
    829c:	f7fe b8e4 	b.w	6468 <ll_rx_sched>
			LL_ASSERT(!hdr->disabled_cb);
    82a0:	696b      	ldr	r3, [r5, #20]
    82a2:	b163      	cbz	r3, 82be <ull_scan_aux_release+0xa2>
    82a4:	4a08      	ldr	r2, [pc, #32]	; (82c8 <ull_scan_aux_release+0xac>)
    82a6:	490c      	ldr	r1, [pc, #48]	; (82d8 <ull_scan_aux_release+0xbc>)
    82a8:	4809      	ldr	r0, [pc, #36]	; (82d0 <ull_scan_aux_release+0xb4>)
    82aa:	f240 23d7 	movw	r3, #727	; 0x2d7
    82ae:	f007 f90a 	bl	f4c6 <printk>
    82b2:	4040      	eors	r0, r0
    82b4:	f380 8811 	msr	BASEPRI, r0
    82b8:	f04f 0003 	mov.w	r0, #3
    82bc:	df02      	svc	2
			hdr->disabled_cb = last_disabled_cb;
    82be:	4b07      	ldr	r3, [pc, #28]	; (82dc <ull_scan_aux_release+0xc0>)
			hdr->disabled_param = aux;
    82c0:	61ad      	str	r5, [r5, #24]
			hdr->disabled_cb = last_disabled_cb;
    82c2:	616b      	str	r3, [r5, #20]
    82c4:	e7e4      	b.n	8290 <ull_scan_aux_release+0x74>
    82c6:	bf00      	nop
    82c8:	00013972 	.word	0x00013972
    82cc:	00013a1b 	.word	0x00013a1b
    82d0:	000133b6 	.word	0x000133b6
    82d4:	00014086 	.word	0x00014086
    82d8:	000137a1 	.word	0x000137a1
    82dc:	0001168d 	.word	0x0001168d

000082e0 <ull_chan_map_get>:

	return 0;
}

uint8_t ull_chan_map_get(uint8_t *const chan_map)
{
    82e0:	b508      	push	{r3, lr}
	(void)memcpy(chan_map, map, sizeof(map));
    82e2:	4903      	ldr	r1, [pc, #12]	; (82f0 <ull_chan_map_get+0x10>)
    82e4:	2205      	movs	r2, #5
    82e6:	f007 fc5e 	bl	fba6 <memcpy>

	return count;
}
    82ea:	4b02      	ldr	r3, [pc, #8]	; (82f4 <ull_chan_map_get+0x14>)
    82ec:	7818      	ldrb	r0, [r3, #0]
    82ee:	bd08      	pop	{r3, pc}
    82f0:	20000581 	.word	0x20000581
    82f4:	20000580 	.word	0x20000580

000082f8 <lll_chan_sel_2>:
 * Channel Selection algorithm #2, and Section 4.5.8.3.1 Overview
 * Below interface is used for ACL connections.
 */
uint8_t lll_chan_sel_2(uint16_t counter, uint16_t chan_id, uint8_t *chan_map,
		    uint8_t chan_count)
{
    82f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
/* Refer to Bluetooth Specification v5.2 Vol 6, Part B, Section 4.5.8.3.2
 * Inputs and basic components, for below operations
 */
static uint8_t chan_rev_8(uint8_t b)
{
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
    82fc:	4f2e      	ldr	r7, [pc, #184]	; (83b8 <lll_chan_sel_2+0xc0>)
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
    82fe:	4d2f      	ldr	r5, [pc, #188]	; (83bc <lll_chan_sel_2+0xc4>)
static uint16_t chan_prn_s(uint16_t counter, uint16_t chan_id)
{
	uint8_t iterate;
	uint16_t prn_s;

	prn_s = counter ^ chan_id;
    8300:	4048      	eors	r0, r1
    8302:	2403      	movs	r4, #3
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
    8304:	f640 0c02 	movw	ip, #2050	; 0x802
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
    8308:	f248 0620 	movw	r6, #32800	; 0x8020
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
    830c:	ea4f 2e10 	mov.w	lr, r0, lsr #8
    8310:	fb0c f80e 	mul.w	r8, ip, lr
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
    8314:	fb06 fe0e 	mul.w	lr, r6, lr
    8318:	ea0e 0e05 	and.w	lr, lr, r5
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
    831c:	ea08 0807 	and.w	r8, r8, r7
    8320:	ea48 080e 	orr.w	r8, r8, lr
    8324:	b2c0      	uxtb	r0, r0
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
    8326:	eb08 2e08 	add.w	lr, r8, r8, lsl #8
    832a:	eb08 280e 	add.w	r8, r8, lr, lsl #8
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
    832e:	fb0c fe00 	mul.w	lr, ip, r0
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
    8332:	4370      	muls	r0, r6
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
    8334:	ea0e 0e07 	and.w	lr, lr, r7
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
    8338:	4028      	ands	r0, r5
	b = (((uint32_t)b * 0x0802LU & 0x22110LU) |
    833a:	ea4e 0000 	orr.w	r0, lr, r0
	     ((uint32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
    833e:	eb00 2e00 	add.w	lr, r0, r0, lsl #8
    8342:	eb00 200e 	add.w	r0, r0, lr, lsl #8
    8346:	ea4f 4818 	mov.w	r8, r8, lsr #16
	return (chan_rev_8((i >> 8) & 0xFF) << 8) | chan_rev_8(i & 0xFF);
    834a:	f3c0 4007 	ubfx	r0, r0, #16, #8
    834e:	ea40 2008 	orr.w	r0, r0, r8, lsl #8
	return ((uint32_t)a * 17U + b) & 0xFFFF;
    8352:	eb00 1000 	add.w	r0, r0, r0, lsl #4

	for (iterate = 0U; iterate < 3; iterate++) {
    8356:	3c01      	subs	r4, #1
	return ((uint32_t)a * 17U + b) & 0xFFFF;
    8358:	4408      	add	r0, r1
	for (iterate = 0U; iterate < 3; iterate++) {
    835a:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
	return ((uint32_t)a * 17U + b) & 0xFFFF;
    835e:	b280      	uxth	r0, r0
	for (iterate = 0U; iterate < 3; iterate++) {
    8360:	d1d4      	bne.n	830c <lll_chan_sel_2+0x14>
static uint16_t chan_prn_e(uint16_t counter, uint16_t chan_id)
{
	uint16_t prn_e;

	prn_e = chan_prn_s(counter, chan_id);
	prn_e ^= chan_id;
    8362:	4041      	eors	r1, r0
	chan_next = prn_e % 37;
    8364:	2025      	movs	r0, #37	; 0x25
    8366:	fbb1 f5f0 	udiv	r5, r1, r0
    836a:	fb00 1515 	mls	r5, r0, r5, r1
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
    836e:	f3c5 06c4 	ubfx	r6, r5, #3, #5
	chan_next = prn_e % 37;
    8372:	b2e8      	uxtb	r0, r5
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
    8374:	5d96      	ldrb	r6, [r2, r6]
    8376:	f005 0507 	and.w	r5, r5, #7
    837a:	fa46 f505 	asr.w	r5, r6, r5
    837e:	07ef      	lsls	r7, r5, #31
    8380:	d407      	bmi.n	8392 <lll_chan_sel_2+0x9a>
		chan_index = ((uint32_t)chan_count * prn_e) >> 16;
    8382:	434b      	muls	r3, r1
    8384:	f3c3 4307 	ubfx	r3, r3, #16, #8
	while (byte_count--) {
    8388:	1e51      	subs	r1, r2, #1
	chan_next = 0U;
    838a:	4620      	mov	r0, r4
    838c:	3204      	adds	r2, #4
	while (byte_count--) {
    838e:	428a      	cmp	r2, r1
    8390:	d101      	bne.n	8396 <lll_chan_sel_2+0x9e>
}
    8392:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bite = *chan_map;
    8396:	f100 0408 	add.w	r4, r0, #8
    839a:	f811 5f01 	ldrb.w	r5, [r1, #1]!
		while (bit_count--) {
    839e:	b2e4      	uxtb	r4, r4
    83a0:	42a0      	cmp	r0, r4
    83a2:	d0f4      	beq.n	838e <lll_chan_sel_2+0x96>
			if (bite & 0x01) {
    83a4:	07ee      	lsls	r6, r5, #31
    83a6:	d503      	bpl.n	83b0 <lll_chan_sel_2+0xb8>
				if (chan_index == 0U) {
    83a8:	2b00      	cmp	r3, #0
    83aa:	d0f2      	beq.n	8392 <lll_chan_sel_2+0x9a>
				chan_index--;
    83ac:	3b01      	subs	r3, #1
    83ae:	b2db      	uxtb	r3, r3
			chan_next++;
    83b0:	3001      	adds	r0, #1
    83b2:	b2c0      	uxtb	r0, r0
			bite >>= 1;
    83b4:	086d      	lsrs	r5, r5, #1
    83b6:	e7f3      	b.n	83a0 <lll_chan_sel_2+0xa8>
    83b8:	00022110 	.word	0x00022110
    83bc:	00088440 	.word	0x00088440

000083c0 <fal_clear>:
#endif /* CONFIG_BT_CTLR_SW_DEFERRED_PRIVACY */

static void fal_clear(void)
{
	for (int i = 0; i < FAL_SIZE; i++) {
		uint8_t j = fal[i].rl_idx;
    83c0:	490c      	ldr	r1, [pc, #48]	; (83f4 <fal_clear+0x34>)

		if (j < ARRAY_SIZE(rl)) {
			rl[j].fal = 0U;
    83c2:	480d      	ldr	r0, [pc, #52]	; (83f8 <fal_clear+0x38>)
{
    83c4:	b530      	push	{r4, r5, lr}
	for (int i = 0; i < FAL_SIZE; i++) {
    83c6:	2300      	movs	r3, #0
			rl[j].fal = 0U;
    83c8:	2528      	movs	r5, #40	; 0x28
		uint8_t j = fal[i].rl_idx;
    83ca:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
    83ce:	7852      	ldrb	r2, [r2, #1]
		if (j < ARRAY_SIZE(rl)) {
    83d0:	2a07      	cmp	r2, #7
			rl[j].fal = 0U;
    83d2:	bf9f      	itttt	ls
    83d4:	436a      	mulls	r2, r5
    83d6:	5c84      	ldrbls	r4, [r0, r2]
    83d8:	f36f 1445 	bfcls	r4, #5, #1
    83dc:	5484      	strbls	r4, [r0, r2]
		}
		fal[i].taken = 0U;
    83de:	f811 2033 	ldrb.w	r2, [r1, r3, lsl #3]
    83e2:	f36f 0200 	bfc	r2, #0, #1
    83e6:	f801 2033 	strb.w	r2, [r1, r3, lsl #3]
	for (int i = 0; i < FAL_SIZE; i++) {
    83ea:	3301      	adds	r3, #1
    83ec:	2b08      	cmp	r3, #8
    83ee:	d1ec      	bne.n	83ca <fal_clear+0xa>
	}
}
    83f0:	bd30      	pop	{r4, r5, pc}
    83f2:	bf00      	nop
    83f4:	20002915 	.word	0x20002915
    83f8:	20002030 	.word	0x20002030

000083fc <rl_clear>:
#endif /* CONFIG_BT_BROADCASTER */

static void rl_clear(void)
{
	for (uint8_t i = 0; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
		rl[i].taken = 0U;
    83fc:	4b19      	ldr	r3, [pc, #100]	; (8464 <rl_clear+0x68>)
    83fe:	781a      	ldrb	r2, [r3, #0]
    8400:	f36f 0200 	bfc	r2, #0, #1
    8404:	701a      	strb	r2, [r3, #0]
    8406:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    840a:	f36f 0200 	bfc	r2, #0, #1
    840e:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    8412:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
    8416:	f36f 0200 	bfc	r2, #0, #1
    841a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
    841e:	f893 2078 	ldrb.w	r2, [r3, #120]	; 0x78
    8422:	f36f 0200 	bfc	r2, #0, #1
    8426:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
    842a:	f893 20a0 	ldrb.w	r2, [r3, #160]	; 0xa0
    842e:	f36f 0200 	bfc	r2, #0, #1
    8432:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
    8436:	f893 20c8 	ldrb.w	r2, [r3, #200]	; 0xc8
    843a:	f36f 0200 	bfc	r2, #0, #1
    843e:	f883 20c8 	strb.w	r2, [r3, #200]	; 0xc8
    8442:	f893 20f0 	ldrb.w	r2, [r3, #240]	; 0xf0
    8446:	f36f 0200 	bfc	r2, #0, #1
    844a:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
    844e:	f893 2118 	ldrb.w	r2, [r3, #280]	; 0x118
    8452:	f36f 0200 	bfc	r2, #0, #1
    8456:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
	}

	peer_irk_count = 0U;
    845a:	4b03      	ldr	r3, [pc, #12]	; (8468 <rl_clear+0x6c>)
    845c:	2200      	movs	r2, #0
    845e:	701a      	strb	r2, [r3, #0]
}
    8460:	4770      	bx	lr
    8462:	bf00      	nop
    8464:	20002030 	.word	0x20002030
    8468:	200029b7 	.word	0x200029b7

0000846c <fal_find>:
{
    846c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8470:	4688      	mov	r8, r1
	if (free_idx) {
    8472:	4615      	mov	r5, r2
    8474:	b10a      	cbz	r2, 847a <fal_find+0xe>
		*free_idx = FILTER_IDX_NONE;
    8476:	23ff      	movs	r3, #255	; 0xff
    8478:	7013      	strb	r3, [r2, #0]
    847a:	4f15      	ldr	r7, [pc, #84]	; (84d0 <fal_find+0x64>)
{
    847c:	2400      	movs	r4, #0
		if (LIST_MATCH(fal, i, addr_type, addr)) {
    847e:	f1a7 0902 	sub.w	r9, r7, #2
    8482:	f000 0601 	and.w	r6, r0, #1
    8486:	f819 3034 	ldrb.w	r3, [r9, r4, lsl #3]
    848a:	07da      	lsls	r2, r3, #31
    848c:	d51c      	bpl.n	84c8 <fal_find+0x5c>
    848e:	f3c3 0340 	ubfx	r3, r3, #1, #1
    8492:	42b3      	cmp	r3, r6
    8494:	d111      	bne.n	84ba <fal_find+0x4e>
    8496:	2206      	movs	r2, #6
    8498:	4641      	mov	r1, r8
    849a:	4638      	mov	r0, r7
    849c:	f007 fb5a 	bl	fb54 <memcmp>
    84a0:	b910      	cbnz	r0, 84a8 <fal_find+0x3c>
			return i;
    84a2:	b2e0      	uxtb	r0, r4
}
    84a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		} else if (free_idx && !fal[i].taken &&
    84a8:	b13d      	cbz	r5, 84ba <fal_find+0x4e>
    84aa:	f819 3034 	ldrb.w	r3, [r9, r4, lsl #3]
    84ae:	07db      	lsls	r3, r3, #31
    84b0:	d403      	bmi.n	84ba <fal_find+0x4e>
    84b2:	782b      	ldrb	r3, [r5, #0]
    84b4:	2bff      	cmp	r3, #255	; 0xff
			*free_idx = i;
    84b6:	bf08      	it	eq
    84b8:	702c      	strbeq	r4, [r5, #0]
	for (i = 0; i < FAL_SIZE; i++) {
    84ba:	3401      	adds	r4, #1
    84bc:	2c08      	cmp	r4, #8
    84be:	f107 0708 	add.w	r7, r7, #8
    84c2:	d1e0      	bne.n	8486 <fal_find+0x1a>
	return FILTER_IDX_NONE;
    84c4:	20ff      	movs	r0, #255	; 0xff
    84c6:	e7ed      	b.n	84a4 <fal_find+0x38>
		} else if (free_idx && !fal[i].taken &&
    84c8:	2d00      	cmp	r5, #0
    84ca:	d1f2      	bne.n	84b2 <fal_find+0x46>
    84cc:	e7f5      	b.n	84ba <fal_find+0x4e>
    84ce:	bf00      	nop
    84d0:	20002917 	.word	0x20002917

000084d4 <fal_update>:
{
    84d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    84d8:	4d1a      	ldr	r5, [pc, #104]	; (8544 <fal_update+0x70>)
    84da:	4e1b      	ldr	r6, [pc, #108]	; (8548 <fal_update+0x74>)
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
    84dc:	f8df 806c 	ldr.w	r8, [pc, #108]	; 854c <fal_update+0x78>
{
    84e0:	2400      	movs	r4, #0
		if (!fal[i].taken) {
    84e2:	1eaf      	subs	r7, r5, #2
    84e4:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
    84e8:	07d9      	lsls	r1, r3, #31
    84ea:	d522      	bpl.n	8532 <fal_update+0x5e>
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
    84ec:	f898 3000 	ldrb.w	r3, [r8]
    84f0:	b15b      	cbz	r3, 850a <fal_update+0x36>
		j = fal[i].rl_idx;
    84f2:	f815 3c01 	ldrb.w	r3, [r5, #-1]
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
    84f6:	2b07      	cmp	r3, #7
    84f8:	d807      	bhi.n	850a <fal_update+0x36>
    84fa:	2228      	movs	r2, #40	; 0x28
    84fc:	4353      	muls	r3, r2
    84fe:	4a14      	ldr	r2, [pc, #80]	; (8550 <fal_update+0x7c>)
    8500:	5cd3      	ldrb	r3, [r2, r3]
    8502:	075a      	lsls	r2, r3, #29
    8504:	d501      	bpl.n	850a <fal_update+0x36>
    8506:	06db      	lsls	r3, r3, #27
    8508:	d513      	bpl.n	8532 <fal_update+0x5e>
}

static void filter_insert(struct lll_filter *const filter, int index,
			  uint8_t addr_type, const uint8_t *const bdaddr)
{
	filter->enable_bitmask |= BIT(index);
    850a:	4a12      	ldr	r2, [pc, #72]	; (8554 <fal_update+0x80>)
			filter_insert(&fal_filter, i, fal[i].id_addr_type,
    850c:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
	filter->enable_bitmask |= BIT(index);
    8510:	2101      	movs	r1, #1
    8512:	fa01 f004 	lsl.w	r0, r1, r4
    8516:	7811      	ldrb	r1, [r2, #0]
    8518:	4301      	orrs	r1, r0
    851a:	7011      	strb	r1, [r2, #0]
			filter_insert(&fal_filter, i, fal[i].id_addr_type,
    851c:	f3c3 0340 	ubfx	r3, r3, #1, #1
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
    8520:	7851      	ldrb	r1, [r2, #1]
    8522:	40a3      	lsls	r3, r4
    8524:	430b      	orrs	r3, r1
    8526:	7053      	strb	r3, [r2, #1]
	(void)memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
    8528:	4629      	mov	r1, r5
    852a:	2206      	movs	r2, #6
    852c:	4630      	mov	r0, r6
    852e:	f007 fb3a 	bl	fba6 <memcpy>
	for (i = 0U; i < FAL_SIZE; i++) {
    8532:	3401      	adds	r4, #1
    8534:	2c08      	cmp	r4, #8
    8536:	f106 0606 	add.w	r6, r6, #6
    853a:	f105 0508 	add.w	r5, r5, #8
    853e:	d1d1      	bne.n	84e4 <fal_update+0x10>
}
    8540:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8544:	20002917 	.word	0x20002917
    8548:	20002957 	.word	0x20002957
    854c:	20002a40 	.word	0x20002a40
    8550:	20002030 	.word	0x20002030
    8554:	20002955 	.word	0x20002955

00008558 <rl_update>:
{
    8558:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    855c:	4e13      	ldr	r6, [pc, #76]	; (85ac <rl_update+0x54>)
    855e:	4d14      	ldr	r5, [pc, #80]	; (85b0 <rl_update+0x58>)
    8560:	2400      	movs	r4, #0
		if (rl[i].taken) {
    8562:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
    8566:	f04f 0928 	mov.w	r9, #40	; 0x28
	filter->enable_bitmask |= BIT(index);
    856a:	1eb7      	subs	r7, r6, #2
		if (rl[i].taken) {
    856c:	fb09 f304 	mul.w	r3, r9, r4
    8570:	f818 3003 	ldrb.w	r3, [r8, r3]
    8574:	07da      	lsls	r2, r3, #31
    8576:	d510      	bpl.n	859a <rl_update+0x42>
	filter->enable_bitmask |= BIT(index);
    8578:	2201      	movs	r2, #1
    857a:	fa02 f104 	lsl.w	r1, r2, r4
    857e:	783a      	ldrb	r2, [r7, #0]
    8580:	430a      	orrs	r2, r1
			filter_insert(&rl_filter, i, rl[i].id_addr_type,
    8582:	f3c3 1380 	ubfx	r3, r3, #6, #1
	filter->enable_bitmask |= BIT(index);
    8586:	703a      	strb	r2, [r7, #0]
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
    8588:	787a      	ldrb	r2, [r7, #1]
    858a:	40a3      	lsls	r3, r4
    858c:	4313      	orrs	r3, r2
	(void)memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
    858e:	4629      	mov	r1, r5
    8590:	2206      	movs	r2, #6
    8592:	4630      	mov	r0, r6
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
    8594:	707b      	strb	r3, [r7, #1]
	(void)memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
    8596:	f007 fb06 	bl	fba6 <memcpy>
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
    859a:	3401      	adds	r4, #1
    859c:	2c08      	cmp	r4, #8
    859e:	f106 0606 	add.w	r6, r6, #6
    85a2:	f105 0528 	add.w	r5, r5, #40	; 0x28
    85a6:	d1e1      	bne.n	856c <rl_update+0x14>
}
    85a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    85ac:	20002a43 	.word	0x20002a43
    85b0:	20002031 	.word	0x20002031

000085b4 <ll_fal_remove>:
{
    85b4:	b538      	push	{r3, r4, r5, lr}
    85b6:	4605      	mov	r5, r0
	if (ull_adv_filter_pol_get(0)) {
    85b8:	2000      	movs	r0, #0
    85ba:	f008 fdce 	bl	1115a <ull_adv_filter_pol_get>
    85be:	b108      	cbz	r0, 85c4 <ll_fal_remove+0x10>
		return BT_HCI_ERR_CMD_DISALLOWED;
    85c0:	200c      	movs	r0, #12
}
    85c2:	bd38      	pop	{r3, r4, r5, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
    85c4:	f009 f859 	bl	1167a <ull_scan_filter_pol_get>
    85c8:	f010 0401 	ands.w	r4, r0, #1
    85cc:	d1f8      	bne.n	85c0 <ll_fal_remove+0xc>
	if (addr->type == ADDR_TYPE_ANON) {
    85ce:	7828      	ldrb	r0, [r5, #0]
    85d0:	28ff      	cmp	r0, #255	; 0xff
    85d2:	d01c      	beq.n	860e <ll_fal_remove+0x5a>
	uint8_t i = fal_find(id_addr->type, id_addr->a.val, NULL);
    85d4:	4622      	mov	r2, r4
    85d6:	1c69      	adds	r1, r5, #1
    85d8:	f7ff ff48 	bl	846c <fal_find>
	if (i < ARRAY_SIZE(fal)) {
    85dc:	2807      	cmp	r0, #7
    85de:	d814      	bhi.n	860a <ll_fal_remove+0x56>
		uint8_t j = fal[i].rl_idx;
    85e0:	4a0c      	ldr	r2, [pc, #48]	; (8614 <ll_fal_remove+0x60>)
    85e2:	eb02 03c0 	add.w	r3, r2, r0, lsl #3
    85e6:	785b      	ldrb	r3, [r3, #1]
		if (j < ARRAY_SIZE(rl)) {
    85e8:	2b07      	cmp	r3, #7
    85ea:	d806      	bhi.n	85fa <ll_fal_remove+0x46>
			rl[j].fal = 0U;
    85ec:	2528      	movs	r5, #40	; 0x28
    85ee:	490a      	ldr	r1, [pc, #40]	; (8618 <ll_fal_remove+0x64>)
    85f0:	436b      	muls	r3, r5
    85f2:	5ccd      	ldrb	r5, [r1, r3]
    85f4:	f364 1545 	bfi	r5, r4, #5, #1
    85f8:	54cd      	strb	r5, [r1, r3]
		fal[i].taken = 0U;
    85fa:	f812 3030 	ldrb.w	r3, [r2, r0, lsl #3]
    85fe:	f36f 0300 	bfc	r3, #0, #1
    8602:	f802 3030 	strb.w	r3, [r2, r0, lsl #3]
	return fal_remove(addr);
    8606:	b2e0      	uxtb	r0, r4
    8608:	e7db      	b.n	85c2 <ll_fal_remove+0xe>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
    860a:	2402      	movs	r4, #2
    860c:	e7fb      	b.n	8606 <ll_fal_remove+0x52>
		return 0;
    860e:	4620      	mov	r0, r4
    8610:	e7d7      	b.n	85c2 <ll_fal_remove+0xe>
    8612:	bf00      	nop
    8614:	20002915 	.word	0x20002915
    8618:	20002030 	.word	0x20002030

0000861c <ll_rl_id_addr_get>:
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
    861c:	2807      	cmp	r0, #7
{
    861e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8620:	4604      	mov	r4, r0
    8622:	460f      	mov	r7, r1
    8624:	4616      	mov	r6, r2
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
    8626:	d90c      	bls.n	8642 <ll_rl_id_addr_get+0x26>
    8628:	4a17      	ldr	r2, [pc, #92]	; (8688 <ll_rl_id_addr_get+0x6c>)
    862a:	4918      	ldr	r1, [pc, #96]	; (868c <ll_rl_id_addr_get+0x70>)
    862c:	4818      	ldr	r0, [pc, #96]	; (8690 <ll_rl_id_addr_get+0x74>)
    862e:	f240 1311 	movw	r3, #273	; 0x111
    8632:	f006 ff48 	bl	f4c6 <printk>
    8636:	4040      	eors	r0, r0
    8638:	f380 8811 	msr	BASEPRI, r0
    863c:	f04f 0003 	mov.w	r0, #3
    8640:	df02      	svc	2
	LL_ASSERT(rl[rl_idx].taken);
    8642:	2328      	movs	r3, #40	; 0x28
    8644:	4d13      	ldr	r5, [pc, #76]	; (8694 <ll_rl_id_addr_get+0x78>)
    8646:	4363      	muls	r3, r4
    8648:	5ceb      	ldrb	r3, [r5, r3]
    864a:	07db      	lsls	r3, r3, #31
    864c:	d40c      	bmi.n	8668 <ll_rl_id_addr_get+0x4c>
    864e:	4a0e      	ldr	r2, [pc, #56]	; (8688 <ll_rl_id_addr_get+0x6c>)
    8650:	4911      	ldr	r1, [pc, #68]	; (8698 <ll_rl_id_addr_get+0x7c>)
    8652:	480f      	ldr	r0, [pc, #60]	; (8690 <ll_rl_id_addr_get+0x74>)
    8654:	f44f 7389 	mov.w	r3, #274	; 0x112
    8658:	f006 ff35 	bl	f4c6 <printk>
    865c:	4040      	eors	r0, r0
    865e:	f380 8811 	msr	BASEPRI, r0
    8662:	f04f 0003 	mov.w	r0, #3
    8666:	df02      	svc	2
	*id_addr_type = rl[rl_idx].id_addr_type;
    8668:	2128      	movs	r1, #40	; 0x28
    866a:	fb01 f304 	mul.w	r3, r1, r4
	(void)memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
    866e:	fb01 5104 	mla	r1, r1, r4, r5
	*id_addr_type = rl[rl_idx].id_addr_type;
    8672:	5ceb      	ldrb	r3, [r5, r3]
    8674:	f3c3 1380 	ubfx	r3, r3, #6, #1
    8678:	703b      	strb	r3, [r7, #0]
	(void)memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
    867a:	4630      	mov	r0, r6
    867c:	2206      	movs	r2, #6
}
    867e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	(void)memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
    8682:	3101      	adds	r1, #1
    8684:	f007 ba8f 	b.w	fba6 <memcpy>
    8688:	00013a4f 	.word	0x00013a4f
    868c:	00013a91 	.word	0x00013a91
    8690:	000133b6 	.word	0x000133b6
    8694:	20002030 	.word	0x20002030
    8698:	00013a9c 	.word	0x00013a9c

0000869c <ll_rl_enable>:
{
    869c:	b510      	push	{r4, lr}
    869e:	4604      	mov	r4, r0
	if (!rl_access_check(false)) {
    86a0:	f009 f808 	bl	116b4 <rl_access_check.constprop.0>
    86a4:	b160      	cbz	r0, 86c0 <ll_rl_enable+0x24>
	switch (enable) {
    86a6:	b124      	cbz	r4, 86b2 <ll_rl_enable+0x16>
    86a8:	2c01      	cmp	r4, #1
    86aa:	d005      	beq.n	86b8 <ll_rl_enable+0x1c>
    86ac:	2412      	movs	r4, #18
}
    86ae:	4620      	mov	r0, r4
    86b0:	bd10      	pop	{r4, pc}
		rl_enable = 0U;
    86b2:	4b04      	ldr	r3, [pc, #16]	; (86c4 <ll_rl_enable+0x28>)
    86b4:	701c      	strb	r4, [r3, #0]
		break;
    86b6:	e7fa      	b.n	86ae <ll_rl_enable+0x12>
		rl_enable = 1U;
    86b8:	4b02      	ldr	r3, [pc, #8]	; (86c4 <ll_rl_enable+0x28>)
    86ba:	701c      	strb	r4, [r3, #0]
	return 0;
    86bc:	2400      	movs	r4, #0
		break;
    86be:	e7f6      	b.n	86ae <ll_rl_enable+0x12>
		return BT_HCI_ERR_CMD_DISALLOWED;
    86c0:	240c      	movs	r4, #12
    86c2:	e7f4      	b.n	86ae <ll_rl_enable+0x12>
    86c4:	20002a40 	.word	0x20002a40

000086c8 <ll_rl_timeout_set>:
	rpa_timeout_ms = timeout * 1000U;
    86c8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    86cc:	4358      	muls	r0, r3
    86ce:	4b01      	ldr	r3, [pc, #4]	; (86d4 <ll_rl_timeout_set+0xc>)
    86d0:	6018      	str	r0, [r3, #0]
}
    86d2:	4770      	bx	lr
    86d4:	20002170 	.word	0x20002170

000086d8 <ull_filter_reset>:
{
    86d8:	b510      	push	{r4, lr}
    86da:	4604      	mov	r4, r0
	fal_clear();
    86dc:	f7ff fe70 	bl	83c0 <fal_clear>
	rl_enable = 0U;
    86e0:	4b0d      	ldr	r3, [pc, #52]	; (8718 <ull_filter_reset+0x40>)
    86e2:	2200      	movs	r2, #0
    86e4:	701a      	strb	r2, [r3, #0]
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
    86e6:	4b0d      	ldr	r3, [pc, #52]	; (871c <ull_filter_reset+0x44>)
    86e8:	4a0d      	ldr	r2, [pc, #52]	; (8720 <ull_filter_reset+0x48>)
    86ea:	601a      	str	r2, [r3, #0]
	rpa_last_ms = -1;
    86ec:	4b0d      	ldr	r3, [pc, #52]	; (8724 <ull_filter_reset+0x4c>)
    86ee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    86f2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    86f6:	e9c3 0100 	strd	r0, r1, [r3]
	rl_clear();
    86fa:	f7ff fe7f 	bl	83fc <rl_clear>
	if (init) {
    86fe:	b12c      	cbz	r4, 870c <ull_filter_reset+0x34>
}
    8700:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_work_init_delayable(&rpa_work, rpa_timeout);
    8704:	4908      	ldr	r1, [pc, #32]	; (8728 <ull_filter_reset+0x50>)
    8706:	4809      	ldr	r0, [pc, #36]	; (872c <ull_filter_reset+0x54>)
    8708:	f00a b855 	b.w	127b6 <k_work_init_delayable>
}
    870c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_work_cancel_delayable(&rpa_work);
    8710:	4806      	ldr	r0, [pc, #24]	; (872c <ull_filter_reset+0x54>)
    8712:	f00a b85c 	b.w	127ce <k_work_cancel_delayable>
    8716:	bf00      	nop
    8718:	20002a40 	.word	0x20002a40
    871c:	20002170 	.word	0x20002170
    8720:	000dbba0 	.word	0x000dbba0
    8724:	20000828 	.word	0x20000828
    8728:	000089bd 	.word	0x000089bd
    872c:	20000830 	.word	0x20000830

00008730 <ull_filter_lll_get>:
}
    8730:	4a03      	ldr	r2, [pc, #12]	; (8740 <ull_filter_lll_get+0x10>)
    8732:	4b04      	ldr	r3, [pc, #16]	; (8744 <ull_filter_lll_get+0x14>)
    8734:	2800      	cmp	r0, #0
    8736:	bf0c      	ite	eq
    8738:	4610      	moveq	r0, r2
    873a:	4618      	movne	r0, r3
    873c:	4770      	bx	lr
    873e:	bf00      	nop
    8740:	20002a41 	.word	0x20002a41
    8744:	20002955 	.word	0x20002955

00008748 <ull_filter_adv_scan_state_cb>:
{
    8748:	b570      	push	{r4, r5, r6, lr}
	if (bm) {
    874a:	b1a0      	cbz	r0, 8776 <ull_filter_adv_scan_state_cb+0x2e>
	k_work_schedule(&rpa_work, K_MSEC(rpa_timeout_ms));
    874c:	4b0c      	ldr	r3, [pc, #48]	; (8780 <ull_filter_adv_scan_state_cb+0x38>)
		} else {
			return (t * to_hz + off) / from_hz;
    874e:	681d      	ldr	r5, [r3, #0]
    8750:	f44f 4400 	mov.w	r4, #32768	; 0x8000
    8754:	f240 30e7 	movw	r0, #999	; 0x3e7
    8758:	2100      	movs	r1, #0
    875a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    875e:	2300      	movs	r3, #0
    8760:	fbe5 0104 	umlal	r0, r1, r5, r4
    8764:	f7f7 fccc 	bl	100 <__aeabi_uldivmod>
}
    8768:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    876c:	4602      	mov	r2, r0
    876e:	460b      	mov	r3, r1
	k_work_schedule(&rpa_work, K_MSEC(rpa_timeout_ms));
    8770:	4804      	ldr	r0, [pc, #16]	; (8784 <ull_filter_adv_scan_state_cb+0x3c>)
    8772:	f006 b91f 	b.w	e9b4 <k_work_schedule>
}
    8776:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_work_cancel_delayable(&rpa_work);
    877a:	4802      	ldr	r0, [pc, #8]	; (8784 <ull_filter_adv_scan_state_cb+0x3c>)
    877c:	f00a b827 	b.w	127ce <k_work_cancel_delayable>
    8780:	20002170 	.word	0x20002170
    8784:	20000830 	.word	0x20000830

00008788 <ull_filter_adv_update>:
}

static void filter_clear(struct lll_filter *filter)
{
	filter->enable_bitmask = 0;
    8788:	4a0d      	ldr	r2, [pc, #52]	; (87c0 <ull_filter_adv_update+0x38>)
{
    878a:	b508      	push	{r3, lr}
	filter->enable_bitmask = 0;
    878c:	2300      	movs	r3, #0
    878e:	7013      	strb	r3, [r2, #0]
	filter->addr_type_bitmask = 0;
    8790:	7053      	strb	r3, [r2, #1]
	if (adv_fp &&
    8792:	b130      	cbz	r0, 87a2 <ull_filter_adv_update+0x1a>
	     !(ull_scan_filter_pol_get(0) & 0x1))) {
    8794:	4618      	mov	r0, r3
    8796:	f008 ff70 	bl	1167a <ull_scan_filter_pol_get>
	if (adv_fp &&
    879a:	07c3      	lsls	r3, r0, #31
    879c:	d401      	bmi.n	87a2 <ull_filter_adv_update+0x1a>
		fal_update();
    879e:	f7ff fe99 	bl	84d4 <fal_update>
	filter->enable_bitmask = 0;
    87a2:	4b08      	ldr	r3, [pc, #32]	; (87c4 <ull_filter_adv_update+0x3c>)
    87a4:	2000      	movs	r0, #0
    87a6:	7018      	strb	r0, [r3, #0]
	filter->addr_type_bitmask = 0;
    87a8:	7058      	strb	r0, [r3, #1]
	if (rl_enable &&
    87aa:	4b07      	ldr	r3, [pc, #28]	; (87c8 <ull_filter_adv_update+0x40>)
    87ac:	781b      	ldrb	r3, [r3, #0]
    87ae:	b133      	cbz	r3, 87be <ull_filter_adv_update+0x36>
	    (!IS_ENABLED(CONFIG_BT_OBSERVER) || !ull_scan_is_enabled(0))) {
    87b0:	f008 ff54 	bl	1165c <ull_scan_is_enabled>
	if (rl_enable &&
    87b4:	b918      	cbnz	r0, 87be <ull_filter_adv_update+0x36>
}
    87b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		rl_update();
    87ba:	f7ff becd 	b.w	8558 <rl_update>
}
    87be:	bd08      	pop	{r3, pc}
    87c0:	20002955 	.word	0x20002955
    87c4:	20002a41 	.word	0x20002a41
    87c8:	20002a40 	.word	0x20002a40

000087cc <ull_filter_scan_update>:
	filter->enable_bitmask = 0;
    87cc:	4a0d      	ldr	r2, [pc, #52]	; (8804 <ull_filter_scan_update+0x38>)
{
    87ce:	b508      	push	{r3, lr}
	filter->enable_bitmask = 0;
    87d0:	2300      	movs	r3, #0
    87d2:	7013      	strb	r3, [r2, #0]
	filter->addr_type_bitmask = 0;
    87d4:	7053      	strb	r3, [r2, #1]
	if ((scan_fp & 0x1) &&
    87d6:	07c2      	lsls	r2, r0, #31
    87d8:	d505      	bpl.n	87e6 <ull_filter_scan_update+0x1a>
	     !ull_adv_filter_pol_get(0))) {
    87da:	4618      	mov	r0, r3
    87dc:	f008 fcbd 	bl	1115a <ull_adv_filter_pol_get>
	if ((scan_fp & 0x1) &&
    87e0:	b908      	cbnz	r0, 87e6 <ull_filter_scan_update+0x1a>
		fal_update();
    87e2:	f7ff fe77 	bl	84d4 <fal_update>
	filter->enable_bitmask = 0;
    87e6:	4b08      	ldr	r3, [pc, #32]	; (8808 <ull_filter_scan_update+0x3c>)
    87e8:	2000      	movs	r0, #0
    87ea:	7018      	strb	r0, [r3, #0]
	filter->addr_type_bitmask = 0;
    87ec:	7058      	strb	r0, [r3, #1]
	if (rl_enable &&
    87ee:	4b07      	ldr	r3, [pc, #28]	; (880c <ull_filter_scan_update+0x40>)
    87f0:	781b      	ldrb	r3, [r3, #0]
    87f2:	b133      	cbz	r3, 8802 <ull_filter_scan_update+0x36>
	    (!IS_ENABLED(CONFIG_BT_BROADCASTER) || !ull_adv_is_enabled(0))) {
    87f4:	f008 fcaa 	bl	1114c <ull_adv_is_enabled>
	if (rl_enable &&
    87f8:	b918      	cbnz	r0, 8802 <ull_filter_scan_update+0x36>
}
    87fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		rl_update();
    87fe:	f7ff beab 	b.w	8558 <rl_update>
}
    8802:	bd08      	pop	{r3, pc}
    8804:	20002955 	.word	0x20002955
    8808:	20002a41 	.word	0x20002a41
    880c:	20002a40 	.word	0x20002a40

00008810 <ull_filter_rpa_update>:
{
    8810:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8814:	b087      	sub	sp, #28
    8816:	9000      	str	r0, [sp, #0]
	return z_impl_k_uptime_ticks();
    8818:	f00a f91d 	bl	12a56 <z_impl_k_uptime_ticks>
    881c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8820:	fba0 4003 	umull	r4, r0, r0, r3
    8824:	fb03 0101 	mla	r1, r3, r1, r0
    8828:	0bcb      	lsrs	r3, r1, #15
    882a:	9301      	str	r3, [sp, #4]
	bool all = timeout || (rpa_last_ms == -1) ||
    882c:	9b00      	ldr	r3, [sp, #0]
    882e:	0be4      	lsrs	r4, r4, #15
    8830:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
    8834:	2b00      	cmp	r3, #0
    8836:	f040 80ad 	bne.w	8994 <ull_filter_rpa_update+0x184>
    883a:	4a58      	ldr	r2, [pc, #352]	; (899c <ull_filter_rpa_update+0x18c>)
    883c:	e9d2 3200 	ldrd	r3, r2, [r2]
    8840:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    8844:	bf08      	it	eq
    8846:	f1b3 3fff 	cmpeq.w	r3, #4294967295	; 0xffffffff
    884a:	f000 80a3 	beq.w	8994 <ull_filter_rpa_update+0x184>
		   (now - rpa_last_ms >= rpa_timeout_ms);
    884e:	9901      	ldr	r1, [sp, #4]
    8850:	1ae3      	subs	r3, r4, r3
    8852:	eb61 0202 	sbc.w	r2, r1, r2
    8856:	4952      	ldr	r1, [pc, #328]	; (89a0 <ull_filter_rpa_update+0x190>)
    8858:	6809      	ldr	r1, [r1, #0]
	bool all = timeout || (rpa_last_ms == -1) ||
    885a:	428b      	cmp	r3, r1
    885c:	f172 0300 	sbcs.w	r3, r2, #0
    8860:	bfac      	ite	ge
    8862:	f04f 0801 	movge.w	r8, #1
    8866:	f04f 0800 	movlt.w	r8, #0
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
    886a:	4d4e      	ldr	r5, [pc, #312]	; (89a4 <ull_filter_rpa_update+0x194>)
    886c:	f8df 9138 	ldr.w	r9, [pc, #312]	; 89a8 <ull_filter_rpa_update+0x198>
				LL_ASSERT(!err);
    8870:	f8df a138 	ldr.w	sl, [pc, #312]	; 89ac <ull_filter_rpa_update+0x19c>
    8874:	f8df b138 	ldr.w	fp, [pc, #312]	; 89b0 <ull_filter_rpa_update+0x1a0>
	bool all = timeout || (rpa_last_ms == -1) ||
    8878:	2600      	movs	r6, #0
    887a:	462f      	mov	r7, r5
		if ((rl[i].taken) && (all || !rl[i].rpas_ready)) {
    887c:	2328      	movs	r3, #40	; 0x28
    887e:	4373      	muls	r3, r6
    8880:	5cfb      	ldrb	r3, [r7, r3]
    8882:	07da      	lsls	r2, r3, #31
    8884:	d54f      	bpl.n	8926 <ull_filter_rpa_update+0x116>
    8886:	f1b8 0f00 	cmp.w	r8, #0
    888a:	d101      	bne.n	8890 <ull_filter_rpa_update+0x80>
    888c:	0798      	lsls	r0, r3, #30
    888e:	d44a      	bmi.n	8926 <ull_filter_rpa_update+0x116>
			if (rl[i].pirk) {
    8890:	2328      	movs	r3, #40	; 0x28
    8892:	4373      	muls	r3, r6
    8894:	5cfb      	ldrb	r3, [r7, r3]
    8896:	0759      	lsls	r1, r3, #29
    8898:	d51f      	bpl.n	88da <ull_filter_rpa_update+0xca>
				sys_memcpy_swap(irk, peer_irks[rl[i].pirk_idx],
    889a:	7dea      	ldrb	r2, [r5, #23]
    889c:	4b45      	ldr	r3, [pc, #276]	; (89b4 <ull_filter_rpa_update+0x1a4>)
    889e:	a902      	add	r1, sp, #8
    88a0:	eb03 1302 	add.w	r3, r3, r2, lsl #4
		  (psrc > pdst && (pdst + length) <= psrc)),
		 "Source and destination buffers must not overlap");

	psrc += length - 1;

	for (; length > 0; length--) {
    88a4:	f103 0210 	add.w	r2, r3, #16
    88a8:	4608      	mov	r0, r1
		*pdst++ = *psrc--;
    88aa:	f812 cd01 	ldrb.w	ip, [r2, #-1]!
    88ae:	f801 cb01 	strb.w	ip, [r1], #1
	for (; length > 0; length--) {
    88b2:	429a      	cmp	r2, r3
    88b4:	d1f9      	bne.n	88aa <ull_filter_rpa_update+0x9a>
				err = bt_rpa_create(irk, &rl[i].peer_rpa);
    88b6:	f105 011e 	add.w	r1, r5, #30
    88ba:	f007 f9d9 	bl	fc70 <bt_rpa_create>
				LL_ASSERT(!err);
    88be:	b160      	cbz	r0, 88da <ull_filter_rpa_update+0xca>
    88c0:	4a3d      	ldr	r2, [pc, #244]	; (89b8 <ull_filter_rpa_update+0x1a8>)
    88c2:	f240 23ea 	movw	r3, #746	; 0x2ea
    88c6:	4651      	mov	r1, sl
    88c8:	4658      	mov	r0, fp
    88ca:	f006 fdfc 	bl	f4c6 <printk>
    88ce:	4040      	eors	r0, r0
    88d0:	f380 8811 	msr	BASEPRI, r0
    88d4:	f04f 0003 	mov.w	r0, #3
    88d8:	df02      	svc	2
			if (rl[i].lirk) {
    88da:	2328      	movs	r3, #40	; 0x28
    88dc:	4373      	muls	r3, r6
    88de:	5cfb      	ldrb	r3, [r7, r3]
    88e0:	071a      	lsls	r2, r3, #28
    88e2:	d51a      	bpl.n	891a <ull_filter_rpa_update+0x10a>
				err = bt_rpa_create(rl[i].local_irk, &rpa);
    88e4:	a902      	add	r1, sp, #8
    88e6:	1de8      	adds	r0, r5, #7
    88e8:	f007 f9c2 	bl	fc70 <bt_rpa_create>
				LL_ASSERT(!err);
    88ec:	b160      	cbz	r0, 8908 <ull_filter_rpa_update+0xf8>
    88ee:	4a32      	ldr	r2, [pc, #200]	; (89b8 <ull_filter_rpa_update+0x1a8>)
    88f0:	f240 23f7 	movw	r3, #759	; 0x2f7
    88f4:	4651      	mov	r1, sl
    88f6:	4658      	mov	r0, fp
    88f8:	f006 fde5 	bl	f4c6 <printk>
    88fc:	4040      	eors	r0, r0
    88fe:	f380 8811 	msr	BASEPRI, r0
    8902:	f04f 0003 	mov.w	r0, #3
    8906:	df02      	svc	2
				rl[i].local_rpa = &rpa;
    8908:	ab02      	add	r3, sp, #8
    890a:	626b      	str	r3, [r5, #36]	; 0x24
	memcpy(dst, src, sizeof(*dst));
    890c:	2206      	movs	r2, #6
    890e:	4619      	mov	r1, r3
    8910:	4648      	mov	r0, r9
    8912:	f007 f948 	bl	fba6 <memcpy>
				rl[i].local_rpa = &local_rpas[i];
    8916:	f8c5 9024 	str.w	r9, [r5, #36]	; 0x24
			rl[i].rpas_ready = 1U;
    891a:	2328      	movs	r3, #40	; 0x28
    891c:	4373      	muls	r3, r6
    891e:	5cfa      	ldrb	r2, [r7, r3]
    8920:	f042 0202 	orr.w	r2, r2, #2
    8924:	54fa      	strb	r2, [r7, r3]
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
    8926:	3601      	adds	r6, #1
    8928:	2e08      	cmp	r6, #8
    892a:	f105 0528 	add.w	r5, r5, #40	; 0x28
    892e:	f109 0906 	add.w	r9, r9, #6
    8932:	d1a3      	bne.n	887c <ull_filter_rpa_update+0x6c>
	if (all) {
    8934:	f1b8 0f00 	cmp.w	r8, #0
    8938:	d003      	beq.n	8942 <ull_filter_rpa_update+0x132>
		rpa_last_ms = now;
    893a:	4b18      	ldr	r3, [pc, #96]	; (899c <ull_filter_rpa_update+0x18c>)
    893c:	9a01      	ldr	r2, [sp, #4]
    893e:	601c      	str	r4, [r3, #0]
    8940:	605a      	str	r2, [r3, #4]
	if (timeout) {
    8942:	9b00      	ldr	r3, [sp, #0]
    8944:	b31b      	cbz	r3, 898e <ull_filter_rpa_update+0x17e>
		adv = ull_adv_is_enabled_get(0);
    8946:	2000      	movs	r0, #0
    8948:	f7fe fdd4 	bl	74f4 <ull_adv_is_enabled_get>
		if (adv) {
    894c:	4604      	mov	r4, r0
    894e:	b1f0      	cbz	r0, 898e <ull_filter_rpa_update+0x17e>
	if (adv->own_addr_type != BT_ADDR_LE_PUBLIC_ID &&
    8950:	f890 3078 	ldrb.w	r3, [r0, #120]	; 0x78
    8954:	075b      	lsls	r3, r3, #29
    8956:	d51a      	bpl.n	898e <ull_filter_rpa_update+0x17e>
	if (adv->lll.rl_idx >= ARRAY_SIZE(rl)) {
    8958:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
    895c:	2b07      	cmp	r3, #7
    895e:	d816      	bhi.n	898e <ull_filter_rpa_update+0x17e>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    8960:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
    8964:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
    8968:	a902      	add	r1, sp, #8
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    896a:	6a9e      	ldr	r6, [r3, #40]	; 0x28
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
    896c:	3024      	adds	r0, #36	; 0x24
    896e:	f008 ff87 	bl	11880 <lll_adv_pdu_alloc>
	(void)memcpy(pdu, prev, PDU_AC_LL_HEADER_SIZE + prev->len);
    8972:	7872      	ldrb	r2, [r6, #1]
    8974:	4605      	mov	r5, r0
    8976:	3202      	adds	r2, #2
    8978:	4631      	mov	r1, r6
    897a:	f007 f914 	bl	fba6 <memcpy>
	ull_adv_pdu_update_addrs(adv, pdu);
    897e:	4629      	mov	r1, r5
    8980:	4620      	mov	r0, r4
    8982:	f008 fbf2 	bl	1116a <ull_adv_pdu_update_addrs>
	pdu->last = idx;
    8986:	f89d 3008 	ldrb.w	r3, [sp, #8]
    898a:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
}
    898e:	b007      	add	sp, #28
    8990:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	bool all = timeout || (rpa_last_ms == -1) ||
    8994:	f04f 0801 	mov.w	r8, #1
    8998:	e767      	b.n	886a <ull_filter_rpa_update+0x5a>
    899a:	bf00      	nop
    899c:	20000828 	.word	0x20000828
    89a0:	20002170 	.word	0x20002170
    89a4:	20002030 	.word	0x20002030
    89a8:	20002987 	.word	0x20002987
    89ac:	00013624 	.word	0x00013624
    89b0:	000133b6 	.word	0x000133b6
    89b4:	200029c0 	.word	0x200029c0
    89b8:	00013a4f 	.word	0x00013a4f

000089bc <rpa_timeout>:
{
    89bc:	b570      	push	{r4, r5, r6, lr}
	ull_filter_rpa_update(true);
    89be:	2001      	movs	r0, #1
    89c0:	f7ff ff26 	bl	8810 <ull_filter_rpa_update>
	k_work_schedule(&rpa_work, K_MSEC(rpa_timeout_ms));
    89c4:	4b0a      	ldr	r3, [pc, #40]	; (89f0 <rpa_timeout+0x34>)
    89c6:	681d      	ldr	r5, [r3, #0]
    89c8:	f44f 4400 	mov.w	r4, #32768	; 0x8000
    89cc:	f240 30e7 	movw	r0, #999	; 0x3e7
    89d0:	2100      	movs	r1, #0
    89d2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    89d6:	2300      	movs	r3, #0
    89d8:	fbe5 0104 	umlal	r0, r1, r5, r4
    89dc:	f7f7 fb90 	bl	100 <__aeabi_uldivmod>
}
    89e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    89e4:	4602      	mov	r2, r0
    89e6:	460b      	mov	r3, r1
	k_work_schedule(&rpa_work, K_MSEC(rpa_timeout_ms));
    89e8:	4802      	ldr	r0, [pc, #8]	; (89f4 <rpa_timeout+0x38>)
    89ea:	f005 bfe3 	b.w	e9b4 <k_work_schedule>
    89ee:	bf00      	nop
    89f0:	20002170 	.word	0x20002170
    89f4:	20000830 	.word	0x20000830

000089f8 <ull_filter_adva_get>:
	if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].lirk) {
    89f8:	2807      	cmp	r0, #7
{
    89fa:	b538      	push	{r3, r4, r5, lr}
    89fc:	4604      	mov	r4, r0
	if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].lirk) {
    89fe:	d81b      	bhi.n	8a38 <ull_filter_adva_get+0x40>
    8a00:	2328      	movs	r3, #40	; 0x28
    8a02:	4343      	muls	r3, r0
    8a04:	4d0d      	ldr	r5, [pc, #52]	; (8a3c <ull_filter_adva_get+0x44>)
    8a06:	5ceb      	ldrb	r3, [r5, r3]
    8a08:	071a      	lsls	r2, r3, #28
    8a0a:	f3c3 00c0 	ubfx	r0, r3, #3, #1
    8a0e:	d512      	bpl.n	8a36 <ull_filter_adva_get+0x3e>
		LL_ASSERT(rl[rl_idx].rpas_ready);
    8a10:	079b      	lsls	r3, r3, #30
    8a12:	d40c      	bmi.n	8a2e <ull_filter_adva_get+0x36>
    8a14:	4a0a      	ldr	r2, [pc, #40]	; (8a40 <ull_filter_adva_get+0x48>)
    8a16:	490b      	ldr	r1, [pc, #44]	; (8a44 <ull_filter_adva_get+0x4c>)
    8a18:	480b      	ldr	r0, [pc, #44]	; (8a48 <ull_filter_adva_get+0x50>)
    8a1a:	f240 331b 	movw	r3, #795	; 0x31b
    8a1e:	f006 fd52 	bl	f4c6 <printk>
    8a22:	4040      	eors	r0, r0
    8a24:	f380 8811 	msr	BASEPRI, r0
    8a28:	f04f 0003 	mov.w	r0, #3
    8a2c:	df02      	svc	2
		return rl[rl_idx].local_rpa->val;
    8a2e:	2028      	movs	r0, #40	; 0x28
    8a30:	fb00 5404 	mla	r4, r0, r4, r5
    8a34:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
    8a36:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
    8a38:	2000      	movs	r0, #0
    8a3a:	e7fc      	b.n	8a36 <ull_filter_adva_get+0x3e>
    8a3c:	20002030 	.word	0x20002030
    8a40:	00013a4f 	.word	0x00013a4f
    8a44:	00013aad 	.word	0x00013aad
    8a48:	000133b6 	.word	0x000133b6

00008a4c <ull_filter_tgta_get>:
	if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].pirk) {
    8a4c:	2807      	cmp	r0, #7
{
    8a4e:	b510      	push	{r4, lr}
    8a50:	4603      	mov	r3, r0
	if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].pirk) {
    8a52:	d80b      	bhi.n	8a6c <ull_filter_tgta_get+0x20>
    8a54:	2128      	movs	r1, #40	; 0x28
    8a56:	4348      	muls	r0, r1
    8a58:	4a05      	ldr	r2, [pc, #20]	; (8a70 <ull_filter_tgta_get+0x24>)
    8a5a:	5c14      	ldrb	r4, [r2, r0]
    8a5c:	f3c4 0080 	ubfx	r0, r4, #2, #1
    8a60:	0764      	lsls	r4, r4, #29
    8a62:	d502      	bpl.n	8a6a <ull_filter_tgta_get+0x1e>
		return rl[rl_idx].peer_rpa.val;
    8a64:	fb01 2003 	mla	r0, r1, r3, r2
    8a68:	301e      	adds	r0, #30
}
    8a6a:	bd10      	pop	{r4, pc}
	return NULL;
    8a6c:	2000      	movs	r0, #0
    8a6e:	e7fc      	b.n	8a6a <ull_filter_tgta_get+0x1e>
    8a70:	20002030 	.word	0x20002030

00008a74 <ull_filter_rl_find>:
{
    8a74:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8a78:	468b      	mov	fp, r1
	if (free_idx) {
    8a7a:	4614      	mov	r4, r2
    8a7c:	b10a      	cbz	r2, 8a82 <ull_filter_rl_find+0xe>
		*free_idx = FILTER_IDX_NONE;
    8a7e:	23ff      	movs	r3, #255	; 0xff
    8a80:	7013      	strb	r3, [r2, #0]
    8a82:	4f18      	ldr	r7, [pc, #96]	; (8ae4 <ull_filter_rl_find+0x70>)
{
    8a84:	2500      	movs	r5, #0
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
    8a86:	f107 3aff 	add.w	sl, r7, #4294967295	; 0xffffffff
    8a8a:	f000 0601 	and.w	r6, r0, #1
    8a8e:	f04f 0828 	mov.w	r8, #40	; 0x28
    8a92:	fb08 f805 	mul.w	r8, r8, r5
    8a96:	fa5f f985 	uxtb.w	r9, r5
    8a9a:	f81a 3008 	ldrb.w	r3, [sl, r8]
    8a9e:	07da      	lsls	r2, r3, #31
    8aa0:	d51d      	bpl.n	8ade <ull_filter_rl_find+0x6a>
    8aa2:	f3c3 1380 	ubfx	r3, r3, #6, #1
    8aa6:	42b3      	cmp	r3, r6
    8aa8:	d10f      	bne.n	8aca <ull_filter_rl_find+0x56>
    8aaa:	2206      	movs	r2, #6
    8aac:	4659      	mov	r1, fp
    8aae:	4638      	mov	r0, r7
    8ab0:	f007 f850 	bl	fb54 <memcmp>
    8ab4:	b180      	cbz	r0, 8ad8 <ull_filter_rl_find+0x64>
		} else if (free_idx && !rl[i].taken &&
    8ab6:	b144      	cbz	r4, 8aca <ull_filter_rl_find+0x56>
    8ab8:	f81a 3008 	ldrb.w	r3, [sl, r8]
    8abc:	07db      	lsls	r3, r3, #31
    8abe:	d404      	bmi.n	8aca <ull_filter_rl_find+0x56>
    8ac0:	7823      	ldrb	r3, [r4, #0]
    8ac2:	2bff      	cmp	r3, #255	; 0xff
			*free_idx = i;
    8ac4:	bf08      	it	eq
    8ac6:	f884 9000 	strbeq.w	r9, [r4]
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
    8aca:	3501      	adds	r5, #1
    8acc:	2d08      	cmp	r5, #8
    8ace:	f107 0728 	add.w	r7, r7, #40	; 0x28
    8ad2:	d1dc      	bne.n	8a8e <ull_filter_rl_find+0x1a>
	return FILTER_IDX_NONE;
    8ad4:	f04f 09ff 	mov.w	r9, #255	; 0xff
}
    8ad8:	4648      	mov	r0, r9
    8ada:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (free_idx && !rl[i].taken &&
    8ade:	2c00      	cmp	r4, #0
    8ae0:	d1ee      	bne.n	8ac0 <ull_filter_rl_find+0x4c>
    8ae2:	e7f2      	b.n	8aca <ull_filter_rl_find+0x56>
    8ae4:	20002031 	.word	0x20002031

00008ae8 <ll_fal_add>:
{
    8ae8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    8aec:	4607      	mov	r7, r0
	if (ull_adv_filter_pol_get(0)) {
    8aee:	2000      	movs	r0, #0
    8af0:	f008 fb33 	bl	1115a <ull_adv_filter_pol_get>
    8af4:	b118      	cbz	r0, 8afe <ll_fal_add+0x16>
		return BT_HCI_ERR_CMD_DISALLOWED;
    8af6:	200c      	movs	r0, #12
}
    8af8:	b002      	add	sp, #8
    8afa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
    8afe:	f008 fdbc 	bl	1167a <ull_scan_filter_pol_get>
    8b02:	f010 0401 	ands.w	r4, r0, #1
    8b06:	d1f6      	bne.n	8af6 <ll_fal_add+0xe>
	if (addr->type == ADDR_TYPE_ANON) {
    8b08:	7838      	ldrb	r0, [r7, #0]
    8b0a:	28ff      	cmp	r0, #255	; 0xff
    8b0c:	d039      	beq.n	8b82 <ll_fal_add+0x9a>
	i = fal_find(id_addr->type, id_addr->a.val, &j);
    8b0e:	f107 0801 	add.w	r8, r7, #1
    8b12:	f10d 0207 	add.w	r2, sp, #7
    8b16:	4641      	mov	r1, r8
    8b18:	f7ff fca8 	bl	846c <fal_find>
	if (i < ARRAY_SIZE(fal)) {
    8b1c:	2807      	cmp	r0, #7
    8b1e:	d929      	bls.n	8b74 <ll_fal_add+0x8c>
	} else if (j >= ARRAY_SIZE(fal)) {
    8b20:	f89d 6007 	ldrb.w	r6, [sp, #7]
    8b24:	2e07      	cmp	r6, #7
    8b26:	d82a      	bhi.n	8b7e <ll_fal_add+0x96>
	fal[i].id_addr_type = id_addr->type & 0x1;
    8b28:	4d17      	ldr	r5, [pc, #92]	; (8b88 <ll_fal_add+0xa0>)
    8b2a:	783a      	ldrb	r2, [r7, #0]
    8b2c:	f815 3036 	ldrb.w	r3, [r5, r6, lsl #3]
	bt_addr_copy(&fal[i].id_addr, &id_addr->a);
    8b30:	eb05 00c6 	add.w	r0, r5, r6, lsl #3
	fal[i].id_addr_type = id_addr->type & 0x1;
    8b34:	f362 0341 	bfi	r3, r2, #1, #1
    8b38:	4641      	mov	r1, r8
    8b3a:	2206      	movs	r2, #6
    8b3c:	3002      	adds	r0, #2
    8b3e:	f805 3036 	strb.w	r3, [r5, r6, lsl #3]
    8b42:	f007 f830 	bl	fba6 <memcpy>
	j = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    8b46:	7838      	ldrb	r0, [r7, #0]
    8b48:	4622      	mov	r2, r4
    8b4a:	4641      	mov	r1, r8
    8b4c:	f7ff ff92 	bl	8a74 <ull_filter_rl_find>
	if (j < ARRAY_SIZE(rl)) {
    8b50:	00f3      	lsls	r3, r6, #3
    8b52:	2807      	cmp	r0, #7
		fal[i].rl_idx = j;
    8b54:	442b      	add	r3, r5
	if (j < ARRAY_SIZE(rl)) {
    8b56:	d80f      	bhi.n	8b78 <ll_fal_add+0x90>
		fal[i].rl_idx = j;
    8b58:	7058      	strb	r0, [r3, #1]
		rl[j].fal = 1U;
    8b5a:	2328      	movs	r3, #40	; 0x28
    8b5c:	4a0b      	ldr	r2, [pc, #44]	; (8b8c <ll_fal_add+0xa4>)
    8b5e:	4358      	muls	r0, r3
    8b60:	5c13      	ldrb	r3, [r2, r0]
    8b62:	f043 0320 	orr.w	r3, r3, #32
    8b66:	5413      	strb	r3, [r2, r0]
	fal[i].taken = 1U;
    8b68:	f815 3036 	ldrb.w	r3, [r5, r6, lsl #3]
    8b6c:	f043 0301 	orr.w	r3, r3, #1
    8b70:	f805 3036 	strb.w	r3, [r5, r6, lsl #3]
	return fal_add(addr);
    8b74:	b2e0      	uxtb	r0, r4
    8b76:	e7bf      	b.n	8af8 <ll_fal_add+0x10>
		fal[i].rl_idx = FILTER_IDX_NONE;
    8b78:	22ff      	movs	r2, #255	; 0xff
    8b7a:	705a      	strb	r2, [r3, #1]
    8b7c:	e7f4      	b.n	8b68 <ll_fal_add+0x80>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
    8b7e:	2407      	movs	r4, #7
    8b80:	e7f8      	b.n	8b74 <ll_fal_add+0x8c>
		return 0;
    8b82:	4620      	mov	r0, r4
    8b84:	e7b8      	b.n	8af8 <ll_fal_add+0x10>
    8b86:	bf00      	nop
    8b88:	20002915 	.word	0x20002915
    8b8c:	20002030 	.word	0x20002030

00008b90 <ll_rl_add>:
{
    8b90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8b94:	b085      	sub	sp, #20
    8b96:	4680      	mov	r8, r0
    8b98:	468a      	mov	sl, r1
    8b9a:	4693      	mov	fp, r2
	if (!rl_access_check(false)) {
    8b9c:	f008 fd8a 	bl	116b4 <rl_access_check.constprop.0>
    8ba0:	2800      	cmp	r0, #0
    8ba2:	f000 8083 	beq.w	8cac <ll_rl_add+0x11c>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, &j);
    8ba6:	46c1      	mov	r9, r8
    8ba8:	f10d 020f 	add.w	r2, sp, #15
    8bac:	f819 0b01 	ldrb.w	r0, [r9], #1
    8bb0:	4649      	mov	r1, r9
    8bb2:	f7ff ff5f 	bl	8a74 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
    8bb6:	2807      	cmp	r0, #7
    8bb8:	d97a      	bls.n	8cb0 <ll_rl_add+0x120>
	} else if (j >= ARRAY_SIZE(rl)) {
    8bba:	f89d 500f 	ldrb.w	r5, [sp, #15]
    8bbe:	2d07      	cmp	r5, #7
    8bc0:	d878      	bhi.n	8cb4 <ll_rl_add+0x124>
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
    8bc2:	eb05 0785 	add.w	r7, r5, r5, lsl #2
    8bc6:	4c3c      	ldr	r4, [pc, #240]	; (8cb8 <ll_rl_add+0x128>)
    8bc8:	00ff      	lsls	r7, r7, #3
	rl[i].id_addr_type = id_addr->type & 0x1;
    8bca:	2628      	movs	r6, #40	; 0x28
    8bcc:	436e      	muls	r6, r5
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
    8bce:	1c78      	adds	r0, r7, #1
    8bd0:	2206      	movs	r2, #6
    8bd2:	4649      	mov	r1, r9
    8bd4:	4420      	add	r0, r4
    8bd6:	f006 ffe6 	bl	fba6 <memcpy>
	rl[i].id_addr_type = id_addr->type & 0x1;
    8bda:	f898 1000 	ldrb.w	r1, [r8]
    8bde:	5da3      	ldrb	r3, [r4, r6]
    8be0:	19a2      	adds	r2, r4, r6
    8be2:	f361 1386 	bfi	r3, r1, #6, #1
	rl[i].pirk = mem_nz((uint8_t *)pirk, IRK_SIZE);
    8be6:	4650      	mov	r0, sl
    8be8:	2110      	movs	r1, #16
	rl[i].id_addr_type = id_addr->type & 0x1;
    8bea:	9201      	str	r2, [sp, #4]
    8bec:	55a3      	strb	r3, [r4, r6]
	rl[i].pirk = mem_nz((uint8_t *)pirk, IRK_SIZE);
    8bee:	f007 fd59 	bl	106a4 <mem_nz>
    8bf2:	5da3      	ldrb	r3, [r4, r6]
	rl[i].lirk = mem_nz((uint8_t *)lirk, IRK_SIZE);
    8bf4:	2110      	movs	r1, #16
	rl[i].pirk = mem_nz((uint8_t *)pirk, IRK_SIZE);
    8bf6:	f360 0382 	bfi	r3, r0, #2, #1
	rl[i].lirk = mem_nz((uint8_t *)lirk, IRK_SIZE);
    8bfa:	4658      	mov	r0, fp
	rl[i].pirk = mem_nz((uint8_t *)pirk, IRK_SIZE);
    8bfc:	55a3      	strb	r3, [r4, r6]
	rl[i].lirk = mem_nz((uint8_t *)lirk, IRK_SIZE);
    8bfe:	f007 fd51 	bl	106a4 <mem_nz>
    8c02:	5da3      	ldrb	r3, [r4, r6]
	if (rl[i].pirk) {
    8c04:	9a01      	ldr	r2, [sp, #4]
	rl[i].lirk = mem_nz((uint8_t *)lirk, IRK_SIZE);
    8c06:	f000 0001 	and.w	r0, r0, #1
    8c0a:	f360 03c3 	bfi	r3, r0, #3, #1
	if (rl[i].pirk) {
    8c0e:	f013 0f04 	tst.w	r3, #4
	rl[i].lirk = mem_nz((uint8_t *)lirk, IRK_SIZE);
    8c12:	55a3      	strb	r3, [r4, r6]
	if (rl[i].pirk) {
    8c14:	d136      	bne.n	8c84 <ll_rl_add+0xf4>
	if (rl[i].lirk) {
    8c16:	b150      	cbz	r0, 8c2e <ll_rl_add+0x9e>
		(void)memcpy(rl[i].local_irk, lirk, IRK_SIZE);
    8c18:	1df8      	adds	r0, r7, #7
    8c1a:	2210      	movs	r2, #16
    8c1c:	4659      	mov	r1, fp
    8c1e:	4420      	add	r0, r4
    8c20:	f006 ffc1 	bl	fba6 <memcpy>
		rl[i].local_rpa = NULL;
    8c24:	2328      	movs	r3, #40	; 0x28
    8c26:	fb03 4305 	mla	r3, r3, r5, r4
    8c2a:	2200      	movs	r2, #0
    8c2c:	625a      	str	r2, [r3, #36]	; 0x24
	memset(rl[i].curr_rpa.val, 0x00, sizeof(rl[i].curr_rpa));
    8c2e:	2628      	movs	r6, #40	; 0x28
    8c30:	436e      	muls	r6, r5
    8c32:	f107 0018 	add.w	r0, r7, #24
    8c36:	2206      	movs	r2, #6
    8c38:	2100      	movs	r1, #0
    8c3a:	4420      	add	r0, r4
    8c3c:	f006 ffbe 	bl	fbbc <memset>
	rl[i].rpas_ready = 0U;
    8c40:	5da3      	ldrb	r3, [r4, r6]
    8c42:	f023 0312 	bic.w	r3, r3, #18
    8c46:	55a3      	strb	r3, [r4, r6]
	j = fal_find(id_addr->type, id_addr->a.val, NULL);
    8c48:	2200      	movs	r2, #0
    8c4a:	f898 0000 	ldrb.w	r0, [r8]
    8c4e:	4649      	mov	r1, r9
    8c50:	f7ff fc0c 	bl	846c <fal_find>
	if (j < ARRAY_SIZE(fal)) {
    8c54:	2807      	cmp	r0, #7
    8c56:	5da3      	ldrb	r3, [r4, r6]
		fal[j].rl_idx = i;
    8c58:	bf9d      	ittte	ls
    8c5a:	4a18      	ldrls	r2, [pc, #96]	; (8cbc <ll_rl_add+0x12c>)
		rl[i].fal = 1U;
    8c5c:	f043 0320 	orrls.w	r3, r3, #32
		fal[j].rl_idx = i;
    8c60:	eb02 00c0 	addls.w	r0, r2, r0, lsl #3
		rl[i].fal = 0U;
    8c64:	f36f 1345 	bfchi	r3, #5, #1
    8c68:	55a3      	strb	r3, [r4, r6]
	rl[i].taken = 1U;
    8c6a:	f04f 0328 	mov.w	r3, #40	; 0x28
		fal[j].rl_idx = i;
    8c6e:	bf98      	it	ls
    8c70:	7045      	strbls	r5, [r0, #1]
	rl[i].taken = 1U;
    8c72:	435d      	muls	r5, r3
	return 0;
    8c74:	2000      	movs	r0, #0
	rl[i].taken = 1U;
    8c76:	5d63      	ldrb	r3, [r4, r5]
    8c78:	f043 0301 	orr.w	r3, r3, #1
    8c7c:	5563      	strb	r3, [r4, r5]
}
    8c7e:	b005      	add	sp, #20
    8c80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rl[i].pirk_idx = peer_irk_count;
    8c84:	4b0e      	ldr	r3, [pc, #56]	; (8cc0 <ll_rl_add+0x130>)
    8c86:	7819      	ldrb	r1, [r3, #0]
    8c88:	75d1      	strb	r1, [r2, #23]
		peer_irk_rl_ids[peer_irk_count] = i;
    8c8a:	4a0e      	ldr	r2, [pc, #56]	; (8cc4 <ll_rl_add+0x134>)
    8c8c:	5455      	strb	r5, [r2, r1]
		sys_memcpy_swap(peer_irks[peer_irk_count++], pirk, IRK_SIZE);
    8c8e:	1c4a      	adds	r2, r1, #1
    8c90:	701a      	strb	r2, [r3, #0]
    8c92:	4b0d      	ldr	r3, [pc, #52]	; (8cc8 <ll_rl_add+0x138>)
    8c94:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    8c98:	f10a 0210 	add.w	r2, sl, #16
    8c9c:	3b01      	subs	r3, #1
		*pdst++ = *psrc--;
    8c9e:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
    8ca2:	f803 1f01 	strb.w	r1, [r3, #1]!
	for (; length > 0; length--) {
    8ca6:	4552      	cmp	r2, sl
    8ca8:	d1f9      	bne.n	8c9e <ll_rl_add+0x10e>
    8caa:	e7b4      	b.n	8c16 <ll_rl_add+0x86>
		return BT_HCI_ERR_CMD_DISALLOWED;
    8cac:	200c      	movs	r0, #12
    8cae:	e7e6      	b.n	8c7e <ll_rl_add+0xee>
		return BT_HCI_ERR_INVALID_PARAM;
    8cb0:	2012      	movs	r0, #18
    8cb2:	e7e4      	b.n	8c7e <ll_rl_add+0xee>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
    8cb4:	2007      	movs	r0, #7
    8cb6:	e7e2      	b.n	8c7e <ll_rl_add+0xee>
    8cb8:	20002030 	.word	0x20002030
    8cbc:	20002915 	.word	0x20002915
    8cc0:	200029b7 	.word	0x200029b7
    8cc4:	200029b8 	.word	0x200029b8
    8cc8:	200029c0 	.word	0x200029c0

00008ccc <ll_rl_remove>:
{
    8ccc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8cd0:	4607      	mov	r7, r0
	if (!rl_access_check(false)) {
    8cd2:	f008 fcef 	bl	116b4 <rl_access_check.constprop.0>
    8cd6:	2800      	cmp	r0, #0
    8cd8:	d05b      	beq.n	8d92 <ll_rl_remove+0xc6>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    8cda:	46b8      	mov	r8, r7
    8cdc:	2200      	movs	r2, #0
    8cde:	f818 0b01 	ldrb.w	r0, [r8], #1
    8ce2:	4641      	mov	r1, r8
    8ce4:	f7ff fec6 	bl	8a74 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
    8ce8:	2807      	cmp	r0, #7
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    8cea:	4604      	mov	r4, r0
	if (i < ARRAY_SIZE(rl)) {
    8cec:	d853      	bhi.n	8d96 <ll_rl_remove+0xca>
		if (rl[i].pirk) {
    8cee:	f04f 0b28 	mov.w	fp, #40	; 0x28
    8cf2:	4e2a      	ldr	r6, [pc, #168]	; (8d9c <ll_rl_remove+0xd0>)
    8cf4:	fb0b f300 	mul.w	r3, fp, r0
    8cf8:	18f2      	adds	r2, r6, r3
    8cfa:	5cf3      	ldrb	r3, [r6, r3]
    8cfc:	075b      	lsls	r3, r3, #29
    8cfe:	d52d      	bpl.n	8d5c <ll_rl_remove+0x90>
			uint8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
    8d00:	f8df a09c 	ldr.w	sl, [pc, #156]	; 8da0 <ll_rl_remove+0xd4>
    8d04:	f89a 5000 	ldrb.w	r5, [sl]
    8d08:	3d01      	subs	r5, #1
			if (pj && pi != pj) {
    8d0a:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
    8d0e:	d020      	beq.n	8d52 <ll_rl_remove+0x86>
			uint8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
    8d10:	f892 9017 	ldrb.w	r9, [r2, #23]
			if (pj && pi != pj) {
    8d14:	45a9      	cmp	r9, r5
    8d16:	d01c      	beq.n	8d52 <ll_rl_remove+0x86>
				(void)memcpy(peer_irks[pi], peer_irks[pj],
    8d18:	4822      	ldr	r0, [pc, #136]	; (8da4 <ll_rl_remove+0xd8>)
    8d1a:	2210      	movs	r2, #16
    8d1c:	eb00 1105 	add.w	r1, r0, r5, lsl #4
    8d20:	eb00 1009 	add.w	r0, r0, r9, lsl #4
    8d24:	f006 ff3f 	bl	fba6 <memcpy>
				     k < CONFIG_BT_CTLR_RL_SIZE;
    8d28:	4632      	mov	r2, r6
				(void)memcpy(peer_irks[pi], peer_irks[pj],
    8d2a:	2300      	movs	r3, #0
					if (rl[k].taken && rl[k].pirk &&
    8d2c:	fb0b f103 	mul.w	r1, fp, r3
    8d30:	eb06 0c01 	add.w	ip, r6, r1
    8d34:	5c71      	ldrb	r1, [r6, r1]
    8d36:	f011 0f01 	tst.w	r1, #1
    8d3a:	b2d8      	uxtb	r0, r3
    8d3c:	d023      	beq.n	8d86 <ll_rl_remove+0xba>
    8d3e:	0749      	lsls	r1, r1, #29
    8d40:	d521      	bpl.n	8d86 <ll_rl_remove+0xba>
    8d42:	7dd1      	ldrb	r1, [r2, #23]
    8d44:	42a9      	cmp	r1, r5
    8d46:	d11e      	bne.n	8d86 <ll_rl_remove+0xba>
						peer_irk_rl_ids[pi] = k;
    8d48:	4b17      	ldr	r3, [pc, #92]	; (8da8 <ll_rl_remove+0xdc>)
						rl[k].pirk_idx = pi;
    8d4a:	f88c 9017 	strb.w	r9, [ip, #23]
						peer_irk_rl_ids[pi] = k;
    8d4e:	f803 0009 	strb.w	r0, [r3, r9]
			peer_irk_count--;
    8d52:	f89a 3000 	ldrb.w	r3, [sl]
    8d56:	3b01      	subs	r3, #1
    8d58:	f88a 3000 	strb.w	r3, [sl]
		j = fal_find(id_addr->type, id_addr->a.val, NULL);
    8d5c:	7838      	ldrb	r0, [r7, #0]
    8d5e:	2200      	movs	r2, #0
    8d60:	4641      	mov	r1, r8
    8d62:	f7ff fb83 	bl	846c <fal_find>
		if (j < ARRAY_SIZE(fal)) {
    8d66:	2807      	cmp	r0, #7
			fal[j].rl_idx = FILTER_IDX_NONE;
    8d68:	bf9f      	itttt	ls
    8d6a:	4b10      	ldrls	r3, [pc, #64]	; (8dac <ll_rl_remove+0xe0>)
    8d6c:	eb03 00c0 	addls.w	r0, r3, r0, lsl #3
    8d70:	23ff      	movls	r3, #255	; 0xff
    8d72:	7043      	strbls	r3, [r0, #1]
		rl[i].taken = 0U;
    8d74:	2028      	movs	r0, #40	; 0x28
    8d76:	4344      	muls	r4, r0
		return 0;
    8d78:	2000      	movs	r0, #0
		rl[i].taken = 0U;
    8d7a:	5d33      	ldrb	r3, [r6, r4]
    8d7c:	f36f 0300 	bfc	r3, #0, #1
    8d80:	5533      	strb	r3, [r6, r4]
}
    8d82:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				for (k = 0U;
    8d86:	3301      	adds	r3, #1
    8d88:	2b08      	cmp	r3, #8
    8d8a:	f102 0228 	add.w	r2, r2, #40	; 0x28
    8d8e:	d1cd      	bne.n	8d2c <ll_rl_remove+0x60>
    8d90:	e7df      	b.n	8d52 <ll_rl_remove+0x86>
		return BT_HCI_ERR_CMD_DISALLOWED;
    8d92:	200c      	movs	r0, #12
    8d94:	e7f5      	b.n	8d82 <ll_rl_remove+0xb6>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
    8d96:	2002      	movs	r0, #2
    8d98:	e7f3      	b.n	8d82 <ll_rl_remove+0xb6>
    8d9a:	bf00      	nop
    8d9c:	20002030 	.word	0x20002030
    8da0:	200029b7 	.word	0x200029b7
    8da4:	200029c0 	.word	0x200029c0
    8da8:	200029b8 	.word	0x200029b8
    8dac:	20002915 	.word	0x20002915

00008db0 <ll_rl_crpa_set>:
{
    8db0:	b538      	push	{r3, r4, r5, lr}
    8db2:	461d      	mov	r5, r3
	if ((crpa[5] & 0xc0) == 0x40) {
    8db4:	795b      	ldrb	r3, [r3, #5]
    8db6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    8dba:	2b40      	cmp	r3, #64	; 0x40
    8dbc:	d117      	bne.n	8dee <ll_rl_crpa_set+0x3e>
		if (id_addr) {
    8dbe:	b119      	cbz	r1, 8dc8 <ll_rl_crpa_set+0x18>
			rl_idx = ull_filter_rl_find(id_addr_type, id_addr,
    8dc0:	2200      	movs	r2, #0
    8dc2:	f7ff fe57 	bl	8a74 <ull_filter_rl_find>
    8dc6:	4602      	mov	r2, r0
		if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].taken) {
    8dc8:	2a07      	cmp	r2, #7
    8dca:	d810      	bhi.n	8dee <ll_rl_crpa_set+0x3e>
    8dcc:	2428      	movs	r4, #40	; 0x28
    8dce:	4808      	ldr	r0, [pc, #32]	; (8df0 <ll_rl_crpa_set+0x40>)
    8dd0:	fb04 f302 	mul.w	r3, r4, r2
    8dd4:	5cc3      	ldrb	r3, [r0, r3]
    8dd6:	07db      	lsls	r3, r3, #31
    8dd8:	d509      	bpl.n	8dee <ll_rl_crpa_set+0x3e>
			(void)memcpy(rl[rl_idx].curr_rpa.val, crpa,
    8dda:	2318      	movs	r3, #24
    8ddc:	fb14 3402 	smlabb	r4, r4, r2, r3
    8de0:	4629      	mov	r1, r5
    8de2:	4420      	add	r0, r4
    8de4:	2206      	movs	r2, #6
}
    8de6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			(void)memcpy(rl[rl_idx].curr_rpa.val, crpa,
    8dea:	f006 bedc 	b.w	fba6 <memcpy>
}
    8dee:	bd38      	pop	{r3, r4, r5, pc}
    8df0:	20002030 	.word	0x20002030

00008df4 <ll_rl_crpa_get>:
{
    8df4:	b538      	push	{r3, r4, r5, lr}
    8df6:	460d      	mov	r5, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    8df8:	4601      	mov	r1, r0
    8dfa:	2200      	movs	r2, #0
    8dfc:	f811 0b01 	ldrb.w	r0, [r1], #1
    8e00:	f7ff fe38 	bl	8a74 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl) &&
    8e04:	2807      	cmp	r0, #7
    8e06:	d901      	bls.n	8e0c <ll_rl_crpa_get+0x18>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
    8e08:	2002      	movs	r0, #2
}
    8e0a:	bd38      	pop	{r3, r4, r5, pc}
	    mem_nz(rl[i].curr_rpa.val, sizeof(rl[i].curr_rpa.val))) {
    8e0c:	2428      	movs	r4, #40	; 0x28
    8e0e:	2318      	movs	r3, #24
    8e10:	fb14 3000 	smlabb	r0, r4, r0, r3
    8e14:	4c07      	ldr	r4, [pc, #28]	; (8e34 <ll_rl_crpa_get+0x40>)
    8e16:	4404      	add	r4, r0
    8e18:	2106      	movs	r1, #6
    8e1a:	4620      	mov	r0, r4
    8e1c:	f007 fc42 	bl	106a4 <mem_nz>
	if (i < ARRAY_SIZE(rl) &&
    8e20:	2800      	cmp	r0, #0
    8e22:	d0f1      	beq.n	8e08 <ll_rl_crpa_get+0x14>
    8e24:	2206      	movs	r2, #6
    8e26:	4621      	mov	r1, r4
    8e28:	4628      	mov	r0, r5
    8e2a:	f006 febc 	bl	fba6 <memcpy>
		return 0;
    8e2e:	2000      	movs	r0, #0
}
    8e30:	e7eb      	b.n	8e0a <ll_rl_crpa_get+0x16>
    8e32:	bf00      	nop
    8e34:	20002030 	.word	0x20002030

00008e38 <ll_rl_lrpa_get>:
{
    8e38:	b510      	push	{r4, lr}
    8e3a:	460c      	mov	r4, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    8e3c:	4601      	mov	r1, r0
    8e3e:	2200      	movs	r2, #0
    8e40:	f811 0b01 	ldrb.w	r0, [r1], #1
    8e44:	f7ff fe16 	bl	8a74 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
    8e48:	2807      	cmp	r0, #7
    8e4a:	d80a      	bhi.n	8e62 <ll_rl_lrpa_get+0x2a>
		bt_addr_copy(lrpa, rl[i].local_rpa);
    8e4c:	4b06      	ldr	r3, [pc, #24]	; (8e68 <ll_rl_lrpa_get+0x30>)
    8e4e:	2228      	movs	r2, #40	; 0x28
    8e50:	fb02 3000 	mla	r0, r2, r0, r3
	memcpy(dst, src, sizeof(*dst));
    8e54:	2206      	movs	r2, #6
    8e56:	6a41      	ldr	r1, [r0, #36]	; 0x24
    8e58:	4620      	mov	r0, r4
    8e5a:	f006 fea4 	bl	fba6 <memcpy>
		return 0;
    8e5e:	2000      	movs	r0, #0
}
    8e60:	bd10      	pop	{r4, pc}
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
    8e62:	2002      	movs	r0, #2
    8e64:	e7fc      	b.n	8e60 <ll_rl_lrpa_get+0x28>
    8e66:	bf00      	nop
    8e68:	20002030 	.word	0x20002030

00008e6c <ll_priv_mode_set>:
{
    8e6c:	b538      	push	{r3, r4, r5, lr}
    8e6e:	4605      	mov	r5, r0
    8e70:	460c      	mov	r4, r1
	if (!rl_access_check(false)) {
    8e72:	f008 fc1f 	bl	116b4 <rl_access_check.constprop.0>
    8e76:	b1f0      	cbz	r0, 8eb6 <ll_priv_mode_set+0x4a>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
    8e78:	4629      	mov	r1, r5
    8e7a:	2200      	movs	r2, #0
    8e7c:	f811 0b01 	ldrb.w	r0, [r1], #1
    8e80:	f7ff fdf8 	bl	8a74 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
    8e84:	2807      	cmp	r0, #7
    8e86:	d818      	bhi.n	8eba <ll_priv_mode_set+0x4e>
		switch (mode) {
    8e88:	b124      	cbz	r4, 8e94 <ll_priv_mode_set+0x28>
    8e8a:	2c01      	cmp	r4, #1
    8e8c:	d00a      	beq.n	8ea4 <ll_priv_mode_set+0x38>
    8e8e:	2412      	movs	r4, #18
}
    8e90:	4620      	mov	r0, r4
    8e92:	bd38      	pop	{r3, r4, r5, pc}
			rl[i].dev = 0U;
    8e94:	2228      	movs	r2, #40	; 0x28
    8e96:	4b0a      	ldr	r3, [pc, #40]	; (8ec0 <ll_priv_mode_set+0x54>)
    8e98:	4350      	muls	r0, r2
    8e9a:	5c1a      	ldrb	r2, [r3, r0]
    8e9c:	f364 1204 	bfi	r2, r4, #4, #1
    8ea0:	541a      	strb	r2, [r3, r0]
			break;
    8ea2:	e7f5      	b.n	8e90 <ll_priv_mode_set+0x24>
			rl[i].dev = 1U;
    8ea4:	2328      	movs	r3, #40	; 0x28
    8ea6:	4a06      	ldr	r2, [pc, #24]	; (8ec0 <ll_priv_mode_set+0x54>)
    8ea8:	4358      	muls	r0, r3
	return 0;
    8eaa:	2400      	movs	r4, #0
			rl[i].dev = 1U;
    8eac:	5c13      	ldrb	r3, [r2, r0]
    8eae:	f043 0310 	orr.w	r3, r3, #16
    8eb2:	5413      	strb	r3, [r2, r0]
			break;
    8eb4:	e7ec      	b.n	8e90 <ll_priv_mode_set+0x24>
		return BT_HCI_ERR_CMD_DISALLOWED;
    8eb6:	240c      	movs	r4, #12
    8eb8:	e7ea      	b.n	8e90 <ll_priv_mode_set+0x24>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
    8eba:	2402      	movs	r4, #2
    8ebc:	e7e8      	b.n	8e90 <ll_priv_mode_set+0x24>
    8ebe:	bf00      	nop
    8ec0:	20002030 	.word	0x20002030

00008ec4 <ull_filter_lll_lrpa_get>:
	if ((rl_idx >= ARRAY_SIZE(rl)) || !rl[rl_idx].lirk ||
    8ec4:	2807      	cmp	r0, #7
    8ec6:	d80e      	bhi.n	8ee6 <ull_filter_lll_lrpa_get+0x22>
    8ec8:	2228      	movs	r2, #40	; 0x28
    8eca:	4350      	muls	r0, r2
    8ecc:	4b07      	ldr	r3, [pc, #28]	; (8eec <ull_filter_lll_lrpa_get+0x28>)
    8ece:	181a      	adds	r2, r3, r0
    8ed0:	5c1b      	ldrb	r3, [r3, r0]
    8ed2:	0719      	lsls	r1, r3, #28
    8ed4:	f3c3 00c0 	ubfx	r0, r3, #3, #1
    8ed8:	d506      	bpl.n	8ee8 <ull_filter_lll_lrpa_get+0x24>
    8eda:	f3c3 0040 	ubfx	r0, r3, #1, #1
    8ede:	079b      	lsls	r3, r3, #30
    8ee0:	d502      	bpl.n	8ee8 <ull_filter_lll_lrpa_get+0x24>
	return rl[rl_idx].local_rpa;
    8ee2:	6a50      	ldr	r0, [r2, #36]	; 0x24
    8ee4:	4770      	bx	lr
		return NULL;
    8ee6:	2000      	movs	r0, #0
}
    8ee8:	4770      	bx	lr
    8eea:	bf00      	nop
    8eec:	20002030 	.word	0x20002030

00008ef0 <ull_filter_lll_irks_get>:
	*count = peer_irk_count;
    8ef0:	4b02      	ldr	r3, [pc, #8]	; (8efc <ull_filter_lll_irks_get+0xc>)
    8ef2:	781b      	ldrb	r3, [r3, #0]
    8ef4:	7003      	strb	r3, [r0, #0]
}
    8ef6:	4802      	ldr	r0, [pc, #8]	; (8f00 <ull_filter_lll_irks_get+0x10>)
    8ef8:	4770      	bx	lr
    8efa:	bf00      	nop
    8efc:	200029b7 	.word	0x200029b7
    8f00:	200029c0 	.word	0x200029c0

00008f04 <ull_filter_lll_rl_idx>:
{
    8f04:	b538      	push	{r3, r4, r5, lr}
    8f06:	460c      	mov	r4, r1
	if (filter) {
    8f08:	b328      	cbz	r0, 8f56 <ull_filter_lll_rl_idx+0x52>
		LL_ASSERT(devmatch_id < ARRAY_SIZE(fal));
    8f0a:	2907      	cmp	r1, #7
    8f0c:	d90c      	bls.n	8f28 <ull_filter_lll_rl_idx+0x24>
    8f0e:	4a23      	ldr	r2, [pc, #140]	; (8f9c <ull_filter_lll_rl_idx+0x98>)
    8f10:	4923      	ldr	r1, [pc, #140]	; (8fa0 <ull_filter_lll_rl_idx+0x9c>)
    8f12:	4824      	ldr	r0, [pc, #144]	; (8fa4 <ull_filter_lll_rl_idx+0xa0>)
    8f14:	f44f 7357 	mov.w	r3, #860	; 0x35c
    8f18:	f006 fad5 	bl	f4c6 <printk>
    8f1c:	4040      	eors	r0, r0
    8f1e:	f380 8811 	msr	BASEPRI, r0
    8f22:	f04f 0003 	mov.w	r0, #3
    8f26:	df02      	svc	2
		LL_ASSERT(fal[devmatch_id].taken);
    8f28:	4d1f      	ldr	r5, [pc, #124]	; (8fa8 <ull_filter_lll_rl_idx+0xa4>)
    8f2a:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
    8f2e:	07da      	lsls	r2, r3, #31
    8f30:	d40c      	bmi.n	8f4c <ull_filter_lll_rl_idx+0x48>
    8f32:	4a1a      	ldr	r2, [pc, #104]	; (8f9c <ull_filter_lll_rl_idx+0x98>)
    8f34:	491d      	ldr	r1, [pc, #116]	; (8fac <ull_filter_lll_rl_idx+0xa8>)
    8f36:	481b      	ldr	r0, [pc, #108]	; (8fa4 <ull_filter_lll_rl_idx+0xa0>)
    8f38:	f240 335d 	movw	r3, #861	; 0x35d
    8f3c:	f006 fac3 	bl	f4c6 <printk>
    8f40:	4040      	eors	r0, r0
    8f42:	f380 8811 	msr	BASEPRI, r0
    8f46:	f04f 0003 	mov.w	r0, #3
    8f4a:	df02      	svc	2
		i = fal[devmatch_id].rl_idx;
    8f4c:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
    8f50:	7864      	ldrb	r4, [r4, #1]
}
    8f52:	4620      	mov	r0, r4
    8f54:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(devmatch_id < ARRAY_SIZE(rl));
    8f56:	2907      	cmp	r1, #7
    8f58:	d90c      	bls.n	8f74 <ull_filter_lll_rl_idx+0x70>
    8f5a:	4a10      	ldr	r2, [pc, #64]	; (8f9c <ull_filter_lll_rl_idx+0x98>)
    8f5c:	4914      	ldr	r1, [pc, #80]	; (8fb0 <ull_filter_lll_rl_idx+0xac>)
    8f5e:	4811      	ldr	r0, [pc, #68]	; (8fa4 <ull_filter_lll_rl_idx+0xa0>)
    8f60:	f44f 7358 	mov.w	r3, #864	; 0x360
    8f64:	f006 faaf 	bl	f4c6 <printk>
    8f68:	4040      	eors	r0, r0
    8f6a:	f380 8811 	msr	BASEPRI, r0
    8f6e:	f04f 0003 	mov.w	r0, #3
    8f72:	df02      	svc	2
		LL_ASSERT(rl[i].taken);
    8f74:	2328      	movs	r3, #40	; 0x28
    8f76:	4a0f      	ldr	r2, [pc, #60]	; (8fb4 <ull_filter_lll_rl_idx+0xb0>)
    8f78:	4363      	muls	r3, r4
    8f7a:	5cd3      	ldrb	r3, [r2, r3]
    8f7c:	07db      	lsls	r3, r3, #31
    8f7e:	d4e8      	bmi.n	8f52 <ull_filter_lll_rl_idx+0x4e>
    8f80:	4a06      	ldr	r2, [pc, #24]	; (8f9c <ull_filter_lll_rl_idx+0x98>)
    8f82:	490d      	ldr	r1, [pc, #52]	; (8fb8 <ull_filter_lll_rl_idx+0xb4>)
    8f84:	4807      	ldr	r0, [pc, #28]	; (8fa4 <ull_filter_lll_rl_idx+0xa0>)
    8f86:	f240 3362 	movw	r3, #866	; 0x362
    8f8a:	f006 fa9c 	bl	f4c6 <printk>
    8f8e:	4040      	eors	r0, r0
    8f90:	f380 8811 	msr	BASEPRI, r0
    8f94:	f04f 0003 	mov.w	r0, #3
    8f98:	df02      	svc	2
    8f9a:	e7da      	b.n	8f52 <ull_filter_lll_rl_idx+0x4e>
    8f9c:	00013a4f 	.word	0x00013a4f
    8fa0:	00013ac3 	.word	0x00013ac3
    8fa4:	000133b6 	.word	0x000133b6
    8fa8:	20002915 	.word	0x20002915
    8fac:	00013b6a 	.word	0x00013b6a
    8fb0:	00013b81 	.word	0x00013b81
    8fb4:	20002030 	.word	0x20002030
    8fb8:	00013c24 	.word	0x00013c24

00008fbc <ull_filter_lll_rl_irk_idx>:
{
    8fbc:	b510      	push	{r4, lr}
	LL_ASSERT(irkmatch_id < peer_irk_count);
    8fbe:	4b1c      	ldr	r3, [pc, #112]	; (9030 <ull_filter_lll_rl_irk_idx+0x74>)
    8fc0:	781b      	ldrb	r3, [r3, #0]
    8fc2:	4283      	cmp	r3, r0
{
    8fc4:	4604      	mov	r4, r0
	LL_ASSERT(irkmatch_id < peer_irk_count);
    8fc6:	d80c      	bhi.n	8fe2 <ull_filter_lll_rl_irk_idx+0x26>
    8fc8:	4a1a      	ldr	r2, [pc, #104]	; (9034 <ull_filter_lll_rl_irk_idx+0x78>)
    8fca:	491b      	ldr	r1, [pc, #108]	; (9038 <ull_filter_lll_rl_irk_idx+0x7c>)
    8fcc:	481b      	ldr	r0, [pc, #108]	; (903c <ull_filter_lll_rl_irk_idx+0x80>)
    8fce:	f44f 735b 	mov.w	r3, #876	; 0x36c
    8fd2:	f006 fa78 	bl	f4c6 <printk>
    8fd6:	4040      	eors	r0, r0
    8fd8:	f380 8811 	msr	BASEPRI, r0
    8fdc:	f04f 0003 	mov.w	r0, #3
    8fe0:	df02      	svc	2
	i = peer_irk_rl_ids[irkmatch_id];
    8fe2:	4b17      	ldr	r3, [pc, #92]	; (9040 <ull_filter_lll_rl_irk_idx+0x84>)
    8fe4:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(i < CONFIG_BT_CTLR_RL_SIZE);
    8fe6:	2c07      	cmp	r4, #7
    8fe8:	d90c      	bls.n	9004 <ull_filter_lll_rl_irk_idx+0x48>
    8fea:	4a12      	ldr	r2, [pc, #72]	; (9034 <ull_filter_lll_rl_irk_idx+0x78>)
    8fec:	4915      	ldr	r1, [pc, #84]	; (9044 <ull_filter_lll_rl_irk_idx+0x88>)
    8fee:	4813      	ldr	r0, [pc, #76]	; (903c <ull_filter_lll_rl_irk_idx+0x80>)
    8ff0:	f240 336e 	movw	r3, #878	; 0x36e
    8ff4:	f006 fa67 	bl	f4c6 <printk>
    8ff8:	4040      	eors	r0, r0
    8ffa:	f380 8811 	msr	BASEPRI, r0
    8ffe:	f04f 0003 	mov.w	r0, #3
    9002:	df02      	svc	2
	LL_ASSERT(rl[i].taken);
    9004:	2328      	movs	r3, #40	; 0x28
    9006:	4a10      	ldr	r2, [pc, #64]	; (9048 <ull_filter_lll_rl_irk_idx+0x8c>)
    9008:	4363      	muls	r3, r4
    900a:	5cd3      	ldrb	r3, [r2, r3]
    900c:	07db      	lsls	r3, r3, #31
    900e:	d40c      	bmi.n	902a <ull_filter_lll_rl_irk_idx+0x6e>
    9010:	4a08      	ldr	r2, [pc, #32]	; (9034 <ull_filter_lll_rl_irk_idx+0x78>)
    9012:	490e      	ldr	r1, [pc, #56]	; (904c <ull_filter_lll_rl_irk_idx+0x90>)
    9014:	4809      	ldr	r0, [pc, #36]	; (903c <ull_filter_lll_rl_irk_idx+0x80>)
    9016:	f240 336f 	movw	r3, #879	; 0x36f
    901a:	f006 fa54 	bl	f4c6 <printk>
    901e:	4040      	eors	r0, r0
    9020:	f380 8811 	msr	BASEPRI, r0
    9024:	f04f 0003 	mov.w	r0, #3
    9028:	df02      	svc	2
}
    902a:	4620      	mov	r0, r4
    902c:	bd10      	pop	{r4, pc}
    902e:	bf00      	nop
    9030:	200029b7 	.word	0x200029b7
    9034:	00013a4f 	.word	0x00013a4f
    9038:	00013c30 	.word	0x00013c30
    903c:	000133b6 	.word	0x000133b6
    9040:	200029b8 	.word	0x200029b8
    9044:	00013c4d 	.word	0x00013c4d
    9048:	20002030 	.word	0x20002030
    904c:	00013c24 	.word	0x00013c24

00009050 <ull_filter_lll_irk_in_fal>:
	if (rl_idx >= ARRAY_SIZE(rl)) {
    9050:	2807      	cmp	r0, #7
{
    9052:	b538      	push	{r3, r4, r5, lr}
    9054:	4604      	mov	r4, r0
	if (rl_idx >= ARRAY_SIZE(rl)) {
    9056:	d818      	bhi.n	908a <ull_filter_lll_irk_in_fal+0x3a>
	LL_ASSERT(rl[rl_idx].taken);
    9058:	2328      	movs	r3, #40	; 0x28
    905a:	4d0d      	ldr	r5, [pc, #52]	; (9090 <ull_filter_lll_irk_in_fal+0x40>)
    905c:	4343      	muls	r3, r0
    905e:	5ceb      	ldrb	r3, [r5, r3]
    9060:	07db      	lsls	r3, r3, #31
    9062:	d40c      	bmi.n	907e <ull_filter_lll_irk_in_fal+0x2e>
    9064:	4a0b      	ldr	r2, [pc, #44]	; (9094 <ull_filter_lll_irk_in_fal+0x44>)
    9066:	490c      	ldr	r1, [pc, #48]	; (9098 <ull_filter_lll_irk_in_fal+0x48>)
    9068:	480c      	ldr	r0, [pc, #48]	; (909c <ull_filter_lll_irk_in_fal+0x4c>)
    906a:	f240 337a 	movw	r3, #890	; 0x37a
    906e:	f006 fa2a 	bl	f4c6 <printk>
    9072:	4040      	eors	r0, r0
    9074:	f380 8811 	msr	BASEPRI, r0
    9078:	f04f 0003 	mov.w	r0, #3
    907c:	df02      	svc	2
	return rl[rl_idx].fal;
    907e:	2028      	movs	r0, #40	; 0x28
    9080:	4344      	muls	r4, r0
    9082:	5d28      	ldrb	r0, [r5, r4]
    9084:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
    9088:	bd38      	pop	{r3, r4, r5, pc}
		return false;
    908a:	2000      	movs	r0, #0
    908c:	e7fc      	b.n	9088 <ull_filter_lll_irk_in_fal+0x38>
    908e:	bf00      	nop
    9090:	20002030 	.word	0x20002030
    9094:	00013a4f 	.word	0x00013a4f
    9098:	00013a9c 	.word	0x00013a9c
    909c:	000133b6 	.word	0x000133b6

000090a0 <ull_filter_lll_rl_idx_allowed>:
{
    90a0:	b538      	push	{r3, r4, r5, lr}
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || irkmatch_ok) {
    90a2:	4b12      	ldr	r3, [pc, #72]	; (90ec <ull_filter_lll_rl_idx_allowed+0x4c>)
    90a4:	781b      	ldrb	r3, [r3, #0]
{
    90a6:	460c      	mov	r4, r1
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || irkmatch_ok) {
    90a8:	b1eb      	cbz	r3, 90e6 <ull_filter_lll_rl_idx_allowed+0x46>
    90aa:	2907      	cmp	r1, #7
    90ac:	d81b      	bhi.n	90e6 <ull_filter_lll_rl_idx_allowed+0x46>
    90ae:	b9d0      	cbnz	r0, 90e6 <ull_filter_lll_rl_idx_allowed+0x46>
	LL_ASSERT(rl[rl_idx].taken);
    90b0:	2328      	movs	r3, #40	; 0x28
    90b2:	4d0f      	ldr	r5, [pc, #60]	; (90f0 <ull_filter_lll_rl_idx_allowed+0x50>)
    90b4:	434b      	muls	r3, r1
    90b6:	5ceb      	ldrb	r3, [r5, r3]
    90b8:	07da      	lsls	r2, r3, #31
    90ba:	d40c      	bmi.n	90d6 <ull_filter_lll_rl_idx_allowed+0x36>
    90bc:	4a0d      	ldr	r2, [pc, #52]	; (90f4 <ull_filter_lll_rl_idx_allowed+0x54>)
    90be:	490e      	ldr	r1, [pc, #56]	; (90f8 <ull_filter_lll_rl_idx_allowed+0x58>)
    90c0:	480e      	ldr	r0, [pc, #56]	; (90fc <ull_filter_lll_rl_idx_allowed+0x5c>)
    90c2:	f240 3393 	movw	r3, #915	; 0x393
    90c6:	f006 f9fe 	bl	f4c6 <printk>
    90ca:	4040      	eors	r0, r0
    90cc:	f380 8811 	msr	BASEPRI, r0
    90d0:	f04f 0003 	mov.w	r0, #3
    90d4:	df02      	svc	2
	return !rl[rl_idx].pirk || rl[rl_idx].dev;
    90d6:	2128      	movs	r1, #40	; 0x28
    90d8:	434c      	muls	r4, r1
    90da:	5d28      	ldrb	r0, [r5, r4]
    90dc:	0743      	lsls	r3, r0, #29
    90de:	d502      	bpl.n	90e6 <ull_filter_lll_rl_idx_allowed+0x46>
    90e0:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
    90e4:	bd38      	pop	{r3, r4, r5, pc}
		return true;
    90e6:	2001      	movs	r0, #1
    90e8:	e7fc      	b.n	90e4 <ull_filter_lll_rl_idx_allowed+0x44>
    90ea:	bf00      	nop
    90ec:	20002a40 	.word	0x20002a40
    90f0:	20002030 	.word	0x20002030
    90f4:	00013a4f 	.word	0x00013a4f
    90f8:	00013a9c 	.word	0x00013a9c
    90fc:	000133b6 	.word	0x000133b6

00009100 <ull_filter_lll_rl_addr_allowed>:
{
    9100:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (*rl_idx != FILTER_IDX_NONE) {
    9104:	7813      	ldrb	r3, [r2, #0]
    9106:	2bff      	cmp	r3, #255	; 0xff
    9108:	d12b      	bne.n	9162 <ull_filter_lll_rl_addr_allowed+0x62>
    910a:	4c17      	ldr	r4, [pc, #92]	; (9168 <ull_filter_lll_rl_addr_allowed+0x68>)
    910c:	2300      	movs	r3, #0
    910e:	4626      	mov	r6, r4
		if (rl[i].taken && (rl[i].id_addr_type == id_addr_type)) {
    9110:	f04f 0e28 	mov.w	lr, #40	; 0x28
    9114:	fb0e f503 	mul.w	r5, lr, r3
    9118:	fa5f fc83 	uxtb.w	ip, r3
    911c:	5d75      	ldrb	r5, [r6, r5]
    911e:	07ef      	lsls	r7, r5, #31
    9120:	d51a      	bpl.n	9158 <ull_filter_lll_rl_addr_allowed+0x58>
    9122:	f3c5 1580 	ubfx	r5, r5, #6, #1
    9126:	4285      	cmp	r5, r0
    9128:	d116      	bne.n	9158 <ull_filter_lll_rl_addr_allowed+0x58>
			for (j = 0U; j < BDADDR_SIZE; j++) {
    912a:	1e4f      	subs	r7, r1, #1
		if (rl[i].taken && (rl[i].id_addr_type == id_addr_type)) {
    912c:	4625      	mov	r5, r4
			for (j = 0U; j < BDADDR_SIZE; j++) {
    912e:	f104 0806 	add.w	r8, r4, #6
				if (addr[j] != id_addr[j]) {
    9132:	f815 af01 	ldrb.w	sl, [r5, #1]!
    9136:	f817 9f01 	ldrb.w	r9, [r7, #1]!
    913a:	45ca      	cmp	sl, r9
    913c:	d10c      	bne.n	9158 <ull_filter_lll_rl_addr_allowed+0x58>
			for (j = 0U; j < BDADDR_SIZE; j++) {
    913e:	4545      	cmp	r5, r8
    9140:	d1f7      	bne.n	9132 <ull_filter_lll_rl_addr_allowed+0x32>
				*rl_idx = i;
    9142:	f882 c000 	strb.w	ip, [r2]
				return !rl[i].pirk || rl[i].dev;
    9146:	2228      	movs	r2, #40	; 0x28
    9148:	4353      	muls	r3, r2
    914a:	5cf0      	ldrb	r0, [r6, r3]
    914c:	0743      	lsls	r3, r0, #29
    914e:	d508      	bpl.n	9162 <ull_filter_lll_rl_addr_allowed+0x62>
    9150:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
    9154:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
    9158:	3301      	adds	r3, #1
    915a:	2b08      	cmp	r3, #8
    915c:	f104 0428 	add.w	r4, r4, #40	; 0x28
    9160:	d1d8      	bne.n	9114 <ull_filter_lll_rl_addr_allowed+0x14>
				return !rl[i].pirk || rl[i].dev;
    9162:	2001      	movs	r0, #1
    9164:	e7f6      	b.n	9154 <ull_filter_lll_rl_addr_allowed+0x54>
    9166:	bf00      	nop
    9168:	20002030 	.word	0x20002030

0000916c <ull_filter_lll_rl_addr_resolve>:
{
    916c:	b470      	push	{r4, r5, r6}
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || !rl[rl_idx].lirk) {
    916e:	4b0d      	ldr	r3, [pc, #52]	; (91a4 <ull_filter_lll_rl_addr_resolve+0x38>)
    9170:	781b      	ldrb	r3, [r3, #0]
    9172:	b1a3      	cbz	r3, 919e <ull_filter_lll_rl_addr_resolve+0x32>
    9174:	2a07      	cmp	r2, #7
    9176:	d812      	bhi.n	919e <ull_filter_lll_rl_addr_resolve+0x32>
    9178:	2528      	movs	r5, #40	; 0x28
    917a:	4b0b      	ldr	r3, [pc, #44]	; (91a8 <ull_filter_lll_rl_addr_resolve+0x3c>)
    917c:	fb05 f602 	mul.w	r6, r5, r2
    9180:	5d9e      	ldrb	r6, [r3, r6]
    9182:	0736      	lsls	r6, r6, #28
    9184:	d50b      	bpl.n	919e <ull_filter_lll_rl_addr_resolve+0x32>
	if ((id_addr_type != 0U) && ((id_addr[5] & 0xc0) == 0x40)) {
    9186:	b150      	cbz	r0, 919e <ull_filter_lll_rl_addr_resolve+0x32>
    9188:	794c      	ldrb	r4, [r1, #5]
    918a:	f004 04c0 	and.w	r4, r4, #192	; 0xc0
    918e:	2c40      	cmp	r4, #64	; 0x40
    9190:	d105      	bne.n	919e <ull_filter_lll_rl_addr_resolve+0x32>
		return bt_rpa_irk_matches(rl[rl_idx].local_irk,
    9192:	fb05 3002 	mla	r0, r5, r2, r3
    9196:	3007      	adds	r0, #7
}
    9198:	bc70      	pop	{r4, r5, r6}
		return bt_rpa_irk_matches(rl[rl_idx].local_irk,
    919a:	f006 bd56 	b.w	fc4a <bt_rpa_irk_matches>
}
    919e:	2000      	movs	r0, #0
    91a0:	bc70      	pop	{r4, r5, r6}
    91a2:	4770      	bx	lr
    91a4:	20002a40 	.word	0x20002a40
    91a8:	20002030 	.word	0x20002030

000091ac <ull_filter_lll_rl_enabled>:
	return rl_enable;
    91ac:	4b02      	ldr	r3, [pc, #8]	; (91b8 <ull_filter_lll_rl_enabled+0xc>)
    91ae:	7818      	ldrb	r0, [r3, #0]
}
    91b0:	3800      	subs	r0, #0
    91b2:	bf18      	it	ne
    91b4:	2001      	movne	r0, #1
    91b6:	4770      	bx	lr
    91b8:	20002a40 	.word	0x20002a40

000091bc <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(const void *arg)
{
    91bc:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	lll_prof_enter_ull_high();

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
    91be:	4b08      	ldr	r3, [pc, #32]	; (91e0 <rtc0_nrf5_isr+0x24>)
    91c0:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
    91c4:	b122      	cbz	r2, 91d0 <rtc0_nrf5_isr+0x14>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
    91c6:	2000      	movs	r0, #0
    91c8:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140

		ticker_trigger(0);
    91cc:	f7fb fc04 	bl	49d8 <ticker_trigger>
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
    91d0:	2001      	movs	r0, #1
    91d2:	f7fa ff43 	bl	405c <mayfly_run>

	lll_prof_exit_ull_low();
#endif

	DEBUG_TICKER_ISR(0);
}
    91d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
    91da:	2002      	movs	r0, #2
    91dc:	f7fa bf3e 	b.w	405c <mayfly_run>
    91e0:	4000b000 	.word	0x4000b000

000091e4 <ticker_stop_op_cb>:
static uint8_t preempt_stop_ack;
static uint8_t preempt_req;
static uint8_t volatile preempt_ack;

static void ticker_stop_op_cb(uint32_t status, void *param)
{
    91e4:	b510      	push	{r4, lr}
	ARG_UNUSED(param);
	ARG_UNUSED(status);

	LL_ASSERT(preempt_stop_req != preempt_stop_ack);
    91e6:	4b0d      	ldr	r3, [pc, #52]	; (921c <ticker_stop_op_cb+0x38>)
    91e8:	4c0d      	ldr	r4, [pc, #52]	; (9220 <ticker_stop_op_cb+0x3c>)
    91ea:	781b      	ldrb	r3, [r3, #0]
    91ec:	7822      	ldrb	r2, [r4, #0]
    91ee:	429a      	cmp	r2, r3
    91f0:	d10c      	bne.n	920c <ticker_stop_op_cb+0x28>
    91f2:	4a0c      	ldr	r2, [pc, #48]	; (9224 <ticker_stop_op_cb+0x40>)
    91f4:	490c      	ldr	r1, [pc, #48]	; (9228 <ticker_stop_op_cb+0x44>)
    91f6:	480d      	ldr	r0, [pc, #52]	; (922c <ticker_stop_op_cb+0x48>)
    91f8:	f44f 733e 	mov.w	r3, #760	; 0x2f8
    91fc:	f006 f963 	bl	f4c6 <printk>
    9200:	4040      	eors	r0, r0
    9202:	f380 8811 	msr	BASEPRI, r0
    9206:	f04f 0003 	mov.w	r0, #3
    920a:	df02      	svc	2
	preempt_stop_ack++;
    920c:	7823      	ldrb	r3, [r4, #0]
    920e:	3301      	adds	r3, #1
    9210:	7023      	strb	r3, [r4, #0]

	preempt_req = preempt_ack;
    9212:	4b07      	ldr	r3, [pc, #28]	; (9230 <ticker_stop_op_cb+0x4c>)
    9214:	781a      	ldrb	r2, [r3, #0]
    9216:	4b07      	ldr	r3, [pc, #28]	; (9234 <ticker_stop_op_cb+0x50>)
    9218:	701a      	strb	r2, [r3, #0]
}
    921a:	bd10      	pop	{r4, pc}
    921c:	20002a78 	.word	0x20002a78
    9220:	20002a77 	.word	0x20002a77
    9224:	00013c53 	.word	0x00013c53
    9228:	00013c99 	.word	0x00013c99
    922c:	000133b6 	.word	0x000133b6
    9230:	20002a73 	.word	0x20002a73
    9234:	20002a74 	.word	0x20002a74

00009238 <ticker_start_op_cb>:

static void ticker_start_op_cb(uint32_t status, void *param)
{
    9238:	b510      	push	{r4, lr}
	ARG_UNUSED(param);
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
    923a:	b160      	cbz	r0, 9256 <ticker_start_op_cb+0x1e>
    923c:	4a1c      	ldr	r2, [pc, #112]	; (92b0 <ticker_start_op_cb+0x78>)
    923e:	491d      	ldr	r1, [pc, #116]	; (92b4 <ticker_start_op_cb+0x7c>)
    9240:	481d      	ldr	r0, [pc, #116]	; (92b8 <ticker_start_op_cb+0x80>)
    9242:	f240 3301 	movw	r3, #769	; 0x301
    9246:	f006 f93e 	bl	f4c6 <printk>
    924a:	4040      	eors	r0, r0
    924c:	f380 8811 	msr	BASEPRI, r0
    9250:	f04f 0003 	mov.w	r0, #3
    9254:	df02      	svc	2

	LL_ASSERT(preempt_start_req != preempt_start_ack);
    9256:	4b19      	ldr	r3, [pc, #100]	; (92bc <ticker_start_op_cb+0x84>)
    9258:	4c19      	ldr	r4, [pc, #100]	; (92c0 <ticker_start_op_cb+0x88>)
    925a:	781b      	ldrb	r3, [r3, #0]
    925c:	7822      	ldrb	r2, [r4, #0]
    925e:	429a      	cmp	r2, r3
    9260:	d10c      	bne.n	927c <ticker_start_op_cb+0x44>
    9262:	4a13      	ldr	r2, [pc, #76]	; (92b0 <ticker_start_op_cb+0x78>)
    9264:	4917      	ldr	r1, [pc, #92]	; (92c4 <ticker_start_op_cb+0x8c>)
    9266:	4814      	ldr	r0, [pc, #80]	; (92b8 <ticker_start_op_cb+0x80>)
    9268:	f240 3303 	movw	r3, #771	; 0x303
    926c:	f006 f92b 	bl	f4c6 <printk>
    9270:	4040      	eors	r0, r0
    9272:	f380 8811 	msr	BASEPRI, r0
    9276:	f04f 0003 	mov.w	r0, #3
    927a:	df02      	svc	2
	preempt_start_ack++;
    927c:	7823      	ldrb	r3, [r4, #0]
    927e:	3301      	adds	r3, #1
    9280:	7023      	strb	r3, [r4, #0]

	LL_ASSERT(preempt_req == preempt_ack);
    9282:	4b11      	ldr	r3, [pc, #68]	; (92c8 <ticker_start_op_cb+0x90>)
    9284:	4c11      	ldr	r4, [pc, #68]	; (92cc <ticker_start_op_cb+0x94>)
    9286:	781b      	ldrb	r3, [r3, #0]
    9288:	7822      	ldrb	r2, [r4, #0]
    928a:	429a      	cmp	r2, r3
    928c:	d00c      	beq.n	92a8 <ticker_start_op_cb+0x70>
    928e:	4a08      	ldr	r2, [pc, #32]	; (92b0 <ticker_start_op_cb+0x78>)
    9290:	490f      	ldr	r1, [pc, #60]	; (92d0 <ticker_start_op_cb+0x98>)
    9292:	4809      	ldr	r0, [pc, #36]	; (92b8 <ticker_start_op_cb+0x80>)
    9294:	f240 3306 	movw	r3, #774	; 0x306
    9298:	f006 f915 	bl	f4c6 <printk>
    929c:	4040      	eors	r0, r0
    929e:	f380 8811 	msr	BASEPRI, r0
    92a2:	f04f 0003 	mov.w	r0, #3
    92a6:	df02      	svc	2
	preempt_req++;
    92a8:	7823      	ldrb	r3, [r4, #0]
    92aa:	3301      	adds	r3, #1
    92ac:	7023      	strb	r3, [r4, #0]
}
    92ae:	bd10      	pop	{r4, pc}
    92b0:	00013c53 	.word	0x00013c53
    92b4:	00013766 	.word	0x00013766
    92b8:	000133b6 	.word	0x000133b6
    92bc:	20002a76 	.word	0x20002a76
    92c0:	20002a75 	.word	0x20002a75
    92c4:	00013cbe 	.word	0x00013cbe
    92c8:	20002a73 	.word	0x20002a73
    92cc:	20002a74 	.word	0x20002a74
    92d0:	00013ce5 	.word	0x00013ce5

000092d4 <preempt_ticker_cb>:
}

static void preempt_ticker_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
			      uint32_t remainder, uint16_t lazy, uint8_t force,
			      void *param)
{
    92d4:	b510      	push	{r4, lr}
	static memq_link_t link;
	static struct mayfly mfy = {0, 0, &link, NULL, preempt};
	uint32_t ret;

	LL_ASSERT(preempt_ack != preempt_req);
    92d6:	4a17      	ldr	r2, [pc, #92]	; (9334 <preempt_ticker_cb+0x60>)
    92d8:	4c17      	ldr	r4, [pc, #92]	; (9338 <preempt_ticker_cb+0x64>)
    92da:	7812      	ldrb	r2, [r2, #0]
    92dc:	7823      	ldrb	r3, [r4, #0]
    92de:	429a      	cmp	r2, r3
    92e0:	d10c      	bne.n	92fc <preempt_ticker_cb+0x28>
    92e2:	4a16      	ldr	r2, [pc, #88]	; (933c <preempt_ticker_cb+0x68>)
    92e4:	4916      	ldr	r1, [pc, #88]	; (9340 <preempt_ticker_cb+0x6c>)
    92e6:	4817      	ldr	r0, [pc, #92]	; (9344 <preempt_ticker_cb+0x70>)
    92e8:	f240 3367 	movw	r3, #871	; 0x367
    92ec:	f006 f8eb 	bl	f4c6 <printk>
    92f0:	4040      	eors	r0, r0
    92f2:	f380 8811 	msr	BASEPRI, r0
    92f6:	f04f 0003 	mov.w	r0, #3
    92fa:	df02      	svc	2
	preempt_ack++;
    92fc:	7823      	ldrb	r3, [r4, #0]

	mfy.param = param;
    92fe:	9a03      	ldr	r2, [sp, #12]
	preempt_ack++;
    9300:	3301      	adds	r3, #1
    9302:	b2db      	uxtb	r3, r3
    9304:	7023      	strb	r3, [r4, #0]
	mfy.param = param;
    9306:	4b10      	ldr	r3, [pc, #64]	; (9348 <preempt_ticker_cb+0x74>)
    9308:	609a      	str	r2, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
    930a:	2200      	movs	r2, #0
    930c:	4611      	mov	r1, r2
    930e:	2001      	movs	r0, #1
    9310:	f7fa fe54 	bl	3fbc <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
    9314:	b160      	cbz	r0, 9330 <preempt_ticker_cb+0x5c>
    9316:	4a09      	ldr	r2, [pc, #36]	; (933c <preempt_ticker_cb+0x68>)
    9318:	490c      	ldr	r1, [pc, #48]	; (934c <preempt_ticker_cb+0x78>)
    931a:	480a      	ldr	r0, [pc, #40]	; (9344 <preempt_ticker_cb+0x70>)
    931c:	f240 336d 	movw	r3, #877	; 0x36d
    9320:	f006 f8d1 	bl	f4c6 <printk>
    9324:	4040      	eors	r0, r0
    9326:	f380 8811 	msr	BASEPRI, r0
    932a:	f04f 0003 	mov.w	r0, #3
    932e:	df02      	svc	2
}
    9330:	bd10      	pop	{r4, pc}
    9332:	bf00      	nop
    9334:	20002a74 	.word	0x20002a74
    9338:	20002a73 	.word	0x20002a73
    933c:	00013c53 	.word	0x00013c53
    9340:	00013d00 	.word	0x00013d00
    9344:	000133b6 	.word	0x000133b6
    9348:	20000438 	.word	0x20000438
    934c:	0001366f 	.word	0x0001366f

00009350 <preempt_ticker_stop>:
{
    9350:	b513      	push	{r0, r1, r4, lr}
	if ((preempt_stop_req != preempt_stop_ack) ||
    9352:	4a17      	ldr	r2, [pc, #92]	; (93b0 <preempt_ticker_stop+0x60>)
    9354:	4917      	ldr	r1, [pc, #92]	; (93b4 <preempt_ticker_stop+0x64>)
    9356:	7813      	ldrb	r3, [r2, #0]
    9358:	7809      	ldrb	r1, [r1, #0]
    935a:	4299      	cmp	r1, r3
    935c:	d003      	beq.n	9366 <preempt_ticker_stop+0x16>
		return TICKER_STATUS_SUCCESS;
    935e:	2400      	movs	r4, #0
}
    9360:	4620      	mov	r0, r4
    9362:	b002      	add	sp, #8
    9364:	bd10      	pop	{r4, pc}
	    (preempt_req == preempt_ack)) {
    9366:	4b14      	ldr	r3, [pc, #80]	; (93b8 <preempt_ticker_stop+0x68>)
    9368:	4914      	ldr	r1, [pc, #80]	; (93bc <preempt_ticker_stop+0x6c>)
    936a:	781b      	ldrb	r3, [r3, #0]
	if ((preempt_stop_req != preempt_stop_ack) ||
    936c:	7809      	ldrb	r1, [r1, #0]
    936e:	4299      	cmp	r1, r3
    9370:	d0f5      	beq.n	935e <preempt_ticker_stop+0xe>
	preempt_stop_req++;
    9372:	7813      	ldrb	r3, [r2, #0]
    9374:	3301      	adds	r3, #1
    9376:	b2db      	uxtb	r3, r3
    9378:	7013      	strb	r3, [r2, #0]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
    937a:	2200      	movs	r2, #0
    937c:	4b10      	ldr	r3, [pc, #64]	; (93c0 <preempt_ticker_stop+0x70>)
    937e:	9200      	str	r2, [sp, #0]
    9380:	4611      	mov	r1, r2
    9382:	4610      	mov	r0, r2
    9384:	f7fb fc10 	bl	4ba8 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    9388:	4604      	mov	r4, r0
    938a:	2800      	cmp	r0, #0
    938c:	d0e7      	beq.n	935e <preempt_ticker_stop+0xe>
    938e:	2802      	cmp	r0, #2
    9390:	d0e6      	beq.n	9360 <preempt_ticker_stop+0x10>
    9392:	4a0c      	ldr	r2, [pc, #48]	; (93c4 <preempt_ticker_stop+0x74>)
    9394:	490c      	ldr	r1, [pc, #48]	; (93c8 <preempt_ticker_stop+0x78>)
    9396:	480d      	ldr	r0, [pc, #52]	; (93cc <preempt_ticker_stop+0x7c>)
    9398:	f240 3359 	movw	r3, #857	; 0x359
    939c:	f006 f893 	bl	f4c6 <printk>
    93a0:	4040      	eors	r0, r0
    93a2:	f380 8811 	msr	BASEPRI, r0
    93a6:	f04f 0003 	mov.w	r0, #3
    93aa:	df02      	svc	2
    93ac:	e7d8      	b.n	9360 <preempt_ticker_stop+0x10>
    93ae:	bf00      	nop
    93b0:	20002a78 	.word	0x20002a78
    93b4:	20002a77 	.word	0x20002a77
    93b8:	20002a73 	.word	0x20002a73
    93bc:	20002a74 	.word	0x20002a74
    93c0:	000091e5 	.word	0x000091e5
    93c4:	00013c53 	.word	0x00013c53
    93c8:	000137b3 	.word	0x000137b3
    93cc:	000133b6 	.word	0x000133b6

000093d0 <preempt_ticker_start>:
	ull = HDR_LLL2ULL(p->param);
    93d0:	68cb      	ldr	r3, [r1, #12]
    93d2:	681b      	ldr	r3, [r3, #0]
{
    93d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	preempt_anchor = p->ticks_at_expire;
    93d8:	f8d1 8000 	ldr.w	r8, [r1]
	preempt_to = MAX(ull->ticks_active_to_start,
    93dc:	68de      	ldr	r6, [r3, #12]
	if ((preempt_start_req != preempt_start_ack) ||
    93de:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 9484 <preempt_ticker_start+0xb4>
{
    93e2:	460d      	mov	r5, r1
	preempt_to = MAX(ull->ticks_active_to_start,
    93e4:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
    93e8:	4291      	cmp	r1, r2
    93ea:	bf2c      	ite	cs
    93ec:	ebc6 0601 	rsbcs	r6, r6, r1
    93f0:	ebc6 0602 	rsbcc	r6, r6, r2
	if ((preempt_start_req != preempt_start_ack) ||
    93f4:	4a24      	ldr	r2, [pc, #144]	; (9488 <preempt_ticker_start+0xb8>)
    93f6:	f899 3000 	ldrb.w	r3, [r9]
    93fa:	7812      	ldrb	r2, [r2, #0]
    93fc:	429a      	cmp	r2, r3
{
    93fe:	b08a      	sub	sp, #40	; 0x28
    9400:	4604      	mov	r4, r0
	ticks_at_preempt_new = preempt_anchor + preempt_to;
    9402:	eb08 0706 	add.w	r7, r8, r6
	if ((preempt_start_req != preempt_start_ack) ||
    9406:	d105      	bne.n	9414 <preempt_ticker_start+0x44>
	    (preempt_req != preempt_ack)) {
    9408:	4b20      	ldr	r3, [pc, #128]	; (948c <preempt_ticker_start+0xbc>)
    940a:	4a21      	ldr	r2, [pc, #132]	; (9490 <preempt_ticker_start+0xc0>)
    940c:	781b      	ldrb	r3, [r3, #0]
	if ((preempt_start_req != preempt_start_ack) ||
    940e:	7812      	ldrb	r2, [r2, #0]
    9410:	429a      	cmp	r2, r3
    9412:	d018      	beq.n	9446 <preempt_ticker_start+0x76>
		if (!prev || prev->is_aborted ||
    9414:	2c00      	cmp	r4, #0
    9416:	d032      	beq.n	947e <preempt_ticker_start+0xae>
    9418:	7f23      	ldrb	r3, [r4, #28]
    941a:	079b      	lsls	r3, r3, #30
    941c:	d42f      	bmi.n	947e <preempt_ticker_start+0xae>
		diff = ticks_at_preempt_new - ticks_at_preempt;
    941e:	f8df a074 	ldr.w	sl, [pc, #116]	; 9494 <preempt_ticker_start+0xc4>
    9422:	f8da 2000 	ldr.w	r2, [sl]
    9426:	1aba      	subs	r2, r7, r2
		if (!prev || prev->is_aborted ||
    9428:	f412 0000 	ands.w	r0, r2, #8388608	; 0x800000
    942c:	d024      	beq.n	9478 <preempt_ticker_start+0xa8>
		preempt_ticker_stop();
    942e:	f7ff ff8f 	bl	9350 <preempt_ticker_stop>
		prev->is_aborted = 1U;
    9432:	7f23      	ldrb	r3, [r4, #28]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
    9434:	68e1      	ldr	r1, [r4, #12]
		ticks_at_preempt = ticks_at_preempt_new;
    9436:	f8ca 7000 	str.w	r7, [sl]
		prev->is_aborted = 1U;
    943a:	f043 0302 	orr.w	r3, r3, #2
    943e:	7723      	strb	r3, [r4, #28]
		prev->abort_cb(&prev->prepare_param, prev->prepare_param.param);
    9440:	4620      	mov	r0, r4
    9442:	69a3      	ldr	r3, [r4, #24]
    9444:	4798      	blx	r3
	preempt_start_req++;
    9446:	f899 2000 	ldrb.w	r2, [r9]
	ticks_at_preempt = ticks_at_preempt_new;
    944a:	4b12      	ldr	r3, [pc, #72]	; (9494 <preempt_ticker_start+0xc4>)
	preempt_start_req++;
    944c:	3201      	adds	r2, #1
	ticks_at_preempt = ticks_at_preempt_new;
    944e:	601f      	str	r7, [r3, #0]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    9450:	4b11      	ldr	r3, [pc, #68]	; (9498 <preempt_ticker_start+0xc8>)
    9452:	9508      	str	r5, [sp, #32]
	preempt_start_req++;
    9454:	b2d2      	uxtb	r2, r2
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    9456:	e9cd 5306 	strd	r5, r3, [sp, #24]
	preempt_start_req++;
    945a:	f889 2000 	strb.w	r2, [r9]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    945e:	4b0f      	ldr	r3, [pc, #60]	; (949c <preempt_ticker_start+0xcc>)
    9460:	9305      	str	r3, [sp, #20]
    9462:	2200      	movs	r2, #0
    9464:	e9cd 2203 	strd	r2, r2, [sp, #12]
    9468:	e9cd 2201 	strd	r2, r2, [sp, #4]
    946c:	9600      	str	r6, [sp, #0]
    946e:	4643      	mov	r3, r8
    9470:	4611      	mov	r1, r2
    9472:	4610      	mov	r0, r2
    9474:	f007 fbb9 	bl	10bea <ticker_start>
}
    9478:	b00a      	add	sp, #40	; 0x28
    947a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			return TICKER_STATUS_SUCCESS;
    947e:	2000      	movs	r0, #0
    9480:	e7fa      	b.n	9478 <preempt_ticker_start+0xa8>
    9482:	bf00      	nop
    9484:	20002a76 	.word	0x20002a76
    9488:	20002a75 	.word	0x20002a75
    948c:	20002a73 	.word	0x20002a73
    9490:	20002a74 	.word	0x20002a74
    9494:	2000218c 	.word	0x2000218c
    9498:	00009239 	.word	0x00009239
    949c:	000092d5 	.word	0x000092d5

000094a0 <preempt>:

static void preempt(void *param)
{
    94a0:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_event *next;
	uint8_t idx;
	int err;

	/* No event to abort */
	if (!event.curr.abort_cb || !event.curr.param) {
    94a2:	4c3a      	ldr	r4, [pc, #232]	; (958c <preempt+0xec>)
    94a4:	68a3      	ldr	r3, [r4, #8]
{
    94a6:	b089      	sub	sp, #36	; 0x24
    94a8:	4605      	mov	r5, r0
	if (!event.curr.abort_cb || !event.curr.param) {
    94aa:	2b00      	cmp	r3, #0
    94ac:	d034      	beq.n	9518 <preempt+0x78>
    94ae:	6823      	ldr	r3, [r4, #0]
    94b0:	2b00      	cmp	r3, #0
    94b2:	d031      	beq.n	9518 <preempt+0x78>
		return;
	}

	/* Check if any prepare in pipeline */
	idx = UINT8_MAX;
    94b4:	23ff      	movs	r3, #255	; 0xff
    94b6:	f88d 300a 	strb.w	r3, [sp, #10]
		return;
	}

	/* Find a prepare that is ready and not a resume */
	while (next && (next->is_aborted || next->is_resume)) {
		next = ull_prepare_dequeue_iter(&idx);
    94ba:	f10d 000a 	add.w	r0, sp, #10
    94be:	f7fd f97f 	bl	67c0 <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
    94c2:	4601      	mov	r1, r0
    94c4:	b340      	cbz	r0, 9518 <preempt+0x78>
    94c6:	7f06      	ldrb	r6, [r0, #28]
    94c8:	f016 0603 	ands.w	r6, r6, #3
    94cc:	d1f5      	bne.n	94ba <preempt+0x1a>
	if (!next) {
		return;
	}

	/* Preemptor not in pipeline */
	if (next != param) {
    94ce:	4285      	cmp	r5, r0
    94d0:	d013      	beq.n	94fa <preempt+0x5a>
		uint32_t ret;

		/* Start the preempt timeout */
		ret = preempt_ticker_start(NULL, next);
    94d2:	4630      	mov	r0, r6
    94d4:	f7ff ff7c 	bl	93d0 <preempt_ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    94d8:	f030 0302 	bics.w	r3, r0, #2
    94dc:	d01c      	beq.n	9518 <preempt+0x78>
    94de:	4a2c      	ldr	r2, [pc, #176]	; (9590 <preempt+0xf0>)
    94e0:	492c      	ldr	r1, [pc, #176]	; (9594 <preempt+0xf4>)
    94e2:	f240 3393 	movw	r3, #915	; 0x393

		/* Enqueue as resume event */
		iter = resume_enqueue(resume_cb);
		LL_ASSERT(iter);
	} else {
		LL_ASSERT(err == -ECANCELED);
    94e6:	482c      	ldr	r0, [pc, #176]	; (9598 <preempt+0xf8>)
    94e8:	f005 ffed 	bl	f4c6 <printk>
    94ec:	4040      	eors	r0, r0
    94ee:	f380 8811 	msr	BASEPRI, r0
    94f2:	f04f 0003 	mov.w	r0, #3
    94f6:	df02      	svc	2
    94f8:	e00e      	b.n	9518 <preempt+0x78>
	err = event.curr.is_abort_cb(next->prepare_param.param,
    94fa:	6863      	ldr	r3, [r4, #4]
    94fc:	6821      	ldr	r1, [r4, #0]
    94fe:	68e8      	ldr	r0, [r5, #12]
    9500:	aa03      	add	r2, sp, #12
    9502:	4798      	blx	r3
	if (!err) {
    9504:	4607      	mov	r7, r0
    9506:	b948      	cbnz	r0, 951c <preempt+0x7c>
		next->is_aborted = 1;
    9508:	7f2b      	ldrb	r3, [r5, #28]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
    950a:	68e9      	ldr	r1, [r5, #12]
		next->is_aborted = 1;
    950c:	f043 0302 	orr.w	r3, r3, #2
    9510:	772b      	strb	r3, [r5, #28]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
    9512:	4628      	mov	r0, r5
    9514:	69ab      	ldr	r3, [r5, #24]
    9516:	4798      	blx	r3
	}
}
    9518:	b009      	add	sp, #36	; 0x24
    951a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	event.curr.abort_cb(NULL, event.curr.param);
    951c:	68a3      	ldr	r3, [r4, #8]
    951e:	6821      	ldr	r1, [r4, #0]
    9520:	4630      	mov	r0, r6
    9522:	4798      	blx	r3
	if (err == -EAGAIN) {
    9524:	f117 0f0b 	cmn.w	r7, #11
    9528:	d129      	bne.n	957e <preempt+0xde>
		iter_idx = UINT8_MAX;
    952a:	25ff      	movs	r5, #255	; 0xff
				iter_idx = UINT8_MAX;
    952c:	f88d 500b 	strb.w	r5, [sp, #11]
			iter = ull_prepare_dequeue_iter(&iter_idx);
    9530:	f10d 000b 	add.w	r0, sp, #11
    9534:	f7fd f944 	bl	67c0 <ull_prepare_dequeue_iter>
		while (iter) {
    9538:	b9a0      	cbnz	r0, 9564 <preempt+0xc4>
	prepare_param.param = event.curr.param;
    953a:	6823      	ldr	r3, [r4, #0]
    953c:	9307      	str	r3, [sp, #28]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
    953e:	2301      	movs	r3, #1
	struct lll_prepare_param prepare_param = {0};
    9540:	e9cd 0004 	strd	r0, r0, [sp, #16]
    9544:	9006      	str	r0, [sp, #24]
	event.curr.param = NULL;
    9546:	6020      	str	r0, [r4, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
    9548:	9300      	str	r3, [sp, #0]
    954a:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
    954e:	9b03      	ldr	r3, [sp, #12]
    9550:	aa04      	add	r2, sp, #16
    9552:	f7fd f8f9 	bl	6748 <ull_prepare_enqueue>
		LL_ASSERT(iter);
    9556:	2800      	cmp	r0, #0
    9558:	d1de      	bne.n	9518 <preempt+0x78>
    955a:	4a0d      	ldr	r2, [pc, #52]	; (9590 <preempt+0xf0>)
    955c:	490f      	ldr	r1, [pc, #60]	; (959c <preempt+0xfc>)
    955e:	f240 33c5 	movw	r3, #965	; 0x3c5
    9562:	e7c0      	b.n	94e6 <preempt+0x46>
			if (!iter->is_aborted &&
    9564:	7f03      	ldrb	r3, [r0, #28]
    9566:	079a      	lsls	r2, r3, #30
    9568:	d4e2      	bmi.n	9530 <preempt+0x90>
			    event.curr.param == iter->prepare_param.param) {
    956a:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
    956c:	6821      	ldr	r1, [r4, #0]
    956e:	4291      	cmp	r1, r2
    9570:	d1de      	bne.n	9530 <preempt+0x90>
				iter->is_aborted = 1;
    9572:	f043 0302 	orr.w	r3, r3, #2
    9576:	7703      	strb	r3, [r0, #28]
				iter->abort_cb(&iter->prepare_param,
    9578:	6983      	ldr	r3, [r0, #24]
    957a:	4798      	blx	r3
    957c:	e7d6      	b.n	952c <preempt+0x8c>
		LL_ASSERT(err == -ECANCELED);
    957e:	378c      	adds	r7, #140	; 0x8c
    9580:	d0ca      	beq.n	9518 <preempt+0x78>
    9582:	4a03      	ldr	r2, [pc, #12]	; (9590 <preempt+0xf0>)
    9584:	4906      	ldr	r1, [pc, #24]	; (95a0 <preempt+0x100>)
    9586:	f240 33c7 	movw	r3, #967	; 0x3c7
    958a:	e7ac      	b.n	94e6 <preempt+0x46>
    958c:	20002178 	.word	0x20002178
    9590:	00013c53 	.word	0x00013c53
    9594:	000137b3 	.word	0x000137b3
    9598:	000133b6 	.word	0x000133b6
    959c:	00013d1b 	.word	0x00013d1b
    95a0:	00013d20 	.word	0x00013d20

000095a4 <lll_init>:
{
    95a4:	b510      	push	{r4, lr}
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    95a6:	4816      	ldr	r0, [pc, #88]	; (9600 <lll_init+0x5c>)
    95a8:	f004 fe66 	bl	e278 <z_impl_device_get_binding>
	dev_entropy = device_get_binding(DT_LABEL(DT_NODELABEL(rng)));
    95ac:	4b15      	ldr	r3, [pc, #84]	; (9604 <lll_init+0x60>)
    95ae:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
    95b0:	b310      	cbz	r0, 95f8 <lll_init+0x54>
	event.curr.abort_cb = NULL;
    95b2:	4b15      	ldr	r3, [pc, #84]	; (9608 <lll_init+0x64>)
    95b4:	2400      	movs	r4, #0
    95b6:	609c      	str	r4, [r3, #8]
	err = lll_clock_init();
    95b8:	f000 fa2c 	bl	9a14 <lll_clock_init>
	if (err < 0) {
    95bc:	2800      	cmp	r0, #0
    95be:	db1a      	blt.n	95f6 <lll_init+0x52>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
    95c0:	4622      	mov	r2, r4
    95c2:	4621      	mov	r1, r4
    95c4:	2001      	movs	r0, #1
    95c6:	f7f8 ffb1 	bl	252c <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
    95ca:	4622      	mov	r2, r4
    95cc:	2101      	movs	r1, #1
    95ce:	200b      	movs	r0, #11
    95d0:	f7f8 ffac 	bl	252c <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
    95d4:	4622      	mov	r2, r4
    95d6:	4621      	mov	r1, r4
    95d8:	2018      	movs	r0, #24
    95da:	f7f8 ffa7 	bl	252c <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
    95de:	2001      	movs	r0, #1
    95e0:	f7f8 ff72 	bl	24c8 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
    95e4:	200b      	movs	r0, #11
    95e6:	f7f8 ff6f 	bl	24c8 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
    95ea:	2018      	movs	r0, #24
    95ec:	f7f8 ff6c 	bl	24c8 <arch_irq_enable>
	radio_setup();
    95f0:	f008 fb4c 	bl	11c8c <radio_setup>
	return 0;
    95f4:	4620      	mov	r0, r4
}
    95f6:	bd10      	pop	{r4, pc}
		return -ENODEV;
    95f8:	f06f 0012 	mvn.w	r0, #18
    95fc:	e7fb      	b.n	95f6 <lll_init+0x52>
    95fe:	bf00      	nop
    9600:	00013d2c 	.word	0x00013d2c
    9604:	20002174 	.word	0x20002174
    9608:	20002178 	.word	0x20002178

0000960c <lll_csrand_get>:
	return entropy_get_entropy(dev_entropy, buf, len);
    960c:	4a05      	ldr	r2, [pc, #20]	; (9624 <lll_csrand_get+0x18>)
{
    960e:	b410      	push	{r4}
    9610:	4603      	mov	r3, r0
	return entropy_get_entropy(dev_entropy, buf, len);
    9612:	6810      	ldr	r0, [r2, #0]
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
    9614:	6882      	ldr	r2, [r0, #8]
    9616:	6814      	ldr	r4, [r2, #0]
    9618:	b28a      	uxth	r2, r1
    961a:	4619      	mov	r1, r3
    961c:	4623      	mov	r3, r4
}
    961e:	bc10      	pop	{r4}
    9620:	4718      	bx	r3
    9622:	bf00      	nop
    9624:	20002174 	.word	0x20002174

00009628 <lll_csrand_isr_get>:
	return entropy_get_entropy_isr(dev_entropy, buf, len, 0);
    9628:	4b08      	ldr	r3, [pc, #32]	; (964c <lll_csrand_isr_get+0x24>)
{
    962a:	b430      	push	{r4, r5}
    962c:	4604      	mov	r4, r0
	return entropy_get_entropy_isr(dev_entropy, buf, len, 0);
    962e:	6818      	ldr	r0, [r3, #0]
					  uint32_t flags)
{
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->api;

	if (unlikely(!api->get_entropy_isr)) {
    9630:	6883      	ldr	r3, [r0, #8]
    9632:	685d      	ldr	r5, [r3, #4]
    9634:	b28a      	uxth	r2, r1
    9636:	b125      	cbz	r5, 9642 <lll_csrand_isr_get+0x1a>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
    9638:	4621      	mov	r1, r4
    963a:	46ac      	mov	ip, r5
    963c:	2300      	movs	r3, #0
}
    963e:	bc30      	pop	{r4, r5}
    9640:	4760      	bx	ip
    9642:	f06f 0085 	mvn.w	r0, #133	; 0x85
    9646:	bc30      	pop	{r4, r5}
    9648:	4770      	bx	lr
    964a:	bf00      	nop
    964c:	20002174 	.word	0x20002174

00009650 <lll_disable>:
{
    9650:	b537      	push	{r0, r1, r2, r4, r5, lr}
    9652:	4b19      	ldr	r3, [pc, #100]	; (96b8 <lll_disable+0x68>)
	if (!param || (param == event.curr.param)) {
    9654:	4604      	mov	r4, r0
    9656:	b110      	cbz	r0, 965e <lll_disable+0xe>
    9658:	681a      	ldr	r2, [r3, #0]
    965a:	4282      	cmp	r2, r0
    965c:	d105      	bne.n	966a <lll_disable+0x1a>
		if (event.curr.abort_cb && event.curr.param) {
    965e:	689a      	ldr	r2, [r3, #8]
    9660:	b16a      	cbz	r2, 967e <lll_disable+0x2e>
    9662:	6819      	ldr	r1, [r3, #0]
    9664:	b159      	cbz	r1, 967e <lll_disable+0x2e>
			event.curr.abort_cb(NULL, event.curr.param);
    9666:	2000      	movs	r0, #0
    9668:	4790      	blx	r2
		idx = UINT8_MAX;
    966a:	25ff      	movs	r5, #255	; 0xff
				idx = UINT8_MAX;
    966c:	f88d 5007 	strb.w	r5, [sp, #7]
			next = ull_prepare_dequeue_iter(&idx);
    9670:	f10d 0007 	add.w	r0, sp, #7
    9674:	f7fd f8a4 	bl	67c0 <ull_prepare_dequeue_iter>
		while (next) {
    9678:	b980      	cbnz	r0, 969c <lll_disable+0x4c>
}
    967a:	b003      	add	sp, #12
    967c:	bd30      	pop	{r4, r5, pc}
			LL_ASSERT(!param);
    967e:	2c00      	cmp	r4, #0
    9680:	d0f3      	beq.n	966a <lll_disable+0x1a>
    9682:	4a0e      	ldr	r2, [pc, #56]	; (96bc <lll_disable+0x6c>)
    9684:	490e      	ldr	r1, [pc, #56]	; (96c0 <lll_disable+0x70>)
    9686:	480f      	ldr	r0, [pc, #60]	; (96c4 <lll_disable+0x74>)
    9688:	23fd      	movs	r3, #253	; 0xfd
    968a:	f005 ff1c 	bl	f4c6 <printk>
    968e:	4040      	eors	r0, r0
    9690:	f380 8811 	msr	BASEPRI, r0
    9694:	f04f 0003 	mov.w	r0, #3
    9698:	df02      	svc	2
    969a:	e7e6      	b.n	966a <lll_disable+0x1a>
			if (!next->is_aborted &&
    969c:	7f03      	ldrb	r3, [r0, #28]
    969e:	079b      	lsls	r3, r3, #30
    96a0:	d4e6      	bmi.n	9670 <lll_disable+0x20>
			    (!param || (param == next->prepare_param.param))) {
    96a2:	68c1      	ldr	r1, [r0, #12]
			if (!next->is_aborted &&
    96a4:	b10c      	cbz	r4, 96aa <lll_disable+0x5a>
			    (!param || (param == next->prepare_param.param))) {
    96a6:	428c      	cmp	r4, r1
    96a8:	d1e2      	bne.n	9670 <lll_disable+0x20>
				next->is_aborted = 1;
    96aa:	7f03      	ldrb	r3, [r0, #28]
    96ac:	f043 0302 	orr.w	r3, r3, #2
    96b0:	7703      	strb	r3, [r0, #28]
				next->abort_cb(&next->prepare_param,
    96b2:	6983      	ldr	r3, [r0, #24]
    96b4:	4798      	blx	r3
    96b6:	e7d9      	b.n	966c <lll_disable+0x1c>
    96b8:	20002178 	.word	0x20002178
    96bc:	00013c53 	.word	0x00013c53
    96c0:	00013d30 	.word	0x00013d30
    96c4:	000133b6 	.word	0x000133b6

000096c8 <lll_done>:
{
    96c8:	b538      	push	{r3, r4, r5, lr}
    96ca:	4604      	mov	r4, r0
	next = ull_prepare_dequeue_get();
    96cc:	f7fd f86a 	bl	67a4 <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
    96d0:	b17c      	cbz	r4, 96f2 <lll_done+0x2a>
    96d2:	b960      	cbnz	r0, 96ee <lll_done+0x26>
    96d4:	4a1d      	ldr	r2, [pc, #116]	; (974c <lll_done+0x84>)
    96d6:	491e      	ldr	r1, [pc, #120]	; (9750 <lll_done+0x88>)
    96d8:	481e      	ldr	r0, [pc, #120]	; (9754 <lll_done+0x8c>)
    96da:	f240 1337 	movw	r3, #311	; 0x137
    96de:	f005 fef2 	bl	f4c6 <printk>
    96e2:	4040      	eors	r0, r0
    96e4:	f380 8811 	msr	BASEPRI, r0
    96e8:	f04f 0003 	mov.w	r0, #3
    96ec:	df02      	svc	2
			ull = HDR_LLL2ULL(param);
    96ee:	6824      	ldr	r4, [r4, #0]
    96f0:	e015      	b.n	971e <lll_done+0x56>
		LL_ASSERT(event.curr.abort_cb);
    96f2:	4d19      	ldr	r5, [pc, #100]	; (9758 <lll_done+0x90>)
    96f4:	68ab      	ldr	r3, [r5, #8]
    96f6:	b963      	cbnz	r3, 9712 <lll_done+0x4a>
    96f8:	4a14      	ldr	r2, [pc, #80]	; (974c <lll_done+0x84>)
    96fa:	4918      	ldr	r1, [pc, #96]	; (975c <lll_done+0x94>)
    96fc:	4815      	ldr	r0, [pc, #84]	; (9754 <lll_done+0x8c>)
    96fe:	f240 133d 	movw	r3, #317	; 0x13d
    9702:	f005 fee0 	bl	f4c6 <printk>
    9706:	4040      	eors	r0, r0
    9708:	f380 8811 	msr	BASEPRI, r0
    970c:	f04f 0003 	mov.w	r0, #3
    9710:	df02      	svc	2
		param = event.curr.param;
    9712:	682c      	ldr	r4, [r5, #0]
		event.curr.abort_cb = NULL;
    9714:	2300      	movs	r3, #0
    9716:	60ab      	str	r3, [r5, #8]
		event.curr.param = NULL;
    9718:	602b      	str	r3, [r5, #0]
		if (param) {
    971a:	2c00      	cmp	r4, #0
    971c:	d1e7      	bne.n	96ee <lll_done+0x26>
	ull_prepare_dequeue(TICKER_USER_ID_LLL);
    971e:	2000      	movs	r0, #0
    9720:	f7fd f86c 	bl	67fc <ull_prepare_dequeue>
	evdone = ull_event_done(ull);
    9724:	4620      	mov	r0, r4
    9726:	f7fd f8c1 	bl	68ac <ull_event_done>
	LL_ASSERT(evdone);
    972a:	b960      	cbnz	r0, 9746 <lll_done+0x7e>
    972c:	4a07      	ldr	r2, [pc, #28]	; (974c <lll_done+0x84>)
    972e:	490c      	ldr	r1, [pc, #48]	; (9760 <lll_done+0x98>)
    9730:	4808      	ldr	r0, [pc, #32]	; (9754 <lll_done+0x8c>)
    9732:	f240 136d 	movw	r3, #365	; 0x16d
    9736:	f005 fec6 	bl	f4c6 <printk>
    973a:	4040      	eors	r0, r0
    973c:	f380 8811 	msr	BASEPRI, r0
    9740:	f04f 0003 	mov.w	r0, #3
    9744:	df02      	svc	2
}
    9746:	2000      	movs	r0, #0
    9748:	bd38      	pop	{r3, r4, r5, pc}
    974a:	bf00      	nop
    974c:	00013c53 	.word	0x00013c53
    9750:	00013d37 	.word	0x00013d37
    9754:	000133b6 	.word	0x000133b6
    9758:	20002178 	.word	0x20002178
    975c:	00013d46 	.word	0x00013d46
    9760:	00013d5a 	.word	0x00013d5a

00009764 <lll_is_done>:
	return !event.curr.abort_cb;
    9764:	4b02      	ldr	r3, [pc, #8]	; (9770 <lll_is_done+0xc>)
    9766:	6898      	ldr	r0, [r3, #8]
}
    9768:	fab0 f080 	clz	r0, r0
    976c:	0940      	lsrs	r0, r0, #5
    976e:	4770      	bx	lr
    9770:	20002178 	.word	0x20002178

00009774 <lll_abort_cb>:
{
    9774:	b510      	push	{r4, lr}
    9776:	460c      	mov	r4, r1
	if (!prepare_param) {
    9778:	b930      	cbnz	r0, 9788 <lll_abort_cb+0x14>
		radio_isr_set(lll_isr_done, param);
    977a:	480e      	ldr	r0, [pc, #56]	; (97b4 <lll_abort_cb+0x40>)
    977c:	f002 fb1e 	bl	bdbc <radio_isr_set>
}
    9780:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
    9784:	f002 bbe2 	b.w	bf4c <radio_disable>
	err = lll_hfclock_off();
    9788:	f000 f96a 	bl	9a60 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
    978c:	2800      	cmp	r0, #0
    978e:	da0c      	bge.n	97aa <lll_abort_cb+0x36>
    9790:	4a09      	ldr	r2, [pc, #36]	; (97b8 <lll_abort_cb+0x44>)
    9792:	490a      	ldr	r1, [pc, #40]	; (97bc <lll_abort_cb+0x48>)
    9794:	480a      	ldr	r0, [pc, #40]	; (97c0 <lll_abort_cb+0x4c>)
    9796:	f44f 73cc 	mov.w	r3, #408	; 0x198
    979a:	f005 fe94 	bl	f4c6 <printk>
    979e:	4040      	eors	r0, r0
    97a0:	f380 8811 	msr	BASEPRI, r0
    97a4:	f04f 0003 	mov.w	r0, #3
    97a8:	df02      	svc	2
	lll_done(param);
    97aa:	4620      	mov	r0, r4
}
    97ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
    97b0:	f7ff bf8a 	b.w	96c8 <lll_done>
    97b4:	0001182d 	.word	0x0001182d
    97b8:	00013c53 	.word	0x00013c53
    97bc:	00013d61 	.word	0x00013d61
    97c0:	000133b6 	.word	0x000133b6

000097c4 <lll_chan_set>:
	switch (chan) {
    97c4:	2826      	cmp	r0, #38	; 0x26
{
    97c6:	b510      	push	{r4, lr}
    97c8:	4604      	mov	r4, r0
	switch (chan) {
    97ca:	d00b      	beq.n	97e4 <lll_chan_set+0x20>
    97cc:	2827      	cmp	r0, #39	; 0x27
    97ce:	d00b      	beq.n	97e8 <lll_chan_set+0x24>
    97d0:	2825      	cmp	r0, #37	; 0x25
    97d2:	d10b      	bne.n	97ec <lll_chan_set+0x28>
		radio_freq_chan_set(2);
    97d4:	2002      	movs	r0, #2
		radio_freq_chan_set(26);
    97d6:	f002 fb4b 	bl	be70 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
    97da:	4620      	mov	r0, r4
}
    97dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
    97e0:	f002 bb4c 	b.w	be7c <radio_whiten_iv_set>
		radio_freq_chan_set(26);
    97e4:	201a      	movs	r0, #26
    97e6:	e7f6      	b.n	97d6 <lll_chan_set+0x12>
		radio_freq_chan_set(80);
    97e8:	2050      	movs	r0, #80	; 0x50
    97ea:	e7f4      	b.n	97d6 <lll_chan_set+0x12>
		if (chan < 11) {
    97ec:	280a      	cmp	r0, #10
    97ee:	d802      	bhi.n	97f6 <lll_chan_set+0x32>
			radio_freq_chan_set(4 + (chan * 2U));
    97f0:	3002      	adds	r0, #2
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
    97f2:	0040      	lsls	r0, r0, #1
    97f4:	e7ef      	b.n	97d6 <lll_chan_set+0x12>
		} else if (chan < 40) {
    97f6:	2827      	cmp	r0, #39	; 0x27
    97f8:	d801      	bhi.n	97fe <lll_chan_set+0x3a>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
    97fa:	3003      	adds	r0, #3
    97fc:	e7f9      	b.n	97f2 <lll_chan_set+0x2e>
			LL_ASSERT(0);
    97fe:	4a07      	ldr	r2, [pc, #28]	; (981c <lll_chan_set+0x58>)
    9800:	4907      	ldr	r1, [pc, #28]	; (9820 <lll_chan_set+0x5c>)
    9802:	4808      	ldr	r0, [pc, #32]	; (9824 <lll_chan_set+0x60>)
    9804:	f44f 73ed 	mov.w	r3, #474	; 0x1da
    9808:	f005 fe5d 	bl	f4c6 <printk>
    980c:	4040      	eors	r0, r0
    980e:	f380 8811 	msr	BASEPRI, r0
    9812:	f04f 0003 	mov.w	r0, #3
    9816:	df02      	svc	2
    9818:	e7df      	b.n	97da <lll_chan_set+0x16>
    981a:	bf00      	nop
    981c:	00013c53 	.word	0x00013c53
    9820:	00014086 	.word	0x00014086
    9824:	000133b6 	.word	0x000133b6

00009828 <lll_isr_cleanup>:
{
    9828:	b508      	push	{r3, lr}
    982a:	4601      	mov	r1, r0
	radio_isr_set(isr_race, param);
    982c:	480f      	ldr	r0, [pc, #60]	; (986c <lll_isr_cleanup+0x44>)
    982e:	f002 fac5 	bl	bdbc <radio_isr_set>
	if (!radio_is_idle()) {
    9832:	f002 fbbd 	bl	bfb0 <radio_is_idle>
    9836:	b908      	cbnz	r0, 983c <lll_isr_cleanup+0x14>
		radio_disable();
    9838:	f002 fb88 	bl	bf4c <radio_disable>
	radio_tmr_stop();
    983c:	f002 fd96 	bl	c36c <radio_tmr_stop>
	err = lll_hfclock_off();
    9840:	f000 f90e 	bl	9a60 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
    9844:	2800      	cmp	r0, #0
    9846:	da0c      	bge.n	9862 <lll_isr_cleanup+0x3a>
    9848:	4a09      	ldr	r2, [pc, #36]	; (9870 <lll_isr_cleanup+0x48>)
    984a:	490a      	ldr	r1, [pc, #40]	; (9874 <lll_isr_cleanup+0x4c>)
    984c:	480a      	ldr	r0, [pc, #40]	; (9878 <lll_isr_cleanup+0x50>)
    984e:	f240 233d 	movw	r3, #573	; 0x23d
    9852:	f005 fe38 	bl	f4c6 <printk>
    9856:	4040      	eors	r0, r0
    9858:	f380 8811 	msr	BASEPRI, r0
    985c:	f04f 0003 	mov.w	r0, #3
    9860:	df02      	svc	2
}
    9862:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
    9866:	2000      	movs	r0, #0
    9868:	f7ff bf2e 	b.w	96c8 <lll_done>
    986c:	0001176b 	.word	0x0001176b
    9870:	00013c53 	.word	0x00013c53
    9874:	00013d61 	.word	0x00013d61
    9878:	000133b6 	.word	0x000133b6

0000987c <lll_isr_early_abort>:
{
    987c:	b508      	push	{r3, lr}
    987e:	4601      	mov	r1, r0
	radio_isr_set(isr_race, param);
    9880:	480e      	ldr	r0, [pc, #56]	; (98bc <lll_isr_early_abort+0x40>)
    9882:	f002 fa9b 	bl	bdbc <radio_isr_set>
	if (!radio_is_idle()) {
    9886:	f002 fb93 	bl	bfb0 <radio_is_idle>
    988a:	b908      	cbnz	r0, 9890 <lll_isr_early_abort+0x14>
		radio_disable();
    988c:	f002 fb5e 	bl	bf4c <radio_disable>
	err = lll_hfclock_off();
    9890:	f000 f8e6 	bl	9a60 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
    9894:	2800      	cmp	r0, #0
    9896:	da0c      	bge.n	98b2 <lll_isr_early_abort+0x36>
    9898:	4a09      	ldr	r2, [pc, #36]	; (98c0 <lll_isr_early_abort+0x44>)
    989a:	490a      	ldr	r1, [pc, #40]	; (98c4 <lll_isr_early_abort+0x48>)
    989c:	480a      	ldr	r0, [pc, #40]	; (98c8 <lll_isr_early_abort+0x4c>)
    989e:	f44f 7313 	mov.w	r3, #588	; 0x24c
    98a2:	f005 fe10 	bl	f4c6 <printk>
    98a6:	4040      	eors	r0, r0
    98a8:	f380 8811 	msr	BASEPRI, r0
    98ac:	f04f 0003 	mov.w	r0, #3
    98b0:	df02      	svc	2
}
    98b2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
    98b6:	2000      	movs	r0, #0
    98b8:	f7ff bf06 	b.w	96c8 <lll_done>
    98bc:	0001176b 	.word	0x0001176b
    98c0:	00013c53 	.word	0x00013c53
    98c4:	00013d61 	.word	0x00013d61
    98c8:	000133b6 	.word	0x000133b6

000098cc <lll_prepare_resolve>:
{
    98cc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    98d0:	461d      	mov	r5, r3
    98d2:	f89d a030 	ldrb.w	sl, [sp, #48]	; 0x30
	idx = UINT8_MAX;
    98d6:	23ff      	movs	r3, #255	; 0xff
{
    98d8:	4681      	mov	r9, r0
    98da:	4688      	mov	r8, r1
    98dc:	4616      	mov	r6, r2
	idx = UINT8_MAX;
    98de:	f88d 300f 	strb.w	r3, [sp, #15]
		p = ull_prepare_dequeue_iter(&idx);
    98e2:	f10d 000f 	add.w	r0, sp, #15
    98e6:	f7fc ff6b 	bl	67c0 <ull_prepare_dequeue_iter>
    98ea:	4604      	mov	r4, r0
	while (p && (p->is_aborted || p->is_resume)) {
    98ec:	b110      	cbz	r0, 98f4 <lll_prepare_resolve+0x28>
    98ee:	7f03      	ldrb	r3, [r0, #28]
    98f0:	079b      	lsls	r3, r3, #30
    98f2:	d1f6      	bne.n	98e2 <lll_prepare_resolve+0x16>
	    event.curr.abort_cb ||
    98f4:	4f41      	ldr	r7, [pc, #260]	; (99fc <lll_prepare_resolve+0x130>)
	if ((!is_dequeue && !is_done_sync()) ||
    98f6:	68bb      	ldr	r3, [r7, #8]
    98f8:	b923      	cbnz	r3, 9904 <lll_prepare_resolve+0x38>
	    event.curr.abort_cb ||
    98fa:	2c00      	cmp	r4, #0
    98fc:	d046      	beq.n	998c <lll_prepare_resolve+0xc0>
	    (p && is_resume)) {
    98fe:	f1ba 0f00 	cmp.w	sl, #0
    9902:	d034      	beq.n	996e <lll_prepare_resolve+0xa2>
		next = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
    9904:	462a      	mov	r2, r5
    9906:	f8cd a000 	str.w	sl, [sp]
    990a:	4633      	mov	r3, r6
    990c:	4641      	mov	r1, r8
    990e:	4648      	mov	r0, r9
    9910:	f7fc ff1a 	bl	6748 <ull_prepare_enqueue>
		LL_ASSERT(next);
    9914:	4605      	mov	r5, r0
    9916:	b960      	cbnz	r0, 9932 <lll_prepare_resolve+0x66>
    9918:	4a39      	ldr	r2, [pc, #228]	; (9a00 <lll_prepare_resolve+0x134>)
    991a:	493a      	ldr	r1, [pc, #232]	; (9a04 <lll_prepare_resolve+0x138>)
    991c:	483a      	ldr	r0, [pc, #232]	; (9a08 <lll_prepare_resolve+0x13c>)
    991e:	f44f 7322 	mov.w	r3, #648	; 0x288
    9922:	f005 fdd0 	bl	f4c6 <printk>
    9926:	4040      	eors	r0, r0
    9928:	f380 8811 	msr	BASEPRI, r0
    992c:	f04f 0003 	mov.w	r0, #3
    9930:	df02      	svc	2
		if (is_resume) {
    9932:	f1ba 0f00 	cmp.w	sl, #0
    9936:	d005      	beq.n	9944 <lll_prepare_resolve+0x78>
		return -EINPROGRESS;
    9938:	f06f 0476 	mvn.w	r4, #118	; 0x76
}
    993c:	4620      	mov	r0, r4
    993e:	b004      	add	sp, #16
    9940:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		ret  = preempt_ticker_start(p, next);
    9944:	4629      	mov	r1, r5
    9946:	4620      	mov	r0, r4
    9948:	f7ff fd42 	bl	93d0 <preempt_ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    994c:	f030 0302 	bics.w	r3, r0, #2
    9950:	d0f2      	beq.n	9938 <lll_prepare_resolve+0x6c>
    9952:	4a2b      	ldr	r2, [pc, #172]	; (9a00 <lll_prepare_resolve+0x134>)
    9954:	492d      	ldr	r1, [pc, #180]	; (9a0c <lll_prepare_resolve+0x140>)
    9956:	482c      	ldr	r0, [pc, #176]	; (9a08 <lll_prepare_resolve+0x13c>)
    9958:	f240 2393 	movw	r3, #659	; 0x293
    995c:	f005 fdb3 	bl	f4c6 <printk>
    9960:	4040      	eors	r0, r0
    9962:	f380 8811 	msr	BASEPRI, r0
    9966:	f04f 0003 	mov.w	r0, #3
    996a:	df02      	svc	2
    996c:	e7e4      	b.n	9938 <lll_prepare_resolve+0x6c>
	LL_ASSERT(!p || &p->prepare_param == prepare_param);
    996e:	42ac      	cmp	r4, r5
    9970:	d00c      	beq.n	998c <lll_prepare_resolve+0xc0>
    9972:	4a23      	ldr	r2, [pc, #140]	; (9a00 <lll_prepare_resolve+0x134>)
    9974:	4926      	ldr	r1, [pc, #152]	; (9a10 <lll_prepare_resolve+0x144>)
    9976:	4824      	ldr	r0, [pc, #144]	; (9a08 <lll_prepare_resolve+0x13c>)
    9978:	f240 23b9 	movw	r3, #697	; 0x2b9
    997c:	f005 fda3 	bl	f4c6 <printk>
    9980:	4040      	eors	r0, r0
    9982:	f380 8811 	msr	BASEPRI, r0
    9986:	f04f 0003 	mov.w	r0, #3
    998a:	df02      	svc	2
	event.curr.param = prepare_param->param;
    998c:	68eb      	ldr	r3, [r5, #12]
	event.curr.abort_cb = abort_cb;
    998e:	f8c7 8008 	str.w	r8, [r7, #8]
	event.curr.is_abort_cb = is_abort_cb;
    9992:	e9c7 3900 	strd	r3, r9, [r7]
	err = prepare_cb(prepare_param);
    9996:	4628      	mov	r0, r5
    9998:	47b0      	blx	r6
    999a:	4604      	mov	r4, r0
	ret = preempt_ticker_stop();
    999c:	f7ff fcd8 	bl	9350 <preempt_ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    99a0:	f030 0302 	bics.w	r3, r0, #2
    99a4:	d00c      	beq.n	99c0 <lll_prepare_resolve+0xf4>
    99a6:	4a16      	ldr	r2, [pc, #88]	; (9a00 <lll_prepare_resolve+0x134>)
    99a8:	4918      	ldr	r1, [pc, #96]	; (9a0c <lll_prepare_resolve+0x140>)
    99aa:	4817      	ldr	r0, [pc, #92]	; (9a08 <lll_prepare_resolve+0x13c>)
    99ac:	f240 23c6 	movw	r3, #710	; 0x2c6
    99b0:	f005 fd89 	bl	f4c6 <printk>
    99b4:	4040      	eors	r0, r0
    99b6:	f380 8811 	msr	BASEPRI, r0
    99ba:	f04f 0003 	mov.w	r0, #3
    99be:	df02      	svc	2
		p = ull_prepare_dequeue_iter(&idx);
    99c0:	f10d 000f 	add.w	r0, sp, #15
    99c4:	f7fc fefc 	bl	67c0 <ull_prepare_dequeue_iter>
		if (!p) {
    99c8:	4601      	mov	r1, r0
    99ca:	2800      	cmp	r0, #0
    99cc:	d0b6      	beq.n	993c <lll_prepare_resolve+0x70>
	} while (p->is_aborted || p->is_resume);
    99ce:	7f00      	ldrb	r0, [r0, #28]
    99d0:	f010 0003 	ands.w	r0, r0, #3
    99d4:	d1f4      	bne.n	99c0 <lll_prepare_resolve+0xf4>
	ret = preempt_ticker_start(NULL, p);
    99d6:	f7ff fcfb 	bl	93d0 <preempt_ticker_start>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    99da:	f030 0302 	bics.w	r3, r0, #2
    99de:	d0ad      	beq.n	993c <lll_prepare_resolve+0x70>
    99e0:	4a07      	ldr	r2, [pc, #28]	; (9a00 <lll_prepare_resolve+0x134>)
    99e2:	490a      	ldr	r1, [pc, #40]	; (9a0c <lll_prepare_resolve+0x140>)
    99e4:	4808      	ldr	r0, [pc, #32]	; (9a08 <lll_prepare_resolve+0x13c>)
    99e6:	f240 23d3 	movw	r3, #723	; 0x2d3
    99ea:	f005 fd6c 	bl	f4c6 <printk>
    99ee:	4040      	eors	r0, r0
    99f0:	f380 8811 	msr	BASEPRI, r0
    99f4:	f04f 0003 	mov.w	r0, #3
    99f8:	df02      	svc	2
    99fa:	e79f      	b.n	993c <lll_prepare_resolve+0x70>
    99fc:	20002178 	.word	0x20002178
    9a00:	00013c53 	.word	0x00013c53
    9a04:	00013d41 	.word	0x00013d41
    9a08:	000133b6 	.word	0x000133b6
    9a0c:	000137b3 	.word	0x000137b3
    9a10:	00013d6a 	.word	0x00013d6a

00009a14 <lll_clock_init>:

	return k_sem_take(&state.sem, K_MSEC(timeout));
}

int lll_clock_init(void)
{
    9a14:	b508      	push	{r3, lr}
	struct onoff_manager *mgr =
		z_nrf_clock_control_get_onoff(CLOCK_CONTROL_NRF_SUBSYS_LF);
    9a16:	2001      	movs	r0, #1
    9a18:	f003 f866 	bl	cae8 <z_nrf_clock_control_get_onoff>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    9a1c:	4904      	ldr	r1, [pc, #16]	; (9a30 <lll_clock_init+0x1c>)
    9a1e:	2300      	movs	r3, #0
    9a20:	604b      	str	r3, [r1, #4]
    9a22:	60cb      	str	r3, [r1, #12]
    9a24:	2301      	movs	r3, #1
    9a26:	608b      	str	r3, [r1, #8]

	sys_notify_init_spinwait(&lf_cli.notify);

	return onoff_request(mgr, &lf_cli);
}
    9a28:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return onoff_request(mgr, &lf_cli);
    9a2c:	f005 bdc7 	b.w	f5be <onoff_request>
    9a30:	20002194 	.word	0x20002194

00009a34 <lll_hfclock_on>:

	return 0;
}

int lll_hfclock_on(void)
{
    9a34:	b508      	push	{r3, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    9a36:	4b09      	ldr	r3, [pc, #36]	; (9a5c <lll_hfclock_on+0x28>)
    9a38:	f3bf 8f5b 	dmb	ish
    9a3c:	e853 2f00 	ldrex	r2, [r3]
    9a40:	1c51      	adds	r1, r2, #1
    9a42:	e843 1000 	strex	r0, r1, [r3]
    9a46:	2800      	cmp	r0, #0
    9a48:	d1f8      	bne.n	9a3c <lll_hfclock_on+0x8>
    9a4a:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&hf_refcnt) > 0) {
    9a4e:	2a00      	cmp	r2, #0
    9a50:	dc01      	bgt.n	9a56 <lll_hfclock_on+0x22>
		return 0;
	}

	z_nrf_clock_bt_ctlr_hf_request();
    9a52:	f003 f851 	bl	caf8 <z_nrf_clock_bt_ctlr_hf_request>
	DEBUG_RADIO_XTAL(1);

	return 0;
}
    9a56:	2000      	movs	r0, #0
    9a58:	bd08      	pop	{r3, pc}
    9a5a:	bf00      	nop
    9a5c:	20002190 	.word	0x20002190

00009a60 <lll_hfclock_off>:

	return err;
}

int lll_hfclock_off(void)
{
    9a60:	b508      	push	{r3, lr}
	if (hf_refcnt < 1) {
    9a62:	4b0c      	ldr	r3, [pc, #48]	; (9a94 <lll_hfclock_off+0x34>)
    9a64:	681a      	ldr	r2, [r3, #0]
    9a66:	2a00      	cmp	r2, #0
    9a68:	dd10      	ble.n	9a8c <lll_hfclock_off+0x2c>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    9a6a:	f3bf 8f5b 	dmb	ish
    9a6e:	e853 2f00 	ldrex	r2, [r3]
    9a72:	1e51      	subs	r1, r2, #1
    9a74:	e843 1000 	strex	r0, r1, [r3]
    9a78:	2800      	cmp	r0, #0
    9a7a:	d1f8      	bne.n	9a6e <lll_hfclock_off+0xe>
    9a7c:	f3bf 8f5b 	dmb	ish
		return -EALREADY;
	}

	if (atomic_dec(&hf_refcnt) > 1) {
    9a80:	2a01      	cmp	r2, #1
    9a82:	dc01      	bgt.n	9a88 <lll_hfclock_off+0x28>
		return 0;
	}

	z_nrf_clock_bt_ctlr_hf_release();
    9a84:	f003 f84e 	bl	cb24 <z_nrf_clock_bt_ctlr_hf_release>
		return 0;
    9a88:	2000      	movs	r0, #0
    9a8a:	e001      	b.n	9a90 <lll_hfclock_off+0x30>
		return -EALREADY;
    9a8c:	f06f 0077 	mvn.w	r0, #119	; 0x77
	DEBUG_RADIO_XTAL(0);

	return 0;
}
    9a90:	bd08      	pop	{r3, pc}
    9a92:	bf00      	nop
    9a94:	20002190 	.word	0x20002190

00009a98 <isr_tx>:
{
	struct node_rx_pdu *node_rx_prof;
	struct node_rx_pdu *node_rx;
#if defined(CONFIG_BT_CTLR_ADV_EXT)
	struct lll_adv *lll = param;
	uint8_t phy_p = lll->phy_p;
    9a98:	7943      	ldrb	r3, [r0, #5]
{
    9a9a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t phy_p = lll->phy_p;
    9a9c:	f003 0507 	and.w	r5, r3, #7
	uint8_t phy_flags = lll->phy_flags;
    9aa0:	f3c3 1680 	ubfx	r6, r3, #6, #1
{
    9aa4:	4604      	mov	r4, r0
		lll_prof_latency_capture();
		node_rx_prof = lll_prof_reserve();
	}

	/* Clear radio tx status and events */
	lll_isr_tx_status_reset();
    9aa6:	f007 fe9b 	bl	117e0 <lll_isr_tx_status_reset>

	/* setup tIFS switching */
	radio_tmr_tifs_set(EVENT_IFS_US);
    9aaa:	2096      	movs	r0, #150	; 0x96
    9aac:	f002 fbc0 	bl	c230 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(phy_p, 0, phy_p, phy_flags);
    9ab0:	4633      	mov	r3, r6
    9ab2:	462a      	mov	r2, r5
    9ab4:	2100      	movs	r1, #0
    9ab6:	4628      	mov	r0, r5
    9ab8:	f002 fb1e 	bl	c0f8 <radio_switch_complete_and_tx>

	/* setup Rx buffer */
	node_rx = ull_pdu_rx_alloc_peek(1);
    9abc:	2001      	movs	r0, #1
    9abe:	f7fc fdf9 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    9ac2:	4606      	mov	r6, r0
    9ac4:	b960      	cbnz	r0, 9ae0 <isr_tx+0x48>
    9ac6:	4a29      	ldr	r2, [pc, #164]	; (9b6c <isr_tx+0xd4>)
    9ac8:	4929      	ldr	r1, [pc, #164]	; (9b70 <isr_tx+0xd8>)
    9aca:	482a      	ldr	r0, [pc, #168]	; (9b74 <isr_tx+0xdc>)
    9acc:	f240 433c 	movw	r3, #1084	; 0x43c
    9ad0:	f005 fcf9 	bl	f4c6 <printk>
    9ad4:	4040      	eors	r0, r0
    9ad6:	f380 8811 	msr	BASEPRI, r0
    9ada:	f04f 0003 	mov.w	r0, #3
    9ade:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
    9ae0:	f106 001c 	add.w	r0, r6, #28
    9ae4:	f002 fa20 	bl	bf28 <radio_pkt_rx_set>

	/* assert if radio packet ptr is not set and radio started rx */
	LL_ASSERT(!radio_is_ready());
    9ae8:	f002 fa4e 	bl	bf88 <radio_is_ready>
    9aec:	b160      	cbz	r0, 9b08 <isr_tx+0x70>
    9aee:	4a1f      	ldr	r2, [pc, #124]	; (9b6c <isr_tx+0xd4>)
    9af0:	4921      	ldr	r1, [pc, #132]	; (9b78 <isr_tx+0xe0>)
    9af2:	4820      	ldr	r0, [pc, #128]	; (9b74 <isr_tx+0xdc>)
    9af4:	f44f 6388 	mov.w	r3, #1088	; 0x440
    9af8:	f005 fce5 	bl	f4c6 <printk>
    9afc:	4040      	eors	r0, r0
    9afe:	f380 8811 	msr	BASEPRI, r0
    9b02:	f04f 0003 	mov.w	r0, #3
    9b06:	df02      	svc	2

	if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
		lll_prof_cputime_capture();
	}

	radio_isr_set(isr_rx, param);
    9b08:	481c      	ldr	r0, [pc, #112]	; (9b7c <isr_tx+0xe4>)
    9b0a:	4621      	mov	r1, r4
    9b0c:	f002 f956 	bl	bdbc <radio_isr_set>

#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (ull_filter_lll_rl_enabled()) {
    9b10:	f7ff fb4c 	bl	91ac <ull_filter_lll_rl_enabled>
    9b14:	b148      	cbz	r0, 9b2a <isr_tx+0x92>
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    9b16:	f10d 0007 	add.w	r0, sp, #7
    9b1a:	f7ff f9e9 	bl	8ef0 <ull_filter_lll_irks_get>

		radio_ar_configure(count, irks, 0);
    9b1e:	2200      	movs	r2, #0
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    9b20:	4601      	mov	r1, r0
		radio_ar_configure(count, irks, 0);
    9b22:	f89d 0007 	ldrb.w	r0, [sp, #7]
    9b26:	f002 fc4d 	bl	c3c4 <radio_ar_configure>
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	/* +/- 2us active clock jitter, +1 us hcto compensation */
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    9b2a:	f002 fc45 	bl	c3b8 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(phy_p, 0);
    9b2e:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    9b30:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(phy_p, 0);
    9b32:	4628      	mov	r0, r5
    9b34:	f008 f8d0 	bl	11cd8 <radio_rx_chain_delay_get>
#define RANGE_DISTANCE 1000 /* meters */
#define RANGE_DELAY_US (2 * RANGE_DISTANCE * 4 / 1000)

static inline uint32_t addr_us_get(uint8_t phy)
{
	switch (phy) {
    9b38:	2d02      	cmp	r5, #2
    9b3a:	4404      	add	r4, r0
    9b3c:	f104 049b 	add.w	r4, r4, #155	; 0x9b
    9b40:	d011      	beq.n	9b66 <isr_tx+0xce>
	default:
	case BIT(0):
		return 40;
    9b42:	2d04      	cmp	r5, #4
    9b44:	bf0c      	ite	eq
    9b46:	f44f 70bc 	moveq.w	r0, #376	; 0x178
    9b4a:	2028      	movne	r0, #40	; 0x28
	hcto += addr_us_get(phy_p);
    9b4c:	4404      	add	r4, r0
	hcto -= radio_tx_chain_delay_get(phy_p, 0);
    9b4e:	2100      	movs	r1, #0
    9b50:	4628      	mov	r0, r5
    9b52:	f008 f8bd 	bl	11cd0 <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
    9b56:	1a20      	subs	r0, r4, r0
    9b58:	f002 fc14 	bl	c384 <radio_tmr_hcto_configure>
		/* NOTE: as scratch packet is used to receive, it is safe to
		 * generate profile event using rx nodes.
		 */
		lll_prof_reserve_send(node_rx_prof);
	}
}
    9b5c:	b002      	add	sp, #8
    9b5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	radio_tmr_end_capture();
    9b62:	f002 bc1b 	b.w	c39c <radio_tmr_end_capture>
	switch (phy) {
    9b66:	2018      	movs	r0, #24
    9b68:	e7f0      	b.n	9b4c <isr_tx+0xb4>
    9b6a:	bf00      	nop
    9b6c:	00013d93 	.word	0x00013d93
    9b70:	00013ddd 	.word	0x00013ddd
    9b74:	000133b6 	.word	0x000133b6
    9b78:	00013de5 	.word	0x00013de5
    9b7c:	0000a0e1 	.word	0x0000a0e1

00009b80 <abort_cb>:
{
    9b80:	b510      	push	{r4, lr}
    9b82:	460c      	mov	r4, r1
	if (!prepare_param) {
    9b84:	b930      	cbnz	r0, 9b94 <abort_cb+0x14>
		radio_isr_set(isr_abort, param);
    9b86:	480e      	ldr	r0, [pc, #56]	; (9bc0 <abort_cb+0x40>)
    9b88:	f002 f918 	bl	bdbc <radio_isr_set>
}
    9b8c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
    9b90:	f002 b9dc 	b.w	bf4c <radio_disable>
	err = lll_hfclock_off();
    9b94:	f7ff ff64 	bl	9a60 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
    9b98:	2800      	cmp	r0, #0
    9b9a:	da0c      	bge.n	9bb6 <abort_cb+0x36>
    9b9c:	4a09      	ldr	r2, [pc, #36]	; (9bc4 <abort_cb+0x44>)
    9b9e:	490a      	ldr	r1, [pc, #40]	; (9bc8 <abort_cb+0x48>)
    9ba0:	480a      	ldr	r0, [pc, #40]	; (9bcc <abort_cb+0x4c>)
    9ba2:	f240 431b 	movw	r3, #1051	; 0x41b
    9ba6:	f005 fc8e 	bl	f4c6 <printk>
    9baa:	4040      	eors	r0, r0
    9bac:	f380 8811 	msr	BASEPRI, r0
    9bb0:	f04f 0003 	mov.w	r0, #3
    9bb4:	df02      	svc	2
	lll_done(param);
    9bb6:	4620      	mov	r0, r4
}
    9bb8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
    9bbc:	f7ff bd84 	b.w	96c8 <lll_done>
    9bc0:	0001183b 	.word	0x0001183b
    9bc4:	00013d93 	.word	0x00013d93
    9bc8:	00013d61 	.word	0x00013d61
    9bcc:	000133b6 	.word	0x000133b6

00009bd0 <init_reset>:
	mem_init(mem_pdu.pool, PDU_MEM_SIZE,
    9bd0:	4b08      	ldr	r3, [pc, #32]	; (9bf4 <init_reset+0x24>)
{
    9bd2:	b510      	push	{r4, lr}
	mem_init(mem_pdu.pool, PDU_MEM_SIZE,
    9bd4:	1d18      	adds	r0, r3, #4
    9bd6:	2205      	movs	r2, #5
    9bd8:	2164      	movs	r1, #100	; 0x64
    9bda:	f006 fcf9 	bl	105d0 <mem_init>
	MFIFO_INIT(pdu_free);
    9bde:	4b06      	ldr	r3, [pc, #24]	; (9bf8 <init_reset+0x28>)
    9be0:	2400      	movs	r4, #0
    9be2:	805c      	strh	r4, [r3, #2]
	return z_impl_k_sem_init(sem, initial_count, limit);
    9be4:	2203      	movs	r2, #3
    9be6:	4621      	mov	r1, r4
    9be8:	4804      	ldr	r0, [pc, #16]	; (9bfc <init_reset+0x2c>)
    9bea:	f008 fd47 	bl	1267c <z_impl_k_sem_init>
}
    9bee:	4620      	mov	r0, r4
    9bf0:	bd10      	pop	{r4, pc}
    9bf2:	bf00      	nop
    9bf4:	200021a4 	.word	0x200021a4
    9bf8:	20000448 	.word	0x20000448
    9bfc:	2000239c 	.word	0x2000239c

00009c00 <lll_adv_data_init>:
{
    9c00:	b510      	push	{r4, lr}
    9c02:	4604      	mov	r4, r0
	p = mem_acquire(&mem_pdu.free);
    9c04:	4805      	ldr	r0, [pc, #20]	; (9c1c <lll_adv_data_init+0x1c>)
    9c06:	f006 fd0b 	bl	10620 <mem_acquire>
	if (!p) {
    9c0a:	4603      	mov	r3, r0
    9c0c:	b118      	cbz	r0, 9c16 <lll_adv_data_init+0x16>
	p->len = 0U;
    9c0e:	2000      	movs	r0, #0
    9c10:	7058      	strb	r0, [r3, #1]
	pdu->pdu[0] = (void *)p;
    9c12:	6063      	str	r3, [r4, #4]
}
    9c14:	bd10      	pop	{r4, pc}
		return -ENOMEM;
    9c16:	f06f 000b 	mvn.w	r0, #11
    9c1a:	e7fb      	b.n	9c14 <lll_adv_data_init+0x14>
    9c1c:	200021a4 	.word	0x200021a4

00009c20 <lll_adv_data_dequeue>:
{
    9c20:	b570      	push	{r4, r5, r6, lr}
	first = pdu->first;
    9c22:	7803      	ldrb	r3, [r0, #0]
	if (first == pdu->last) {
    9c24:	7842      	ldrb	r2, [r0, #1]
    9c26:	429a      	cmp	r2, r3
{
    9c28:	4605      	mov	r5, r0
	first = pdu->first;
    9c2a:	b2dc      	uxtb	r4, r3
	if (first == pdu->last) {
    9c2c:	d00f      	beq.n	9c4e <lll_adv_data_dequeue+0x2e>
	p = pdu->pdu[first];
    9c2e:	eb00 0384 	add.w	r3, r0, r4, lsl #2
	pdu->pdu[first] = NULL;
    9c32:	2600      	movs	r6, #0
	p = pdu->pdu[first];
    9c34:	6858      	ldr	r0, [r3, #4]
	mem_release(p, &mem_pdu.free);
    9c36:	4907      	ldr	r1, [pc, #28]	; (9c54 <lll_adv_data_dequeue+0x34>)
	pdu->pdu[first] = NULL;
    9c38:	605e      	str	r6, [r3, #4]
	mem_release(p, &mem_pdu.free);
    9c3a:	f006 fd0a 	bl	10652 <mem_release>
	first++;
    9c3e:	1c63      	adds	r3, r4, #1
    9c40:	b2db      	uxtb	r3, r3
		first = 0U;
    9c42:	2b02      	cmp	r3, #2
    9c44:	bf08      	it	eq
    9c46:	4633      	moveq	r3, r6
	pdu->first = first;
    9c48:	702b      	strb	r3, [r5, #0]
	return 0;
    9c4a:	4630      	mov	r0, r6
}
    9c4c:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
    9c4e:	f06f 000b 	mvn.w	r0, #11
    9c52:	e7fb      	b.n	9c4c <lll_adv_data_dequeue+0x2c>
    9c54:	200021a4 	.word	0x200021a4

00009c58 <lll_adv_data_release>:
{
    9c58:	b570      	push	{r4, r5, r6, lr}
	last = pdu->last;
    9c5a:	7845      	ldrb	r5, [r0, #1]
	mem_release(p, &mem_pdu.free);
    9c5c:	490b      	ldr	r1, [pc, #44]	; (9c8c <lll_adv_data_release+0x34>)
    9c5e:	eb00 0385 	add.w	r3, r0, r5, lsl #2
	pdu->pdu[last] = NULL;
    9c62:	2600      	movs	r6, #0
{
    9c64:	4604      	mov	r4, r0
	p = pdu->pdu[last];
    9c66:	6858      	ldr	r0, [r3, #4]
	pdu->pdu[last] = NULL;
    9c68:	605e      	str	r6, [r3, #4]
	mem_release(p, &mem_pdu.free);
    9c6a:	f006 fcf2 	bl	10652 <mem_release>
	last++;
    9c6e:	1c68      	adds	r0, r5, #1
    9c70:	b2c0      	uxtb	r0, r0
		last = 0U;
    9c72:	2802      	cmp	r0, #2
    9c74:	bf08      	it	eq
    9c76:	4630      	moveq	r0, r6
	p = pdu->pdu[last];
    9c78:	eb04 0480 	add.w	r4, r4, r0, lsl #2
    9c7c:	6860      	ldr	r0, [r4, #4]
	if (p) {
    9c7e:	b118      	cbz	r0, 9c88 <lll_adv_data_release+0x30>
		mem_release(p, &mem_pdu.free);
    9c80:	4902      	ldr	r1, [pc, #8]	; (9c8c <lll_adv_data_release+0x34>)
		pdu->pdu[last] = NULL;
    9c82:	6066      	str	r6, [r4, #4]
		mem_release(p, &mem_pdu.free);
    9c84:	f006 fce5 	bl	10652 <mem_release>
}
    9c88:	2000      	movs	r0, #0
    9c8a:	bd70      	pop	{r4, r5, r6, pc}
    9c8c:	200021a4 	.word	0x200021a4

00009c90 <lll_adv_pdu_alloc_pdu_adv>:
{
    9c90:	b538      	push	{r3, r4, r5, lr}
	p = MFIFO_DEQUEUE_PEEK(pdu_free);
    9c92:	4c33      	ldr	r4, [pc, #204]	; (9d60 <lll_adv_pdu_alloc_pdu_adv+0xd0>)
    9c94:	78a2      	ldrb	r2, [r4, #2]
	if (first == last) {
    9c96:	78e1      	ldrb	r1, [r4, #3]
    9c98:	7823      	ldrb	r3, [r4, #0]
    9c9a:	4291      	cmp	r1, r2
    9c9c:	d023      	beq.n	9ce6 <lll_adv_pdu_alloc_pdu_adv+0x56>
	return *((void **)(fifo + first * size));
    9c9e:	fb02 4303 	mla	r3, r2, r3, r4
    9ca2:	685d      	ldr	r5, [r3, #4]
	if (p) {
    9ca4:	b1fd      	cbz	r5, 9ce6 <lll_adv_pdu_alloc_pdu_adv+0x56>
	return z_impl_k_sem_take(sem, timeout);
    9ca6:	482f      	ldr	r0, [pc, #188]	; (9d64 <lll_adv_pdu_alloc_pdu_adv+0xd4>)
    9ca8:	2200      	movs	r2, #0
    9caa:	2300      	movs	r3, #0
    9cac:	f004 fd0c 	bl	e6c8 <z_impl_k_sem_take>
		LL_ASSERT(!err);
    9cb0:	b160      	cbz	r0, 9ccc <lll_adv_pdu_alloc_pdu_adv+0x3c>
    9cb2:	4a2d      	ldr	r2, [pc, #180]	; (9d68 <lll_adv_pdu_alloc_pdu_adv+0xd8>)
    9cb4:	492d      	ldr	r1, [pc, #180]	; (9d6c <lll_adv_pdu_alloc_pdu_adv+0xdc>)
    9cb6:	482e      	ldr	r0, [pc, #184]	; (9d70 <lll_adv_pdu_alloc_pdu_adv+0xe0>)
    9cb8:	f44f 73cb 	mov.w	r3, #406	; 0x196
    9cbc:	f005 fc03 	bl	f4c6 <printk>
    9cc0:	4040      	eors	r0, r0
    9cc2:	f380 8811 	msr	BASEPRI, r0
    9cc6:	f04f 0003 	mov.w	r0, #3
    9cca:	df02      	svc	2
	uint8_t _first = *first; /* Copy read-index */
    9ccc:	78a3      	ldrb	r3, [r4, #2]
	if (_first == last) {
    9cce:	78e1      	ldrb	r1, [r4, #3]
		MFIFO_DEQUEUE(pdu_free);
    9cd0:	7862      	ldrb	r2, [r4, #1]
    9cd2:	4299      	cmp	r1, r3
    9cd4:	d005      	beq.n	9ce2 <lll_adv_pdu_alloc_pdu_adv+0x52>
	_first += 1U;
    9cd6:	3301      	adds	r3, #1
    9cd8:	b2db      	uxtb	r3, r3
		_first = 0U;
    9cda:	429a      	cmp	r2, r3
    9cdc:	bf08      	it	eq
    9cde:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
    9ce0:	70a3      	strb	r3, [r4, #2]
}
    9ce2:	4628      	mov	r0, r5
    9ce4:	bd38      	pop	{r3, r4, r5, pc}
	p = mem_acquire(&mem_pdu.free);
    9ce6:	4823      	ldr	r0, [pc, #140]	; (9d74 <lll_adv_pdu_alloc_pdu_adv+0xe4>)
    9ce8:	f006 fc9a 	bl	10620 <mem_acquire>
	if (p) {
    9cec:	4605      	mov	r5, r0
    9cee:	2800      	cmp	r0, #0
    9cf0:	d1f7      	bne.n	9ce2 <lll_adv_pdu_alloc_pdu_adv+0x52>
    9cf2:	481c      	ldr	r0, [pc, #112]	; (9d64 <lll_adv_pdu_alloc_pdu_adv+0xd4>)
    9cf4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9cf8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9cfc:	f004 fce4 	bl	e6c8 <z_impl_k_sem_take>
	LL_ASSERT(!err);
    9d00:	b160      	cbz	r0, 9d1c <lll_adv_pdu_alloc_pdu_adv+0x8c>
    9d02:	4a19      	ldr	r2, [pc, #100]	; (9d68 <lll_adv_pdu_alloc_pdu_adv+0xd8>)
    9d04:	4919      	ldr	r1, [pc, #100]	; (9d6c <lll_adv_pdu_alloc_pdu_adv+0xdc>)
    9d06:	481a      	ldr	r0, [pc, #104]	; (9d70 <lll_adv_pdu_alloc_pdu_adv+0xe0>)
    9d08:	f240 13a9 	movw	r3, #425	; 0x1a9
    9d0c:	f005 fbdb 	bl	f4c6 <printk>
    9d10:	4040      	eors	r0, r0
    9d12:	f380 8811 	msr	BASEPRI, r0
    9d16:	f04f 0003 	mov.w	r0, #3
    9d1a:	df02      	svc	2
	uint8_t _first = *first; /* Copy read-index */
    9d1c:	78a3      	ldrb	r3, [r4, #2]
	if (_first == last) {
    9d1e:	78e0      	ldrb	r0, [r4, #3]
	p = MFIFO_DEQUEUE(pdu_free);
    9d20:	7822      	ldrb	r2, [r4, #0]
    9d22:	7861      	ldrb	r1, [r4, #1]
    9d24:	4298      	cmp	r0, r3
    9d26:	d10d      	bne.n	9d44 <lll_adv_pdu_alloc_pdu_adv+0xb4>
	LL_ASSERT(p);
    9d28:	4a0f      	ldr	r2, [pc, #60]	; (9d68 <lll_adv_pdu_alloc_pdu_adv+0xd8>)
    9d2a:	4913      	ldr	r1, [pc, #76]	; (9d78 <lll_adv_pdu_alloc_pdu_adv+0xe8>)
    9d2c:	4810      	ldr	r0, [pc, #64]	; (9d70 <lll_adv_pdu_alloc_pdu_adv+0xe0>)
    9d2e:	f44f 73d6 	mov.w	r3, #428	; 0x1ac
    9d32:	f005 fbc8 	bl	f4c6 <printk>
    9d36:	4040      	eors	r0, r0
    9d38:	f380 8811 	msr	BASEPRI, r0
    9d3c:	f04f 0003 	mov.w	r0, #3
    9d40:	df02      	svc	2
    9d42:	e7ce      	b.n	9ce2 <lll_adv_pdu_alloc_pdu_adv+0x52>
	mem = *((void **)(fifo + _first * size));
    9d44:	fb03 4202 	mla	r2, r3, r2, r4
	_first += 1U;
    9d48:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
    9d4a:	6852      	ldr	r2, [r2, #4]
	_first += 1U;
    9d4c:	b2db      	uxtb	r3, r3
		_first = 0U;
    9d4e:	4299      	cmp	r1, r3
    9d50:	bf08      	it	eq
    9d52:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
    9d54:	70a3      	strb	r3, [r4, #2]
    9d56:	2a00      	cmp	r2, #0
    9d58:	d0e6      	beq.n	9d28 <lll_adv_pdu_alloc_pdu_adv+0x98>
    9d5a:	4615      	mov	r5, r2
    9d5c:	e7c1      	b.n	9ce2 <lll_adv_pdu_alloc_pdu_adv+0x52>
    9d5e:	bf00      	nop
    9d60:	20000448 	.word	0x20000448
    9d64:	2000239c 	.word	0x2000239c
    9d68:	00013d93 	.word	0x00013d93
    9d6c:	00013624 	.word	0x00013624
    9d70:	000133b6 	.word	0x000133b6
    9d74:	200021a4 	.word	0x200021a4
    9d78:	00013df7 	.word	0x00013df7

00009d7c <lll_adv_pdu_latest_get>:
{
    9d7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	first = pdu->first;
    9d7e:	7803      	ldrb	r3, [r0, #0]
	if (first != pdu->last) {
    9d80:	7842      	ldrb	r2, [r0, #1]
    9d82:	429a      	cmp	r2, r3
{
    9d84:	4605      	mov	r5, r0
    9d86:	460e      	mov	r6, r1
	first = pdu->first;
    9d88:	b2dc      	uxtb	r4, r3
	if (first != pdu->last) {
    9d8a:	d021      	beq.n	9dd0 <lll_adv_pdu_latest_get+0x54>
			if (!MFIFO_ENQUEUE_IDX_GET(pdu_free, &free_idx)) {
    9d8c:	4a13      	ldr	r2, [pc, #76]	; (9ddc <lll_adv_pdu_latest_get+0x60>)
    9d8e:	78d0      	ldrb	r0, [r2, #3]
	if (last == count) {
    9d90:	7857      	ldrb	r7, [r2, #1]
    9d92:	7891      	ldrb	r1, [r2, #2]
	last = last + 1;
    9d94:	1c43      	adds	r3, r0, #1
    9d96:	b2db      	uxtb	r3, r3
		last = 0U;
    9d98:	429f      	cmp	r7, r3
    9d9a:	bf08      	it	eq
    9d9c:	2300      	moveq	r3, #0
	if (last == first) {
    9d9e:	4299      	cmp	r1, r3
    9da0:	d01a      	beq.n	9dd8 <lll_adv_pdu_latest_get+0x5c>
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
    9da2:	f892 c000 	ldrb.w	ip, [r2]
    9da6:	eb05 0784 	add.w	r7, r5, r4, lsl #2
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
    9daa:	fb0c 2000 	mla	r0, ip, r0, r2
		p = pdu->pdu[pdu_idx];
    9dae:	6879      	ldr	r1, [r7, #4]
    9db0:	6041      	str	r1, [r0, #4]
	*last = idx; /* Commit: Update write index */
    9db2:	70d3      	strb	r3, [r2, #3]
		first += 1U;
    9db4:	3401      	adds	r4, #1
    9db6:	b2e4      	uxtb	r4, r4
	z_impl_k_sem_give(sem);
    9db8:	4809      	ldr	r0, [pc, #36]	; (9de0 <lll_adv_pdu_latest_get+0x64>)
    9dba:	f004 fc5f 	bl	e67c <z_impl_k_sem_give>
			first = 0U;
    9dbe:	2c02      	cmp	r4, #2
		*is_modified = 1U;
    9dc0:	f04f 0301 	mov.w	r3, #1
			first = 0U;
    9dc4:	bf08      	it	eq
    9dc6:	2400      	moveq	r4, #0
		pdu->first = first;
    9dc8:	702c      	strb	r4, [r5, #0]
		*is_modified = 1U;
    9dca:	7033      	strb	r3, [r6, #0]
		pdu->pdu[pdu_idx] = NULL;
    9dcc:	2300      	movs	r3, #0
    9dce:	607b      	str	r3, [r7, #4]
	return (void *)pdu->pdu[first];
    9dd0:	eb05 0484 	add.w	r4, r5, r4, lsl #2
    9dd4:	6860      	ldr	r0, [r4, #4]
}
    9dd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				return NULL;
    9dd8:	2000      	movs	r0, #0
    9dda:	e7fc      	b.n	9dd6 <lll_adv_pdu_latest_get+0x5a>
    9ddc:	20000448 	.word	0x20000448
    9de0:	2000239c 	.word	0x2000239c

00009de4 <chan_prepare>:
{
	struct pdu_adv *pdu;
	uint8_t chan;
	uint8_t upd;

	chan = find_lsb_set(lll->chan_map_curr);
    9de4:	7903      	ldrb	r3, [r0, #4]
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
    9de6:	f3c3 03c2 	ubfx	r3, r3, #3, #3
{
    9dea:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9dec:	2b00      	cmp	r3, #0
    9dee:	4604      	mov	r4, r0
    9df0:	fa93 f0a3 	rbit	r0, r3
    9df4:	fab0 f080 	clz	r0, r0
    9df8:	bf08      	it	eq
    9dfa:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
	LL_ASSERT(chan);
    9dfe:	1c45      	adds	r5, r0, #1
    9e00:	d10c      	bne.n	9e1c <chan_prepare+0x38>
    9e02:	4a36      	ldr	r2, [pc, #216]	; (9edc <chan_prepare+0xf8>)
    9e04:	4936      	ldr	r1, [pc, #216]	; (9ee0 <chan_prepare+0xfc>)
    9e06:	4837      	ldr	r0, [pc, #220]	; (9ee4 <chan_prepare+0x100>)
    9e08:	f240 5332 	movw	r3, #1330	; 0x532
    9e0c:	f005 fb5b 	bl	f4c6 <printk>
    9e10:	4040      	eors	r0, r0
    9e12:	f380 8811 	msr	BASEPRI, r0
    9e16:	f04f 0003 	mov.w	r0, #3
    9e1a:	df02      	svc	2

	lll->chan_map_curr &= (lll->chan_map_curr - 1);
    9e1c:	7923      	ldrb	r3, [r4, #4]
    9e1e:	f3c3 02c2 	ubfx	r2, r3, #3, #3
    9e22:	1e51      	subs	r1, r2, #1
    9e24:	400a      	ands	r2, r1
    9e26:	f362 03c5 	bfi	r3, r2, #3, #3

	lll_chan_set(36 + chan);
    9e2a:	f105 0024 	add.w	r0, r5, #36	; 0x24
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
    9e2e:	7123      	strb	r3, [r4, #4]
	lll_chan_set(36 + chan);
    9e30:	f7ff fcc8 	bl	97c4 <lll_chan_set>

	/* FIXME: get latest only when primary PDU without Aux PDUs */
	upd = 0U;
    9e34:	2300      	movs	r3, #0
#endif /* CONFIG_BT_CTLR_ADV_EXT_PDU_EXTRA_DATA_MEMORY */

static inline struct pdu_adv *lll_adv_data_latest_get(struct lll_adv *lll,
						      uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->adv_data, is_modified);
    9e36:	f10d 0107 	add.w	r1, sp, #7
    9e3a:	f104 0008 	add.w	r0, r4, #8
    9e3e:	f88d 3007 	strb.w	r3, [sp, #7]
    9e42:	f7ff ff9b 	bl	9d7c <lll_adv_pdu_latest_get>
	pdu = lll_adv_data_latest_get(lll, &upd);
	LL_ASSERT(pdu);
    9e46:	4605      	mov	r5, r0
    9e48:	b960      	cbnz	r0, 9e64 <chan_prepare+0x80>
    9e4a:	4a24      	ldr	r2, [pc, #144]	; (9edc <chan_prepare+0xf8>)
    9e4c:	4926      	ldr	r1, [pc, #152]	; (9ee8 <chan_prepare+0x104>)
    9e4e:	4825      	ldr	r0, [pc, #148]	; (9ee4 <chan_prepare+0x100>)
    9e50:	f240 533b 	movw	r3, #1339	; 0x53b
    9e54:	f005 fb37 	bl	f4c6 <printk>
    9e58:	4040      	eors	r0, r0
    9e5a:	f380 8811 	msr	BASEPRI, r0
    9e5e:	f04f 0003 	mov.w	r0, #3
    9e62:	df02      	svc	2

	radio_pkt_tx_set(pdu);
    9e64:	4628      	mov	r0, r5
    9e66:	f002 f865 	bl	bf34 <radio_pkt_tx_set>

	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
    9e6a:	782b      	ldrb	r3, [r5, #0]
    9e6c:	f003 030f 	and.w	r3, r3, #15
    9e70:	2b02      	cmp	r3, #2
    9e72:	d02b      	beq.n	9ecc <chan_prepare+0xe8>
    9e74:	2b07      	cmp	r3, #7
    9e76:	d029      	beq.n	9ecc <chan_prepare+0xe8>
}

static inline struct pdu_adv *lll_adv_scan_rsp_latest_get(struct lll_adv *lll,
							  uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
    9e78:	f10d 0107 	add.w	r1, sp, #7
    9e7c:	f104 0014 	add.w	r0, r4, #20
    9e80:	f7ff ff7c 	bl	9d7c <lll_adv_pdu_latest_get>
	    (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) ||
	     (pdu->type != PDU_ADV_TYPE_EXT_IND))) {
		struct pdu_adv *scan_pdu;

		scan_pdu = lll_adv_scan_rsp_latest_get(lll, &upd);
		LL_ASSERT(scan_pdu);
    9e84:	4606      	mov	r6, r0
    9e86:	b960      	cbnz	r0, 9ea2 <chan_prepare+0xbe>
    9e88:	4a14      	ldr	r2, [pc, #80]	; (9edc <chan_prepare+0xf8>)
    9e8a:	4918      	ldr	r1, [pc, #96]	; (9eec <chan_prepare+0x108>)
    9e8c:	4815      	ldr	r0, [pc, #84]	; (9ee4 <chan_prepare+0x100>)
    9e8e:	f240 5345 	movw	r3, #1349	; 0x545
    9e92:	f005 fb18 	bl	f4c6 <printk>
    9e96:	4040      	eors	r0, r0
    9e98:	f380 8811 	msr	BASEPRI, r0
    9e9c:	f04f 0003 	mov.w	r0, #3
    9ea0:	df02      	svc	2

#if defined(CONFIG_BT_CTLR_PRIVACY)
		if (upd) {
    9ea2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9ea6:	b123      	cbz	r3, 9eb2 <chan_prepare+0xce>
			/* Copy the address from the adv packet we will send
			 * into the scan response.
			 */
			memcpy(&scan_pdu->scan_rsp.addr[0],
    9ea8:	2206      	movs	r2, #6
    9eaa:	1ca9      	adds	r1, r5, #2
    9eac:	1cb0      	adds	r0, r6, #2
    9eae:	f005 fe7a 	bl	fba6 <memcpy>
#else
		ARG_UNUSED(scan_pdu);
		ARG_UNUSED(upd);
#endif /* !CONFIG_BT_CTLR_PRIVACY */

		radio_isr_set(isr_tx, lll);
    9eb2:	480f      	ldr	r0, [pc, #60]	; (9ef0 <chan_prepare+0x10c>)
    9eb4:	4621      	mov	r1, r4
    9eb6:	f001 ff81 	bl	bdbc <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
    9eba:	2096      	movs	r0, #150	; 0x96
    9ebc:	f002 f9b8 	bl	c230 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
    9ec0:	2000      	movs	r0, #0
    9ec2:	f002 f907 	bl	c0d4 <radio_switch_complete_and_rx>
		radio_isr_set(isr_done, lll);
		radio_switch_complete_and_disable();
	}

	return pdu;
}
    9ec6:	4628      	mov	r0, r5
    9ec8:	b002      	add	sp, #8
    9eca:	bd70      	pop	{r4, r5, r6, pc}
		radio_isr_set(isr_done, lll);
    9ecc:	4809      	ldr	r0, [pc, #36]	; (9ef4 <chan_prepare+0x110>)
    9ece:	4621      	mov	r1, r4
    9ed0:	f001 ff74 	bl	bdbc <radio_isr_set>
		radio_switch_complete_and_disable();
    9ed4:	f002 f922 	bl	c11c <radio_switch_complete_and_disable>
	return pdu;
    9ed8:	e7f5      	b.n	9ec6 <chan_prepare+0xe2>
    9eda:	bf00      	nop
    9edc:	00013d93 	.word	0x00013d93
    9ee0:	00013df9 	.word	0x00013df9
    9ee4:	000133b6 	.word	0x000133b6
    9ee8:	00013e73 	.word	0x00013e73
    9eec:	00013dfe 	.word	0x00013dfe
    9ef0:	00009a99 	.word	0x00009a99
    9ef4:	00009ff9 	.word	0x00009ff9

00009ef8 <prepare_cb>:
{
    9ef8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	lll = p->param;
    9efa:	68c4      	ldr	r4, [r0, #12]
{
    9efc:	4605      	mov	r5, r0
	radio_reset();
    9efe:	f001 ff7d 	bl	bdfc <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
    9f02:	2000      	movs	r0, #0
    9f04:	f001 ffae 	bl	be64 <radio_tx_power_set>
	radio_phy_set(lll->phy_p, lll->phy_flags);
    9f08:	7960      	ldrb	r0, [r4, #5]
    9f0a:	f3c0 1180 	ubfx	r1, r0, #6, #1
    9f0e:	f000 0007 	and.w	r0, r0, #7
    9f12:	f001 ff97 	bl	be44 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_LEG_PAYLOAD_SIZE_MAX, (lll->phy_p << 1));
    9f16:	7962      	ldrb	r2, [r4, #5]
    9f18:	0052      	lsls	r2, r2, #1
    9f1a:	f002 020e 	and.w	r2, r2, #14
    9f1e:	2125      	movs	r1, #37	; 0x25
    9f20:	2008      	movs	r0, #8
    9f22:	f001 ffd5 	bl	bed0 <radio_pkt_configure>
	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
    9f26:	4b2e      	ldr	r3, [pc, #184]	; (9fe0 <prepare_cb+0xe8>)
    9f28:	9301      	str	r3, [sp, #4]
	radio_aa_set((uint8_t *)&aa);
    9f2a:	a801      	add	r0, sp, #4
    9f2c:	f001 ffb8 	bl	bea0 <radio_aa_set>
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
    9f30:	492c      	ldr	r1, [pc, #176]	; (9fe4 <prepare_cb+0xec>)
    9f32:	f240 605b 	movw	r0, #1627	; 0x65b
    9f36:	f002 f845 	bl	bfc4 <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
    9f3a:	7923      	ldrb	r3, [r4, #4]
    9f3c:	f3c3 0202 	ubfx	r2, r3, #0, #3
    9f40:	f362 03c5 	bfi	r3, r2, #3, #3
    9f44:	7123      	strb	r3, [r4, #4]
	pdu = chan_prepare(lll);
    9f46:	4620      	mov	r0, r4
    9f48:	f7ff ff4c 	bl	9de4 <chan_prepare>
	if (ull_filter_lll_rl_enabled()) {
    9f4c:	f7ff f92e 	bl	91ac <ull_filter_lll_rl_enabled>
    9f50:	7923      	ldrb	r3, [r4, #4]
    9f52:	b360      	cbz	r0, 9fae <prepare_cb+0xb6>
			ull_filter_lll_get(!!(lll->filter_policy));
    9f54:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    9f58:	bf14      	ite	ne
    9f5a:	2001      	movne	r0, #1
    9f5c:	2000      	moveq	r0, #0
		struct lll_filter *fal = ull_filter_lll_get(true);
    9f5e:	f7fe fbe7 	bl	8730 <ull_filter_lll_get>
		radio_filter_configure(fal->enable_bitmask,
    9f62:	7841      	ldrb	r1, [r0, #1]
    9f64:	1c82      	adds	r2, r0, #2
    9f66:	7800      	ldrb	r0, [r0, #0]
    9f68:	f002 f908 	bl	c17c <radio_filter_configure>
	ull = HDR_LLL2ULL(lll);
    9f6c:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = p->ticks_at_expire;
    9f6e:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_event_offset_get(ull);
    9f70:	4638      	mov	r0, r7
    9f72:	f007 fc16 	bl	117a2 <lll_event_offset_get>
    9f76:	4406      	add	r6, r0
	start_us = radio_tmr_start(1, ticks_at_start, remainder);
    9f78:	686a      	ldr	r2, [r5, #4]
    9f7a:	f106 0109 	add.w	r1, r6, #9
    9f7e:	2001      	movs	r0, #1
    9f80:	f002 f962 	bl	c248 <radio_tmr_start>
	radio_tmr_end_capture();
    9f84:	f002 fa0a 	bl	c39c <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
    9f88:	4620      	mov	r0, r4
    9f8a:	f7fd faab 	bl	74e4 <ull_adv_lll_handle_get>
	if (lll_preempt_calc(ull, (TICKER_ID_ADV_BASE +
    9f8e:	1c81      	adds	r1, r0, #2
    9f90:	4632      	mov	r2, r6
    9f92:	b2c9      	uxtb	r1, r1
    9f94:	4638      	mov	r0, r7
    9f96:	f007 fc12 	bl	117be <lll_preempt_calc>
    9f9a:	b168      	cbz	r0, 9fb8 <prepare_cb+0xc0>
		radio_isr_set(isr_abort, lll);
    9f9c:	4812      	ldr	r0, [pc, #72]	; (9fe8 <prepare_cb+0xf0>)
    9f9e:	4621      	mov	r1, r4
    9fa0:	f001 ff0c 	bl	bdbc <radio_isr_set>
		radio_disable();
    9fa4:	f001 ffd2 	bl	bf4c <radio_disable>
}
    9fa8:	2000      	movs	r0, #0
    9faa:	b003      	add	sp, #12
    9fac:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER_ACCEPT_LIST) && lll->filter_policy) {
    9fae:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    9fb2:	d0db      	beq.n	9f6c <prepare_cb+0x74>
		struct lll_filter *fal = ull_filter_lll_get(true);
    9fb4:	2001      	movs	r0, #1
    9fb6:	e7d2      	b.n	9f5e <prepare_cb+0x66>
		ret = lll_prepare_done(lll);
    9fb8:	4620      	mov	r0, r4
    9fba:	f007 fbed 	bl	11798 <lll_prepare_done>
		LL_ASSERT(!ret);
    9fbe:	2800      	cmp	r0, #0
    9fc0:	d0f2      	beq.n	9fa8 <prepare_cb+0xb0>
    9fc2:	4a0a      	ldr	r2, [pc, #40]	; (9fec <prepare_cb+0xf4>)
    9fc4:	490a      	ldr	r1, [pc, #40]	; (9ff0 <prepare_cb+0xf8>)
    9fc6:	480b      	ldr	r0, [pc, #44]	; (9ff4 <prepare_cb+0xfc>)
    9fc8:	f44f 7373 	mov.w	r3, #972	; 0x3cc
    9fcc:	f005 fa7b 	bl	f4c6 <printk>
    9fd0:	4040      	eors	r0, r0
    9fd2:	f380 8811 	msr	BASEPRI, r0
    9fd6:	f04f 0003 	mov.w	r0, #3
    9fda:	df02      	svc	2
    9fdc:	e7e4      	b.n	9fa8 <prepare_cb+0xb0>
    9fde:	bf00      	nop
    9fe0:	8e89bed6 	.word	0x8e89bed6
    9fe4:	00555555 	.word	0x00555555
    9fe8:	0001183b 	.word	0x0001183b
    9fec:	00013d93 	.word	0x00013d93
    9ff0:	0001366f 	.word	0x0001366f
    9ff4:	000133b6 	.word	0x000133b6

00009ff8 <isr_done>:
{
    9ff8:	b538      	push	{r3, r4, r5, lr}
    9ffa:	4604      	mov	r4, r0
	lll_isr_status_reset();
    9ffc:	f007 fc00 	bl	11800 <lll_isr_status_reset>
	if (lll->chan_map_curr &&
    a000:	7923      	ldrb	r3, [r4, #4]
    a002:	f013 0f38 	tst.w	r3, #56	; 0x38
    a006:	d011      	beq.n	a02c <isr_done+0x34>
		pdu = chan_prepare(lll);
    a008:	4620      	mov	r0, r4
    a00a:	f7ff feeb 	bl	9de4 <chan_prepare>
    a00e:	4605      	mov	r5, r0
		start_us = radio_tmr_start_now(1);
    a010:	2001      	movs	r0, #1
    a012:	f002 f98f 	bl	c334 <radio_tmr_start_now>
		lll_aux = lll->aux;
    a016:	6a63      	ldr	r3, [r4, #36]	; 0x24
		start_us = radio_tmr_start_now(1);
    a018:	4602      	mov	r2, r0
		if (lll_aux) {
    a01a:	b11b      	cbz	r3, a024 <isr_done+0x2c>
			(void)ull_adv_aux_lll_offset_fill(pdu,
    a01c:	68d9      	ldr	r1, [r3, #12]
    a01e:	4628      	mov	r0, r5
    a020:	f7f6 fff2 	bl	1008 <ull_adv_aux_lll_offset_fill>
}
    a024:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		radio_tmr_end_capture();
    a028:	f002 b9b8 	b.w	c39c <radio_tmr_end_capture>
	radio_filter_disable();
    a02c:	f002 f8c2 	bl	c1b4 <radio_filter_disable>
	if (!lll->aux) {
    a030:	6a63      	ldr	r3, [r4, #36]	; 0x24
    a032:	b983      	cbnz	r3, a056 <isr_done+0x5e>
		extra = ull_done_extra_type_set(EVENT_DONE_EXTRA_TYPE_ADV);
    a034:	2001      	movs	r0, #1
    a036:	f006 ffc4 	bl	10fc2 <ull_done_extra_type_set>
		LL_ASSERT(extra);
    a03a:	b960      	cbnz	r0, a056 <isr_done+0x5e>
    a03c:	4a08      	ldr	r2, [pc, #32]	; (a060 <isr_done+0x68>)
    a03e:	4909      	ldr	r1, [pc, #36]	; (a064 <isr_done+0x6c>)
    a040:	4809      	ldr	r0, [pc, #36]	; (a068 <isr_done+0x70>)
    a042:	f240 531a 	movw	r3, #1306	; 0x51a
    a046:	f005 fa3e 	bl	f4c6 <printk>
    a04a:	4040      	eors	r0, r0
    a04c:	f380 8811 	msr	BASEPRI, r0
    a050:	f04f 0003 	mov.w	r0, #3
    a054:	df02      	svc	2
	lll_isr_cleanup(param);
    a056:	4620      	mov	r0, r4
}
    a058:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_isr_cleanup(param);
    a05c:	f7ff bbe4 	b.w	9828 <lll_isr_cleanup>
    a060:	00013d93 	.word	0x00013d93
    a064:	00013e07 	.word	0x00013e07
    a068:	000133b6 	.word	0x000133b6

0000a06c <lll_adv_prepare>:
{
    a06c:	b513      	push	{r0, r1, r4, lr}
    a06e:	4604      	mov	r4, r0
	err = lll_hfclock_on();
    a070:	f7ff fce0 	bl	9a34 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
    a074:	2800      	cmp	r0, #0
    a076:	da0c      	bge.n	a092 <lll_adv_prepare+0x26>
    a078:	4a12      	ldr	r2, [pc, #72]	; (a0c4 <lll_adv_prepare+0x58>)
    a07a:	4913      	ldr	r1, [pc, #76]	; (a0c8 <lll_adv_prepare+0x5c>)
    a07c:	4813      	ldr	r0, [pc, #76]	; (a0cc <lll_adv_prepare+0x60>)
    a07e:	f240 2397 	movw	r3, #663	; 0x297
    a082:	f005 fa20 	bl	f4c6 <printk>
    a086:	4040      	eors	r0, r0
    a088:	f380 8811 	msr	BASEPRI, r0
    a08c:	f04f 0003 	mov.w	r0, #3
    a090:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, param);
    a092:	4a0f      	ldr	r2, [pc, #60]	; (a0d0 <lll_adv_prepare+0x64>)
    a094:	490f      	ldr	r1, [pc, #60]	; (a0d4 <lll_adv_prepare+0x68>)
    a096:	4810      	ldr	r0, [pc, #64]	; (a0d8 <lll_adv_prepare+0x6c>)
    a098:	9400      	str	r4, [sp, #0]
    a09a:	2300      	movs	r3, #0
    a09c:	f006 ffe6 	bl	1106c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
    a0a0:	b170      	cbz	r0, a0c0 <lll_adv_prepare+0x54>
    a0a2:	3077      	adds	r0, #119	; 0x77
    a0a4:	d00c      	beq.n	a0c0 <lll_adv_prepare+0x54>
    a0a6:	4a07      	ldr	r2, [pc, #28]	; (a0c4 <lll_adv_prepare+0x58>)
    a0a8:	490c      	ldr	r1, [pc, #48]	; (a0dc <lll_adv_prepare+0x70>)
    a0aa:	4808      	ldr	r0, [pc, #32]	; (a0cc <lll_adv_prepare+0x60>)
    a0ac:	f240 239a 	movw	r3, #666	; 0x29a
    a0b0:	f005 fa09 	bl	f4c6 <printk>
    a0b4:	4040      	eors	r0, r0
    a0b6:	f380 8811 	msr	BASEPRI, r0
    a0ba:	f04f 0003 	mov.w	r0, #3
    a0be:	df02      	svc	2
}
    a0c0:	b002      	add	sp, #8
    a0c2:	bd10      	pop	{r4, pc}
    a0c4:	00013d93 	.word	0x00013d93
    a0c8:	00013d61 	.word	0x00013d61
    a0cc:	000133b6 	.word	0x000133b6
    a0d0:	00009ef9 	.word	0x00009ef9
    a0d4:	00009b81 	.word	0x00009b81
    a0d8:	00011835 	.word	0x00011835
    a0dc:	00013e0d 	.word	0x00013e0d

0000a0e0 <isr_rx>:
{
    a0e0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    a0e4:	4604      	mov	r4, r0
	trx_done = radio_is_done();
    a0e6:	f001 ff59 	bl	bf9c <radio_is_done>
	if (trx_done) {
    a0ea:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
    a0ee:	f000 8089 	beq.w	a204 <isr_rx+0x124>
		crc_ok = radio_crc_is_valid();
    a0f2:	f001 ff73 	bl	bfdc <radio_crc_is_valid>
    a0f6:	fa5f fa80 	uxtb.w	sl, r0
		devmatch_ok = radio_filter_has_match();
    a0fa:	f002 f86d 	bl	c1d8 <radio_filter_has_match>
    a0fe:	b2c7      	uxtb	r7, r0
		devmatch_id = radio_filter_match_get();
    a100:	f002 f874 	bl	c1ec <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
    a104:	f002 f9b0 	bl	c468 <radio_ar_has_match>
    a108:	fa5f f980 	uxtb.w	r9, r0
		irkmatch_id = radio_ar_match_get();
    a10c:	f002 f994 	bl	c438 <radio_ar_match_get>
    a110:	fa5f f880 	uxtb.w	r8, r0
		rssi_ready = radio_rssi_is_ready();
    a114:	f002 f828 	bl	c168 <radio_rssi_is_ready>
    a118:	b2c6      	uxtb	r6, r0
	lll_isr_status_reset();
    a11a:	f007 fb71 	bl	11800 <lll_isr_status_reset>
	if (!trx_done) {
    a11e:	2d00      	cmp	r5, #0
    a120:	d067      	beq.n	a1f2 <isr_rx+0x112>
	if (crc_ok) {
    a122:	f1ba 0f00 	cmp.w	sl, #0
    a126:	d064      	beq.n	a1f2 <isr_rx+0x112>
	uint8_t rx_addr;
	uint8_t *tgt_addr;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* An IRK match implies address resolution enabled */
	uint8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    a128:	f1b9 0f00 	cmp.w	r9, #0
    a12c:	d071      	beq.n	a212 <isr_rx+0x132>
    a12e:	4640      	mov	r0, r8
    a130:	f7fe ff44 	bl	8fbc <ull_filter_lll_rl_irk_idx>
    a134:	f88d 000f 	strb.w	r0, [sp, #15]
				    FILTER_IDX_NONE;
#else
	uint8_t rl_idx = FILTER_IDX_NONE;
#endif /* CONFIG_BT_CTLR_PRIVACY */

	node_rx = ull_pdu_rx_alloc_peek(1);
    a138:	2001      	movs	r0, #1
    a13a:	f7fc fabb 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    a13e:	4605      	mov	r5, r0
    a140:	b960      	cbnz	r0, a15c <isr_rx+0x7c>
    a142:	4a36      	ldr	r2, [pc, #216]	; (a21c <isr_rx+0x13c>)
    a144:	4936      	ldr	r1, [pc, #216]	; (a220 <isr_rx+0x140>)
    a146:	4837      	ldr	r0, [pc, #220]	; (a224 <isr_rx+0x144>)
    a148:	f240 5375 	movw	r3, #1397	; 0x575
    a14c:	f005 f9bb 	bl	f4c6 <printk>
    a150:	4040      	eors	r0, r0
    a152:	f380 8811 	msr	BASEPRI, r0
    a156:	f04f 0003 	mov.w	r0, #3
    a15a:	df02      	svc	2
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
    a15c:	7a23      	ldrb	r3, [r4, #8]
    a15e:	eb04 0383 	add.w	r3, r4, r3, lsl #2

	pdu_rx = (void *)node_rx->pdu;
    a162:	f105 081c 	add.w	r8, r5, #28
    a166:	68d9      	ldr	r1, [r3, #12]
	pdu_adv = lll_adv_data_curr_get(lll);

	addr = pdu_adv->adv_ind.addr;
    a168:	460b      	mov	r3, r1
	tx_addr = pdu_adv->tx_addr;
    a16a:	f813 0b02 	ldrb.w	r0, [r3], #2
    a16e:	f3c0 1280 	ubfx	r2, r0, #6, #1

	if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
    a172:	f000 000f 	and.w	r0, r0, #15
    a176:	2801      	cmp	r0, #1
	} else {
		tgt_addr = NULL;
	}
	rx_addr = pdu_adv->rx_addr;

	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
    a178:	7f28      	ldrb	r0, [r5, #28]
    a17a:	f000 000f 	and.w	r0, r0, #15
		tgt_addr = pdu_adv->direct_ind.tgt_addr;
    a17e:	bf0c      	ite	eq
    a180:	3108      	addeq	r1, #8
		tgt_addr = NULL;
    a182:	2100      	movne	r1, #0
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
    a184:	2803      	cmp	r0, #3
    a186:	d134      	bne.n	a1f2 <isr_rx+0x112>
    a188:	7f68      	ldrb	r0, [r5, #29]
    a18a:	280c      	cmp	r0, #12
    a18c:	d131      	bne.n	a1f2 <isr_rx+0x112>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
    a18e:	bb81      	cbnz	r1, a1f2 <isr_rx+0x112>
	    (tgt_addr == NULL) &&
	    lll_adv_scan_req_check(lll, pdu_rx, tx_addr, addr, devmatch_ok,
    a190:	f10d 010f 	add.w	r1, sp, #15
    a194:	e9cd 7100 	strd	r7, r1, [sp]
    a198:	4620      	mov	r0, r4
    a19a:	4641      	mov	r1, r8
    a19c:	f007 fb8a 	bl	118b4 <lll_adv_scan_req_check>
	    (tgt_addr == NULL) &&
    a1a0:	b338      	cbz	r0, a1f2 <isr_rx+0x112>
				    &rl_idx)) {
		radio_isr_set(isr_done, lll);
    a1a2:	4821      	ldr	r0, [pc, #132]	; (a228 <isr_rx+0x148>)
    a1a4:	4621      	mov	r1, r4
    a1a6:	f001 fe09 	bl	bdbc <radio_isr_set>
		radio_switch_complete_and_disable();
    a1aa:	f001 ffb7 	bl	c11c <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
    a1ae:	7d23      	ldrb	r3, [r4, #20]
    a1b0:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
    a1b4:	6998      	ldr	r0, [r3, #24]
    a1b6:	f001 febd 	bl	bf34 <radio_pkt_tx_set>

		/* assert if radio packet ptr is not set and radio started tx */
		LL_ASSERT(!radio_is_ready());
    a1ba:	f001 fee5 	bl	bf88 <radio_is_ready>
    a1be:	b160      	cbz	r0, a1da <isr_rx+0xfa>
    a1c0:	4a16      	ldr	r2, [pc, #88]	; (a21c <isr_rx+0x13c>)
    a1c2:	491a      	ldr	r1, [pc, #104]	; (a22c <isr_rx+0x14c>)
    a1c4:	4817      	ldr	r0, [pc, #92]	; (a224 <isr_rx+0x144>)
    a1c6:	f240 538e 	movw	r3, #1422	; 0x58e
    a1ca:	f005 f97c 	bl	f4c6 <printk>
    a1ce:	4040      	eors	r0, r0
    a1d0:	f380 8811 	msr	BASEPRI, r0
    a1d4:	f04f 0003 	mov.w	r0, #3
    a1d8:	df02      	svc	2
		if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
			lll_prof_cputime_capture();
		}

#if defined(CONFIG_BT_CTLR_SCAN_REQ_NOTIFY)
		if (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) ||
    a1da:	f994 3005 	ldrsb.w	r3, [r4, #5]
    a1de:	2b00      	cmp	r3, #0
    a1e0:	da19      	bge.n	a216 <isr_rx+0x136>
		    lll->scan_req_notify) {
			uint32_t err;

			/* Generate the scan request event */
			err = lll_adv_scan_req_report(lll, pdu_rx, rl_idx,
    a1e2:	f89d 200f 	ldrb.w	r2, [sp, #15]
    a1e6:	4633      	mov	r3, r6
    a1e8:	4641      	mov	r1, r8
    a1ea:	4620      	mov	r0, r4
    a1ec:	f007 fb95 	bl	1191a <lll_adv_scan_req_report>
						      rssi_ready);
			if (err) {
    a1f0:	b188      	cbz	r0, a216 <isr_rx+0x136>
	radio_isr_set(isr_done, param);
    a1f2:	480d      	ldr	r0, [pc, #52]	; (a228 <isr_rx+0x148>)
    a1f4:	4621      	mov	r1, r4
    a1f6:	f001 fde1 	bl	bdbc <radio_isr_set>
}
    a1fa:	b004      	add	sp, #16
    a1fc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	radio_disable();
    a200:	f001 bea4 	b.w	bf4c <radio_disable>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
    a204:	46aa      	mov	sl, r5
    a206:	462e      	mov	r6, r5
    a208:	46a9      	mov	r9, r5
    a20a:	462f      	mov	r7, r5
		devmatch_id = irkmatch_id = 0xFF;
    a20c:	f04f 08ff 	mov.w	r8, #255	; 0xff
    a210:	e783      	b.n	a11a <isr_rx+0x3a>
	uint8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    a212:	20ff      	movs	r0, #255	; 0xff
    a214:	e78e      	b.n	a134 <isr_rx+0x54>
}
    a216:	b004      	add	sp, #16
    a218:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a21c:	00013d93 	.word	0x00013d93
    a220:	00013ddd 	.word	0x00013ddd
    a224:	000133b6 	.word	0x000133b6
    a228:	00009ff9 	.word	0x00009ff9
    a22c:	00013de5 	.word	0x00013de5

0000a230 <isr_done>:

	return 0;
}

static void isr_done(void *param)
{
    a230:	b510      	push	{r4, lr}
    a232:	4604      	mov	r4, r0
	struct event_done_extra *extra;

	/* Clear radio status and events */
	lll_isr_status_reset();
    a234:	f007 fae4 	bl	11800 <lll_isr_status_reset>

	/* Generate auxiliary radio event done */
	extra = ull_done_extra_type_set(EVENT_DONE_EXTRA_TYPE_ADV_AUX);
    a238:	2002      	movs	r0, #2
    a23a:	f006 fec2 	bl	10fc2 <ull_done_extra_type_set>
	LL_ASSERT(extra);
    a23e:	b960      	cbnz	r0, a25a <isr_done+0x2a>
    a240:	4a08      	ldr	r2, [pc, #32]	; (a264 <isr_done+0x34>)
    a242:	4909      	ldr	r1, [pc, #36]	; (a268 <isr_done+0x38>)
    a244:	4809      	ldr	r0, [pc, #36]	; (a26c <isr_done+0x3c>)
    a246:	f240 132f 	movw	r3, #303	; 0x12f
    a24a:	f005 f93c 	bl	f4c6 <printk>
    a24e:	4040      	eors	r0, r0
    a250:	f380 8811 	msr	BASEPRI, r0
    a254:	f04f 0003 	mov.w	r0, #3
    a258:	df02      	svc	2

	/* Cleanup radio event and dispatch the done event */
	lll_isr_cleanup(param);
    a25a:	4620      	mov	r0, r4
}
    a25c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
    a260:	f7ff bae2 	b.w	9828 <lll_isr_cleanup>
    a264:	00013e21 	.word	0x00013e21
    a268:	00013e07 	.word	0x00013e07
    a26c:	000133b6 	.word	0x000133b6

0000a270 <isr_tx_rx>:
	}
}
#endif /* CONFIG_BT_CTLR_ADV_PDU_BACK2BACK */

static void isr_tx_rx(void *param)
{
    a270:	b573      	push	{r0, r1, r4, r5, r6, lr}
    a272:	4604      	mov	r4, r0
		lll_prof_latency_capture();
		node_rx_prof = lll_prof_reserve();
	}

	/* Clear radio tx status and events */
	lll_isr_tx_status_reset();
    a274:	f007 fab4 	bl	117e0 <lll_isr_tx_status_reset>

	lll_aux = param;
	lll = lll_aux->adv;
    a278:	6865      	ldr	r5, [r4, #4]

	/* setup tIFS switching */
	radio_tmr_tifs_set(EVENT_IFS_US);
    a27a:	2096      	movs	r0, #150	; 0x96
    a27c:	f001 ffd8 	bl	c230 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(lll->phy_s, 0, lll->phy_s, lll->phy_flags);
    a280:	796b      	ldrb	r3, [r5, #5]
    a282:	f3c3 02c2 	ubfx	r2, r3, #3, #3
    a286:	4610      	mov	r0, r2
    a288:	f3c3 1380 	ubfx	r3, r3, #6, #1
    a28c:	2100      	movs	r1, #0
    a28e:	f001 ff33 	bl	c0f8 <radio_switch_complete_and_tx>

	/* setup Rx buffer */
	node_rx = ull_pdu_rx_alloc_peek(1);
    a292:	2001      	movs	r0, #1
    a294:	f7fc fa0e 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    a298:	4606      	mov	r6, r0
    a29a:	b960      	cbnz	r0, a2b6 <isr_tx_rx+0x46>
    a29c:	4a2e      	ldr	r2, [pc, #184]	; (a358 <isr_tx_rx+0xe8>)
    a29e:	492f      	ldr	r1, [pc, #188]	; (a35c <isr_tx_rx+0xec>)
    a2a0:	482f      	ldr	r0, [pc, #188]	; (a360 <isr_tx_rx+0xf0>)
    a2a2:	f44f 73ca 	mov.w	r3, #404	; 0x194
    a2a6:	f005 f90e 	bl	f4c6 <printk>
    a2aa:	4040      	eors	r0, r0
    a2ac:	f380 8811 	msr	BASEPRI, r0
    a2b0:	f04f 0003 	mov.w	r0, #3
    a2b4:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
    a2b6:	f106 001c 	add.w	r0, r6, #28
    a2ba:	f001 fe35 	bl	bf28 <radio_pkt_rx_set>

	/* assert if radio packet ptr is not set and radio started rx */
	LL_ASSERT(!radio_is_ready());
    a2be:	f001 fe63 	bl	bf88 <radio_is_ready>
    a2c2:	b160      	cbz	r0, a2de <isr_tx_rx+0x6e>
    a2c4:	4a24      	ldr	r2, [pc, #144]	; (a358 <isr_tx_rx+0xe8>)
    a2c6:	4927      	ldr	r1, [pc, #156]	; (a364 <isr_tx_rx+0xf4>)
    a2c8:	4825      	ldr	r0, [pc, #148]	; (a360 <isr_tx_rx+0xf0>)
    a2ca:	f44f 73cc 	mov.w	r3, #408	; 0x198
    a2ce:	f005 f8fa 	bl	f4c6 <printk>
    a2d2:	4040      	eors	r0, r0
    a2d4:	f380 8811 	msr	BASEPRI, r0
    a2d8:	f04f 0003 	mov.w	r0, #3
    a2dc:	df02      	svc	2

	if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
		lll_prof_cputime_capture();
	}

	radio_isr_set(isr_rx, param);
    a2de:	4822      	ldr	r0, [pc, #136]	; (a368 <isr_tx_rx+0xf8>)
    a2e0:	4621      	mov	r1, r4
    a2e2:	f001 fd6b 	bl	bdbc <radio_isr_set>

#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (ull_filter_lll_rl_enabled()) {
    a2e6:	f7fe ff61 	bl	91ac <ull_filter_lll_rl_enabled>
    a2ea:	b180      	cbz	r0, a30e <isr_tx_rx+0x9e>
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    a2ec:	f10d 0007 	add.w	r0, sp, #7
    a2f0:	f7fe fdfe 	bl	8ef0 <ull_filter_lll_irks_get>

		radio_ar_configure(count, irks, (lll->phy_s << 2) | BIT(0));
    a2f4:	796a      	ldrb	r2, [r5, #5]
    a2f6:	f3c2 02c2 	ubfx	r2, r2, #3, #3
    a2fa:	0092      	lsls	r2, r2, #2
    a2fc:	f042 0201 	orr.w	r2, r2, #1
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    a300:	4601      	mov	r1, r0
		radio_ar_configure(count, irks, (lll->phy_s << 2) | BIT(0));
    a302:	f002 021d 	and.w	r2, r2, #29
    a306:	f89d 0007 	ldrb.w	r0, [sp, #7]
    a30a:	f002 f85b 	bl	c3c4 <radio_ar_configure>
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	/* +/- 2us active clock jitter, +1 us hcto compensation */
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    a30e:	f002 f853 	bl	c3b8 <radio_tmr_tifs_base_get>
    a312:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(lll->phy_s, 1);
    a314:	7968      	ldrb	r0, [r5, #5]
    a316:	2101      	movs	r1, #1
    a318:	f3c0 00c2 	ubfx	r0, r0, #3, #3
    a31c:	f007 fcdc 	bl	11cd8 <radio_rx_chain_delay_get>
    a320:	4404      	add	r4, r0
	hcto += addr_us_get(lll->phy_s);
    a322:	7968      	ldrb	r0, [r5, #5]
    a324:	f3c0 00c2 	ubfx	r0, r0, #3, #3
    a328:	2802      	cmp	r0, #2
	hcto += radio_rx_chain_delay_get(lll->phy_s, 1);
    a32a:	f104 049b 	add.w	r4, r4, #155	; 0x9b
    a32e:	d010      	beq.n	a352 <isr_tx_rx+0xe2>
		return 40;
    a330:	2804      	cmp	r0, #4
    a332:	bf0c      	ite	eq
    a334:	f44f 73bc 	moveq.w	r3, #376	; 0x178
    a338:	2328      	movne	r3, #40	; 0x28
	hcto -= radio_tx_chain_delay_get(lll->phy_s, 1);
    a33a:	2101      	movs	r1, #1
	hcto += addr_us_get(lll->phy_s);
    a33c:	441c      	add	r4, r3
	hcto -= radio_tx_chain_delay_get(lll->phy_s, 1);
    a33e:	f007 fcc7 	bl	11cd0 <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
    a342:	1a20      	subs	r0, r4, r0
    a344:	f002 f81e 	bl	c384 <radio_tmr_hcto_configure>
#endif /* HAL_RADIO_GPIO_HAVE_LNA_PIN */

	if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
		lll_prof_reserve_send(node_rx_prof);
	}
}
    a348:	b002      	add	sp, #8
    a34a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	radio_tmr_end_capture();
    a34e:	f002 b825 	b.w	c39c <radio_tmr_end_capture>
	switch (phy) {
    a352:	2318      	movs	r3, #24
    a354:	e7f1      	b.n	a33a <isr_tx_rx+0xca>
    a356:	bf00      	nop
    a358:	00013e21 	.word	0x00013e21
    a35c:	00013ddd 	.word	0x00013ddd
    a360:	000133b6 	.word	0x000133b6
    a364:	00013de5 	.word	0x00013de5
    a368:	0000a575 	.word	0x0000a575

0000a36c <prepare_cb>:
{
    a36c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	lll = p->param;
    a370:	68c4      	ldr	r4, [r0, #12]
	upd = 0U;
    a372:	2300      	movs	r3, #0
{
    a374:	4607      	mov	r7, r0

#if defined(CONFIG_BT_CTLR_ADV_EXT)
static inline struct pdu_adv *
lll_adv_aux_data_latest_get(struct lll_adv_aux *lll, uint8_t *is_modified)
{
	return lll_adv_pdu_latest_get(&lll->data, is_modified);
    a376:	f10d 0103 	add.w	r1, sp, #3
    a37a:	f104 0010 	add.w	r0, r4, #16
	upd = 0U;
    a37e:	f88d 3003 	strb.w	r3, [sp, #3]
    a382:	f7ff fcfb 	bl	9d7c <lll_adv_pdu_latest_get>
	LL_ASSERT(sec_pdu);
    a386:	4680      	mov	r8, r0
    a388:	b958      	cbnz	r0, a3a2 <prepare_cb+0x36>
    a38a:	4a6d      	ldr	r2, [pc, #436]	; (a540 <prepare_cb+0x1d4>)
    a38c:	496d      	ldr	r1, [pc, #436]	; (a544 <prepare_cb+0x1d8>)
    a38e:	486e      	ldr	r0, [pc, #440]	; (a548 <prepare_cb+0x1dc>)
    a390:	2384      	movs	r3, #132	; 0x84
    a392:	f005 f898 	bl	f4c6 <printk>
    a396:	4040      	eors	r0, r0
    a398:	f380 8811 	msr	BASEPRI, r0
    a39c:	f04f 0003 	mov.w	r0, #3
    a3a0:	df02      	svc	2
	lll_adv = lll->adv;
    a3a2:	f8d4 a004 	ldr.w	sl, [r4, #4]
    a3a6:	f89a 3008 	ldrb.w	r3, [sl, #8]
    a3aa:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
    a3ae:	68de      	ldr	r6, [r3, #12]
	LL_ASSERT(pri_pdu->type == PDU_ADV_TYPE_EXT_IND);
    a3b0:	7833      	ldrb	r3, [r6, #0]
    a3b2:	f003 030f 	and.w	r3, r3, #15
    a3b6:	2b07      	cmp	r3, #7
    a3b8:	d00b      	beq.n	a3d2 <prepare_cb+0x66>
    a3ba:	4a61      	ldr	r2, [pc, #388]	; (a540 <prepare_cb+0x1d4>)
    a3bc:	4963      	ldr	r1, [pc, #396]	; (a54c <prepare_cb+0x1e0>)
    a3be:	4862      	ldr	r0, [pc, #392]	; (a548 <prepare_cb+0x1dc>)
    a3c0:	2389      	movs	r3, #137	; 0x89
    a3c2:	f005 f880 	bl	f4c6 <printk>
    a3c6:	4040      	eors	r0, r0
    a3c8:	f380 8811 	msr	BASEPRI, r0
    a3cc:	f04f 0003 	mov.w	r0, #3
    a3d0:	df02      	svc	2
	LL_ASSERT(pri_com_hdr->ext_hdr_len);
    a3d2:	78b3      	ldrb	r3, [r6, #2]
    a3d4:	069d      	lsls	r5, r3, #26
    a3d6:	d10b      	bne.n	a3f0 <prepare_cb+0x84>
    a3d8:	4a59      	ldr	r2, [pc, #356]	; (a540 <prepare_cb+0x1d4>)
    a3da:	495d      	ldr	r1, [pc, #372]	; (a550 <prepare_cb+0x1e4>)
    a3dc:	485a      	ldr	r0, [pc, #360]	; (a548 <prepare_cb+0x1dc>)
    a3de:	2395      	movs	r3, #149	; 0x95
    a3e0:	f005 f871 	bl	f4c6 <printk>
    a3e4:	4040      	eors	r0, r0
    a3e6:	f380 8811 	msr	BASEPRI, r0
    a3ea:	f04f 0003 	mov.w	r0, #3
    a3ee:	df02      	svc	2
	if (pri_hdr->adv_addr) {
    a3f0:	78f3      	ldrb	r3, [r6, #3]
    a3f2:	07d8      	lsls	r0, r3, #31
		pri_dptr += BDADDR_SIZE;
    a3f4:	bf4c      	ite	mi
    a3f6:	f106 050a 	addmi.w	r5, r6, #10
	pri_dptr = pri_hdr->data;
    a3fa:	1d35      	addpl	r5, r6, #4
	if (pri_hdr->tgt_addr) {
    a3fc:	0799      	lsls	r1, r3, #30
		pri_dptr += BDADDR_SIZE;
    a3fe:	bf48      	it	mi
    a400:	3506      	addmi	r5, #6
	if (pri_hdr->adi) {
    a402:	071a      	lsls	r2, r3, #28
		pri_dptr += sizeof(struct pdu_adv_adi);
    a404:	bf48      	it	mi
    a406:	3502      	addmi	r5, #2
	if (unlikely(!pri_hdr->aux_ptr || !aux_ptr->offs)) {
    a408:	06db      	lsls	r3, r3, #27
    a40a:	d506      	bpl.n	a41a <prepare_cb+0xae>
    a40c:	78ab      	ldrb	r3, [r5, #2]
    a40e:	786a      	ldrb	r2, [r5, #1]
    a410:	f003 031f 	and.w	r3, r3, #31
    a414:	ea52 2303 	orrs.w	r3, r2, r3, lsl #8
    a418:	d109      	bne.n	a42e <prepare_cb+0xc2>
		radio_isr_set(lll_isr_early_abort, lll);
    a41a:	484e      	ldr	r0, [pc, #312]	; (a554 <prepare_cb+0x1e8>)
    a41c:	4621      	mov	r1, r4
		radio_isr_set(lll_isr_abort, lll);
    a41e:	f001 fccd 	bl	bdbc <radio_isr_set>
		radio_disable();
    a422:	f001 fd93 	bl	bf4c <radio_disable>
}
    a426:	2000      	movs	r0, #0
    a428:	b002      	add	sp, #8
    a42a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	lll->data_chan_counter++;
    a42e:	8923      	ldrh	r3, [r4, #8]
    a430:	3301      	adds	r3, #1
    a432:	8123      	strh	r3, [r4, #8]
	radio_reset();
    a434:	f001 fce2 	bl	bdfc <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
    a438:	2000      	movs	r0, #0
    a43a:	f001 fd13 	bl	be64 <radio_tx_power_set>
	phy_s = lll_adv->phy_s;
    a43e:	f89a 1005 	ldrb.w	r1, [sl, #5]
    a442:	f3c1 09c2 	ubfx	r9, r1, #3, #3
	radio_phy_set(phy_s, lll_adv->phy_flags);
    a446:	4648      	mov	r0, r9
    a448:	f3c1 1180 	ubfx	r1, r1, #6, #1
    a44c:	f001 fcfa 	bl	be44 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, (phy_s << 1));
    a450:	ea4f 0249 	mov.w	r2, r9, lsl #1
    a454:	215f      	movs	r1, #95	; 0x5f
    a456:	2008      	movs	r0, #8
    a458:	f001 fd3a 	bl	bed0 <radio_pkt_configure>
	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
    a45c:	4b3e      	ldr	r3, [pc, #248]	; (a558 <prepare_cb+0x1ec>)
    a45e:	9301      	str	r3, [sp, #4]
	radio_aa_set((uint8_t *)&aa);
    a460:	a801      	add	r0, sp, #4
    a462:	f001 fd1d 	bl	bea0 <radio_aa_set>
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
    a466:	493d      	ldr	r1, [pc, #244]	; (a55c <prepare_cb+0x1f0>)
    a468:	f240 605b 	movw	r0, #1627	; 0x65b
    a46c:	f001 fdaa 	bl	bfc4 <radio_crc_configure>
	lll_chan_set(aux_ptr->chan_idx);
    a470:	7828      	ldrb	r0, [r5, #0]
    a472:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    a476:	f7ff f9a5 	bl	97c4 <lll_chan_set>
	radio_pkt_tx_set(sec_pdu);
    a47a:	4640      	mov	r0, r8
    a47c:	f001 fd5a 	bl	bf34 <radio_pkt_tx_set>
	if (pri_com_hdr->adv_mode & (BT_HCI_LE_ADV_PROP_CONN |
    a480:	78b3      	ldrb	r3, [r6, #2]
    a482:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    a486:	d041      	beq.n	a50c <prepare_cb+0x1a0>
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
    a488:	f10d 0103 	add.w	r1, sp, #3
    a48c:	f10a 0014 	add.w	r0, sl, #20
    a490:	f7ff fc74 	bl	9d7c <lll_adv_pdu_latest_get>
		LL_ASSERT(scan_pdu);
    a494:	4605      	mov	r5, r0
    a496:	b958      	cbnz	r0, a4b0 <prepare_cb+0x144>
    a498:	4a29      	ldr	r2, [pc, #164]	; (a540 <prepare_cb+0x1d4>)
    a49a:	4931      	ldr	r1, [pc, #196]	; (a560 <prepare_cb+0x1f4>)
    a49c:	482a      	ldr	r0, [pc, #168]	; (a548 <prepare_cb+0x1dc>)
    a49e:	23d7      	movs	r3, #215	; 0xd7
    a4a0:	f005 f811 	bl	f4c6 <printk>
    a4a4:	4040      	eors	r0, r0
    a4a6:	f380 8811 	msr	BASEPRI, r0
    a4aa:	f04f 0003 	mov.w	r0, #3
    a4ae:	df02      	svc	2
		if (upd) {
    a4b0:	f89d 3003 	ldrb.w	r3, [sp, #3]
    a4b4:	b12b      	cbz	r3, a4c2 <prepare_cb+0x156>
			memcpy(&scan_pdu->adv_ext_ind.ext_hdr.data[ADVA_OFFSET],
    a4b6:	2206      	movs	r2, #6
    a4b8:	f108 0104 	add.w	r1, r8, #4
    a4bc:	1d28      	adds	r0, r5, #4
    a4be:	f005 fb72 	bl	fba6 <memcpy>
		radio_isr_set(isr_tx_rx, lll);
    a4c2:	4828      	ldr	r0, [pc, #160]	; (a564 <prepare_cb+0x1f8>)
    a4c4:	4621      	mov	r1, r4
    a4c6:	f001 fc79 	bl	bdbc <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
    a4ca:	2096      	movs	r0, #150	; 0x96
    a4cc:	f001 feb0 	bl	c230 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(phy_s);
    a4d0:	4648      	mov	r0, r9
    a4d2:	f001 fdff 	bl	c0d4 <radio_switch_complete_and_rx>
	ull = HDR_LLL2ULL(lll);
    a4d6:	6826      	ldr	r6, [r4, #0]
	ticks_at_event = p->ticks_at_expire;
    a4d8:	683d      	ldr	r5, [r7, #0]
	ticks_at_event += lll_event_offset_get(ull);
    a4da:	4630      	mov	r0, r6
    a4dc:	f007 f961 	bl	117a2 <lll_event_offset_get>
    a4e0:	4405      	add	r5, r0
	start_us = radio_tmr_start(1, ticks_at_start, remainder);
    a4e2:	687a      	ldr	r2, [r7, #4]
    a4e4:	f105 0109 	add.w	r1, r5, #9
    a4e8:	2001      	movs	r0, #1
    a4ea:	f001 fead 	bl	c248 <radio_tmr_start>
	radio_tmr_end_capture();
    a4ee:	f001 ff55 	bl	c39c <radio_tmr_end_capture>
				   ull_adv_aux_lll_handle_get(lll)),
    a4f2:	4620      	mov	r0, r4
    a4f4:	f006 ffe8 	bl	114c8 <ull_adv_aux_lll_handle_get>
	if (lll_preempt_calc(ull, (TICKER_ID_ADV_AUX_BASE +
    a4f8:	1cc1      	adds	r1, r0, #3
    a4fa:	462a      	mov	r2, r5
    a4fc:	b2c9      	uxtb	r1, r1
    a4fe:	4630      	mov	r0, r6
    a500:	f007 f95d 	bl	117be <lll_preempt_calc>
    a504:	b148      	cbz	r0, a51a <prepare_cb+0x1ae>
		radio_isr_set(lll_isr_abort, lll);
    a506:	4818      	ldr	r0, [pc, #96]	; (a568 <prepare_cb+0x1fc>)
    a508:	4621      	mov	r1, r4
    a50a:	e788      	b.n	a41e <prepare_cb+0xb2>
		radio_isr_set(isr_done, lll);
    a50c:	4817      	ldr	r0, [pc, #92]	; (a56c <prepare_cb+0x200>)
    a50e:	4621      	mov	r1, r4
    a510:	f001 fc54 	bl	bdbc <radio_isr_set>
		radio_switch_complete_and_disable();
    a514:	f001 fe02 	bl	c11c <radio_switch_complete_and_disable>
    a518:	e7dd      	b.n	a4d6 <prepare_cb+0x16a>
		ret = lll_prepare_done(lll);
    a51a:	4620      	mov	r0, r4
    a51c:	f007 f93c 	bl	11798 <lll_prepare_done>
		LL_ASSERT(!ret);
    a520:	2800      	cmp	r0, #0
    a522:	d080      	beq.n	a426 <prepare_cb+0xba>
    a524:	4a06      	ldr	r2, [pc, #24]	; (a540 <prepare_cb+0x1d4>)
    a526:	4912      	ldr	r1, [pc, #72]	; (a570 <prepare_cb+0x204>)
    a528:	4807      	ldr	r0, [pc, #28]	; (a548 <prepare_cb+0x1dc>)
    a52a:	f44f 738f 	mov.w	r3, #286	; 0x11e
    a52e:	f004 ffca 	bl	f4c6 <printk>
    a532:	4040      	eors	r0, r0
    a534:	f380 8811 	msr	BASEPRI, r0
    a538:	f04f 0003 	mov.w	r0, #3
    a53c:	df02      	svc	2
    a53e:	e772      	b.n	a426 <prepare_cb+0xba>
    a540:	00013e21 	.word	0x00013e21
    a544:	00013e6f 	.word	0x00013e6f
    a548:	000133b6 	.word	0x000133b6
    a54c:	00013e77 	.word	0x00013e77
    a550:	00013e9d 	.word	0x00013e9d
    a554:	0000987d 	.word	0x0000987d
    a558:	8e89bed6 	.word	0x8e89bed6
    a55c:	00555555 	.word	0x00555555
    a560:	00013dfe 	.word	0x00013dfe
    a564:	0000a271 	.word	0x0000a271
    a568:	0001181b 	.word	0x0001181b
    a56c:	0000a231 	.word	0x0000a231
    a570:	0001366f 	.word	0x0001366f

0000a574 <isr_rx>:

static void isr_rx(void *param)
{
    a574:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    a578:	4605      	mov	r5, r0
	if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
		lll_prof_latency_capture();
	}

	/* Read radio status and events */
	trx_done = radio_is_done();
    a57a:	f001 fd0f 	bl	bf9c <radio_is_done>
	if (trx_done) {
    a57e:	f010 04ff 	ands.w	r4, r0, #255	; 0xff
    a582:	f000 8095 	beq.w	a6b0 <isr_rx+0x13c>
		crc_ok = radio_crc_is_valid();
    a586:	f001 fd29 	bl	bfdc <radio_crc_is_valid>
    a58a:	fa5f fa80 	uxtb.w	sl, r0
		devmatch_ok = radio_filter_has_match();
    a58e:	f001 fe23 	bl	c1d8 <radio_filter_has_match>
    a592:	fa5f f980 	uxtb.w	r9, r0
		devmatch_id = radio_filter_match_get();
    a596:	f001 fe29 	bl	c1ec <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
    a59a:	f001 ff65 	bl	c468 <radio_ar_has_match>
    a59e:	b2c7      	uxtb	r7, r0
		irkmatch_id = radio_ar_match_get();
    a5a0:	f001 ff4a 	bl	c438 <radio_ar_match_get>
    a5a4:	b2c6      	uxtb	r6, r0
		rssi_ready = radio_rssi_is_ready();
    a5a6:	f001 fddf 	bl	c168 <radio_rssi_is_ready>
    a5aa:	fa5f f880 	uxtb.w	r8, r0
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
		devmatch_id = irkmatch_id = 0xFF;
	}

	/* Clear radio status and events */
	lll_isr_status_reset();
    a5ae:	f007 f927 	bl	11800 <lll_isr_status_reset>

	/* No Rx */
	if (!trx_done) {
    a5b2:	2c00      	cmp	r4, #0
    a5b4:	d073      	beq.n	a69e <isr_rx+0x12a>
		goto isr_rx_do_close;
	}

	if (crc_ok) {
    a5b6:	f1ba 0f00 	cmp.w	sl, #0
    a5ba:	d070      	beq.n	a69e <isr_rx+0x12a>
	uint8_t *addr;
	uint8_t upd;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* An IRK match implies address resolution enabled */
	uint8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    a5bc:	2f00      	cmp	r7, #0
    a5be:	d07d      	beq.n	a6bc <isr_rx+0x148>
    a5c0:	4630      	mov	r0, r6
    a5c2:	f7fe fcfb 	bl	8fbc <ull_filter_lll_rl_irk_idx>
    a5c6:	f88d 000f 	strb.w	r0, [sp, #15]
	uint8_t rl_idx = FILTER_IDX_NONE;
#endif /* CONFIG_BT_CTLR_PRIVACY */

	lll = lll_aux->adv;

	node_rx = ull_pdu_rx_alloc_peek(1);
    a5ca:	2001      	movs	r0, #1
	lll = lll_aux->adv;
    a5cc:	686e      	ldr	r6, [r5, #4]
	node_rx = ull_pdu_rx_alloc_peek(1);
    a5ce:	f7fc f871 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    a5d2:	4607      	mov	r7, r0
    a5d4:	b960      	cbnz	r0, a5f0 <isr_rx+0x7c>
    a5d6:	4a3c      	ldr	r2, [pc, #240]	; (a6c8 <isr_rx+0x154>)
    a5d8:	493c      	ldr	r1, [pc, #240]	; (a6cc <isr_rx+0x158>)
    a5da:	483d      	ldr	r0, [pc, #244]	; (a6d0 <isr_rx+0x15c>)
    a5dc:	f240 231f 	movw	r3, #543	; 0x21f
    a5e0:	f004 ff71 	bl	f4c6 <printk>
    a5e4:	4040      	eors	r0, r0
    a5e6:	f380 8811 	msr	BASEPRI, r0
    a5ea:	f04f 0003 	mov.w	r0, #3
    a5ee:	df02      	svc	2
	return lll_adv_pdu_latest_get(&lll->data, is_modified);
    a5f0:	f10d 010e 	add.w	r1, sp, #14
    a5f4:	f105 0010 	add.w	r0, r5, #16
    a5f8:	7a33      	ldrb	r3, [r6, #8]
    a5fa:	f7ff fbbf 	bl	9d7c <lll_adv_pdu_latest_get>

	pdu_rx = (void *)node_rx->pdu;
    a5fe:	f107 0a1c 	add.w	sl, r7, #28
	pdu_adv = lll_adv_data_curr_get(lll);
	pdu_aux = lll_adv_aux_data_latest_get(lll_aux, &upd);
	LL_ASSERT(pdu_aux);
    a602:	4604      	mov	r4, r0
    a604:	b960      	cbnz	r0, a620 <isr_rx+0xac>
    a606:	4a30      	ldr	r2, [pc, #192]	; (a6c8 <isr_rx+0x154>)
    a608:	4932      	ldr	r1, [pc, #200]	; (a6d4 <isr_rx+0x160>)
    a60a:	4831      	ldr	r0, [pc, #196]	; (a6d0 <isr_rx+0x15c>)
    a60c:	f44f 7309 	mov.w	r3, #548	; 0x224
    a610:	f004 ff59 	bl	f4c6 <printk>
    a614:	4040      	eors	r0, r0
    a616:	f380 8811 	msr	BASEPRI, r0
    a61a:	f04f 0003 	mov.w	r0, #3
    a61e:	df02      	svc	2
	} else {
		tgt_addr = NULL;
	}
	rx_addr = pdu_aux->rx_addr;

	if ((pdu_rx->type == PDU_ADV_TYPE_AUX_SCAN_REQ) &&
    a620:	7f39      	ldrb	r1, [r7, #28]
	addr = &pdu_aux->adv_ext_ind.ext_hdr.data[ADVA_OFFSET];
    a622:	4623      	mov	r3, r4
	if ((pdu_rx->type == PDU_ADV_TYPE_AUX_SCAN_REQ) &&
    a624:	f001 010f 	and.w	r1, r1, #15
	tx_addr = pdu_aux->tx_addr;
    a628:	f813 2b04 	ldrb.w	r2, [r3], #4
	if ((pdu_rx->type == PDU_ADV_TYPE_AUX_SCAN_REQ) &&
    a62c:	2903      	cmp	r1, #3
	tx_addr = pdu_aux->tx_addr;
    a62e:	f3c2 1280 	ubfx	r2, r2, #6, #1
	if ((pdu_rx->type == PDU_ADV_TYPE_AUX_SCAN_REQ) &&
    a632:	d134      	bne.n	a69e <isr_rx+0x12a>
    a634:	7f79      	ldrb	r1, [r7, #29]
    a636:	290c      	cmp	r1, #12
    a638:	d131      	bne.n	a69e <isr_rx+0x12a>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
	    lll_adv_scan_req_check(lll, pdu_rx, tx_addr, addr, devmatch_ok,
    a63a:	f10d 010f 	add.w	r1, sp, #15
    a63e:	e9cd 9100 	strd	r9, r1, [sp]
    a642:	4630      	mov	r0, r6
    a644:	4651      	mov	r1, sl
    a646:	f007 f935 	bl	118b4 <lll_adv_scan_req_check>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
    a64a:	b340      	cbz	r0, a69e <isr_rx+0x12a>
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
    a64c:	7d33      	ldrb	r3, [r6, #20]
							 lll->phy_s,
							 lll->phy_flags);
#endif /* CONFIG_BT_CTLR_ADV_PDU_BACK2BACK */

		} else {
			radio_isr_set(isr_done, lll_aux);
    a64e:	4822      	ldr	r0, [pc, #136]	; (a6d8 <isr_rx+0x164>)
    a650:	eb06 0383 	add.w	r3, r6, r3, lsl #2
    a654:	4629      	mov	r1, r5
    a656:	699c      	ldr	r4, [r3, #24]
    a658:	f001 fbb0 	bl	bdbc <radio_isr_set>
			radio_switch_complete_and_disable();
    a65c:	f001 fd5e 	bl	c11c <radio_switch_complete_and_disable>
		}

		radio_pkt_tx_set(sr_pdu);
    a660:	4620      	mov	r0, r4
    a662:	f001 fc67 	bl	bf34 <radio_pkt_tx_set>

		/* assert if radio packet ptr is not set and radio started tx */
		LL_ASSERT(!radio_is_ready());
    a666:	f001 fc8f 	bl	bf88 <radio_is_ready>
    a66a:	b160      	cbz	r0, a686 <isr_rx+0x112>
    a66c:	4a16      	ldr	r2, [pc, #88]	; (a6c8 <isr_rx+0x154>)
    a66e:	491b      	ldr	r1, [pc, #108]	; (a6dc <isr_rx+0x168>)
    a670:	4817      	ldr	r0, [pc, #92]	; (a6d0 <isr_rx+0x15c>)
    a672:	f240 2351 	movw	r3, #593	; 0x251
    a676:	f004 ff26 	bl	f4c6 <printk>
    a67a:	4040      	eors	r0, r0
    a67c:	f380 8811 	msr	BASEPRI, r0
    a680:	f04f 0003 	mov.w	r0, #3
    a684:	df02      	svc	2
		if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
			lll_prof_cputime_capture();
		}

#if defined(CONFIG_BT_CTLR_SCAN_REQ_NOTIFY)
		if (lll->scan_req_notify) {
    a686:	f996 3005 	ldrsb.w	r3, [r6, #5]
    a68a:	2b00      	cmp	r3, #0
    a68c:	da18      	bge.n	a6c0 <isr_rx+0x14c>
			uint32_t err;

			/* Generate the scan request event */
			err = lll_adv_scan_req_report(lll, pdu_rx, rl_idx,
    a68e:	f89d 200f 	ldrb.w	r2, [sp, #15]
    a692:	4643      	mov	r3, r8
    a694:	4651      	mov	r1, sl
    a696:	4630      	mov	r0, r6
    a698:	f007 f93f 	bl	1191a <lll_adv_scan_req_report>
						      rssi_ready);
			if (err) {
    a69c:	b180      	cbz	r0, a6c0 <isr_rx+0x14c>
	radio_isr_set(isr_done, param);
    a69e:	480e      	ldr	r0, [pc, #56]	; (a6d8 <isr_rx+0x164>)
    a6a0:	4629      	mov	r1, r5
    a6a2:	f001 fb8b 	bl	bdbc <radio_isr_set>
}
    a6a6:	b004      	add	sp, #16
    a6a8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	radio_disable();
    a6ac:	f001 bc4e 	b.w	bf4c <radio_disable>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
    a6b0:	46a2      	mov	sl, r4
    a6b2:	46a0      	mov	r8, r4
    a6b4:	4627      	mov	r7, r4
    a6b6:	46a1      	mov	r9, r4
		devmatch_id = irkmatch_id = 0xFF;
    a6b8:	26ff      	movs	r6, #255	; 0xff
    a6ba:	e778      	b.n	a5ae <isr_rx+0x3a>
	uint8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    a6bc:	20ff      	movs	r0, #255	; 0xff
    a6be:	e782      	b.n	a5c6 <isr_rx+0x52>
}
    a6c0:	b004      	add	sp, #16
    a6c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a6c6:	bf00      	nop
    a6c8:	00013e21 	.word	0x00013e21
    a6cc:	00013ddd 	.word	0x00013ddd
    a6d0:	000133b6 	.word	0x000133b6
    a6d4:	00013eb6 	.word	0x00013eb6
    a6d8:	0000a231 	.word	0x0000a231
    a6dc:	00013de5 	.word	0x00013de5

0000a6e0 <lll_adv_aux_prepare>:
{
    a6e0:	b513      	push	{r0, r1, r4, lr}
    a6e2:	4604      	mov	r4, r0
	err = lll_hfclock_on();
    a6e4:	f7ff f9a6 	bl	9a34 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
    a6e8:	2800      	cmp	r0, #0
    a6ea:	da0b      	bge.n	a704 <lll_adv_aux_prepare+0x24>
    a6ec:	4a11      	ldr	r2, [pc, #68]	; (a734 <lll_adv_aux_prepare+0x54>)
    a6ee:	4912      	ldr	r1, [pc, #72]	; (a738 <lll_adv_aux_prepare+0x58>)
    a6f0:	4812      	ldr	r0, [pc, #72]	; (a73c <lll_adv_aux_prepare+0x5c>)
    a6f2:	235d      	movs	r3, #93	; 0x5d
    a6f4:	f004 fee7 	bl	f4c6 <printk>
    a6f8:	4040      	eors	r0, r0
    a6fa:	f380 8811 	msr	BASEPRI, r0
    a6fe:	f04f 0003 	mov.w	r0, #3
    a702:	df02      	svc	2
	err = lll_prepare(lll_is_abort_cb, lll_abort_cb, prepare_cb, 0, param);
    a704:	4a0e      	ldr	r2, [pc, #56]	; (a740 <lll_adv_aux_prepare+0x60>)
    a706:	490f      	ldr	r1, [pc, #60]	; (a744 <lll_adv_aux_prepare+0x64>)
    a708:	480f      	ldr	r0, [pc, #60]	; (a748 <lll_adv_aux_prepare+0x68>)
    a70a:	9400      	str	r4, [sp, #0]
    a70c:	2300      	movs	r3, #0
    a70e:	f006 fcad 	bl	1106c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
    a712:	b168      	cbz	r0, a730 <lll_adv_aux_prepare+0x50>
    a714:	3077      	adds	r0, #119	; 0x77
    a716:	d00b      	beq.n	a730 <lll_adv_aux_prepare+0x50>
    a718:	4a06      	ldr	r2, [pc, #24]	; (a734 <lll_adv_aux_prepare+0x54>)
    a71a:	490c      	ldr	r1, [pc, #48]	; (a74c <lll_adv_aux_prepare+0x6c>)
    a71c:	4807      	ldr	r0, [pc, #28]	; (a73c <lll_adv_aux_prepare+0x5c>)
    a71e:	2360      	movs	r3, #96	; 0x60
    a720:	f004 fed1 	bl	f4c6 <printk>
    a724:	4040      	eors	r0, r0
    a726:	f380 8811 	msr	BASEPRI, r0
    a72a:	f04f 0003 	mov.w	r0, #3
    a72e:	df02      	svc	2
}
    a730:	b002      	add	sp, #8
    a732:	bd10      	pop	{r4, pc}
    a734:	00013e21 	.word	0x00013e21
    a738:	00013d61 	.word	0x00013d61
    a73c:	000133b6 	.word	0x000133b6
    a740:	0000a36d 	.word	0x0000a36d
    a744:	00009775 	.word	0x00009775
    a748:	0001179d 	.word	0x0001179d
    a74c:	00013e0d 	.word	0x00013e0d

0000a750 <ticker_stop_cb>:
	lll_done(param);
}

static void ticker_stop_cb(uint32_t ticks_at_expire, uint32_t ticks_drift,
			   uint32_t remainder, uint16_t lazy, uint8_t force, void *param)
{
    a750:	b508      	push	{r3, lr}
	radio_isr_set(isr_done_cleanup, param);
    a752:	9903      	ldr	r1, [sp, #12]
    a754:	4803      	ldr	r0, [pc, #12]	; (a764 <ticker_stop_cb+0x14>)
    a756:	f001 fb31 	bl	bdbc <radio_isr_set>
	radio_disable();
}
    a75a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_disable();
    a75e:	f001 bbf5 	b.w	bf4c <radio_disable>
    a762:	bf00      	nop
    a764:	0000ace5 	.word	0x0000ace5

0000a768 <common_prepare_cb>:
{
    a768:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	lll = p->param;
    a76c:	68c4      	ldr	r4, [r0, #12]
	lll->state = 0U;
    a76e:	7923      	ldrb	r3, [r4, #4]
    a770:	f36f 0300 	bfc	r3, #0, #1
{
    a774:	b08c      	sub	sp, #48	; 0x30
	lll->state = 0U;
    a776:	7123      	strb	r3, [r4, #4]
{
    a778:	460d      	mov	r5, r1
    a77a:	4607      	mov	r7, r0
	radio_reset();
    a77c:	f001 fb3e 	bl	bdfc <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
    a780:	2000      	movs	r0, #0
    a782:	f001 fb6f 	bl	be64 <radio_tx_power_set>
	radio_phy_set(lll->phy, 1);
    a786:	7aa0      	ldrb	r0, [r4, #10]
    a788:	2101      	movs	r1, #1
    a78a:	f000 0007 	and.w	r0, r0, #7
    a78e:	f001 fb59 	bl	be44 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_LEG_PAYLOAD_SIZE_MAX, (lll->phy << 1));
    a792:	7aa2      	ldrb	r2, [r4, #10]
    a794:	0052      	lsls	r2, r2, #1
    a796:	f002 020e 	and.w	r2, r2, #14
    a79a:	2125      	movs	r1, #37	; 0x25
    a79c:	2008      	movs	r0, #8
    a79e:	f001 fb97 	bl	bed0 <radio_pkt_configure>
	lll->is_adv_ind = 0U;
    a7a2:	7aa3      	ldrb	r3, [r4, #10]
    a7a4:	f023 0318 	bic.w	r3, r3, #24
    a7a8:	72a3      	strb	r3, [r4, #10]
	node_rx = ull_pdu_rx_alloc_peek(1);
    a7aa:	2001      	movs	r0, #1
    a7ac:	f7fb ff82 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    a7b0:	4606      	mov	r6, r0
    a7b2:	b960      	cbnz	r0, a7ce <common_prepare_cb+0x66>
    a7b4:	4a5c      	ldr	r2, [pc, #368]	; (a928 <common_prepare_cb+0x1c0>)
    a7b6:	495d      	ldr	r1, [pc, #372]	; (a92c <common_prepare_cb+0x1c4>)
    a7b8:	485d      	ldr	r0, [pc, #372]	; (a930 <common_prepare_cb+0x1c8>)
    a7ba:	f240 138b 	movw	r3, #395	; 0x18b
    a7be:	f004 fe82 	bl	f4c6 <printk>
    a7c2:	4040      	eors	r0, r0
    a7c4:	f380 8811 	msr	BASEPRI, r0
    a7c8:	f04f 0003 	mov.w	r0, #3
    a7cc:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
    a7ce:	f106 001c 	add.w	r0, r6, #28
    a7d2:	f001 fba9 	bl	bf28 <radio_pkt_rx_set>
	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
    a7d6:	4b57      	ldr	r3, [pc, #348]	; (a934 <common_prepare_cb+0x1cc>)
    a7d8:	930b      	str	r3, [sp, #44]	; 0x2c
	radio_aa_set((uint8_t *)&aa);
    a7da:	a80b      	add	r0, sp, #44	; 0x2c
    a7dc:	f001 fb60 	bl	bea0 <radio_aa_set>
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
    a7e0:	4955      	ldr	r1, [pc, #340]	; (a938 <common_prepare_cb+0x1d0>)
    a7e2:	f240 605b 	movw	r0, #1627	; 0x65b
    a7e6:	f001 fbed 	bl	bfc4 <radio_crc_configure>
	lll_chan_set(37 + lll->chan);
    a7ea:	7920      	ldrb	r0, [r4, #4]
    a7ec:	f3c0 0041 	ubfx	r0, r0, #1, #2
    a7f0:	3025      	adds	r0, #37	; 0x25
    a7f2:	f7fe ffe7 	bl	97c4 <lll_chan_set>
	radio_isr_set(isr_rx, lll);
    a7f6:	4851      	ldr	r0, [pc, #324]	; (a93c <common_prepare_cb+0x1d4>)
    a7f8:	4621      	mov	r1, r4
    a7fa:	f001 fadf 	bl	bdbc <radio_isr_set>
	} else if (lll->type ||
    a7fe:	7923      	ldrb	r3, [r4, #4]
    a800:	069b      	lsls	r3, r3, #26
    a802:	d54a      	bpl.n	a89a <common_prepare_cb+0x132>
		radio_tmr_tifs_set(EVENT_IFS_US);
    a804:	2096      	movs	r0, #150	; 0x96
    a806:	f001 fd13 	bl	c230 <radio_tmr_tifs_set>
		radio_switch_complete_and_tx(0, 0, 0, 0);
    a80a:	2300      	movs	r3, #0
    a80c:	461a      	mov	r2, r3
    a80e:	4619      	mov	r1, r3
    a810:	4618      	mov	r0, r3
    a812:	f001 fc71 	bl	c0f8 <radio_switch_complete_and_tx>
	if (ull_filter_lll_rl_enabled()) {
    a816:	f7fe fcc9 	bl	91ac <ull_filter_lll_rl_enabled>
    a81a:	7923      	ldrb	r3, [r4, #4]
    a81c:	2800      	cmp	r0, #0
    a81e:	d03f      	beq.n	a8a0 <common_prepare_cb+0x138>
			ull_filter_lll_get((lll->filter_policy &
    a820:	f3c3 00c0 	ubfx	r0, r3, #3, #1
    a824:	f7fd ff84 	bl	8730 <ull_filter_lll_get>
    a828:	4606      	mov	r6, r0
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    a82a:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
    a82e:	f7fe fb5f 	bl	8ef0 <ull_filter_lll_irks_get>
		radio_filter_configure(filter->enable_bitmask,
    a832:	7871      	ldrb	r1, [r6, #1]
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    a834:	4680      	mov	r8, r0
		radio_filter_configure(filter->enable_bitmask,
    a836:	1cb2      	adds	r2, r6, #2
    a838:	7830      	ldrb	r0, [r6, #0]
    a83a:	f001 fc9f 	bl	c17c <radio_filter_configure>
		radio_ar_configure(count, irks, (lll->phy << 2));
    a83e:	7aa2      	ldrb	r2, [r4, #10]
    a840:	f89d 002b 	ldrb.w	r0, [sp, #43]	; 0x2b
    a844:	0092      	lsls	r2, r2, #2
    a846:	f002 021c 	and.w	r2, r2, #28
    a84a:	4641      	mov	r1, r8
    a84c:	f001 fdba 	bl	c3c4 <radio_ar_configure>
	ull = HDR_LLL2ULL(lll);
    a850:	f8d4 8000 	ldr.w	r8, [r4]
	ticks_at_event = p->ticks_at_expire;
    a854:	683e      	ldr	r6, [r7, #0]
	ticks_at_event += lll_event_offset_get(ull);
    a856:	4640      	mov	r0, r8
    a858:	f006 ffa3 	bl	117a2 <lll_event_offset_get>
    a85c:	4406      	add	r6, r0
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
    a85e:	687a      	ldr	r2, [r7, #4]
    a860:	f106 0109 	add.w	r1, r6, #9
    a864:	2000      	movs	r0, #0
    a866:	f001 fcef 	bl	c248 <radio_tmr_start>
	radio_tmr_end_capture();
    a86a:	f001 fd97 	bl	c39c <radio_tmr_end_capture>
	radio_rssi_measure();
    a86e:	f001 fc63 	bl	c138 <radio_rssi_measure>
				   ull_scan_lll_handle_get(lll)),
    a872:	4620      	mov	r0, r4
    a874:	f7fd fb20 	bl	7eb8 <ull_scan_lll_handle_get>
	if (lll_preempt_calc(ull, (TICKER_ID_SCAN_BASE +
    a878:	1d41      	adds	r1, r0, #5
    a87a:	4632      	mov	r2, r6
    a87c:	b2c9      	uxtb	r1, r1
    a87e:	4640      	mov	r0, r8
    a880:	f006 ff9d 	bl	117be <lll_preempt_calc>
    a884:	b1c0      	cbz	r0, a8b8 <common_prepare_cb+0x150>
		radio_isr_set(isr_abort, lll);
    a886:	482e      	ldr	r0, [pc, #184]	; (a940 <common_prepare_cb+0x1d8>)
    a888:	4621      	mov	r1, r4
    a88a:	f001 fa97 	bl	bdbc <radio_isr_set>
		radio_disable();
    a88e:	f001 fb5d 	bl	bf4c <radio_disable>
}
    a892:	2000      	movs	r0, #0
    a894:	b00c      	add	sp, #48	; 0x30
    a896:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		radio_switch_complete_and_disable();
    a89a:	f001 fc3f 	bl	c11c <radio_switch_complete_and_disable>
    a89e:	e7ba      	b.n	a816 <common_prepare_cb+0xae>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER_ACCEPT_LIST) && lll->filter_policy) {
    a8a0:	f013 0f18 	tst.w	r3, #24
    a8a4:	d0d4      	beq.n	a850 <common_prepare_cb+0xe8>
		struct lll_filter *fal = ull_filter_lll_get(true);
    a8a6:	2001      	movs	r0, #1
    a8a8:	f7fd ff42 	bl	8730 <ull_filter_lll_get>
		radio_filter_configure(fal->enable_bitmask,
    a8ac:	7841      	ldrb	r1, [r0, #1]
    a8ae:	1c82      	adds	r2, r0, #2
    a8b0:	7800      	ldrb	r0, [r0, #0]
    a8b2:	f001 fc63 	bl	c17c <radio_filter_configure>
    a8b6:	e7cb      	b.n	a850 <common_prepare_cb+0xe8>
		if (!is_resume && lll->ticks_window) {
    a8b8:	bb1d      	cbnz	r5, a902 <common_prepare_cb+0x19a>
    a8ba:	69e3      	ldr	r3, [r4, #28]
    a8bc:	b30b      	cbz	r3, a902 <common_prepare_cb+0x19a>
			ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    a8be:	f44f 72fc 	mov.w	r2, #504	; 0x1f8
    a8c2:	9208      	str	r2, [sp, #32]
    a8c4:	4a1f      	ldr	r2, [pc, #124]	; (a944 <common_prepare_cb+0x1dc>)
    a8c6:	e9cd 4206 	strd	r4, r2, [sp, #24]
    a8ca:	4a1f      	ldr	r2, [pc, #124]	; (a948 <common_prepare_cb+0x1e0>)
    a8cc:	e9cd 3500 	strd	r3, r5, [sp]
    a8d0:	e9cd 5204 	strd	r5, r2, [sp, #16]
    a8d4:	4633      	mov	r3, r6
    a8d6:	e9cd 5502 	strd	r5, r5, [sp, #8]
    a8da:	2204      	movs	r2, #4
    a8dc:	4629      	mov	r1, r5
    a8de:	f006 f984 	bl	10bea <ticker_start>
			LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
    a8e2:	f030 0302 	bics.w	r3, r0, #2
    a8e6:	d00c      	beq.n	a902 <common_prepare_cb+0x19a>
    a8e8:	4a0f      	ldr	r2, [pc, #60]	; (a928 <common_prepare_cb+0x1c0>)
    a8ea:	4918      	ldr	r1, [pc, #96]	; (a94c <common_prepare_cb+0x1e4>)
    a8ec:	4810      	ldr	r0, [pc, #64]	; (a930 <common_prepare_cb+0x1c8>)
    a8ee:	f240 13f9 	movw	r3, #505	; 0x1f9
    a8f2:	f004 fde8 	bl	f4c6 <printk>
    a8f6:	4040      	eors	r0, r0
    a8f8:	f380 8811 	msr	BASEPRI, r0
    a8fc:	f04f 0003 	mov.w	r0, #3
    a900:	df02      	svc	2
		ret = lll_prepare_done(lll);
    a902:	4620      	mov	r0, r4
    a904:	f006 ff48 	bl	11798 <lll_prepare_done>
		LL_ASSERT(!ret);
    a908:	2800      	cmp	r0, #0
    a90a:	d0c2      	beq.n	a892 <common_prepare_cb+0x12a>
    a90c:	4a06      	ldr	r2, [pc, #24]	; (a928 <common_prepare_cb+0x1c0>)
    a90e:	4910      	ldr	r1, [pc, #64]	; (a950 <common_prepare_cb+0x1e8>)
    a910:	4807      	ldr	r0, [pc, #28]	; (a930 <common_prepare_cb+0x1c8>)
    a912:	f240 2312 	movw	r3, #530	; 0x212
    a916:	f004 fdd6 	bl	f4c6 <printk>
    a91a:	4040      	eors	r0, r0
    a91c:	f380 8811 	msr	BASEPRI, r0
    a920:	f04f 0003 	mov.w	r0, #3
    a924:	df02      	svc	2
    a926:	e7b4      	b.n	a892 <common_prepare_cb+0x12a>
    a928:	00013ebe 	.word	0x00013ebe
    a92c:	00013ddd 	.word	0x00013ddd
    a930:	000133b6 	.word	0x000133b6
    a934:	8e89bed6 	.word	0x8e89bed6
    a938:	00555555 	.word	0x00555555
    a93c:	0000ae89 	.word	0x0000ae89
    a940:	0000aa75 	.word	0x0000aa75
    a944:	0000acb9 	.word	0x0000acb9
    a948:	0000a751 	.word	0x0000a751
    a94c:	000137b3 	.word	0x000137b3
    a950:	0001366f 	.word	0x0001366f

0000a954 <isr_common_done>:

	radio_isr_set(isr_rx, param);
}

static void isr_common_done(void *param)
{
    a954:	b537      	push	{r0, r1, r2, r4, r5, lr}
    a956:	4604      	mov	r4, r0
	struct node_rx_pdu *node_rx;
	struct lll_scan *lll;

	/* Clear radio status and events */
	lll_isr_status_reset();
    a958:	f006 ff52 	bl	11800 <lll_isr_status_reset>

	/* Reset scanning state */
	lll = param;
	lll->state = 0U;
    a95c:	7923      	ldrb	r3, [r4, #4]

#if defined(CONFIG_BT_CTLR_ADV_EXT)
	lll->is_adv_ind = 0U;
    a95e:	7aa2      	ldrb	r2, [r4, #10]
	lll->state = 0U;
    a960:	f36f 0300 	bfc	r3, #0, #1
    a964:	7123      	strb	r3, [r4, #4]
	lll->is_adv_ind = 0U;
    a966:	f36f 02c3 	bfc	r2, #3, #1
#endif /* CONFIG_BT_CTLR_ADV_EXT */

	/* setup tIFS switching */
	if (0) {
		/* TODO: Add Rx-Rx switch usecase improvement in the future */
	} else if (lll->type ||
    a96a:	069b      	lsls	r3, r3, #26
	lll->is_adv_ind = 0U;
    a96c:	72a2      	strb	r2, [r4, #10]
	} else if (lll->type ||
    a96e:	d537      	bpl.n	a9e0 <isr_common_done+0x8c>
#if defined(CONFIG_BT_CENTRAL)
		   lll->conn) {
#else /* !CONFIG_BT_CENTRAL */
		   0) {
#endif /* !CONFIG_BT_CENTRAL */
		radio_tmr_tifs_set(EVENT_IFS_US);
    a970:	2096      	movs	r0, #150	; 0x96
    a972:	f001 fc5d 	bl	c230 <radio_tmr_tifs_set>
		radio_switch_complete_and_tx(0, 0, 0, 0);
    a976:	2300      	movs	r3, #0
    a978:	461a      	mov	r2, r3
    a97a:	4619      	mov	r1, r3
    a97c:	4618      	mov	r0, r3
    a97e:	f001 fbbb 	bl	c0f8 <radio_switch_complete_and_tx>
	} else {
		radio_switch_complete_and_disable();
	}

	node_rx = ull_pdu_rx_alloc_peek(1);
    a982:	2001      	movs	r0, #1
    a984:	f7fb fe96 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    a988:	4605      	mov	r5, r0
    a98a:	b960      	cbnz	r0, a9a6 <isr_common_done+0x52>
    a98c:	4a16      	ldr	r2, [pc, #88]	; (a9e8 <isr_common_done+0x94>)
    a98e:	4917      	ldr	r1, [pc, #92]	; (a9ec <isr_common_done+0x98>)
    a990:	4817      	ldr	r0, [pc, #92]	; (a9f0 <isr_common_done+0x9c>)
    a992:	f240 3342 	movw	r3, #834	; 0x342
    a996:	f004 fd96 	bl	f4c6 <printk>
    a99a:	4040      	eors	r0, r0
    a99c:	f380 8811 	msr	BASEPRI, r0
    a9a0:	f04f 0003 	mov.w	r0, #3
    a9a4:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
    a9a6:	f105 001c 	add.w	r0, r5, #28
    a9aa:	f001 fabd 	bl	bf28 <radio_pkt_rx_set>

#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (ull_filter_lll_rl_enabled()) {
    a9ae:	f7fe fbfd 	bl	91ac <ull_filter_lll_rl_enabled>
    a9b2:	b160      	cbz	r0, a9ce <isr_common_done+0x7a>
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    a9b4:	f10d 0007 	add.w	r0, sp, #7
    a9b8:	f7fe fa9a 	bl	8ef0 <ull_filter_lll_irks_get>

#if defined(CONFIG_BT_CTLR_ADV_EXT)
		radio_ar_configure(count, irks, (lll->phy << 2));
    a9bc:	7aa2      	ldrb	r2, [r4, #10]
    a9be:	0092      	lsls	r2, r2, #2
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    a9c0:	4601      	mov	r1, r0
		radio_ar_configure(count, irks, (lll->phy << 2));
    a9c2:	f002 021c 	and.w	r2, r2, #28
    a9c6:	f89d 0007 	ldrb.w	r0, [sp, #7]
    a9ca:	f001 fcfb 	bl	c3c4 <radio_ar_configure>
		radio_ar_configure(count, irks, 0);
#endif
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	radio_rssi_measure();
    a9ce:	f001 fbb3 	bl	c138 <radio_rssi_measure>

	radio_isr_set(isr_rx, param);
    a9d2:	4808      	ldr	r0, [pc, #32]	; (a9f4 <isr_common_done+0xa0>)
    a9d4:	4621      	mov	r1, r4
}
    a9d6:	b003      	add	sp, #12
    a9d8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	radio_isr_set(isr_rx, param);
    a9dc:	f001 b9ee 	b.w	bdbc <radio_isr_set>
		radio_switch_complete_and_disable();
    a9e0:	f001 fb9c 	bl	c11c <radio_switch_complete_and_disable>
    a9e4:	e7cd      	b.n	a982 <isr_common_done+0x2e>
    a9e6:	bf00      	nop
    a9e8:	00013ebe 	.word	0x00013ebe
    a9ec:	00013ddd 	.word	0x00013ddd
    a9f0:	000133b6 	.word	0x000133b6
    a9f4:	0000ae89 	.word	0x0000ae89

0000a9f8 <is_abort_cb>:
	if (next != curr) {
    a9f8:	4281      	cmp	r1, r0
{
    a9fa:	b508      	push	{r3, lr}
		if (unlikely(!lll->duration_reload || lll->duration_expire))
    a9fc:	88cb      	ldrh	r3, [r1, #6]
	if (next != curr) {
    a9fe:	d01a      	beq.n	aa36 <is_abort_cb+0x3e>
		if (unlikely(!lll->duration_reload || lll->duration_expire))
    aa00:	b10b      	cbz	r3, aa06 <is_abort_cb+0xe>
    aa02:	890b      	ldrh	r3, [r1, #8]
    aa04:	b1d3      	cbz	r3, aa3c <is_abort_cb+0x44>
			if (!lll->ticks_window) {
    aa06:	69cb      	ldr	r3, [r1, #28]
    aa08:	bb23      	cbnz	r3, aa54 <is_abort_cb+0x5c>
				*resume_cb = resume_prepare_cb;
    aa0a:	4b14      	ldr	r3, [pc, #80]	; (aa5c <is_abort_cb+0x64>)
    aa0c:	6013      	str	r3, [r2, #0]
				err = lll_hfclock_on();
    aa0e:	f7ff f811 	bl	9a34 <lll_hfclock_on>
				LL_ASSERT(err >= 0);
    aa12:	2800      	cmp	r0, #0
    aa14:	da0c      	bge.n	aa30 <is_abort_cb+0x38>
    aa16:	4a12      	ldr	r2, [pc, #72]	; (aa60 <is_abort_cb+0x68>)
    aa18:	4912      	ldr	r1, [pc, #72]	; (aa64 <is_abort_cb+0x6c>)
    aa1a:	4813      	ldr	r0, [pc, #76]	; (aa68 <is_abort_cb+0x70>)
    aa1c:	f44f 730c 	mov.w	r3, #560	; 0x230
    aa20:	f004 fd51 	bl	f4c6 <printk>
    aa24:	4040      	eors	r0, r0
    aa26:	f380 8811 	msr	BASEPRI, r0
    aa2a:	f04f 0003 	mov.w	r0, #3
    aa2e:	df02      	svc	2
				return -EAGAIN;
    aa30:	f06f 000a 	mvn.w	r0, #10
    aa34:	e010      	b.n	aa58 <is_abort_cb+0x60>
	} else if (unlikely(lll->duration_reload && !lll->duration_expire)) {
    aa36:	b143      	cbz	r3, aa4a <is_abort_cb+0x52>
    aa38:	890b      	ldrh	r3, [r1, #8]
    aa3a:	b933      	cbnz	r3, aa4a <is_abort_cb+0x52>
		radio_isr_set(isr_done_cleanup, lll);
    aa3c:	480b      	ldr	r0, [pc, #44]	; (aa6c <is_abort_cb+0x74>)
		radio_isr_set(isr_window, lll);
    aa3e:	f001 f9bd 	bl	bdbc <radio_isr_set>
	radio_disable();
    aa42:	f001 fa83 	bl	bf4c <radio_disable>
		return 0;
    aa46:	2000      	movs	r0, #0
    aa48:	e006      	b.n	aa58 <is_abort_cb+0x60>
	} else if (lll->is_aux_sched) {
    aa4a:	7a8b      	ldrb	r3, [r1, #10]
    aa4c:	06db      	lsls	r3, r3, #27
    aa4e:	d4fa      	bmi.n	aa46 <is_abort_cb+0x4e>
		radio_isr_set(isr_window, lll);
    aa50:	4807      	ldr	r0, [pc, #28]	; (aa70 <is_abort_cb+0x78>)
    aa52:	e7f4      	b.n	aa3e <is_abort_cb+0x46>
			return -ECANCELED;
    aa54:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
    aa58:	bd08      	pop	{r3, pc}
    aa5a:	bf00      	nop
    aa5c:	000119bf 	.word	0x000119bf
    aa60:	00013ebe 	.word	0x00013ebe
    aa64:	00013d61 	.word	0x00013d61
    aa68:	000133b6 	.word	0x000133b6
    aa6c:	0000ace5 	.word	0x0000ace5
    aa70:	00011983 	.word	0x00011983

0000aa74 <isr_abort>:
}

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
static void isr_abort(void *param)
{
    aa74:	b510      	push	{r4, lr}
    aa76:	4604      	mov	r4, r0
	/* Clear radio status and events */
	lll_isr_status_reset();
    aa78:	f006 fec2 	bl	11800 <lll_isr_status_reset>

	/* Disable Rx filters when aborting scan prepare */
	radio_filter_disable();
    aa7c:	f001 fb9a 	bl	c1b4 <radio_filter_disable>
	struct event_done_extra *extra;

	/* Generate Scan done events so that duration and max expiry is
	 * detected in ULL.
	 */
	extra = ull_done_extra_type_set(EVENT_DONE_EXTRA_TYPE_SCAN);
    aa80:	2003      	movs	r0, #3
    aa82:	f006 fa9e 	bl	10fc2 <ull_done_extra_type_set>
	LL_ASSERT(extra);
    aa86:	b960      	cbnz	r0, aaa2 <isr_abort+0x2e>
    aa88:	4a08      	ldr	r2, [pc, #32]	; (aaac <isr_abort+0x38>)
    aa8a:	4909      	ldr	r1, [pc, #36]	; (aab0 <isr_abort+0x3c>)
    aa8c:	4809      	ldr	r0, [pc, #36]	; (aab4 <isr_abort+0x40>)
    aa8e:	f240 33ca 	movw	r3, #970	; 0x3ca
    aa92:	f004 fd18 	bl	f4c6 <printk>
    aa96:	4040      	eors	r0, r0
    aa98:	f380 8811 	msr	BASEPRI, r0
    aa9c:	f04f 0003 	mov.w	r0, #3
    aaa0:	df02      	svc	2
#endif  /* CONFIG_BT_CTLR_ADV_EXT */

	lll_isr_cleanup(param);
    aaa2:	4620      	mov	r0, r4
}
    aaa4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
    aaa8:	f7fe bebe 	b.w	9828 <lll_isr_cleanup>
    aaac:	00013ebe 	.word	0x00013ebe
    aab0:	00013e07 	.word	0x00013e07
    aab4:	000133b6 	.word	0x000133b6

0000aab8 <isr_tx>:
{
    aab8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    aaba:	4605      	mov	r5, r0
	lll_isr_tx_status_reset();
    aabc:	f006 fe90 	bl	117e0 <lll_isr_tx_status_reset>
	radio_switch_complete_and_disable();
    aac0:	f001 fb2c 	bl	c11c <radio_switch_complete_and_disable>
	node_rx = ull_pdu_rx_alloc_peek(1);
    aac4:	2001      	movs	r0, #1
    aac6:	f7fb fdf5 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    aaca:	4604      	mov	r4, r0
    aacc:	b960      	cbnz	r0, aae8 <isr_tx+0x30>
    aace:	4a25      	ldr	r2, [pc, #148]	; (ab64 <isr_tx+0xac>)
    aad0:	4925      	ldr	r1, [pc, #148]	; (ab68 <isr_tx+0xb0>)
    aad2:	4826      	ldr	r0, [pc, #152]	; (ab6c <isr_tx+0xb4>)
    aad4:	f44f 733f 	mov.w	r3, #764	; 0x2fc
    aad8:	f004 fcf5 	bl	f4c6 <printk>
    aadc:	4040      	eors	r0, r0
    aade:	f380 8811 	msr	BASEPRI, r0
    aae2:	f04f 0003 	mov.w	r0, #3
    aae6:	df02      	svc	2
	radio_pkt_rx_set(node_rx->pdu);
    aae8:	f104 001c 	add.w	r0, r4, #28
    aaec:	f001 fa1c 	bl	bf28 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
    aaf0:	f001 fa4a 	bl	bf88 <radio_is_ready>
    aaf4:	b160      	cbz	r0, ab10 <isr_tx+0x58>
    aaf6:	4a1b      	ldr	r2, [pc, #108]	; (ab64 <isr_tx+0xac>)
    aaf8:	491d      	ldr	r1, [pc, #116]	; (ab70 <isr_tx+0xb8>)
    aafa:	481c      	ldr	r0, [pc, #112]	; (ab6c <isr_tx+0xb4>)
    aafc:	f44f 7340 	mov.w	r3, #768	; 0x300
    ab00:	f004 fce1 	bl	f4c6 <printk>
    ab04:	4040      	eors	r0, r0
    ab06:	f380 8811 	msr	BASEPRI, r0
    ab0a:	f04f 0003 	mov.w	r0, #3
    ab0e:	df02      	svc	2
	if (ull_filter_lll_rl_enabled()) {
    ab10:	f7fe fb4c 	bl	91ac <ull_filter_lll_rl_enabled>
    ab14:	b160      	cbz	r0, ab30 <isr_tx+0x78>
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    ab16:	f10d 0007 	add.w	r0, sp, #7
    ab1a:	f7fe f9e9 	bl	8ef0 <ull_filter_lll_irks_get>
		radio_ar_configure(count, irks, (lll->phy << 2));
    ab1e:	7aaa      	ldrb	r2, [r5, #10]
    ab20:	0092      	lsls	r2, r2, #2
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    ab22:	4601      	mov	r1, r0
		radio_ar_configure(count, irks, (lll->phy << 2));
    ab24:	f002 021c 	and.w	r2, r2, #28
    ab28:	f89d 0007 	ldrb.w	r0, [sp, #7]
    ab2c:	f001 fc4a 	bl	c3c4 <radio_ar_configure>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    ab30:	f001 fc42 	bl	c3b8 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
    ab34:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
    ab36:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
    ab38:	4608      	mov	r0, r1
    ab3a:	f007 f8cd 	bl	11cd8 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
    ab3e:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
    ab40:	4606      	mov	r6, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
    ab42:	4608      	mov	r0, r1
    ab44:	f007 f8c4 	bl	11cd0 <radio_tx_chain_delay_get>
    ab48:	4434      	add	r4, r6
    ab4a:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
    ab4c:	1a20      	subs	r0, r4, r0
    ab4e:	f001 fc19 	bl	c384 <radio_tmr_hcto_configure>
	radio_rssi_measure();
    ab52:	f001 faf1 	bl	c138 <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
    ab56:	4807      	ldr	r0, [pc, #28]	; (ab74 <isr_tx+0xbc>)
    ab58:	4629      	mov	r1, r5
}
    ab5a:	b002      	add	sp, #8
    ab5c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	radio_isr_set(isr_rx, param);
    ab60:	f001 b92c 	b.w	bdbc <radio_isr_set>
    ab64:	00013ebe 	.word	0x00013ebe
    ab68:	00013ddd 	.word	0x00013ddd
    ab6c:	000133b6 	.word	0x000133b6
    ab70:	00013de5 	.word	0x00013de5
    ab74:	0000ae89 	.word	0x0000ae89

0000ab78 <isr_rx_scan_report>:
}

static int isr_rx_scan_report(struct lll_scan *lll, uint8_t rssi_ready,
			      uint8_t phy_flags_rx, uint8_t irkmatch_ok,
			      uint8_t rl_idx, bool dir_report)
{
    ab78:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    ab7c:	4605      	mov	r5, r0
	struct node_rx_pdu *node_rx;
	int err = 0;

	node_rx = ull_pdu_rx_alloc_peek(3);
    ab7e:	2003      	movs	r0, #3
{
    ab80:	f89d 6028 	ldrb.w	r6, [sp, #40]	; 0x28
    ab84:	4688      	mov	r8, r1
    ab86:	4691      	mov	r9, r2
    ab88:	461f      	mov	r7, r3
	node_rx = ull_pdu_rx_alloc_peek(3);
    ab8a:	f7fb fd93 	bl	66b4 <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
    ab8e:	4604      	mov	r4, r0
    ab90:	2800      	cmp	r0, #0
    ab92:	f000 8085 	beq.w	aca0 <isr_rx_scan_report+0x128>
		return -ENOBUFS;
	}
	ull_pdu_rx_alloc();
    ab96:	f7fb fda5 	bl	66e4 <ull_pdu_rx_alloc>
		   _radio.advertiser.is_mesh) {
		node_rx->hdr.type = NODE_RX_TYPE_MESH_REPORT;
#endif /* CONFIG_BT_HCI_MESH_EXT */

#if defined(CONFIG_BT_CTLR_ADV_EXT)
	} else if (lll->phy) {
    ab9a:	7aa8      	ldrb	r0, [r5, #10]
	node_rx->hdr.handle = 0xffff;
    ab9c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    aba0:	80e3      	strh	r3, [r4, #6]
	} else if (lll->phy) {
    aba2:	f010 0307 	ands.w	r3, r0, #7
    aba6:	d075      	beq.n	ac94 <isr_rx_scan_report+0x11c>
		struct pdu_adv *pdu_adv_rx;

		switch (lll->phy) {
    aba8:	2b01      	cmp	r3, #1
    abaa:	d00f      	beq.n	abcc <isr_rx_scan_report+0x54>
    abac:	2b04      	cmp	r3, #4
    abae:	d03c      	beq.n	ac2a <isr_rx_scan_report+0xb2>
		case PHY_CODED:
			node_rx->hdr.type = NODE_RX_TYPE_EXT_CODED_REPORT;
			break;

		default:
			LL_ASSERT(0);
    abb0:	4a3d      	ldr	r2, [pc, #244]	; (aca8 <isr_rx_scan_report+0x130>)
    abb2:	493e      	ldr	r1, [pc, #248]	; (acac <isr_rx_scan_report+0x134>)
    abb4:	483e      	ldr	r0, [pc, #248]	; (acb0 <isr_rx_scan_report+0x138>)
    abb6:	f240 53ec 	movw	r3, #1516	; 0x5ec
    abba:	f004 fc84 	bl	f4c6 <printk>
    abbe:	4040      	eors	r0, r0
    abc0:	f380 8811 	msr	BASEPRI, r0
    abc4:	f04f 0003 	mov.w	r0, #3
    abc8:	df02      	svc	2
			break;
    abca:	e001      	b.n	abd0 <isr_rx_scan_report+0x58>
			node_rx->hdr.type = NODE_RX_TYPE_EXT_1M_REPORT;
    abcc:	2306      	movs	r3, #6
			node_rx->hdr.type = NODE_RX_TYPE_EXT_CODED_REPORT;
    abce:	7123      	strb	r3, [r4, #4]
		}

		pdu_adv_rx = (void *)node_rx->pdu;
		switch (pdu_adv_rx->type) {
    abd0:	7f23      	ldrb	r3, [r4, #28]
    abd2:	f003 020f 	and.w	r2, r3, #15
    abd6:	2a04      	cmp	r2, #4
    abd8:	d029      	beq.n	ac2e <isr_rx_scan_report+0xb6>
    abda:	2a07      	cmp	r2, #7
    abdc:	d02f      	beq.n	ac3e <isr_rx_scan_report+0xc6>
	int err = 0;
    abde:	2500      	movs	r5, #0
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
	}

	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
    abe0:	f1b8 0f00 	cmp.w	r8, #0
    abe4:	d05a      	beq.n	ac9c <isr_rx_scan_report+0x124>
    abe6:	f001 fab1 	bl	c14c <radio_rssi_get>
    abea:	b2c0      	uxtb	r0, r0
						  BT_HCI_LE_RSSI_NOT_AVAILABLE;
#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* save the resolving list index. */
	node_rx->hdr.rx_ftr.rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
    abec:	2f00      	cmp	r7, #0
    abee:	bf14      	ite	ne
    abf0:	4633      	movne	r3, r6
    abf2:	23ff      	moveq	r3, #255	; 0xff
    abf4:	7663      	strb	r3, [r4, #25]
#endif /* CONFIG_BT_CTLR_ADV_EXT */
#endif /* CONFIG_BT_CTLR_PRIVACY */

#if defined(CONFIG_BT_CTLR_EXT_SCAN_FP)
	/* save the directed adv report flag */
	node_rx->hdr.rx_ftr.direct = dir_report;
    abf6:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    abfa:	7ea2      	ldrb	r2, [r4, #26]
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
    abfc:	7620      	strb	r0, [r4, #24]
	node_rx->hdr.rx_ftr.direct_resolved = (rl_idx != FILTER_IDX_NONE);
    abfe:	3eff      	subs	r6, #255	; 0xff
    ac00:	bf18      	it	ne
    ac02:	2601      	movne	r6, #1
	node_rx->hdr.rx_ftr.direct = dir_report;
    ac04:	005b      	lsls	r3, r3, #1
    ac06:	ea43 0386 	orr.w	r3, r3, r6, lsl #2
    ac0a:	f022 0206 	bic.w	r2, r2, #6
    ac0e:	f003 0306 	and.w	r3, r3, #6
    ac12:	4313      	orrs	r3, r2
		node_rx->hdr.rx_ftr.chan = _radio.scanner.chan - 1;
		node_rx->hdr.rx_ftr.ticks_anchor = _radio.ticks_anchor;
	}
#endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */

	ull_rx_put(node_rx->hdr.link, node_rx);
    ac14:	6820      	ldr	r0, [r4, #0]
	node_rx->hdr.rx_ftr.direct = dir_report;
    ac16:	76a3      	strb	r3, [r4, #26]
	ull_rx_put(node_rx->hdr.link, node_rx);
    ac18:	4621      	mov	r1, r4
    ac1a:	f7fb fd79 	bl	6710 <ull_rx_put>
	ull_rx_sched();
    ac1e:	f7fb fd7d 	bl	671c <ull_rx_sched>

	return err;
}
    ac22:	4628      	mov	r0, r5
    ac24:	b002      	add	sp, #8
    ac26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			node_rx->hdr.type = NODE_RX_TYPE_EXT_CODED_REPORT;
    ac2a:	2308      	movs	r3, #8
    ac2c:	e7cf      	b.n	abce <isr_rx_scan_report+0x56>
			if (lll->is_adv_ind) {
    ac2e:	7aaa      	ldrb	r2, [r5, #10]
    ac30:	0711      	lsls	r1, r2, #28
				pdu_adv_rx->type =
    ac32:	bf42      	ittt	mi
    ac34:	2205      	movmi	r2, #5
    ac36:	f362 0303 	bfimi	r3, r2, #0, #4
    ac3a:	7723      	strbmi	r3, [r4, #28]
    ac3c:	e7cf      	b.n	abde <isr_rx_scan_report+0x66>
				ftr->param = lll;
    ac3e:	60a5      	str	r5, [r4, #8]
				ftr->ticks_anchor = radio_tmr_start_get();
    ac40:	f001 fb8e 	bl	c360 <radio_tmr_start_get>
    ac44:	6120      	str	r0, [r4, #16]
					radio_tmr_end_get() -
    ac46:	f001 fbb1 	bl	c3ac <radio_tmr_end_get>
    ac4a:	4682      	mov	sl, r0
					radio_rx_chain_delay_get(lll->phy,
    ac4c:	7aa8      	ldrb	r0, [r5, #10]
    ac4e:	4649      	mov	r1, r9
    ac50:	f000 0007 	and.w	r0, r0, #7
    ac54:	f007 f840 	bl	11cd8 <radio_rx_chain_delay_get>
				ftr->phy_flags = phy_flags_rx;
    ac58:	7ea3      	ldrb	r3, [r4, #26]
					lll_scan_aux_setup(pdu_adv_rx, lll->phy,
    ac5a:	7aa9      	ldrb	r1, [r5, #10]
					radio_tmr_end_get() -
    ac5c:	ebaa 0000 	sub.w	r0, sl, r0
				ftr->phy_flags = phy_flags_rx;
    ac60:	f369 1386 	bfi	r3, r9, #6, #1
				ftr->radio_end_us =
    ac64:	6160      	str	r0, [r4, #20]
				ftr->phy_flags = phy_flags_rx;
    ac66:	76a3      	strb	r3, [r4, #26]
					lll_scan_aux_setup(pdu_adv_rx, lll->phy,
    ac68:	464a      	mov	r2, r9
    ac6a:	4b12      	ldr	r3, [pc, #72]	; (acb4 <isr_rx_scan_report+0x13c>)
    ac6c:	9500      	str	r5, [sp, #0]
    ac6e:	f001 0107 	and.w	r1, r1, #7
    ac72:	f104 001c 	add.w	r0, r4, #28
    ac76:	f000 fd5b 	bl	b730 <lll_scan_aux_setup>
				ftr->aux_lll_sched =
    ac7a:	7ea3      	ldrb	r3, [r4, #26]
    ac7c:	f360 03c3 	bfi	r3, r0, #3, #1
				if (ftr->aux_lll_sched) {
    ac80:	071a      	lsls	r2, r3, #28
				ftr->aux_lll_sched =
    ac82:	76a3      	strb	r3, [r4, #26]
				if (ftr->aux_lll_sched) {
    ac84:	d5ab      	bpl.n	abde <isr_rx_scan_report+0x66>
					lll->is_aux_sched = 1U;
    ac86:	7aab      	ldrb	r3, [r5, #10]
    ac88:	f043 0310 	orr.w	r3, r3, #16
    ac8c:	72ab      	strb	r3, [r5, #10]
					err = -EBUSY;
    ac8e:	f06f 050f 	mvn.w	r5, #15
    ac92:	e7a5      	b.n	abe0 <isr_rx_scan_report+0x68>
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
    ac94:	2205      	movs	r2, #5
    ac96:	7122      	strb	r2, [r4, #4]
	int err = 0;
    ac98:	461d      	mov	r5, r3
    ac9a:	e7a1      	b.n	abe0 <isr_rx_scan_report+0x68>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
    ac9c:	207f      	movs	r0, #127	; 0x7f
    ac9e:	e7a5      	b.n	abec <isr_rx_scan_report+0x74>
		return -ENOBUFS;
    aca0:	f06f 0568 	mvn.w	r5, #104	; 0x68
    aca4:	e7bd      	b.n	ac22 <isr_rx_scan_report+0xaa>
    aca6:	bf00      	nop
    aca8:	00013ebe 	.word	0x00013ebe
    acac:	00014086 	.word	0x00014086
    acb0:	000133b6 	.word	0x000133b6
    acb4:	0000b405 	.word	0x0000b405

0000acb8 <ticker_op_start_cb>:
{
    acb8:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
    acba:	b160      	cbz	r0, acd6 <ticker_op_start_cb+0x1e>
    acbc:	4a06      	ldr	r2, [pc, #24]	; (acd8 <ticker_op_start_cb+0x20>)
    acbe:	4907      	ldr	r1, [pc, #28]	; (acdc <ticker_op_start_cb+0x24>)
    acc0:	4807      	ldr	r0, [pc, #28]	; (ace0 <ticker_op_start_cb+0x28>)
    acc2:	f240 238a 	movw	r3, #650	; 0x28a
    acc6:	f004 fbfe 	bl	f4c6 <printk>
    acca:	4040      	eors	r0, r0
    accc:	f380 8811 	msr	BASEPRI, r0
    acd0:	f04f 0003 	mov.w	r0, #3
    acd4:	df02      	svc	2
}
    acd6:	bd08      	pop	{r3, pc}
    acd8:	00013ebe 	.word	0x00013ebe
    acdc:	00013766 	.word	0x00013766
    ace0:	000133b6 	.word	0x000133b6

0000ace4 <isr_done_cleanup>:
{
    ace4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    ace6:	4604      	mov	r4, r0
	lll_isr_status_reset();
    ace8:	f006 fd8a 	bl	11800 <lll_isr_status_reset>
	if (lll_is_done(param)) {
    acec:	4620      	mov	r0, r4
    acee:	f7fe fd39 	bl	9764 <lll_is_done>
    acf2:	4605      	mov	r5, r0
    acf4:	2800      	cmp	r0, #0
    acf6:	d151      	bne.n	ad9c <isr_done_cleanup+0xb8>
	radio_filter_disable();
    acf8:	f001 fa5c 	bl	c1b4 <radio_filter_disable>
	if (++lll->chan == ADV_CHAN_MAX) {
    acfc:	7923      	ldrb	r3, [r4, #4]
    acfe:	f3c3 0241 	ubfx	r2, r3, #1, #2
    ad02:	3201      	adds	r2, #1
    ad04:	f002 0203 	and.w	r2, r2, #3
    ad08:	2a03      	cmp	r2, #3
    ad0a:	bf14      	ite	ne
    ad0c:	f362 0342 	bfine	r3, r2, #1, #2
		lll->chan = 0U;
    ad10:	f365 0342 	bfieq	r3, r5, #1, #2
    ad14:	7123      	strb	r3, [r4, #4]
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
    ad16:	2300      	movs	r3, #0
    ad18:	9300      	str	r3, [sp, #0]
    ad1a:	4619      	mov	r1, r3
    ad1c:	4618      	mov	r0, r3
    ad1e:	2204      	movs	r2, #4
    ad20:	f7f9 ff42 	bl	4ba8 <ticker_stop>
	if (lll->is_aux_sched) {
    ad24:	7aa3      	ldrb	r3, [r4, #10]
    ad26:	06db      	lsls	r3, r3, #27
    ad28:	d519      	bpl.n	ad5e <isr_done_cleanup+0x7a>
		node_rx = ull_pdu_rx_alloc();
    ad2a:	f7fb fcdb 	bl	66e4 <ull_pdu_rx_alloc>
		LL_ASSERT(node_rx);
    ad2e:	4605      	mov	r5, r0
    ad30:	b960      	cbnz	r0, ad4c <isr_done_cleanup+0x68>
    ad32:	4a1b      	ldr	r2, [pc, #108]	; (ada0 <isr_done_cleanup+0xbc>)
    ad34:	491b      	ldr	r1, [pc, #108]	; (ada4 <isr_done_cleanup+0xc0>)
    ad36:	481c      	ldr	r0, [pc, #112]	; (ada8 <isr_done_cleanup+0xc4>)
    ad38:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
    ad3c:	f004 fbc3 	bl	f4c6 <printk>
    ad40:	4040      	eors	r0, r0
    ad42:	f380 8811 	msr	BASEPRI, r0
    ad46:	f04f 0003 	mov.w	r0, #3
    ad4a:	df02      	svc	2
		node_rx->hdr.type = NODE_RX_TYPE_EXT_AUX_RELEASE;
    ad4c:	230a      	movs	r3, #10
		ull_rx_put(node_rx->hdr.link, node_rx);
    ad4e:	6828      	ldr	r0, [r5, #0]
		node_rx->hdr.type = NODE_RX_TYPE_EXT_AUX_RELEASE;
    ad50:	712b      	strb	r3, [r5, #4]
		ull_rx_put(node_rx->hdr.link, node_rx);
    ad52:	4629      	mov	r1, r5
		node_rx->hdr.rx_ftr.param = lll;
    ad54:	60ac      	str	r4, [r5, #8]
		ull_rx_put(node_rx->hdr.link, node_rx);
    ad56:	f7fb fcdb 	bl	6710 <ull_rx_put>
		ull_rx_sched();
    ad5a:	f7fb fcdf 	bl	671c <ull_rx_sched>
	extra = ull_done_extra_type_set(EVENT_DONE_EXTRA_TYPE_SCAN);
    ad5e:	2003      	movs	r0, #3
    ad60:	f006 f92f 	bl	10fc2 <ull_done_extra_type_set>
	LL_ASSERT(extra);
    ad64:	b960      	cbnz	r0, ad80 <isr_done_cleanup+0x9c>
    ad66:	4a0e      	ldr	r2, [pc, #56]	; (ada0 <isr_done_cleanup+0xbc>)
    ad68:	4910      	ldr	r1, [pc, #64]	; (adac <isr_done_cleanup+0xc8>)
    ad6a:	480f      	ldr	r0, [pc, #60]	; (ada8 <isr_done_cleanup+0xc4>)
    ad6c:	f240 4306 	movw	r3, #1030	; 0x406
    ad70:	f004 fba9 	bl	f4c6 <printk>
    ad74:	4040      	eors	r0, r0
    ad76:	f380 8811 	msr	BASEPRI, r0
    ad7a:	f04f 0003 	mov.w	r0, #3
    ad7e:	df02      	svc	2
	if (unlikely(lll->duration_reload && !lll->duration_expire)) {
    ad80:	88e3      	ldrh	r3, [r4, #6]
    ad82:	b12b      	cbz	r3, ad90 <isr_done_cleanup+0xac>
    ad84:	8923      	ldrh	r3, [r4, #8]
    ad86:	b91b      	cbnz	r3, ad90 <isr_done_cleanup+0xac>
		lll->is_stop = 1U;
    ad88:	7923      	ldrb	r3, [r4, #4]
    ad8a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    ad8e:	7123      	strb	r3, [r4, #4]
	lll_isr_cleanup(param);
    ad90:	4620      	mov	r0, r4
}
    ad92:	b003      	add	sp, #12
    ad94:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	lll_isr_cleanup(param);
    ad98:	f7fe bd46 	b.w	9828 <lll_isr_cleanup>
}
    ad9c:	b003      	add	sp, #12
    ad9e:	bd30      	pop	{r4, r5, pc}
    ada0:	00013ebe 	.word	0x00013ebe
    ada4:	00013ddd 	.word	0x00013ddd
    ada8:	000133b6 	.word	0x000133b6
    adac:	00013e07 	.word	0x00013e07

0000adb0 <abort_cb>:
{
    adb0:	b510      	push	{r4, lr}
    adb2:	460c      	mov	r4, r1
	if (!prepare_param) {
    adb4:	b930      	cbnz	r0, adc4 <abort_cb+0x14>
			radio_isr_set(isr_cleanup, param);
    adb6:	480e      	ldr	r0, [pc, #56]	; (adf0 <abort_cb+0x40>)
    adb8:	f001 f800 	bl	bdbc <radio_isr_set>
}
    adbc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			radio_disable();
    adc0:	f001 b8c4 	b.w	bf4c <radio_disable>
	err = lll_hfclock_off();
    adc4:	f7fe fe4c 	bl	9a60 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
    adc8:	2800      	cmp	r0, #0
    adca:	da0c      	bge.n	ade6 <abort_cb+0x36>
    adcc:	4a09      	ldr	r2, [pc, #36]	; (adf4 <abort_cb+0x44>)
    adce:	490a      	ldr	r1, [pc, #40]	; (adf8 <abort_cb+0x48>)
    add0:	480a      	ldr	r0, [pc, #40]	; (adfc <abort_cb+0x4c>)
    add2:	f240 237a 	movw	r3, #634	; 0x27a
    add6:	f004 fb76 	bl	f4c6 <printk>
    adda:	4040      	eors	r0, r0
    addc:	f380 8811 	msr	BASEPRI, r0
    ade0:	f04f 0003 	mov.w	r0, #3
    ade4:	df02      	svc	2
	lll_done(param);
    ade6:	4620      	mov	r0, r4
}
    ade8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
    adec:	f7fe bc6c 	b.w	96c8 <lll_done>
    adf0:	000119e9 	.word	0x000119e9
    adf4:	00013ebe 	.word	0x00013ebe
    adf8:	00013d61 	.word	0x00013d61
    adfc:	000133b6 	.word	0x000133b6

0000ae00 <lll_scan_prepare>:
{
    ae00:	b513      	push	{r0, r1, r4, lr}
    ae02:	4604      	mov	r4, r0
	err = lll_hfclock_on();
    ae04:	f7fe fe16 	bl	9a34 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
    ae08:	2800      	cmp	r0, #0
    ae0a:	da0b      	bge.n	ae24 <lll_scan_prepare+0x24>
    ae0c:	4a11      	ldr	r2, [pc, #68]	; (ae54 <lll_scan_prepare+0x54>)
    ae0e:	4912      	ldr	r1, [pc, #72]	; (ae58 <lll_scan_prepare+0x58>)
    ae10:	4812      	ldr	r0, [pc, #72]	; (ae5c <lll_scan_prepare+0x5c>)
    ae12:	2388      	movs	r3, #136	; 0x88
    ae14:	f004 fb57 	bl	f4c6 <printk>
    ae18:	4040      	eors	r0, r0
    ae1a:	f380 8811 	msr	BASEPRI, r0
    ae1e:	f04f 0003 	mov.w	r0, #3
    ae22:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, param);
    ae24:	4a0e      	ldr	r2, [pc, #56]	; (ae60 <lll_scan_prepare+0x60>)
    ae26:	490f      	ldr	r1, [pc, #60]	; (ae64 <lll_scan_prepare+0x64>)
    ae28:	480f      	ldr	r0, [pc, #60]	; (ae68 <lll_scan_prepare+0x68>)
    ae2a:	9400      	str	r4, [sp, #0]
    ae2c:	2300      	movs	r3, #0
    ae2e:	f006 f91d 	bl	1106c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
    ae32:	b168      	cbz	r0, ae50 <lll_scan_prepare+0x50>
    ae34:	3077      	adds	r0, #119	; 0x77
    ae36:	d00b      	beq.n	ae50 <lll_scan_prepare+0x50>
    ae38:	4a06      	ldr	r2, [pc, #24]	; (ae54 <lll_scan_prepare+0x54>)
    ae3a:	490c      	ldr	r1, [pc, #48]	; (ae6c <lll_scan_prepare+0x6c>)
    ae3c:	4807      	ldr	r0, [pc, #28]	; (ae5c <lll_scan_prepare+0x5c>)
    ae3e:	238b      	movs	r3, #139	; 0x8b
    ae40:	f004 fb41 	bl	f4c6 <printk>
    ae44:	4040      	eors	r0, r0
    ae46:	f380 8811 	msr	BASEPRI, r0
    ae4a:	f04f 0003 	mov.w	r0, #3
    ae4e:	df02      	svc	2
}
    ae50:	b002      	add	sp, #8
    ae52:	bd10      	pop	{r4, pc}
    ae54:	00013ebe 	.word	0x00013ebe
    ae58:	00013d61 	.word	0x00013d61
    ae5c:	000133b6 	.word	0x000133b6
    ae60:	0001196b 	.word	0x0001196b
    ae64:	0000adb1 	.word	0x0000adb1
    ae68:	0000a9f9 	.word	0x0000a9f9
    ae6c:	00013e0d 	.word	0x00013e0d

0000ae70 <lll_scan_isr_resume>:
{
    ae70:	b510      	push	{r4, lr}
    ae72:	4604      	mov	r4, r0
	lll_isr_status_reset();
    ae74:	f006 fcc4 	bl	11800 <lll_isr_status_reset>
	p.param = param;
    ae78:	4802      	ldr	r0, [pc, #8]	; (ae84 <lll_scan_isr_resume+0x14>)
    ae7a:	60c4      	str	r4, [r0, #12]
}
    ae7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	resume_prepare_cb(&p);
    ae80:	f006 bd9d 	b.w	119be <resume_prepare_cb>
    ae84:	200023b4 	.word	0x200023b4

0000ae88 <isr_rx>:
{
    ae88:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    ae8c:	4604      	mov	r4, r0
	trx_done = radio_is_done();
    ae8e:	f001 f885 	bl	bf9c <radio_is_done>
	if (trx_done) {
    ae92:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
    ae96:	f000 80d1 	beq.w	b03c <isr_rx+0x1b4>
		crc_ok = radio_crc_is_valid();
    ae9a:	f001 f89f 	bl	bfdc <radio_crc_is_valid>
    ae9e:	b2c6      	uxtb	r6, r0
		devmatch_ok = radio_filter_has_match();
    aea0:	f001 f99a 	bl	c1d8 <radio_filter_has_match>
    aea4:	f88d 000b 	strb.w	r0, [sp, #11]
		devmatch_id = radio_filter_match_get();
    aea8:	f001 f9a0 	bl	c1ec <radio_filter_match_get>
    aeac:	f88d 000c 	strb.w	r0, [sp, #12]
		irkmatch_ok = radio_ar_has_match();
    aeb0:	f001 fada 	bl	c468 <radio_ar_has_match>
    aeb4:	f88d 000d 	strb.w	r0, [sp, #13]
		irkmatch_id = radio_ar_match_get();
    aeb8:	f001 fabe 	bl	c438 <radio_ar_match_get>
    aebc:	f88d 000e 	strb.w	r0, [sp, #14]
		rssi_ready = radio_rssi_is_ready();
    aec0:	f001 f952 	bl	c168 <radio_rssi_is_ready>
    aec4:	fa5f f880 	uxtb.w	r8, r0
		phy_flags_rx = radio_phy_flags_rx_get();
    aec8:	f006 ff0b 	bl	11ce2 <radio_phy_flags_rx_get>
    aecc:	4607      	mov	r7, r0
	lll_isr_status_reset();
    aece:	f006 fc97 	bl	11800 <lll_isr_status_reset>
	if (!trx_done || !crc_ok) {
    aed2:	2d00      	cmp	r5, #0
    aed4:	f000 80d7 	beq.w	b086 <isr_rx+0x1fe>
    aed8:	2e00      	cmp	r6, #0
    aeda:	f000 80d4 	beq.w	b086 <isr_rx+0x1fe>
	node_rx = ull_pdu_rx_alloc_peek(1);
    aede:	2001      	movs	r0, #1
    aee0:	f7fb fbe8 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    aee4:	4605      	mov	r5, r0
    aee6:	b960      	cbnz	r0, af02 <isr_rx+0x7a>
    aee8:	4aa0      	ldr	r2, [pc, #640]	; (b16c <isr_rx+0x2e4>)
    aeea:	49a1      	ldr	r1, [pc, #644]	; (b170 <isr_rx+0x2e8>)
    aeec:	48a1      	ldr	r0, [pc, #644]	; (b174 <isr_rx+0x2ec>)
    aeee:	f240 23bd 	movw	r3, #701	; 0x2bd
    aef2:	f004 fae8 	bl	f4c6 <printk>
    aef6:	4040      	eors	r0, r0
    aef8:	f380 8811 	msr	BASEPRI, r0
    aefc:	f04f 0003 	mov.w	r0, #3
    af00:	df02      	svc	2
	} else if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
    af02:	7f2b      	ldrb	r3, [r5, #28]
    af04:	f003 030f 	and.w	r3, r3, #15
    af08:	2b07      	cmp	r3, #7
	pdu = (void *)node_rx->pdu;
    af0a:	f105 0a1c 	add.w	sl, r5, #28
	} else if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
    af0e:	f040 80a2 	bne.w	b056 <isr_rx+0x1ce>
		has_adva = lll_scan_aux_addr_match_get(lll, pdu,
    af12:	f10d 030e 	add.w	r3, sp, #14
    af16:	9301      	str	r3, [sp, #4]
    af18:	f10d 030d 	add.w	r3, sp, #13
    af1c:	9300      	str	r3, [sp, #0]
    af1e:	f10d 020b 	add.w	r2, sp, #11
    af22:	ab03      	add	r3, sp, #12
    af24:	4651      	mov	r1, sl
    af26:	4620      	mov	r0, r4
    af28:	f006 fe2e 	bl	11b88 <lll_scan_aux_addr_match_get>
    af2c:	4681      	mov	r9, r0
	rl_idx = devmatch_ok ?
    af2e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    af32:	2b00      	cmp	r3, #0
    af34:	f000 8092 	beq.w	b05c <isr_rx+0x1d4>
		 ull_filter_lll_rl_idx(((lll->filter_policy &
    af38:	7920      	ldrb	r0, [r4, #4]
    af3a:	f89d 100c 	ldrb.w	r1, [sp, #12]
    af3e:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    af42:	f7fd ffdf 	bl	8f04 <ull_filter_lll_rl_idx>
		 irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    af46:	4606      	mov	r6, r0
	if (has_adva &&
    af48:	f1b9 0f00 	cmp.w	r9, #0
    af4c:	f040 8090 	bne.w	b070 <isr_rx+0x1e8>
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    af50:	7f2a      	ldrb	r2, [r5, #28]
	err = isr_rx_pdu(lll, pdu, devmatch_ok, devmatch_id, irkmatch_ok,
    af52:	f89d 900d 	ldrb.w	r9, [sp, #13]
	bool dir_report = false;
    af56:	2300      	movs	r3, #0
    af58:	f88d 300f 	strb.w	r3, [sp, #15]
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    af5c:	f012 030f 	ands.w	r3, r2, #15
    af60:	d002      	beq.n	af68 <isr_rx+0xe0>
    af62:	2b06      	cmp	r3, #6
    af64:	f040 80ff 	bne.w	b166 <isr_rx+0x2de>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
    af68:	7f69      	ldrb	r1, [r5, #29]
    af6a:	2925      	cmp	r1, #37	; 0x25
    af6c:	f200 809c 	bhi.w	b0a8 <isr_rx+0x220>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind)) &&
    af70:	7921      	ldrb	r1, [r4, #4]
		   lll->type &&
    af72:	0688      	lsls	r0, r1, #26
    af74:	f140 8098 	bpl.w	b0a8 <isr_rx+0x220>
		radio_tmr_tifs_set(EVENT_IFS_US);
    af78:	2096      	movs	r0, #150	; 0x96
    af7a:	f001 f959 	bl	c230 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
    af7e:	2000      	movs	r0, #0
    af80:	f001 f8a8 	bl	c0d4 <radio_switch_complete_and_rx>
		err = isr_rx_scan_report(lll, rssi_ready, phy_flags_rx,
    af84:	2300      	movs	r3, #0
    af86:	e9cd 6300 	strd	r6, r3, [sp]
    af8a:	463a      	mov	r2, r7
    af8c:	464b      	mov	r3, r9
    af8e:	4641      	mov	r1, r8
    af90:	4620      	mov	r0, r4
    af92:	f7ff fdf1 	bl	ab78 <isr_rx_scan_report>
		if (err) {
    af96:	2800      	cmp	r0, #0
    af98:	d175      	bne.n	b086 <isr_rx+0x1fe>
		pdu_tx = (void *)radio_pkt_scratch_get();
    af9a:	f001 f829 	bl	bff0 <radio_pkt_scratch_get>
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
    af9e:	7f2b      	ldrb	r3, [r5, #28]
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
    afa0:	7802      	ldrb	r2, [r0, #0]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
    afa2:	f3c3 1380 	ubfx	r3, r3, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
    afa6:	01db      	lsls	r3, r3, #7
    afa8:	f002 0270 	and.w	r2, r2, #112	; 0x70
    afac:	f043 0303 	orr.w	r3, r3, #3
    afb0:	4313      	orrs	r3, r2
    afb2:	7003      	strb	r3, [r0, #0]
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
    afb4:	230c      	movs	r3, #12
    afb6:	7043      	strb	r3, [r0, #1]
		pdu_tx = (void *)radio_pkt_scratch_get();
    afb8:	4607      	mov	r7, r0
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
    afba:	4630      	mov	r0, r6
    afbc:	f7fd ff82 	bl	8ec4 <ull_filter_lll_lrpa_get>
		if (lll->rpa_gen && lrpa) {
    afc0:	7c23      	ldrb	r3, [r4, #16]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
    afc2:	4601      	mov	r1, r0
		if (lll->rpa_gen && lrpa) {
    afc4:	4638      	mov	r0, r7
    afc6:	f013 0f01 	tst.w	r3, #1
    afca:	f810 3b02 	ldrb.w	r3, [r0], #2
    afce:	d061      	beq.n	b094 <isr_rx+0x20c>
    afd0:	2900      	cmp	r1, #0
    afd2:	d05f      	beq.n	b094 <isr_rx+0x20c>
			pdu_tx->tx_addr = 1;
    afd4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    afd8:	703b      	strb	r3, [r7, #0]
			memcpy(&pdu_tx->scan_req.scan_addr[0], lrpa->val,
    afda:	2206      	movs	r2, #6
			memcpy(&pdu_tx->scan_req.scan_addr[0],
    afdc:	f004 fde3 	bl	fba6 <memcpy>
		memcpy(&pdu_tx->scan_req.adv_addr[0],
    afe0:	2206      	movs	r2, #6
    afe2:	f105 011e 	add.w	r1, r5, #30
    afe6:	f107 0008 	add.w	r0, r7, #8
    afea:	f004 fddc 	bl	fba6 <memcpy>
		radio_pkt_tx_set(pdu_tx);
    afee:	4638      	mov	r0, r7
    aff0:	f000 ffa0 	bl	bf34 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
    aff4:	f000 ffc8 	bl	bf88 <radio_is_ready>
    aff8:	b160      	cbz	r0, b014 <isr_rx+0x18c>
    affa:	4a5c      	ldr	r2, [pc, #368]	; (b16c <isr_rx+0x2e4>)
    affc:	495e      	ldr	r1, [pc, #376]	; (b178 <isr_rx+0x2f0>)
    affe:	485d      	ldr	r0, [pc, #372]	; (b174 <isr_rx+0x2ec>)
    b000:	f240 5324 	movw	r3, #1316	; 0x524
    b004:	f004 fa5f 	bl	f4c6 <printk>
    b008:	4040      	eors	r0, r0
    b00a:	f380 8811 	msr	BASEPRI, r0
    b00e:	f04f 0003 	mov.w	r0, #3
    b012:	df02      	svc	2
		radio_tmr_end_capture();
    b014:	f001 f9c2 	bl	c39c <radio_tmr_end_capture>
		lll->state = 1U;
    b018:	7923      	ldrb	r3, [r4, #4]
		radio_isr_set(isr_tx, lll);
    b01a:	4858      	ldr	r0, [pc, #352]	; (b17c <isr_rx+0x2f4>)
		lll->state = 1U;
    b01c:	f043 0301 	orr.w	r3, r3, #1
    b020:	7123      	strb	r3, [r4, #4]
		if (pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) {
    b022:	7f2b      	ldrb	r3, [r5, #28]
    b024:	0719      	lsls	r1, r3, #28
			lll->is_adv_ind = 1U;
    b026:	bf02      	ittt	eq
    b028:	7aa3      	ldrbeq	r3, [r4, #10]
    b02a:	f043 0308 	orreq.w	r3, r3, #8
    b02e:	72a3      	strbeq	r3, [r4, #10]
		radio_isr_set(isr_tx, lll);
    b030:	4621      	mov	r1, r4
    b032:	f000 fec3 	bl	bdbc <radio_isr_set>
}
    b036:	b004      	add	sp, #16
    b038:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		devmatch_id = irkmatch_id = 0xFF;
    b03c:	23ff      	movs	r3, #255	; 0xff
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready =
    b03e:	f88d 500d 	strb.w	r5, [sp, #13]
    b042:	f88d 500b 	strb.w	r5, [sp, #11]
		devmatch_id = irkmatch_id = 0xFF;
    b046:	f88d 300e 	strb.w	r3, [sp, #14]
    b04a:	f88d 300c 	strb.w	r3, [sp, #12]
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready =
    b04e:	462e      	mov	r6, r5
    b050:	46a8      	mov	r8, r5
			phy_flags_rx = 0U;
    b052:	462f      	mov	r7, r5
    b054:	e73b      	b.n	aece <isr_rx+0x46>
		has_adva = true;
    b056:	f04f 0901 	mov.w	r9, #1
    b05a:	e768      	b.n	af2e <isr_rx+0xa6>
	rl_idx = devmatch_ok ?
    b05c:	f89d 300d 	ldrb.w	r3, [sp, #13]
    b060:	b123      	cbz	r3, b06c <isr_rx+0x1e4>
		 irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    b062:	f89d 000e 	ldrb.w	r0, [sp, #14]
    b066:	f7fd ffa9 	bl	8fbc <ull_filter_lll_rl_irk_idx>
    b06a:	e76c      	b.n	af46 <isr_rx+0xbe>
	rl_idx = devmatch_ok ?
    b06c:	26ff      	movs	r6, #255	; 0xff
    b06e:	e76b      	b.n	af48 <isr_rx+0xc0>
	    !lll_scan_isr_rx_check(lll, irkmatch_ok, devmatch_ok, rl_idx)) {
    b070:	f89d 200b 	ldrb.w	r2, [sp, #11]
    b074:	f89d 100d 	ldrb.w	r1, [sp, #13]
    b078:	4633      	mov	r3, r6
    b07a:	4620      	mov	r0, r4
    b07c:	f006 fd18 	bl	11ab0 <lll_scan_isr_rx_check>
	if (has_adva &&
    b080:	2800      	cmp	r0, #0
    b082:	f47f af65 	bne.w	af50 <isr_rx+0xc8>
	radio_isr_set(isr_done, lll);
    b086:	483e      	ldr	r0, [pc, #248]	; (b180 <isr_rx+0x2f8>)
    b088:	4621      	mov	r1, r4
    b08a:	f000 fe97 	bl	bdbc <radio_isr_set>
	radio_disable();
    b08e:	f000 ff5d 	bl	bf4c <radio_disable>
    b092:	e7d0      	b.n	b036 <isr_rx+0x1ae>
			pdu_tx->tx_addr = lll->init_addr_type;
    b094:	7922      	ldrb	r2, [r4, #4]
    b096:	f3c2 1280 	ubfx	r2, r2, #6, #1
    b09a:	f362 1386 	bfi	r3, r2, #6, #1
    b09e:	703b      	strb	r3, [r7, #0]
			memcpy(&pdu_tx->scan_req.scan_addr[0],
    b0a0:	2206      	movs	r2, #6
    b0a2:	f104 0112 	add.w	r1, r4, #18
    b0a6:	e799      	b.n	afdc <isr_rx+0x154>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    b0a8:	f012 0f0d 	tst.w	r2, #13
    b0ac:	d001      	beq.n	b0b2 <isr_rx+0x22a>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_NONCONN_IND) ||
    b0ae:	2b06      	cmp	r3, #6
    b0b0:	d102      	bne.n	b0b8 <isr_rx+0x230>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
    b0b2:	7f69      	ldrb	r1, [r5, #29]
    b0b4:	2925      	cmp	r1, #37	; 0x25
    b0b6:	d940      	bls.n	b13a <isr_rx+0x2b2>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
    b0b8:	2b01      	cmp	r3, #1
    b0ba:	d02e      	beq.n	b11a <isr_rx+0x292>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_EXT_IND) &&
    b0bc:	7f2b      	ldrb	r3, [r5, #28]
					rl_idx, &dir_report))) ||
    b0be:	f003 030f 	and.w	r3, r3, #15
    b0c2:	2b07      	cmp	r3, #7
    b0c4:	d10d      	bne.n	b0e2 <isr_rx+0x25a>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_EXT_IND) &&
    b0c6:	7aa3      	ldrb	r3, [r4, #10]
    b0c8:	075a      	lsls	r2, r3, #29
    b0ca:	d0dc      	beq.n	b086 <isr_rx+0x1fe>
		   lll->phy && lll_scan_ext_tgta_check(lll, true, false,
    b0cc:	f10d 030f 	add.w	r3, sp, #15
    b0d0:	e9cd 6300 	strd	r6, r3, [sp]
    b0d4:	2200      	movs	r2, #0
    b0d6:	4653      	mov	r3, sl
    b0d8:	2101      	movs	r1, #1
    b0da:	4620      	mov	r0, r4
    b0dc:	f006 fd17 	bl	11b0e <lll_scan_ext_tgta_check>
    b0e0:	bb58      	cbnz	r0, b13a <isr_rx+0x2b2>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
    b0e2:	7f2b      	ldrb	r3, [r5, #28]
						       &dir_report)) ||
    b0e4:	f003 030f 	and.w	r3, r3, #15
    b0e8:	2b04      	cmp	r3, #4
    b0ea:	d1cc      	bne.n	b086 <isr_rx+0x1fe>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
    b0ec:	7f6b      	ldrb	r3, [r5, #29]
    b0ee:	2b25      	cmp	r3, #37	; 0x25
    b0f0:	d8c9      	bhi.n	b086 <isr_rx+0x1fe>
		   (lll->state != 0U) &&
    b0f2:	7923      	ldrb	r3, [r4, #4]
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
    b0f4:	07db      	lsls	r3, r3, #31
    b0f6:	d5c6      	bpl.n	b086 <isr_rx+0x1fe>
	struct pdu_adv *sreq = (void *)radio_pkt_scratch_get();
    b0f8:	f000 ff7a 	bl	bff0 <radio_pkt_scratch_get>
	return ((sreq->rx_addr == srsp->tx_addr) &&
    b0fc:	7f2b      	ldrb	r3, [r5, #28]
    b0fe:	7802      	ldrb	r2, [r0, #0]
    b100:	f3c3 1380 	ubfx	r3, r3, #6, #1
    b104:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
    b108:	d1bd      	bne.n	b086 <isr_rx+0x1fe>
		(memcmp(&sreq->scan_req.adv_addr[0],
    b10a:	2206      	movs	r2, #6
    b10c:	f105 011e 	add.w	r1, r5, #30
    b110:	3008      	adds	r0, #8
    b112:	f004 fd1f 	bl	fb54 <memcmp>
		   (lll->state != 0U) &&
    b116:	b180      	cbz	r0, b13a <isr_rx+0x2b2>
    b118:	e7b5      	b.n	b086 <isr_rx+0x1fe>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_DIRECT_IND) &&
    b11a:	7f6b      	ldrb	r3, [r5, #29]
    b11c:	2b0c      	cmp	r3, #12
    b11e:	d1b2      	bne.n	b086 <isr_rx+0x1fe>
		    isr_scan_tgta_check(lll, false, pdu_adv_rx->rx_addr,
    b120:	f10d 030f 	add.w	r3, sp, #15
    b124:	e9cd 6300 	strd	r6, r3, [sp]
    b128:	09d2      	lsrs	r2, r2, #7
    b12a:	f105 0324 	add.w	r3, r5, #36	; 0x24
    b12e:	2100      	movs	r1, #0
    b130:	4620      	mov	r0, r4
    b132:	f006 fc77 	bl	11a24 <isr_scan_tgta_check>
		   (pdu_adv_rx->len == sizeof(struct pdu_adv_direct_ind)) &&
    b136:	2800      	cmp	r0, #0
    b138:	d0c0      	beq.n	b0bc <isr_rx+0x234>
		   isr_scan_rsp_adva_matches(pdu_adv_rx))) &&
    b13a:	7f6b      	ldrb	r3, [r5, #29]
    b13c:	2b00      	cmp	r3, #0
    b13e:	d0a2      	beq.n	b086 <isr_rx+0x1fe>
		err = isr_rx_scan_report(lll, rssi_ready, phy_flags_rx,
    b140:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b144:	463a      	mov	r2, r7
    b146:	e9cd 6300 	strd	r6, r3, [sp]
    b14a:	4641      	mov	r1, r8
    b14c:	464b      	mov	r3, r9
    b14e:	4620      	mov	r0, r4
    b150:	f7ff fd12 	bl	ab78 <isr_rx_scan_report>
		if (err) {
    b154:	2800      	cmp	r0, #0
    b156:	d096      	beq.n	b086 <isr_rx+0x1fe>
			if (IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) &&
    b158:	f110 0f10 	cmn.w	r0, #16
    b15c:	f43f af6b 	beq.w	b036 <isr_rx+0x1ae>
	if (!err) {
    b160:	2800      	cmp	r0, #0
    b162:	d190      	bne.n	b086 <isr_rx+0x1fe>
    b164:	e767      	b.n	b036 <isr_rx+0x1ae>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    b166:	2b02      	cmp	r3, #2
    b168:	e7a2      	b.n	b0b0 <isr_rx+0x228>
    b16a:	bf00      	nop
    b16c:	00013ebe 	.word	0x00013ebe
    b170:	00013ddd 	.word	0x00013ddd
    b174:	000133b6 	.word	0x000133b6
    b178:	00013de5 	.word	0x00013de5
    b17c:	0000aab9 	.word	0x0000aab9
    b180:	00011971 	.word	0x00011971

0000b184 <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *p)
{
    b184:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	uint32_t hcto;
	uint32_t aa;

	DEBUG_RADIO_START_O(1);

	lll_aux = p->param;
    b188:	68c4      	ldr	r4, [r0, #12]
	lll = ull_scan_aux_lll_parent_get(lll_aux, &is_lll_scan);
    b18a:	f10d 0102 	add.w	r1, sp, #2
{
    b18e:	4605      	mov	r5, r0
	lll = ull_scan_aux_lll_parent_get(lll_aux, &is_lll_scan);
    b190:	4620      	mov	r0, r4
    b192:	f006 fa81 	bl	11698 <ull_scan_aux_lll_parent_get>

	/* Initialize scanning state */
	lll_aux->state = 0U;
    b196:	7923      	ldrb	r3, [r4, #4]
    b198:	f36f 1386 	bfc	r3, #6, #1
    b19c:	7123      	strb	r3, [r4, #4]

	/* Reset Tx/rx count */
	trx_cnt = 0U;
    b19e:	4b69      	ldr	r3, [pc, #420]	; (b344 <prepare_cb+0x1c0>)
    b1a0:	2700      	movs	r7, #0
    b1a2:	801f      	strh	r7, [r3, #0]
		return 0;
	}
#endif /* CONFIG_BT_CENTRAL */

	/* Initialize scanning state */
	lll->state = 0U;
    b1a4:	7903      	ldrb	r3, [r0, #4]
    b1a6:	f367 0300 	bfi	r3, r7, #0, #1
    b1aa:	7103      	strb	r3, [r0, #4]
	lll = ull_scan_aux_lll_parent_get(lll_aux, &is_lll_scan);
    b1ac:	4606      	mov	r6, r0

	/* Reset Tx/rx count */
	trx_cnt = 0U;

	/* Start setting up Radio h/w */
	radio_reset();
    b1ae:	f000 fe25 	bl	bdfc <radio_reset>

#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll_aux->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
    b1b2:	4638      	mov	r0, r7
    b1b4:	f000 fe56 	bl	be64 <radio_tx_power_set>
#endif

	radio_phy_set(lll_aux->phy, PHY_FLAGS_S8);
    b1b8:	7960      	ldrb	r0, [r4, #5]
    b1ba:	2101      	movs	r1, #1
    b1bc:	f000 0007 	and.w	r0, r0, #7
    b1c0:	f000 fe40 	bl	be44 <radio_phy_set>
	radio_pkt_configure(8, LL_EXT_OCTETS_RX_MAX, (lll_aux->phy << 1));
    b1c4:	7962      	ldrb	r2, [r4, #5]
    b1c6:	0052      	lsls	r2, r2, #1
    b1c8:	f002 020e 	and.w	r2, r2, #14
    b1cc:	21ff      	movs	r1, #255	; 0xff
    b1ce:	2008      	movs	r0, #8
    b1d0:	f000 fe7e 	bl	bed0 <radio_pkt_configure>

	node_rx = ull_pdu_rx_alloc_peek(1);
    b1d4:	2001      	movs	r0, #1
    b1d6:	f7fb fa6d 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    b1da:	4607      	mov	r7, r0
    b1dc:	b960      	cbnz	r0, b1f8 <prepare_cb+0x74>
    b1de:	4a5a      	ldr	r2, [pc, #360]	; (b348 <prepare_cb+0x1c4>)
    b1e0:	495a      	ldr	r1, [pc, #360]	; (b34c <prepare_cb+0x1c8>)
    b1e2:	485b      	ldr	r0, [pc, #364]	; (b350 <prepare_cb+0x1cc>)
    b1e4:	f44f 73ee 	mov.w	r3, #476	; 0x1dc
    b1e8:	f004 f96d 	bl	f4c6 <printk>
    b1ec:	4040      	eors	r0, r0
    b1ee:	f380 8811 	msr	BASEPRI, r0
    b1f2:	f04f 0003 	mov.w	r0, #3
    b1f6:	df02      	svc	2

	radio_pkt_rx_set(node_rx->pdu);
    b1f8:	f107 001c 	add.w	r0, r7, #28
    b1fc:	f000 fe94 	bl	bf28 <radio_pkt_rx_set>

	aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
    b200:	4b54      	ldr	r3, [pc, #336]	; (b354 <prepare_cb+0x1d0>)
    b202:	9301      	str	r3, [sp, #4]
	radio_aa_set((uint8_t *)&aa);
    b204:	a801      	add	r0, sp, #4
    b206:	f000 fe4b 	bl	bea0 <radio_aa_set>
	radio_crc_configure(PDU_CRC_POLYNOMIAL,
    b20a:	4953      	ldr	r1, [pc, #332]	; (b358 <prepare_cb+0x1d4>)
    b20c:	f240 605b 	movw	r0, #1627	; 0x65b
    b210:	f000 fed8 	bl	bfc4 <radio_crc_configure>
				PDU_AC_CRC_IV);

	lll_chan_set(lll_aux->chan);
    b214:	7920      	ldrb	r0, [r4, #4]
    b216:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    b21a:	f7fe fad3 	bl	97c4 <lll_chan_set>

	radio_isr_set(isr_rx_ull_schedule, lll_aux);
    b21e:	4621      	mov	r1, r4
    b220:	484e      	ldr	r0, [pc, #312]	; (b35c <prepare_cb+0x1d8>)
    b222:	f000 fdcb 	bl	bdbc <radio_isr_set>

	/* setup tIFS switching */
	radio_tmr_tifs_set(EVENT_IFS_US);
    b226:	2096      	movs	r0, #150	; 0x96
    b228:	f001 f802 	bl	c230 <radio_tmr_tifs_set>
	/* TODO: for passive scanning use complete_and_disable */
	radio_switch_complete_and_tx(lll_aux->phy, 0, lll_aux->phy, 1);
    b22c:	7962      	ldrb	r2, [r4, #5]
    b22e:	f002 0207 	and.w	r2, r2, #7
    b232:	2301      	movs	r3, #1
    b234:	2100      	movs	r1, #0
    b236:	4610      	mov	r0, r2
    b238:	f000 ff5e 	bl	c0f8 <radio_switch_complete_and_tx>

	/* TODO: skip filtering if AdvA was already found in previous PDU */

	if (0) {
#if defined(CONFIG_BT_CTLR_PRIVACY)
	} else if (ull_filter_lll_rl_enabled()) {
    b23c:	f7fd ffb6 	bl	91ac <ull_filter_lll_rl_enabled>
    b240:	7933      	ldrb	r3, [r6, #4]
    b242:	2800      	cmp	r0, #0
    b244:	d05c      	beq.n	b300 <prepare_cb+0x17c>
		struct lll_filter *filter =
			ull_filter_lll_get((lll->filter_policy &
    b246:	f3c3 00c0 	ubfx	r0, r3, #3, #1
    b24a:	f7fd fa71 	bl	8730 <ull_filter_lll_get>
    b24e:	4606      	mov	r6, r0
					    SCAN_FP_FILTER) != 0);
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    b250:	f10d 0003 	add.w	r0, sp, #3
    b254:	f7fd fe4c 	bl	8ef0 <ull_filter_lll_irks_get>

		radio_filter_configure(filter->enable_bitmask,
    b258:	7871      	ldrb	r1, [r6, #1]
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    b25a:	4607      	mov	r7, r0
		radio_filter_configure(filter->enable_bitmask,
    b25c:	1cb2      	adds	r2, r6, #2
    b25e:	7830      	ldrb	r0, [r6, #0]
    b260:	f000 ff8c 	bl	c17c <radio_filter_configure>
				       filter->addr_type_bitmask,
				       (uint8_t *) filter->bdaddr);

		radio_ar_configure(count, irks, (lll_aux->phy << 2) | BIT(1));
    b264:	7962      	ldrb	r2, [r4, #5]
    b266:	f89d 0003 	ldrb.w	r0, [sp, #3]
    b26a:	f3c2 0202 	ubfx	r2, r2, #0, #3
    b26e:	0092      	lsls	r2, r2, #2
    b270:	f042 0202 	orr.w	r2, r2, #2
    b274:	f002 021e 	and.w	r2, r2, #30
    b278:	4639      	mov	r1, r7
    b27a:	f001 f8a3 	bl	c3c4 <radio_ar_configure>
#if defined(CONFIG_BT_CTLR_SYNC_PERIODIC)
sync_aux_prepare_done:
#endif
	/* Calculate event timings, coarse and fine */
	ticks_at_event = p->ticks_at_expire;
	ull = HDR_LLL2ULL(lll_aux);
    b27e:	f8d4 8000 	ldr.w	r8, [r4]
	ticks_at_event = p->ticks_at_expire;
    b282:	682f      	ldr	r7, [r5, #0]
	ticks_at_event += lll_event_offset_get(ull);
    b284:	4640      	mov	r0, r8
    b286:	f006 fa8c 	bl	117a2 <lll_event_offset_get>
    b28a:	4407      	add	r7, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = p->remainder;
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
    b28c:	686a      	ldr	r2, [r5, #4]
    b28e:	f107 0109 	add.w	r1, r7, #9
    b292:	2000      	movs	r0, #0
    b294:	f000 ffd8 	bl	c248 <radio_tmr_start>
    b298:	4605      	mov	r5, r0

	hcto = remainder_us + lll_aux->window_size_us;
	hcto += radio_rx_ready_delay_get(lll_aux->phy, 1);
    b29a:	7960      	ldrb	r0, [r4, #5]
	hcto = remainder_us + lll_aux->window_size_us;
    b29c:	f8d4 9008 	ldr.w	r9, [r4, #8]
	hcto += radio_rx_ready_delay_get(lll_aux->phy, 1);
    b2a0:	2101      	movs	r1, #1
    b2a2:	f000 0007 	and.w	r0, r0, #7
    b2a6:	f006 fd15 	bl	11cd4 <radio_rx_ready_delay_get>
    b2aa:	4405      	add	r5, r0
	hcto += addr_us_get(lll_aux->phy);
    b2ac:	7960      	ldrb	r0, [r4, #5]
    b2ae:	f000 0007 	and.w	r0, r0, #7
    b2b2:	2802      	cmp	r0, #2
	hcto += radio_rx_ready_delay_get(lll_aux->phy, 1);
    b2b4:	444d      	add	r5, r9
    b2b6:	d02f      	beq.n	b318 <prepare_cb+0x194>
		return 40;
    b2b8:	2804      	cmp	r0, #4
    b2ba:	bf0c      	ite	eq
    b2bc:	f44f 73bc 	moveq.w	r3, #376	; 0x178
    b2c0:	2328      	movne	r3, #40	; 0x28
	hcto += radio_rx_chain_delay_get(lll_aux->phy, 1);
    b2c2:	2101      	movs	r1, #1
	hcto += addr_us_get(lll_aux->phy);
    b2c4:	441d      	add	r5, r3
	hcto += radio_rx_chain_delay_get(lll_aux->phy, 1);
    b2c6:	f006 fd07 	bl	11cd8 <radio_rx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
    b2ca:	4428      	add	r0, r5
    b2cc:	f001 f85a 	bl	c384 <radio_tmr_hcto_configure>

	/* capture end of Rx-ed PDU, extended scan to schedule auxiliary
	 * channel chaining, create connection or to create periodic sync.
	 */
	radio_tmr_end_capture();
    b2d0:	f001 f864 	bl	c39c <radio_tmr_end_capture>

	/* scanner always measures RSSI */
	radio_rssi_measure();
    b2d4:	f000 ff30 	bl	c138 <radio_rssi_measure>

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(ull, (TICKER_ID_SCAN_AUX_BASE +
				   ull_scan_aux_lll_handle_get(lll_aux)),
    b2d8:	4620      	mov	r0, r4
    b2da:	f7fc ff6f 	bl	81bc <ull_scan_aux_lll_handle_get>
	if (lll_preempt_calc(ull, (TICKER_ID_SCAN_AUX_BASE +
    b2de:	1d81      	adds	r1, r0, #6
    b2e0:	463a      	mov	r2, r7
    b2e2:	b2c9      	uxtb	r1, r1
    b2e4:	4640      	mov	r0, r8
    b2e6:	f006 fa6a 	bl	117be <lll_preempt_calc>
    b2ea:	b1b8      	cbz	r0, b31c <prepare_cb+0x198>
				   ticks_at_event)) {
		radio_isr_set(isr_done, lll_aux);
    b2ec:	481c      	ldr	r0, [pc, #112]	; (b360 <prepare_cb+0x1dc>)
    b2ee:	4621      	mov	r1, r4
    b2f0:	f000 fd64 	bl	bdbc <radio_isr_set>
		radio_disable();
    b2f4:	f000 fe2a 	bl	bf4c <radio_disable>
	}

	DEBUG_RADIO_START_O(1);

	return 0;
}
    b2f8:	2000      	movs	r0, #0
    b2fa:	b003      	add	sp, #12
    b2fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (IS_ENABLED(CONFIG_BT_CTLR_FILTER_ACCEPT_LIST) &&
    b300:	f013 0f18 	tst.w	r3, #24
    b304:	d0bb      	beq.n	b27e <prepare_cb+0xfa>
		struct lll_filter *fal = ull_filter_lll_get(true);
    b306:	2001      	movs	r0, #1
    b308:	f7fd fa12 	bl	8730 <ull_filter_lll_get>
		radio_filter_configure(fal->enable_bitmask,
    b30c:	7841      	ldrb	r1, [r0, #1]
    b30e:	1c82      	adds	r2, r0, #2
    b310:	7800      	ldrb	r0, [r0, #0]
    b312:	f000 ff33 	bl	c17c <radio_filter_configure>
    b316:	e7b2      	b.n	b27e <prepare_cb+0xfa>
	switch (phy) {
    b318:	2318      	movs	r3, #24
    b31a:	e7d2      	b.n	b2c2 <prepare_cb+0x13e>
		ret = lll_prepare_done(lll_aux);
    b31c:	4620      	mov	r0, r4
    b31e:	f006 fa3b 	bl	11798 <lll_prepare_done>
		LL_ASSERT(!ret);
    b322:	2800      	cmp	r0, #0
    b324:	d0e8      	beq.n	b2f8 <prepare_cb+0x174>
    b326:	4a08      	ldr	r2, [pc, #32]	; (b348 <prepare_cb+0x1c4>)
    b328:	490e      	ldr	r1, [pc, #56]	; (b364 <prepare_cb+0x1e0>)
    b32a:	4809      	ldr	r0, [pc, #36]	; (b350 <prepare_cb+0x1cc>)
    b32c:	f240 2351 	movw	r3, #593	; 0x251
    b330:	f004 f8c9 	bl	f4c6 <printk>
    b334:	4040      	eors	r0, r0
    b336:	f380 8811 	msr	BASEPRI, r0
    b33a:	f04f 0003 	mov.w	r0, #3
    b33e:	df02      	svc	2
    b340:	e7da      	b.n	b2f8 <prepare_cb+0x174>
    b342:	bf00      	nop
    b344:	20002902 	.word	0x20002902
    b348:	00013f09 	.word	0x00013f09
    b34c:	00013ddd 	.word	0x00013ddd
    b350:	000133b6 	.word	0x000133b6
    b354:	8e89bed6 	.word	0x8e89bed6
    b358:	00555555 	.word	0x00555555
    b35c:	00011c1d 	.word	0x00011c1d
    b360:	0000b369 	.word	0x0000b369
    b364:	0001366f 	.word	0x0001366f

0000b368 <isr_done>:

	lll_done(param);
}

static void isr_done(void *param)
{
    b368:	b510      	push	{r4, lr}
    b36a:	4604      	mov	r4, r0
	struct event_done_extra *e;

	lll_isr_status_reset();
    b36c:	f006 fa48 	bl	11800 <lll_isr_status_reset>

	if (!trx_cnt) {
    b370:	4b0c      	ldr	r3, [pc, #48]	; (b3a4 <isr_done+0x3c>)
    b372:	881b      	ldrh	r3, [r3, #0]
    b374:	b983      	cbnz	r3, b398 <isr_done+0x30>
		e = ull_done_extra_type_set(EVENT_DONE_EXTRA_TYPE_SCAN_AUX);
    b376:	2004      	movs	r0, #4
    b378:	f005 fe23 	bl	10fc2 <ull_done_extra_type_set>
		LL_ASSERT(e);
    b37c:	b960      	cbnz	r0, b398 <isr_done+0x30>
    b37e:	4a0a      	ldr	r2, [pc, #40]	; (b3a8 <isr_done+0x40>)
    b380:	490a      	ldr	r1, [pc, #40]	; (b3ac <isr_done+0x44>)
    b382:	480b      	ldr	r0, [pc, #44]	; (b3b0 <isr_done+0x48>)
    b384:	f240 2379 	movw	r3, #633	; 0x279
    b388:	f004 f89d 	bl	f4c6 <printk>
    b38c:	4040      	eors	r0, r0
    b38e:	f380 8811 	msr	BASEPRI, r0
    b392:	f04f 0003 	mov.w	r0, #3
    b396:	df02      	svc	2
	}

	lll_isr_cleanup(param);
    b398:	4620      	mov	r0, r4
}
    b39a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
    b39e:	f7fe ba43 	b.w	9828 <lll_isr_cleanup>
    b3a2:	bf00      	nop
    b3a4:	20002902 	.word	0x20002902
    b3a8:	00013f09 	.word	0x00013f09
    b3ac:	000136bc 	.word	0x000136bc
    b3b0:	000133b6 	.word	0x000133b6

0000b3b4 <abort_cb>:
{
    b3b4:	b510      	push	{r4, lr}
    b3b6:	460c      	mov	r4, r1
	if (!prepare_param) {
    b3b8:	b930      	cbnz	r0, b3c8 <abort_cb+0x14>
		radio_isr_set(isr_done, param);
    b3ba:	480e      	ldr	r0, [pc, #56]	; (b3f4 <abort_cb+0x40>)
    b3bc:	f000 fcfe 	bl	bdbc <radio_isr_set>
}
    b3c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
    b3c4:	f000 bdc2 	b.w	bf4c <radio_disable>
	err = lll_hfclock_off();
    b3c8:	f7fe fb4a 	bl	9a60 <lll_hfclock_off>
	LL_ASSERT(err >= 0);
    b3cc:	2800      	cmp	r0, #0
    b3ce:	da0c      	bge.n	b3ea <abort_cb+0x36>
    b3d0:	4a09      	ldr	r2, [pc, #36]	; (b3f8 <abort_cb+0x44>)
    b3d2:	490a      	ldr	r1, [pc, #40]	; (b3fc <abort_cb+0x48>)
    b3d4:	480a      	ldr	r0, [pc, #40]	; (b400 <abort_cb+0x4c>)
    b3d6:	f44f 731b 	mov.w	r3, #620	; 0x26c
    b3da:	f004 f874 	bl	f4c6 <printk>
    b3de:	4040      	eors	r0, r0
    b3e0:	f380 8811 	msr	BASEPRI, r0
    b3e4:	f04f 0003 	mov.w	r0, #3
    b3e8:	df02      	svc	2
	lll_done(param);
    b3ea:	4620      	mov	r0, r4
}
    b3ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
    b3f0:	f7fe b96a 	b.w	96c8 <lll_done>
    b3f4:	0000b369 	.word	0x0000b369
    b3f8:	00013f09 	.word	0x00013f09
    b3fc:	00013d61 	.word	0x00013d61
    b400:	000133b6 	.word	0x000133b6

0000b404 <lll_scan_aux_isr_aux_setup>:
{
    b404:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b408:	4607      	mov	r7, r0
    b40a:	b085      	sub	sp, #20
	lll_isr_status_reset();
    b40c:	f006 f9f8 	bl	11800 <lll_isr_status_reset>
	aux_ptr = ftr->aux_ptr;
    b410:	68fb      	ldr	r3, [r7, #12]
	phy_aux = BIT(aux_ptr->phy);
    b412:	9301      	str	r3, [sp, #4]
	if (aux_ptr->offs_units) {
    b414:	f993 1000 	ldrsb.w	r1, [r3]
    b418:	f893 9002 	ldrb.w	r9, [r3, #2]
    b41c:	781a      	ldrb	r2, [r3, #0]
	phy_aux = BIT(aux_ptr->phy);
    b41e:	789e      	ldrb	r6, [r3, #2]
	aux_offset_us = (uint32_t)aux_ptr->offs * window_size_us;
    b420:	785d      	ldrb	r5, [r3, #1]
	lll = ftr->param;
    b422:	f8d7 b008 	ldr.w	fp, [r7, #8]
		window_size_us = OFFS_UNIT_30_US;
    b426:	2900      	cmp	r1, #0
	aux_offset_us = (uint32_t)aux_ptr->offs * window_size_us;
    b428:	f009 091f 	and.w	r9, r9, #31
		window_size_us = OFFS_UNIT_30_US;
    b42c:	bfb4      	ite	lt
    b42e:	f44f 7a96 	movlt.w	sl, #300	; 0x12c
    b432:	f04f 0a1e 	movge.w	sl, #30
	aux_offset_us = (uint32_t)aux_ptr->offs * window_size_us;
    b436:	ea45 2509 	orr.w	r5, r5, r9, lsl #8
	if (aux_ptr->ca) {
    b43a:	f012 0f40 	tst.w	r2, #64	; 0x40
	phy_aux = BIT(aux_ptr->phy);
    b43e:	ea4f 1656 	mov.w	r6, r6, lsr #5
    b442:	f04f 0401 	mov.w	r4, #1
		window_widening_us = SCA_DRIFT_50_PPM_US(aux_offset_us);
    b446:	bf14      	ite	ne
    b448:	2232      	movne	r2, #50	; 0x32
		window_widening_us = SCA_DRIFT_500_PPM_US(aux_offset_us);
    b44a:	f44f 72fa 	moveq.w	r2, #500	; 0x1f4
	aux_offset_us = (uint32_t)aux_ptr->offs * window_size_us;
    b44e:	fb0a f905 	mul.w	r9, sl, r5
	phy_aux = BIT(aux_ptr->phy);
    b452:	40b4      	lsls	r4, r6
    b454:	b2e4      	uxtb	r4, r4
	ftr->aux_phy = phy_aux;
    b456:	4d41      	ldr	r5, [pc, #260]	; (b55c <lll_scan_aux_isr_aux_setup+0x158>)
    b458:	733c      	strb	r4, [r7, #12]
		window_widening_us = SCA_DRIFT_500_PPM_US(aux_offset_us);
    b45a:	fb02 f209 	mul.w	r2, r2, r9
    b45e:	fbb2 f8f5 	udiv	r8, r2, r5
	trx_cnt = 0U;
    b462:	4a3f      	ldr	r2, [pc, #252]	; (b560 <lll_scan_aux_isr_aux_setup+0x15c>)
    b464:	2500      	movs	r5, #0
	radio_phy_set(phy_aux, PHY_FLAGS_S8);
    b466:	2101      	movs	r1, #1
    b468:	4620      	mov	r0, r4
	trx_cnt = 0U;
    b46a:	8015      	strh	r5, [r2, #0]
	radio_phy_set(phy_aux, PHY_FLAGS_S8);
    b46c:	f000 fcea 	bl	be44 <radio_phy_set>
	radio_pkt_configure(8, LL_EXT_OCTETS_RX_MAX, (phy_aux << 1));
    b470:	0062      	lsls	r2, r4, #1
    b472:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    b476:	21ff      	movs	r1, #255	; 0xff
    b478:	2008      	movs	r0, #8
    b47a:	f000 fd29 	bl	bed0 <radio_pkt_configure>
	lll_chan_set(aux_ptr->chan_idx);
    b47e:	9b01      	ldr	r3, [sp, #4]
    b480:	7818      	ldrb	r0, [r3, #0]
    b482:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    b486:	f7fe f99d 	bl	97c4 <lll_chan_set>
	radio_pkt_rx_set(node_rx->pdu);
    b48a:	f107 001c 	add.w	r0, r7, #28
    b48e:	f000 fd4b 	bl	bf28 <radio_pkt_rx_set>
	radio_isr_set(isr_rx_lll_schedule, node_rx);
    b492:	4639      	mov	r1, r7
    b494:	4833      	ldr	r0, [pc, #204]	; (b564 <lll_scan_aux_isr_aux_setup+0x160>)
    b496:	f000 fc91 	bl	bdbc <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
    b49a:	2096      	movs	r0, #150	; 0x96
    b49c:	f000 fec8 	bl	c230 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(phy_aux, 0, phy_aux, 1);
    b4a0:	2301      	movs	r3, #1
    b4a2:	4622      	mov	r2, r4
    b4a4:	4629      	mov	r1, r5
    b4a6:	4620      	mov	r0, r4
    b4a8:	f000 fe26 	bl	c0f8 <radio_switch_complete_and_tx>
	} else if (ull_filter_lll_rl_enabled()) {
    b4ac:	f7fd fe7e 	bl	91ac <ull_filter_lll_rl_enabled>
    b4b0:	f89b 3004 	ldrb.w	r3, [fp, #4]
    b4b4:	2800      	cmp	r0, #0
    b4b6:	d042      	beq.n	b53e <lll_scan_aux_isr_aux_setup+0x13a>
			ull_filter_lll_get((lll->filter_policy &
    b4b8:	f3c3 00c0 	ubfx	r0, r3, #3, #1
    b4bc:	f7fd f938 	bl	8730 <ull_filter_lll_get>
    b4c0:	4605      	mov	r5, r0
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    b4c2:	f10d 000f 	add.w	r0, sp, #15
    b4c6:	f7fd fd13 	bl	8ef0 <ull_filter_lll_irks_get>
		radio_filter_configure(fal->enable_bitmask,
    b4ca:	7869      	ldrb	r1, [r5, #1]
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    b4cc:	4683      	mov	fp, r0
		radio_filter_configure(fal->enable_bitmask,
    b4ce:	1caa      	adds	r2, r5, #2
    b4d0:	7828      	ldrb	r0, [r5, #0]
    b4d2:	f000 fe53 	bl	c17c <radio_filter_configure>
		radio_ar_configure(count, irks, (phy_aux << 2) | BIT(1));
    b4d6:	00a2      	lsls	r2, r4, #2
    b4d8:	f042 0202 	orr.w	r2, r2, #2
    b4dc:	f89d 000f 	ldrb.w	r0, [sp, #15]
    b4e0:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    b4e4:	4659      	mov	r1, fp
    b4e6:	f000 ff6d 	bl	c3c4 <radio_ar_configure>
	aux_start_us = ftr->radio_end_us + aux_offset_us;
    b4ea:	6979      	ldr	r1, [r7, #20]
	aux_start_us -= lll_radio_rx_ready_delay_get(phy_aux, PHY_FLAGS_S8);
    b4ec:	4620      	mov	r0, r4
    b4ee:	f1a1 0510 	sub.w	r5, r1, #16
    b4f2:	2101      	movs	r1, #1
    b4f4:	f006 f972 	bl	117dc <lll_radio_rx_ready_delay_get>
	aux_start_us -= EVENT_JITTER_US;
    b4f8:	eb09 0105 	add.w	r1, r9, r5
    b4fc:	eba1 0108 	sub.w	r1, r1, r8
	radio_tmr_start_us(0, aux_start_us);
    b500:	1a09      	subs	r1, r1, r0
    b502:	2000      	movs	r0, #0
    b504:	f000 ff0e 	bl	c324 <radio_tmr_start_us>
	hcto += EVENT_JITTER_US;
    b508:	697d      	ldr	r5, [r7, #20]
	hcto += radio_rx_chain_delay_get(phy_aux, 1);
    b50a:	2101      	movs	r1, #1
	hcto += EVENT_JITTER_US;
    b50c:	3510      	adds	r5, #16
	hcto += radio_rx_chain_delay_get(phy_aux, 1);
    b50e:	4620      	mov	r0, r4
    b510:	f006 fbe2 	bl	11cd8 <radio_rx_chain_delay_get>
	hcto += EVENT_JITTER_US;
    b514:	4455      	add	r5, sl
    b516:	444d      	add	r5, r9
    b518:	4445      	add	r5, r8
    b51a:	2e01      	cmp	r6, #1
	hcto += radio_rx_chain_delay_get(phy_aux, 1);
    b51c:	4405      	add	r5, r0
    b51e:	d01a      	beq.n	b556 <lll_scan_aux_isr_aux_setup+0x152>
	case BIT(1):
		return 24;
	case BIT(2):
		return 376;
    b520:	2c04      	cmp	r4, #4
    b522:	bf14      	ite	ne
    b524:	2028      	movne	r0, #40	; 0x28
    b526:	f44f 70bc 	moveq.w	r0, #376	; 0x178
	radio_tmr_hcto_configure(hcto);
    b52a:	4428      	add	r0, r5
    b52c:	f000 ff2a 	bl	c384 <radio_tmr_hcto_configure>
	radio_tmr_end_capture();
    b530:	f000 ff34 	bl	c39c <radio_tmr_end_capture>
}
    b534:	b005      	add	sp, #20
    b536:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	radio_rssi_measure();
    b53a:	f000 bdfd 	b.w	c138 <radio_rssi_measure>
	} else if (IS_ENABLED(CONFIG_BT_CTLR_FILTER_ACCEPT_LIST) && lll->filter_policy) {
    b53e:	f013 0f18 	tst.w	r3, #24
    b542:	d0d2      	beq.n	b4ea <lll_scan_aux_isr_aux_setup+0xe6>
		const struct lll_filter *fal = ull_filter_lll_get(true);
    b544:	2001      	movs	r0, #1
    b546:	f7fd f8f3 	bl	8730 <ull_filter_lll_get>
		radio_filter_configure(fal->enable_bitmask,
    b54a:	7841      	ldrb	r1, [r0, #1]
    b54c:	1c82      	adds	r2, r0, #2
    b54e:	7800      	ldrb	r0, [r0, #0]
    b550:	f000 fe14 	bl	c17c <radio_filter_configure>
    b554:	e7c9      	b.n	b4ea <lll_scan_aux_isr_aux_setup+0xe6>
	switch (phy) {
    b556:	2018      	movs	r0, #24
    b558:	e7e7      	b.n	b52a <lll_scan_aux_isr_aux_setup+0x126>
    b55a:	bf00      	nop
    b55c:	000f4240 	.word	0x000f4240
    b560:	20002902 	.word	0x20002902
    b564:	00011c37 	.word	0x00011c37

0000b568 <isr_tx>:
	return -EINVAL;
}

static void isr_tx(struct lll_scan_aux *lll_aux, void *pdu_rx,
		   void (*isr)(void *), void *param)
{
    b568:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    b56a:	460c      	mov	r4, r1
    b56c:	4607      	mov	r7, r0
    b56e:	4615      	mov	r5, r2
    b570:	461e      	mov	r6, r3
	uint32_t hcto;

	/* Clear radio tx status and events */
	lll_isr_tx_status_reset();
    b572:	f006 f935 	bl	117e0 <lll_isr_tx_status_reset>

	/* complete the reception and disable radio  */
	radio_switch_complete_and_disable();
    b576:	f000 fdd1 	bl	c11c <radio_switch_complete_and_disable>

	radio_pkt_rx_set(pdu_rx);
    b57a:	4620      	mov	r0, r4
    b57c:	f000 fcd4 	bl	bf28 <radio_pkt_rx_set>

	/* assert if radio packet ptr is not set and radio started rx */
	LL_ASSERT(!radio_is_ready());
    b580:	f000 fd02 	bl	bf88 <radio_is_ready>
    b584:	b160      	cbz	r0, b5a0 <isr_tx+0x38>
    b586:	4a25      	ldr	r2, [pc, #148]	; (b61c <isr_tx+0xb4>)
    b588:	4925      	ldr	r1, [pc, #148]	; (b620 <isr_tx+0xb8>)
    b58a:	4826      	ldr	r0, [pc, #152]	; (b624 <isr_tx+0xbc>)
    b58c:	f240 43e1 	movw	r3, #1249	; 0x4e1
    b590:	f003 ff99 	bl	f4c6 <printk>
    b594:	4040      	eors	r0, r0
    b596:	f380 8811 	msr	BASEPRI, r0
    b59a:	f04f 0003 	mov.w	r0, #3
    b59e:	df02      	svc	2

#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (ull_filter_lll_rl_enabled()) {
    b5a0:	f7fd fe04 	bl	91ac <ull_filter_lll_rl_enabled>
    b5a4:	b180      	cbz	r0, b5c8 <isr_tx+0x60>
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    b5a6:	f10d 0007 	add.w	r0, sp, #7
    b5aa:	f7fd fca1 	bl	8ef0 <ull_filter_lll_irks_get>

		radio_ar_configure(count, irks, (lll_aux->phy << 2) | BIT(1));
    b5ae:	797c      	ldrb	r4, [r7, #5]
    b5b0:	f3c4 0402 	ubfx	r4, r4, #0, #3
    b5b4:	00a4      	lsls	r4, r4, #2
    b5b6:	f044 0402 	orr.w	r4, r4, #2
		uint8_t count, *irks = ull_filter_lll_irks_get(&count);
    b5ba:	4601      	mov	r1, r0
		radio_ar_configure(count, irks, (lll_aux->phy << 2) | BIT(1));
    b5bc:	f004 021e 	and.w	r2, r4, #30
    b5c0:	f89d 0007 	ldrb.w	r0, [sp, #7]
    b5c4:	f000 fefe 	bl	c3c4 <radio_ar_configure>
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	/* +/- 2us active clock jitter, +1 us hcto compensation */
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 +
    b5c8:	f000 fef6 	bl	c3b8 <radio_tmr_tifs_base_get>
    b5cc:	4604      	mov	r4, r0
		RANGE_DELAY_US + 1;
	hcto += radio_rx_chain_delay_get(lll_aux->phy, 1);
    b5ce:	7978      	ldrb	r0, [r7, #5]
    b5d0:	2101      	movs	r1, #1
    b5d2:	f000 0007 	and.w	r0, r0, #7
    b5d6:	f006 fb7f 	bl	11cd8 <radio_rx_chain_delay_get>
    b5da:	4404      	add	r4, r0
	hcto += addr_us_get(lll_aux->phy);
    b5dc:	7978      	ldrb	r0, [r7, #5]
    b5de:	f000 0007 	and.w	r0, r0, #7
    b5e2:	2802      	cmp	r0, #2
	hcto += radio_rx_chain_delay_get(lll_aux->phy, 1);
    b5e4:	f104 04a3 	add.w	r4, r4, #163	; 0xa3
    b5e8:	d016      	beq.n	b618 <isr_tx+0xb0>
		return 40;
    b5ea:	2804      	cmp	r0, #4
    b5ec:	bf0c      	ite	eq
    b5ee:	f44f 73bc 	moveq.w	r3, #376	; 0x178
    b5f2:	2328      	movne	r3, #40	; 0x28
	hcto -= radio_tx_chain_delay_get(lll_aux->phy, 1);
    b5f4:	2101      	movs	r1, #1
	hcto += addr_us_get(lll_aux->phy);
    b5f6:	441c      	add	r4, r3
	hcto -= radio_tx_chain_delay_get(lll_aux->phy, 1);
    b5f8:	f006 fb6a 	bl	11cd0 <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
    b5fc:	1a20      	subs	r0, r4, r0
    b5fe:	f000 fec1 	bl	c384 <radio_tmr_hcto_configure>

	/* capture end of Rx-ed PDU, extended scan to schedule auxiliary
	 * channel chaining.
	 */
	radio_tmr_end_capture();
    b602:	f000 fecb 	bl	c39c <radio_tmr_end_capture>

	/* scanner always measures RSSI */
	radio_rssi_measure();
    b606:	f000 fd97 	bl	c138 <radio_rssi_measure>
	radio_gpio_pa_lna_enable(radio_tmr_tifs_base_get() + EVENT_IFS_US - 4 -
				 radio_tx_chain_delay_get(lll_aux->phy, 1) -
				 HAL_RADIO_GPIO_LNA_OFFSET);
#endif /* HAL_RADIO_GPIO_HAVE_LNA_PIN */

	radio_isr_set(isr, param);
    b60a:	4631      	mov	r1, r6
    b60c:	4628      	mov	r0, r5
		/* NOTE: as scratch packet is used to receive, it is safe to
		 * generate profile event using rx nodes.
		 */
		lll_prof_send();
	}
}
    b60e:	b003      	add	sp, #12
    b610:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	radio_isr_set(isr, param);
    b614:	f000 bbd2 	b.w	bdbc <radio_isr_set>
	switch (phy) {
    b618:	2318      	movs	r3, #24
    b61a:	e7eb      	b.n	b5f4 <isr_tx+0x8c>
    b61c:	00013f09 	.word	0x00013f09
    b620:	00013de5 	.word	0x00013de5
    b624:	000133b6 	.word	0x000133b6

0000b628 <isr_tx_scan_req_lll_schedule>:

	isr_tx(param, node_rx->pdu, isr_rx_ull_schedule, param);
}

static void isr_tx_scan_req_lll_schedule(void *param)
{
    b628:	b570      	push	{r4, r5, r6, lr}
	struct node_rx_pdu *node_rx_adv = param;
	struct node_rx_pdu *node_rx;
	struct lll_scan *lll;

	lll = node_rx_adv->hdr.rx_ftr.param;
    b62a:	6886      	ldr	r6, [r0, #8]
{
    b62c:	4605      	mov	r5, r0

	node_rx = ull_pdu_rx_alloc_peek(1);
    b62e:	2001      	movs	r0, #1
    b630:	f7fb f840 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    b634:	4604      	mov	r4, r0
    b636:	b960      	cbnz	r0, b652 <isr_tx_scan_req_lll_schedule+0x2a>
    b638:	4a0a      	ldr	r2, [pc, #40]	; (b664 <isr_tx_scan_req_lll_schedule+0x3c>)
    b63a:	490b      	ldr	r1, [pc, #44]	; (b668 <isr_tx_scan_req_lll_schedule+0x40>)
    b63c:	480b      	ldr	r0, [pc, #44]	; (b66c <isr_tx_scan_req_lll_schedule+0x44>)
    b63e:	f240 5326 	movw	r3, #1318	; 0x526
    b642:	f003 ff40 	bl	f4c6 <printk>
    b646:	4040      	eors	r0, r0
    b648:	f380 8811 	msr	BASEPRI, r0
    b64c:	f04f 0003 	mov.w	r0, #3
    b650:	df02      	svc	2

	isr_tx(lll->lll_aux, node_rx->pdu, isr_rx_lll_schedule, param);
    b652:	68f0      	ldr	r0, [r6, #12]
    b654:	4a06      	ldr	r2, [pc, #24]	; (b670 <isr_tx_scan_req_lll_schedule+0x48>)
    b656:	462b      	mov	r3, r5
    b658:	f104 011c 	add.w	r1, r4, #28
}
    b65c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	isr_tx(lll->lll_aux, node_rx->pdu, isr_rx_lll_schedule, param);
    b660:	f7ff bf82 	b.w	b568 <isr_tx>
    b664:	00013f09 	.word	0x00013f09
    b668:	00013ddd 	.word	0x00013ddd
    b66c:	000133b6 	.word	0x000133b6
    b670:	00011c37 	.word	0x00011c37

0000b674 <isr_tx_scan_req_ull_schedule>:
{
    b674:	b570      	push	{r4, r5, r6, lr}
    b676:	4605      	mov	r5, r0
	node_rx = ull_pdu_rx_alloc_peek(1);
    b678:	2001      	movs	r0, #1
    b67a:	f7fb f81b 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    b67e:	4604      	mov	r4, r0
    b680:	b960      	cbnz	r0, b69c <isr_tx_scan_req_ull_schedule+0x28>
    b682:	4a0b      	ldr	r2, [pc, #44]	; (b6b0 <isr_tx_scan_req_ull_schedule+0x3c>)
    b684:	490b      	ldr	r1, [pc, #44]	; (b6b4 <isr_tx_scan_req_ull_schedule+0x40>)
    b686:	480c      	ldr	r0, [pc, #48]	; (b6b8 <isr_tx_scan_req_ull_schedule+0x44>)
    b688:	f44f 63a3 	mov.w	r3, #1304	; 0x518
    b68c:	f003 ff1b 	bl	f4c6 <printk>
    b690:	4040      	eors	r0, r0
    b692:	f380 8811 	msr	BASEPRI, r0
    b696:	f04f 0003 	mov.w	r0, #3
    b69a:	df02      	svc	2
	isr_tx(param, node_rx->pdu, isr_rx_ull_schedule, param);
    b69c:	462b      	mov	r3, r5
    b69e:	f104 011c 	add.w	r1, r4, #28
    b6a2:	4628      	mov	r0, r5
    b6a4:	4a05      	ldr	r2, [pc, #20]	; (b6bc <isr_tx_scan_req_ull_schedule+0x48>)
}
    b6a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	isr_tx(param, node_rx->pdu, isr_rx_ull_schedule, param);
    b6aa:	f7ff bf5d 	b.w	b568 <isr_tx>
    b6ae:	bf00      	nop
    b6b0:	00013f09 	.word	0x00013f09
    b6b4:	00013ddd 	.word	0x00013ddd
    b6b8:	000133b6 	.word	0x000133b6
    b6bc:	00011c1d 	.word	0x00011c1d

0000b6c0 <lll_scan_aux_prepare>:
{
    b6c0:	b513      	push	{r0, r1, r4, lr}
    b6c2:	4604      	mov	r4, r0
	err = lll_hfclock_on();
    b6c4:	f7fe f9b6 	bl	9a34 <lll_hfclock_on>
	LL_ASSERT(err >= 0);
    b6c8:	2800      	cmp	r0, #0
    b6ca:	da0b      	bge.n	b6e4 <lll_scan_aux_prepare+0x24>
    b6cc:	4a11      	ldr	r2, [pc, #68]	; (b714 <lll_scan_aux_prepare+0x54>)
    b6ce:	4912      	ldr	r1, [pc, #72]	; (b718 <lll_scan_aux_prepare+0x58>)
    b6d0:	4812      	ldr	r0, [pc, #72]	; (b71c <lll_scan_aux_prepare+0x5c>)
    b6d2:	236e      	movs	r3, #110	; 0x6e
    b6d4:	f003 fef7 	bl	f4c6 <printk>
    b6d8:	4040      	eors	r0, r0
    b6da:	f380 8811 	msr	BASEPRI, r0
    b6de:	f04f 0003 	mov.w	r0, #3
    b6e2:	df02      	svc	2
	err = lll_prepare(lll_is_abort_cb, abort_cb, prepare_cb, 0, param);
    b6e4:	4a0e      	ldr	r2, [pc, #56]	; (b720 <lll_scan_aux_prepare+0x60>)
    b6e6:	490f      	ldr	r1, [pc, #60]	; (b724 <lll_scan_aux_prepare+0x64>)
    b6e8:	480f      	ldr	r0, [pc, #60]	; (b728 <lll_scan_aux_prepare+0x68>)
    b6ea:	9400      	str	r4, [sp, #0]
    b6ec:	2300      	movs	r3, #0
    b6ee:	f005 fcbd 	bl	1106c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
    b6f2:	b168      	cbz	r0, b710 <lll_scan_aux_prepare+0x50>
    b6f4:	3077      	adds	r0, #119	; 0x77
    b6f6:	d00b      	beq.n	b710 <lll_scan_aux_prepare+0x50>
    b6f8:	4a06      	ldr	r2, [pc, #24]	; (b714 <lll_scan_aux_prepare+0x54>)
    b6fa:	490c      	ldr	r1, [pc, #48]	; (b72c <lll_scan_aux_prepare+0x6c>)
    b6fc:	4807      	ldr	r0, [pc, #28]	; (b71c <lll_scan_aux_prepare+0x5c>)
    b6fe:	2371      	movs	r3, #113	; 0x71
    b700:	f003 fee1 	bl	f4c6 <printk>
    b704:	4040      	eors	r0, r0
    b706:	f380 8811 	msr	BASEPRI, r0
    b70a:	f04f 0003 	mov.w	r0, #3
    b70e:	df02      	svc	2
}
    b710:	b002      	add	sp, #8
    b712:	bd10      	pop	{r4, pc}
    b714:	00013f09 	.word	0x00013f09
    b718:	00013d61 	.word	0x00013d61
    b71c:	000133b6 	.word	0x000133b6
    b720:	0000b185 	.word	0x0000b185
    b724:	0000b3b5 	.word	0x0000b3b5
    b728:	0001179d 	.word	0x0001179d
    b72c:	00013e0d 	.word	0x00013e0d

0000b730 <lll_scan_aux_setup>:
{
    b730:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b734:	4699      	mov	r9, r3
	LL_ASSERT(pdu->type == PDU_ADV_TYPE_EXT_IND);
    b736:	7803      	ldrb	r3, [r0, #0]
    b738:	f003 030f 	and.w	r3, r3, #15
    b73c:	2b07      	cmp	r3, #7
{
    b73e:	4606      	mov	r6, r0
    b740:	460f      	mov	r7, r1
    b742:	4692      	mov	sl, r2
	LL_ASSERT(pdu->type == PDU_ADV_TYPE_EXT_IND);
    b744:	d00b      	beq.n	b75e <lll_scan_aux_setup+0x2e>
    b746:	4a45      	ldr	r2, [pc, #276]	; (b85c <lll_scan_aux_setup+0x12c>)
    b748:	4945      	ldr	r1, [pc, #276]	; (b860 <lll_scan_aux_setup+0x130>)
    b74a:	4846      	ldr	r0, [pc, #280]	; (b864 <lll_scan_aux_setup+0x134>)
    b74c:	2385      	movs	r3, #133	; 0x85
    b74e:	f003 feba 	bl	f4c6 <printk>
    b752:	4040      	eors	r0, r0
    b754:	f380 8811 	msr	BASEPRI, r0
    b758:	f04f 0003 	mov.w	r0, #3
    b75c:	df02      	svc	2
	if (pri_hdr->adv_addr) {
    b75e:	78f3      	ldrb	r3, [r6, #3]
    b760:	07dc      	lsls	r4, r3, #31
		pri_dptr += BDADDR_SIZE;
    b762:	bf4c      	ite	mi
    b764:	f106 050a 	addmi.w	r5, r6, #10
	pri_dptr = pri_hdr->data;
    b768:	1d35      	addpl	r5, r6, #4
	if (pri_hdr->tgt_addr) {
    b76a:	0798      	lsls	r0, r3, #30
		pri_dptr += BDADDR_SIZE;
    b76c:	bf48      	it	mi
    b76e:	3506      	addmi	r5, #6
	if (pri_hdr->cte_info) {
    b770:	0759      	lsls	r1, r3, #29
		pri_dptr += sizeof(struct pdu_cte_info);
    b772:	bf48      	it	mi
    b774:	3501      	addmi	r5, #1
	if (pri_hdr->adi) {
    b776:	071a      	lsls	r2, r3, #28
		pri_dptr += sizeof(struct pdu_adv_adi);
    b778:	bf48      	it	mi
    b77a:	3502      	addmi	r5, #2
	if (unlikely(!pri_hdr->aux_ptr || !aux_ptr->offs ||
    b77c:	06db      	lsls	r3, r3, #27
    b77e:	d403      	bmi.n	b788 <lll_scan_aux_setup+0x58>
		return 0;
    b780:	2000      	movs	r0, #0
}
    b782:	b003      	add	sp, #12
    b784:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (unlikely(!pri_hdr->aux_ptr || !aux_ptr->offs ||
    b788:	78aa      	ldrb	r2, [r5, #2]
    b78a:	786b      	ldrb	r3, [r5, #1]
    b78c:	f002 011f 	and.w	r1, r2, #31
    b790:	ea53 2301 	orrs.w	r3, r3, r1, lsl #8
    b794:	d0f4      	beq.n	b780 <lll_scan_aux_setup+0x50>
    b796:	2a5f      	cmp	r2, #95	; 0x5f
    b798:	ea4f 1052 	mov.w	r0, r2, lsr #5
    b79c:	d8f0      	bhi.n	b780 <lll_scan_aux_setup+0x50>
	if (aux_ptr->offs_units) {
    b79e:	f995 1000 	ldrsb.w	r1, [r5]
    b7a2:	782a      	ldrb	r2, [r5, #0]
	overhead_us = PDU_AC_US(pdu->len, pdu_phy, pdu_phy_flags_rx);
    b7a4:	7874      	ldrb	r4, [r6, #1]
		window_size_us = OFFS_UNIT_30_US;
    b7a6:	2900      	cmp	r1, #0
    b7a8:	bfb4      	ite	lt
    b7aa:	f44f 7196 	movlt.w	r1, #300	; 0x12c
    b7ae:	211e      	movge	r1, #30
	if (aux_ptr->ca) {
    b7b0:	f012 0f40 	tst.w	r2, #64	; 0x40
	aux_offset_us = (uint32_t)aux_ptr->offs * window_size_us;
    b7b4:	fb01 f303 	mul.w	r3, r1, r3
	if (aux_ptr->ca) {
    b7b8:	f007 0803 	and.w	r8, r7, #3
		window_widening_us = SCA_DRIFT_50_PPM_US(aux_offset_us);
    b7bc:	bf14      	ite	ne
    b7be:	2132      	movne	r1, #50	; 0x32
		window_widening_us = SCA_DRIFT_500_PPM_US(aux_offset_us);
    b7c0:	f44f 71fa 	moveq.w	r1, #500	; 0x1f4
    b7c4:	4359      	muls	r1, r3
    b7c6:	4a28      	ldr	r2, [pc, #160]	; (b868 <lll_scan_aux_setup+0x138>)
    b7c8:	fbb1 f2f2 	udiv	r2, r1, r2
    b7cc:	f108 0809 	add.w	r8, r8, #9
	phy = BIT(aux_ptr->phy);
    b7d0:	2101      	movs	r1, #1
    b7d2:	fa01 f000 	lsl.w	r0, r1, r0
	overhead_us = PDU_AC_US(pdu->len, pdu_phy, pdu_phy_flags_rx);
    b7d6:	4444      	add	r4, r8
    b7d8:	f3c7 0b40 	ubfx	fp, r7, #1, #1
    b7dc:	00e4      	lsls	r4, r4, #3
	overhead_us += lll_radio_rx_ready_delay_get(phy, 1);
    b7de:	b2c0      	uxtb	r0, r0
    b7e0:	e9cd 2300 	strd	r2, r3, [sp]
	overhead_us = PDU_AC_US(pdu->len, pdu_phy, pdu_phy_flags_rx);
    b7e4:	fa24 f40b 	lsr.w	r4, r4, fp
	overhead_us += lll_radio_rx_ready_delay_get(phy, 1);
    b7e8:	f005 fff8 	bl	117dc <lll_radio_rx_ready_delay_get>
	overhead_us += window_widening_us;
    b7ec:	9a00      	ldr	r2, [sp, #0]
	if (aux_offset_us > overhead_us) {
    b7ee:	9b01      	ldr	r3, [sp, #4]
    b7f0:	f204 2457 	addw	r4, r4, #599	; 0x257
    b7f4:	4422      	add	r2, r4
	overhead_us += EVENT_OVERHEAD_END_US + EVENT_OVERHEAD_START_US;
    b7f6:	4402      	add	r2, r0
	if (aux_offset_us > overhead_us) {
    b7f8:	4293      	cmp	r3, r2
    b7fa:	d8c1      	bhi.n	b780 <lll_scan_aux_setup+0x50>
	node_rx = ull_pdu_rx_alloc_peek(1);
    b7fc:	2101      	movs	r1, #1
    b7fe:	4608      	mov	r0, r1
    b800:	f7fa ff58 	bl	66b4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    b804:	4604      	mov	r4, r0
    b806:	b958      	cbnz	r0, b820 <lll_scan_aux_setup+0xf0>
    b808:	4a14      	ldr	r2, [pc, #80]	; (b85c <lll_scan_aux_setup+0x12c>)
    b80a:	4918      	ldr	r1, [pc, #96]	; (b86c <lll_scan_aux_setup+0x13c>)
    b80c:	4815      	ldr	r0, [pc, #84]	; (b864 <lll_scan_aux_setup+0x134>)
    b80e:	23db      	movs	r3, #219	; 0xdb
    b810:	f003 fe59 	bl	f4c6 <printk>
    b814:	4040      	eors	r0, r0
    b816:	f380 8811 	msr	BASEPRI, r0
    b81a:	f04f 0003 	mov.w	r0, #3
    b81e:	df02      	svc	2
	ftr->param = param;
    b820:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	ftr->aux_ptr = aux_ptr;
    b822:	e9c4 3502 	strd	r3, r5, [r4, #8]
	ftr->radio_end_us = radio_tmr_end_get() -
    b826:	f000 fdc1 	bl	c3ac <radio_tmr_end_get>
			    radio_rx_chain_delay_get(pdu_phy,
    b82a:	4651      	mov	r1, sl
	ftr->radio_end_us = radio_tmr_end_get() -
    b82c:	4605      	mov	r5, r0
			    radio_rx_chain_delay_get(pdu_phy,
    b82e:	4638      	mov	r0, r7
    b830:	f006 fa52 	bl	11cd8 <radio_rx_chain_delay_get>
			    PDU_AC_US(pdu->len, pdu_phy, pdu_phy_flags_rx);
    b834:	7873      	ldrb	r3, [r6, #1]
    b836:	4498      	add	r8, r3
    b838:	ea4f 08c8 	mov.w	r8, r8, lsl #3
    b83c:	fa28 fb0b 	lsr.w	fp, r8, fp
						     pdu_phy_flags_rx) -
    b840:	eba5 0b0b 	sub.w	fp, r5, fp
    b844:	ebab 0000 	sub.w	r0, fp, r0
	ftr->radio_end_us = radio_tmr_end_get() -
    b848:	6160      	str	r0, [r4, #20]
	radio_isr_set(setup_cb, node_rx);
    b84a:	4621      	mov	r1, r4
    b84c:	4648      	mov	r0, r9
    b84e:	f000 fab5 	bl	bdbc <radio_isr_set>
	radio_disable();
    b852:	f000 fb7b 	bl	bf4c <radio_disable>
	return 1;
    b856:	2001      	movs	r0, #1
    b858:	e793      	b.n	b782 <lll_scan_aux_setup+0x52>
    b85a:	bf00      	nop
    b85c:	00013f09 	.word	0x00013f09
    b860:	00013e7b 	.word	0x00013e7b
    b864:	000133b6 	.word	0x000133b6
    b868:	000f4240 	.word	0x000f4240
    b86c:	00013ddd 	.word	0x00013ddd

0000b870 <isr_rx>:
{
    b870:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b874:	b087      	sub	sp, #28
    b876:	4605      	mov	r5, r0
    b878:	460e      	mov	r6, r1
    b87a:	4691      	mov	r9, r2
	trx_done = radio_is_done();
    b87c:	f000 fb8e 	bl	bf9c <radio_is_done>
	if (trx_done) {
    b880:	f010 04ff 	ands.w	r4, r0, #255	; 0xff
    b884:	f000 80ba 	beq.w	b9fc <isr_rx+0x18c>
		crc_ok = radio_crc_is_valid();
    b888:	f000 fba8 	bl	bfdc <radio_crc_is_valid>
    b88c:	b2c7      	uxtb	r7, r0
		devmatch_ok = radio_filter_has_match();
    b88e:	f000 fca3 	bl	c1d8 <radio_filter_has_match>
    b892:	f88d 0013 	strb.w	r0, [sp, #19]
		devmatch_id = radio_filter_match_get();
    b896:	f000 fca9 	bl	c1ec <radio_filter_match_get>
    b89a:	f88d 0014 	strb.w	r0, [sp, #20]
		irkmatch_ok = radio_ar_has_match();
    b89e:	f000 fde3 	bl	c468 <radio_ar_has_match>
    b8a2:	f88d 0015 	strb.w	r0, [sp, #21]
		irkmatch_id = radio_ar_match_get();
    b8a6:	f000 fdc7 	bl	c438 <radio_ar_match_get>
    b8aa:	f88d 0016 	strb.w	r0, [sp, #22]
		rssi_ready = radio_rssi_is_ready();
    b8ae:	f000 fc5b 	bl	c168 <radio_rssi_is_ready>
    b8b2:	b2c3      	uxtb	r3, r0
    b8b4:	9302      	str	r3, [sp, #8]
		phy_aux_flags_rx = radio_phy_flags_rx_get();
    b8b6:	f006 fa14 	bl	11ce2 <radio_phy_flags_rx_get>
    b8ba:	4680      	mov	r8, r0
	lll_isr_rx_status_reset();
    b8bc:	f005 ff97 	bl	117ee <lll_isr_rx_status_reset>
	if (!trx_done || !crc_ok) {
    b8c0:	2c00      	cmp	r4, #0
    b8c2:	f000 80bd 	beq.w	ba40 <isr_rx+0x1d0>
    b8c6:	2f00      	cmp	r7, #0
    b8c8:	f000 80ba 	beq.w	ba40 <isr_rx+0x1d0>
	node_rx = ull_pdu_rx_alloc_peek(3);
    b8cc:	2003      	movs	r0, #3
    b8ce:	f7fa fef1 	bl	66b4 <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
    b8d2:	4604      	mov	r4, r0
    b8d4:	2800      	cmp	r0, #0
    b8d6:	f000 80b3 	beq.w	ba40 <isr_rx+0x1d0>
	if ((pdu->type != PDU_ADV_TYPE_EXT_IND) || !pdu->len) {
    b8da:	7f03      	ldrb	r3, [r0, #28]
    b8dc:	f003 030f 	and.w	r3, r3, #15
    b8e0:	2b07      	cmp	r3, #7
    b8e2:	f040 80ad 	bne.w	ba40 <isr_rx+0x1d0>
    b8e6:	7f43      	ldrb	r3, [r0, #29]
    b8e8:	2b00      	cmp	r3, #0
    b8ea:	f000 80a9 	beq.w	ba40 <isr_rx+0x1d0>
	has_adva = lll_scan_aux_addr_match_get(lll, pdu, &devmatch_ok,
    b8ee:	f10d 0316 	add.w	r3, sp, #22
	pdu = (void *)node_rx->pdu;
    b8f2:	f100 0a1c 	add.w	sl, r0, #28
	has_adva = lll_scan_aux_addr_match_get(lll, pdu, &devmatch_ok,
    b8f6:	9301      	str	r3, [sp, #4]
    b8f8:	f10d 0315 	add.w	r3, sp, #21
    b8fc:	9300      	str	r3, [sp, #0]
    b8fe:	f10d 0213 	add.w	r2, sp, #19
    b902:	ab05      	add	r3, sp, #20
    b904:	4651      	mov	r1, sl
    b906:	4628      	mov	r0, r5
    b908:	f006 f93e 	bl	11b88 <lll_scan_aux_addr_match_get>
	rl_idx = devmatch_ok ?
    b90c:	f89d 3013 	ldrb.w	r3, [sp, #19]
	has_adva = lll_scan_aux_addr_match_get(lll, pdu, &devmatch_ok,
    b910:	4683      	mov	fp, r0
	rl_idx = devmatch_ok ?
    b912:	2b00      	cmp	r3, #0
    b914:	d07f      	beq.n	ba16 <isr_rx+0x1a6>
		 ull_filter_lll_rl_idx(((lll->filter_policy &
    b916:	7928      	ldrb	r0, [r5, #4]
    b918:	f89d 1014 	ldrb.w	r1, [sp, #20]
    b91c:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    b920:	f7fd faf0 	bl	8f04 <ull_filter_lll_rl_idx>
		 irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    b924:	4607      	mov	r7, r0
	if (has_adva &&
    b926:	f1bb 0f00 	cmp.w	fp, #0
    b92a:	d17e      	bne.n	ba2a <isr_rx+0x1ba>
	bool dir_report = false;
    b92c:	2300      	movs	r3, #0
	err = isr_rx_pdu(lll, lll_aux, node_rx, pdu, phy_aux, phy_aux_flags_rx,
    b92e:	f89d b015 	ldrb.w	fp, [sp, #21]
	bool dir_report = false;
    b932:	f88d 3017 	strb.w	r3, [sp, #23]
	} else if (lll && lll->type &&
    b936:	2d00      	cmp	r5, #0
    b938:	f040 80a4 	bne.w	ba84 <isr_rx+0x214>
	} else if ((lll_aux && lll_aux->is_chain_sched) ||
    b93c:	2e00      	cmp	r6, #0
    b93e:	f000 8164 	beq.w	bc0a <isr_rx+0x39a>
    b942:	f996 3004 	ldrsb.w	r3, [r6, #4]
    b946:	2b00      	cmp	r3, #0
    b948:	f280 815f 	bge.w	bc0a <isr_rx+0x39a>
			ftr->scan_rsp = lll_aux->state;
    b94c:	7933      	ldrb	r3, [r6, #4]
    b94e:	7ee2      	ldrb	r2, [r4, #27]
			ftr->param = lll_aux;
    b950:	60a6      	str	r6, [r4, #8]
			ftr->scan_rsp = lll_aux->state;
    b952:	f3c3 1380 	ubfx	r3, r3, #6, #1
    b956:	f363 0200 	bfi	r2, r3, #0, #1
    b95a:	76e2      	strb	r2, [r4, #27]
			lll_aux->is_chain_sched = 1U;
    b95c:	7933      	ldrb	r3, [r6, #4]
    b95e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    b962:	7133      	strb	r3, [r6, #4]
		(void)ull_pdu_rx_alloc();
    b964:	f7fa febe 	bl	66e4 <ull_pdu_rx_alloc>
		ftr->ticks_anchor = radio_tmr_start_get();
    b968:	f000 fcfa 	bl	c360 <radio_tmr_start_get>
    b96c:	6120      	str	r0, [r4, #16]
		ftr->radio_end_us = radio_tmr_end_get() -
    b96e:	f000 fd1d 	bl	c3ac <radio_tmr_end_get>
				    radio_rx_chain_delay_get(phy_aux,
    b972:	4641      	mov	r1, r8
		ftr->radio_end_us = radio_tmr_end_get() -
    b974:	9003      	str	r0, [sp, #12]
				    radio_rx_chain_delay_get(phy_aux,
    b976:	4648      	mov	r0, r9
    b978:	f006 f9ae 	bl	11cd8 <radio_rx_chain_delay_get>
		ftr->radio_end_us = radio_tmr_end_get() -
    b97c:	9b03      	ldr	r3, [sp, #12]
    b97e:	1a1b      	subs	r3, r3, r0
    b980:	6163      	str	r3, [r4, #20]
		ftr->phy_flags = phy_aux_flags_rx;
    b982:	7ea3      	ldrb	r3, [r4, #26]
    b984:	f368 1386 	bfi	r3, r8, #6, #1
    b988:	76a3      	strb	r3, [r4, #26]
		ftr->rssi = (rssi_ready) ? radio_rssi_get() :
    b98a:	9b02      	ldr	r3, [sp, #8]
    b98c:	2b00      	cmp	r3, #0
    b98e:	f000 8167 	beq.w	bc60 <isr_rx+0x3f0>
    b992:	f000 fbdb 	bl	c14c <radio_rssi_get>
    b996:	b2c0      	uxtb	r0, r0
		ftr->scan_req = 0U;
    b998:	7ea3      	ldrb	r3, [r4, #26]
		ftr->direct = dir_report;
    b99a:	f89d 2017 	ldrb.w	r2, [sp, #23]
		ftr->rssi = (rssi_ready) ? radio_rssi_get() :
    b99e:	7620      	strb	r0, [r4, #24]
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
    b9a0:	f1bb 0f00 	cmp.w	fp, #0
		ftr->direct = dir_report;
    b9a4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
    b9a8:	bf08      	it	eq
    b9aa:	27ff      	moveq	r7, #255	; 0xff
		ftr->direct = dir_report;
    b9ac:	f362 0341 	bfi	r3, r2, #1, #1
    b9b0:	76a3      	strb	r3, [r4, #26]
		ftr->aux_lll_sched = lll_scan_aux_setup(pdu, phy_aux,
    b9b2:	4642      	mov	r2, r8
    b9b4:	4bab      	ldr	r3, [pc, #684]	; (bc64 <isr_rx+0x3f4>)
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
    b9b6:	7667      	strb	r7, [r4, #25]
		ftr->aux_lll_sched = lll_scan_aux_setup(pdu, phy_aux,
    b9b8:	4649      	mov	r1, r9
    b9ba:	9500      	str	r5, [sp, #0]
    b9bc:	4650      	mov	r0, sl
    b9be:	f7ff feb7 	bl	b730 <lll_scan_aux_setup>
    b9c2:	7ea3      	ldrb	r3, [r4, #26]
    b9c4:	f360 03c3 	bfi	r3, r0, #3, #1
    b9c8:	76a3      	strb	r3, [r4, #26]
		node_rx->hdr.type = NODE_RX_TYPE_EXT_AUX_REPORT;
    b9ca:	2309      	movs	r3, #9
    b9cc:	7123      	strb	r3, [r4, #4]
		ull_rx_put(node_rx->hdr.link, node_rx);
    b9ce:	6820      	ldr	r0, [r4, #0]
    b9d0:	4621      	mov	r1, r4
    b9d2:	f7fa fe9d 	bl	6710 <ull_rx_put>
		ull_rx_sched();
    b9d6:	f7fa fea1 	bl	671c <ull_rx_sched>
		trx_cnt++;
    b9da:	4aa3      	ldr	r2, [pc, #652]	; (bc68 <isr_rx+0x3f8>)
    b9dc:	8813      	ldrh	r3, [r2, #0]
    b9de:	3301      	adds	r3, #1
    b9e0:	8013      	strh	r3, [r2, #0]
		if (ftr->aux_lll_sched) {
    b9e2:	7ea3      	ldrb	r3, [r4, #26]
    b9e4:	071a      	lsls	r2, r3, #28
    b9e6:	f100 80f5 	bmi.w	bbd4 <isr_rx+0x364>
	if (lll_aux) {
    b9ea:	2e00      	cmp	r6, #0
    b9ec:	d044      	beq.n	ba78 <isr_rx+0x208>
		radio_isr_set(isr_done, NULL);
    b9ee:	489f      	ldr	r0, [pc, #636]	; (bc6c <isr_rx+0x3fc>)
    b9f0:	2100      	movs	r1, #0
			radio_isr_set(lll_scan_isr_resume, lll);
    b9f2:	f000 f9e3 	bl	bdbc <radio_isr_set>
	radio_disable();
    b9f6:	f000 faa9 	bl	bf4c <radio_disable>
    b9fa:	e0eb      	b.n	bbd4 <isr_rx+0x364>
		devmatch_id = irkmatch_id = 0xFF;
    b9fc:	23ff      	movs	r3, #255	; 0xff
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready =
    b9fe:	f88d 4015 	strb.w	r4, [sp, #21]
    ba02:	f88d 4013 	strb.w	r4, [sp, #19]
		devmatch_id = irkmatch_id = 0xFF;
    ba06:	f88d 3016 	strb.w	r3, [sp, #22]
    ba0a:	f88d 3014 	strb.w	r3, [sp, #20]
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready =
    ba0e:	4627      	mov	r7, r4
    ba10:	9402      	str	r4, [sp, #8]
			phy_aux_flags_rx = 0U;
    ba12:	46a0      	mov	r8, r4
    ba14:	e752      	b.n	b8bc <isr_rx+0x4c>
	rl_idx = devmatch_ok ?
    ba16:	f89d 3015 	ldrb.w	r3, [sp, #21]
    ba1a:	b123      	cbz	r3, ba26 <isr_rx+0x1b6>
		 irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    ba1c:	f89d 0016 	ldrb.w	r0, [sp, #22]
    ba20:	f7fd facc 	bl	8fbc <ull_filter_lll_rl_irk_idx>
    ba24:	e77e      	b.n	b924 <isr_rx+0xb4>
	rl_idx = devmatch_ok ?
    ba26:	27ff      	movs	r7, #255	; 0xff
    ba28:	e77d      	b.n	b926 <isr_rx+0xb6>
	    !lll_scan_isr_rx_check(lll, irkmatch_ok, devmatch_ok, rl_idx)) {
    ba2a:	f89d 2013 	ldrb.w	r2, [sp, #19]
    ba2e:	f89d 1015 	ldrb.w	r1, [sp, #21]
    ba32:	463b      	mov	r3, r7
    ba34:	4628      	mov	r0, r5
    ba36:	f006 f83b 	bl	11ab0 <lll_scan_isr_rx_check>
	if (has_adva &&
    ba3a:	2800      	cmp	r0, #0
    ba3c:	f47f af76 	bne.w	b92c <isr_rx+0xbc>
	if (lll_aux) {
    ba40:	2e00      	cmp	r6, #0
    ba42:	d1d4      	bne.n	b9ee <isr_rx+0x17e>
			node_rx = ull_pdu_rx_alloc();
    ba44:	f7fa fe4e 	bl	66e4 <ull_pdu_rx_alloc>
			LL_ASSERT(node_rx);
    ba48:	4604      	mov	r4, r0
    ba4a:	b960      	cbnz	r0, ba66 <isr_rx+0x1f6>
    ba4c:	4a88      	ldr	r2, [pc, #544]	; (bc70 <isr_rx+0x400>)
    ba4e:	4989      	ldr	r1, [pc, #548]	; (bc74 <isr_rx+0x404>)
    ba50:	4889      	ldr	r0, [pc, #548]	; (bc78 <isr_rx+0x408>)
    ba52:	f240 330a 	movw	r3, #778	; 0x30a
    ba56:	f003 fd36 	bl	f4c6 <printk>
    ba5a:	4040      	eors	r0, r0
    ba5c:	f380 8811 	msr	BASEPRI, r0
    ba60:	f04f 0003 	mov.w	r0, #3
    ba64:	df02      	svc	2
			node_rx->hdr.type = NODE_RX_TYPE_EXT_AUX_RELEASE;
    ba66:	230a      	movs	r3, #10
			ull_rx_put(node_rx->hdr.link, node_rx);
    ba68:	6820      	ldr	r0, [r4, #0]
			node_rx->hdr.type = NODE_RX_TYPE_EXT_AUX_RELEASE;
    ba6a:	7123      	strb	r3, [r4, #4]
			ull_rx_put(node_rx->hdr.link, node_rx);
    ba6c:	4621      	mov	r1, r4
			node_rx->hdr.rx_ftr.param = lll;
    ba6e:	60a5      	str	r5, [r4, #8]
			ull_rx_put(node_rx->hdr.link, node_rx);
    ba70:	f7fa fe4e 	bl	6710 <ull_rx_put>
			ull_rx_sched();
    ba74:	f7fa fe52 	bl	671c <ull_rx_sched>
		if (lll->is_aux_sched) {
    ba78:	7aab      	ldrb	r3, [r5, #10]
    ba7a:	06db      	lsls	r3, r3, #27
    ba7c:	d5b7      	bpl.n	b9ee <isr_rx+0x17e>
			radio_isr_set(lll_scan_isr_resume, lll);
    ba7e:	487f      	ldr	r0, [pc, #508]	; (bc7c <isr_rx+0x40c>)
    ba80:	4629      	mov	r1, r5
    ba82:	e7b6      	b.n	b9f2 <isr_rx+0x182>
	} else if (lll && lll->type &&
    ba84:	792b      	ldrb	r3, [r5, #4]
    ba86:	069b      	lsls	r3, r3, #26
    ba88:	f57f af58 	bpl.w	b93c <isr_rx+0xcc>
    ba8c:	b116      	cbz	r6, ba94 <isr_rx+0x224>
		   ((lll_aux && !lll_aux->state) ||
    ba8e:	7933      	ldrb	r3, [r6, #4]
    ba90:	0658      	lsls	r0, r3, #25
    ba92:	d507      	bpl.n	baa4 <isr_rx+0x234>
		    (lll->lll_aux && !lll->lll_aux->state)) &&
    ba94:	68eb      	ldr	r3, [r5, #12]
		   ((lll_aux && !lll_aux->state) ||
    ba96:	2b00      	cmp	r3, #0
    ba98:	f43f af50 	beq.w	b93c <isr_rx+0xcc>
		    (lll->lll_aux && !lll->lll_aux->state)) &&
    ba9c:	791b      	ldrb	r3, [r3, #4]
    ba9e:	0659      	lsls	r1, r3, #25
    baa0:	f53f af4c 	bmi.w	b93c <isr_rx+0xcc>
		   (pdu->adv_ext_ind.adv_mode & BT_HCI_LE_ADV_PROP_SCAN) &&
    baa4:	7fa3      	ldrb	r3, [r4, #30]
		    (lll->lll_aux && !lll->lll_aux->state)) &&
    baa6:	09db      	lsrs	r3, r3, #7
    baa8:	f43f af48 	beq.w	b93c <isr_rx+0xcc>
		   lll_scan_ext_tgta_check(lll, false, false, pdu, rl_idx,
    baac:	f10d 0317 	add.w	r3, sp, #23
    bab0:	2200      	movs	r2, #0
    bab2:	e9cd 7300 	strd	r7, r3, [sp]
    bab6:	4611      	mov	r1, r2
    bab8:	4653      	mov	r3, sl
    baba:	4628      	mov	r0, r5
    babc:	f006 f827 	bl	11b0e <lll_scan_ext_tgta_check>
		   (pdu->adv_ext_ind.adv_mode & BT_HCI_LE_ADV_PROP_SCAN) &&
    bac0:	2800      	cmp	r0, #0
    bac2:	f43f af3b 	beq.w	b93c <isr_rx+0xcc>
		rx = ull_pdu_rx_alloc_peek(4);
    bac6:	2004      	movs	r0, #4
    bac8:	f7fa fdf4 	bl	66b4 <ull_pdu_rx_alloc_peek>
		if (!rx) {
    bacc:	2800      	cmp	r0, #0
    bace:	d0b7      	beq.n	ba40 <isr_rx+0x1d0>
		radio_tmr_tifs_set(EVENT_IFS_US);
    bad0:	2096      	movs	r0, #150	; 0x96
    bad2:	f000 fbad 	bl	c230 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(phy_aux);
    bad6:	4648      	mov	r0, r9
    bad8:	f000 fafc 	bl	c0d4 <radio_switch_complete_and_rx>
		pdu_tx = (void *)radio_pkt_scratch_get();
    badc:	f000 fa88 	bl	bff0 <radio_pkt_scratch_get>
		pdu_tx->rx_addr = pdu->tx_addr;
    bae0:	7f23      	ldrb	r3, [r4, #28]
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
    bae2:	7802      	ldrb	r2, [r0, #0]
		pdu_tx->rx_addr = pdu->tx_addr;
    bae4:	f3c3 1380 	ubfx	r3, r3, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
    bae8:	01db      	lsls	r3, r3, #7
    baea:	f002 0270 	and.w	r2, r2, #112	; 0x70
    baee:	f043 0303 	orr.w	r3, r3, #3
    baf2:	4313      	orrs	r3, r2
    baf4:	7003      	strb	r3, [r0, #0]
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
    baf6:	230c      	movs	r3, #12
    baf8:	7043      	strb	r3, [r0, #1]
		pdu_tx = (void *)radio_pkt_scratch_get();
    bafa:	4682      	mov	sl, r0
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
    bafc:	4638      	mov	r0, r7
    bafe:	f7fd f9e1 	bl	8ec4 <ull_filter_lll_lrpa_get>
		if (lll->rpa_gen && lrpa) {
    bb02:	7c2b      	ldrb	r3, [r5, #16]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
    bb04:	4601      	mov	r1, r0
		if (lll->rpa_gen && lrpa) {
    bb06:	4650      	mov	r0, sl
    bb08:	f013 0f01 	tst.w	r3, #1
    bb0c:	f810 3b02 	ldrb.w	r3, [r0], #2
    bb10:	d063      	beq.n	bbda <isr_rx+0x36a>
    bb12:	2900      	cmp	r1, #0
    bb14:	d061      	beq.n	bbda <isr_rx+0x36a>
			pdu_tx->tx_addr = 1;
    bb16:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    bb1a:	f88a 3000 	strb.w	r3, [sl]
			(void)memcpy(pdu_tx->scan_req.scan_addr, lrpa->val,
    bb1e:	2206      	movs	r2, #6
			(void)memcpy(pdu_tx->scan_req.scan_addr, lll->init_addr,
    bb20:	f004 f841 	bl	fba6 <memcpy>
		(void)memcpy(pdu_tx->scan_req.adv_addr,
    bb24:	2206      	movs	r2, #6
    bb26:	f104 0120 	add.w	r1, r4, #32
    bb2a:	f10a 0008 	add.w	r0, sl, #8
    bb2e:	f004 f83a 	bl	fba6 <memcpy>
		radio_pkt_tx_set(pdu_tx);
    bb32:	4650      	mov	r0, sl
    bb34:	f000 f9fe 	bl	bf34 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
    bb38:	f000 fa26 	bl	bf88 <radio_is_ready>
    bb3c:	b160      	cbz	r0, bb58 <isr_rx+0x2e8>
    bb3e:	4a4c      	ldr	r2, [pc, #304]	; (bc70 <isr_rx+0x400>)
    bb40:	494f      	ldr	r1, [pc, #316]	; (bc80 <isr_rx+0x410>)
    bb42:	484d      	ldr	r0, [pc, #308]	; (bc78 <isr_rx+0x408>)
    bb44:	f240 4332 	movw	r3, #1074	; 0x432
    bb48:	f003 fcbd 	bl	f4c6 <printk>
    bb4c:	4040      	eors	r0, r0
    bb4e:	f380 8811 	msr	BASEPRI, r0
    bb52:	f04f 0003 	mov.w	r0, #3
    bb56:	df02      	svc	2
		radio_tmr_end_capture();
    bb58:	f000 fc20 	bl	c39c <radio_tmr_end_capture>
		(void)ull_pdu_rx_alloc();
    bb5c:	f7fa fdc2 	bl	66e4 <ull_pdu_rx_alloc>
		node_rx->hdr.type = NODE_RX_TYPE_EXT_AUX_REPORT;
    bb60:	2309      	movs	r3, #9
    bb62:	7123      	strb	r3, [r4, #4]
		if (lll_aux) {
    bb64:	2e00      	cmp	r6, #0
    bb66:	d043      	beq.n	bbf0 <isr_rx+0x380>
			radio_isr_set(isr_tx_scan_req_ull_schedule,
    bb68:	4846      	ldr	r0, [pc, #280]	; (bc84 <isr_rx+0x414>)
			ftr->param = lll_aux;
    bb6a:	60a6      	str	r6, [r4, #8]
			radio_isr_set(isr_tx_scan_req_ull_schedule,
    bb6c:	4631      	mov	r1, r6
    bb6e:	f000 f925 	bl	bdbc <radio_isr_set>
			lll_aux->state = 1U;
    bb72:	7933      	ldrb	r3, [r6, #4]
    bb74:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    bb78:	7133      	strb	r3, [r6, #4]
		ftr->ticks_anchor = radio_tmr_start_get();
    bb7a:	f000 fbf1 	bl	c360 <radio_tmr_start_get>
    bb7e:	6120      	str	r0, [r4, #16]
		ftr->radio_end_us = radio_tmr_end_get() -
    bb80:	f000 fc14 	bl	c3ac <radio_tmr_end_get>
				    radio_rx_chain_delay_get(phy_aux,
    bb84:	4641      	mov	r1, r8
		ftr->radio_end_us = radio_tmr_end_get() -
    bb86:	4605      	mov	r5, r0
				    radio_rx_chain_delay_get(phy_aux,
    bb88:	4648      	mov	r0, r9
    bb8a:	f006 f8a5 	bl	11cd8 <radio_rx_chain_delay_get>
		ftr->rssi = (rssi_ready) ? radio_rssi_get() :
    bb8e:	9b02      	ldr	r3, [sp, #8]
		ftr->radio_end_us = radio_tmr_end_get() -
    bb90:	1a2d      	subs	r5, r5, r0
    bb92:	6165      	str	r5, [r4, #20]
		ftr->rssi = (rssi_ready) ? radio_rssi_get() :
    bb94:	2b00      	cmp	r3, #0
    bb96:	d036      	beq.n	bc06 <isr_rx+0x396>
    bb98:	f000 fad8 	bl	c14c <radio_rssi_get>
    bb9c:	b2c0      	uxtb	r0, r0
		ftr->scan_req = 1U;
    bb9e:	8b63      	ldrh	r3, [r4, #26]
		ftr->direct = dir_report;
    bba0:	f89d 2017 	ldrb.w	r2, [sp, #23]
		ftr->rssi = (rssi_ready) ? radio_rssi_get() :
    bba4:	7620      	strb	r0, [r4, #24]
		ftr->scan_req = 1U;
    bba6:	f423 73c0 	bic.w	r3, r3, #384	; 0x180
    bbaa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
		ftr->direct = dir_report;
    bbae:	0052      	lsls	r2, r2, #1
		ftr->scan_req = 1U;
    bbb0:	8363      	strh	r3, [r4, #26]
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
    bbb2:	f1bb 0f00 	cmp.w	fp, #0
		ftr->direct = dir_report;
    bbb6:	f002 020a 	and.w	r2, r2, #10
    bbba:	f003 03f5 	and.w	r3, r3, #245	; 0xf5
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
    bbbe:	bf08      	it	eq
    bbc0:	27ff      	moveq	r7, #255	; 0xff
		ftr->direct = dir_report;
    bbc2:	4313      	orrs	r3, r2
		ull_rx_put(node_rx->hdr.link, node_rx);
    bbc4:	6820      	ldr	r0, [r4, #0]
		ftr->direct = dir_report;
    bbc6:	76a3      	strb	r3, [r4, #26]
		ull_rx_put(node_rx->hdr.link, node_rx);
    bbc8:	4621      	mov	r1, r4
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
    bbca:	7667      	strb	r7, [r4, #25]
		ull_rx_put(node_rx->hdr.link, node_rx);
    bbcc:	f7fa fda0 	bl	6710 <ull_rx_put>
		ull_rx_sched();
    bbd0:	f7fa fda4 	bl	671c <ull_rx_sched>
}
    bbd4:	b007      	add	sp, #28
    bbd6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			pdu_tx->tx_addr = lll->init_addr_type;
    bbda:	792a      	ldrb	r2, [r5, #4]
    bbdc:	f3c2 1280 	ubfx	r2, r2, #6, #1
    bbe0:	f362 1386 	bfi	r3, r2, #6, #1
    bbe4:	f88a 3000 	strb.w	r3, [sl]
			(void)memcpy(pdu_tx->scan_req.scan_addr, lll->init_addr,
    bbe8:	2206      	movs	r2, #6
    bbea:	f105 0112 	add.w	r1, r5, #18
    bbee:	e797      	b.n	bb20 <isr_rx+0x2b0>
			radio_isr_set(isr_tx_scan_req_lll_schedule,
    bbf0:	4825      	ldr	r0, [pc, #148]	; (bc88 <isr_rx+0x418>)
			ftr->param = lll;
    bbf2:	60a5      	str	r5, [r4, #8]
			radio_isr_set(isr_tx_scan_req_lll_schedule,
    bbf4:	4621      	mov	r1, r4
    bbf6:	f000 f8e1 	bl	bdbc <radio_isr_set>
			lll->lll_aux->state = 1U;
    bbfa:	68ea      	ldr	r2, [r5, #12]
    bbfc:	7913      	ldrb	r3, [r2, #4]
    bbfe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    bc02:	7113      	strb	r3, [r2, #4]
    bc04:	e7b9      	b.n	bb7a <isr_rx+0x30a>
		ftr->rssi = (rssi_ready) ? radio_rssi_get() :
    bc06:	207f      	movs	r0, #127	; 0x7f
    bc08:	e7c9      	b.n	bb9e <isr_rx+0x32e>
		   (lll->lll_aux && lll->lll_aux->is_chain_sched) ||
    bc0a:	68eb      	ldr	r3, [r5, #12]
	} else if ((lll_aux && lll_aux->is_chain_sched) ||
    bc0c:	b1db      	cbz	r3, bc46 <isr_rx+0x3d6>
		   (lll->lll_aux && lll->lll_aux->is_chain_sched) ||
    bc0e:	f993 3004 	ldrsb.w	r3, [r3, #4]
    bc12:	2b00      	cmp	r3, #0
    bc14:	da17      	bge.n	bc46 <isr_rx+0x3d6>
		if (lll_aux) {
    bc16:	2e00      	cmp	r6, #0
    bc18:	f47f ae98 	bne.w	b94c <isr_rx+0xdc>
		} else if (lll->lll_aux) {
    bc1c:	68eb      	ldr	r3, [r5, #12]
    bc1e:	2b00      	cmp	r3, #0
    bc20:	f43f af10 	beq.w	ba44 <isr_rx+0x1d4>
			ftr->scan_rsp = lll->lll_aux->state;
    bc24:	791a      	ldrb	r2, [r3, #4]
    bc26:	7ee1      	ldrb	r1, [r4, #27]
			ftr->param = lll;
    bc28:	60a5      	str	r5, [r4, #8]
			ftr->scan_rsp = lll->lll_aux->state;
    bc2a:	f3c2 1280 	ubfx	r2, r2, #6, #1
    bc2e:	f362 0100 	bfi	r1, r2, #0, #1
    bc32:	76e1      	strb	r1, [r4, #27]
			lll->is_aux_sched = 1U;
    bc34:	7aaa      	ldrb	r2, [r5, #10]
    bc36:	f042 0210 	orr.w	r2, r2, #16
    bc3a:	72aa      	strb	r2, [r5, #10]
			lll->lll_aux->is_chain_sched = 1U;
    bc3c:	791a      	ldrb	r2, [r3, #4]
    bc3e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    bc42:	711a      	strb	r2, [r3, #4]
    bc44:	e68e      	b.n	b964 <isr_rx+0xf4>
		   lll_scan_ext_tgta_check(lll, false, false, pdu, rl_idx,
    bc46:	f10d 0317 	add.w	r3, sp, #23
    bc4a:	2200      	movs	r2, #0
    bc4c:	e9cd 7300 	strd	r7, r3, [sp]
    bc50:	4611      	mov	r1, r2
    bc52:	4653      	mov	r3, sl
    bc54:	4628      	mov	r0, r5
    bc56:	f005 ff5a 	bl	11b0e <lll_scan_ext_tgta_check>
		   (lll->lll_aux && lll->lll_aux->is_chain_sched) ||
    bc5a:	2800      	cmp	r0, #0
    bc5c:	d1db      	bne.n	bc16 <isr_rx+0x3a6>
    bc5e:	e6ef      	b.n	ba40 <isr_rx+0x1d0>
		ftr->rssi = (rssi_ready) ? radio_rssi_get() :
    bc60:	207f      	movs	r0, #127	; 0x7f
    bc62:	e699      	b.n	b998 <isr_rx+0x128>
    bc64:	0000b405 	.word	0x0000b405
    bc68:	20002902 	.word	0x20002902
    bc6c:	0000b369 	.word	0x0000b369
    bc70:	00013f09 	.word	0x00013f09
    bc74:	00013ddd 	.word	0x00013ddd
    bc78:	000133b6 	.word	0x000133b6
    bc7c:	0000ae71 	.word	0x0000ae71
    bc80:	00013de5 	.word	0x00013de5
    bc84:	0000b675 	.word	0x0000b675
    bc88:	0000b629 	.word	0x0000b629

0000bc8c <cntr_init>:

static uint8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
    bc8c:	4b05      	ldr	r3, [pc, #20]	; (bca4 <cntr_init+0x18>)
    bc8e:	2200      	movs	r2, #0
    bc90:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    bc94:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    bc98:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
    bc9c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
    bca0:	4770      	bx	lr
    bca2:	bf00      	nop
    bca4:	4000b000 	.word	0x4000b000

0000bca8 <cntr_start>:

uint32_t cntr_start(void)
{
	if (_refcount++) {
    bca8:	4a04      	ldr	r2, [pc, #16]	; (bcbc <cntr_start+0x14>)
    bcaa:	7813      	ldrb	r3, [r2, #0]
    bcac:	1c59      	adds	r1, r3, #1
    bcae:	7011      	strb	r1, [r2, #0]
    bcb0:	2001      	movs	r0, #1
    bcb2:	b913      	cbnz	r3, bcba <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    bcb4:	4a02      	ldr	r2, [pc, #8]	; (bcc0 <cntr_start+0x18>)
    bcb6:	6010      	str	r0, [r2, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
    bcb8:	4618      	mov	r0, r3
}
    bcba:	4770      	bx	lr
    bcbc:	20002a79 	.word	0x20002a79
    bcc0:	4000b000 	.word	0x4000b000

0000bcc4 <cntr_stop>:

uint32_t cntr_stop(void)
{
    bcc4:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
    bcc6:	4c0d      	ldr	r4, [pc, #52]	; (bcfc <cntr_stop+0x38>)
    bcc8:	7823      	ldrb	r3, [r4, #0]
    bcca:	b95b      	cbnz	r3, bce4 <cntr_stop+0x20>
    bccc:	4a0c      	ldr	r2, [pc, #48]	; (bd00 <cntr_stop+0x3c>)
    bcce:	490d      	ldr	r1, [pc, #52]	; (bd04 <cntr_stop+0x40>)
    bcd0:	480d      	ldr	r0, [pc, #52]	; (bd08 <cntr_stop+0x44>)
    bcd2:	232d      	movs	r3, #45	; 0x2d
    bcd4:	f003 fbf7 	bl	f4c6 <printk>
    bcd8:	4040      	eors	r0, r0
    bcda:	f380 8811 	msr	BASEPRI, r0
    bcde:	f04f 0003 	mov.w	r0, #3
    bce2:	df02      	svc	2

	if (--_refcount) {
    bce4:	7820      	ldrb	r0, [r4, #0]
    bce6:	3801      	subs	r0, #1
    bce8:	b2c0      	uxtb	r0, r0
    bcea:	7020      	strb	r0, [r4, #0]
    bcec:	2301      	movs	r3, #1
    bcee:	b910      	cbnz	r0, bcf6 <cntr_stop+0x32>
    bcf0:	4a06      	ldr	r2, [pc, #24]	; (bd0c <cntr_stop+0x48>)
    bcf2:	6053      	str	r3, [r2, #4]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
    bcf4:	bd10      	pop	{r4, pc}
		return 1;
    bcf6:	4618      	mov	r0, r3
    bcf8:	e7fc      	b.n	bcf4 <cntr_stop+0x30>
    bcfa:	bf00      	nop
    bcfc:	20002a79 	.word	0x20002a79
    bd00:	00013f58 	.word	0x00013f58
    bd04:	00013fa4 	.word	0x00013fa4
    bd08:	000133b6 	.word	0x000133b6
    bd0c:	4000b000 	.word	0x4000b000

0000bd10 <cntr_cnt_get>:
     return p_reg->COUNTER;
    bd10:	4b01      	ldr	r3, [pc, #4]	; (bd18 <cntr_cnt_get+0x8>)
    bd12:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

uint32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
    bd16:	4770      	bx	lr
    bd18:	4000b000 	.word	0x4000b000

0000bd1c <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
    bd1c:	4b02      	ldr	r3, [pc, #8]	; (bd28 <cntr_cmp_set+0xc>)
    bd1e:	f500 70a8 	add.w	r0, r0, #336	; 0x150
    bd22:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(uint8_t cmp, uint32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
    bd26:	4770      	bx	lr
    bd28:	4000b000 	.word	0x4000b000

0000bd2c <do_ecb>:

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bd2c:	4b10      	ldr	r3, [pc, #64]	; (bd70 <do_ecb+0x44>)
	uint8_t clear_text[16];
	uint8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
    bd2e:	b530      	push	{r4, r5, lr}
    bd30:	2201      	movs	r2, #1
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
		NRF_ECB->EVENTS_ENDECB = 0;
    bd32:	2400      	movs	r4, #0
    bd34:	605a      	str	r2, [r3, #4]
		NRF_ECB->ECBDATAPTR = (uint32_t)ecb;
    bd36:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
    bd3a:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
    bd3e:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
    bd42:	601a      	str	r2, [r3, #0]
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
    bd44:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    bd48:	b931      	cbnz	r1, bd58 <do_ecb+0x2c>
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
    bd4a:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
    bd4e:	b919      	cbnz	r1, bd58 <do_ecb+0x2c>
		       (NRF_ECB->ECBDATAPTR != 0)) {
    bd50:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
    bd54:	2900      	cmp	r1, #0
    bd56:	d1f5      	bne.n	bd44 <do_ecb+0x18>
    bd58:	605a      	str	r2, [r3, #4]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
    bd5a:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
    bd5e:	2900      	cmp	r1, #0
    bd60:	d1e8      	bne.n	bd34 <do_ecb+0x8>
    bd62:	f8d3 5504 	ldr.w	r5, [r3, #1284]	; 0x504
    bd66:	2d00      	cmp	r5, #0
    bd68:	d0e4      	beq.n	bd34 <do_ecb+0x8>

	NRF_ECB->ECBDATAPTR = 0;
    bd6a:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
}
    bd6e:	bd30      	pop	{r4, r5, pc}
    bd70:	4000e000 	.word	0x4000e000

0000bd74 <hal_radio_enable_on_tick_ppi_config_and_enable>:
static inline void hal_radio_enable_on_tick_ppi_config_and_enable(uint8_t trx)
{
	/* No need to configure anything for the pre-programmed channels.
	 * Just enable and disable them accordingly.
	 */
	nrf_ppi_channels_disable(
    bd74:	2800      	cmp	r0, #0
    p_reg->CHENSET = mask;
}

NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask)
{
    p_reg->CHENCLR = mask;
    bd76:	4b08      	ldr	r3, [pc, #32]	; (bd98 <hal_radio_enable_on_tick_ppi_config_and_enable+0x24>)
    bd78:	bf14      	ite	ne
    bd7a:	f44f 1200 	movne.w	r2, #2097152	; 0x200000
    bd7e:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
    bd82:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI));
	nrf_ppi_channels_enable(
    bd86:	bf14      	ite	ne
    bd88:	f44f 1280 	movne.w	r2, #1048576	; 0x100000
    bd8c:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
    p_reg->CHENSET = mask;
    bd90:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI));
}
    bd94:	4770      	bx	lr
    bd96:	bf00      	nop
    bd98:	4001f000 	.word	0x4001f000

0000bd9c <isr_radio>:
}
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

uint32_t radio_has_disabled(void)
{
	return (NRF_RADIO->EVENTS_DISABLED != 0);
    bd9c:	4b04      	ldr	r3, [pc, #16]	; (bdb0 <isr_radio+0x14>)
    bd9e:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
    bda2:	b123      	cbz	r3, bdae <isr_radio+0x12>
		isr_cb(isr_cb_param);
    bda4:	4b03      	ldr	r3, [pc, #12]	; (bdb4 <isr_radio+0x18>)
    bda6:	4a04      	ldr	r2, [pc, #16]	; (bdb8 <isr_radio+0x1c>)
    bda8:	681b      	ldr	r3, [r3, #0]
    bdaa:	6810      	ldr	r0, [r2, #0]
    bdac:	4718      	bx	r3
}
    bdae:	4770      	bx	lr
    bdb0:	40001000 	.word	0x40001000
    bdb4:	200024cc 	.word	0x200024cc
    bdb8:	200024d0 	.word	0x200024d0

0000bdbc <radio_isr_set>:
{
    bdbc:	b538      	push	{r3, r4, r5, lr}
    bdbe:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
    bdc0:	2001      	movs	r0, #1
{
    bdc2:	460d      	mov	r5, r1
	irq_disable(RADIO_IRQn);
    bdc4:	f7f6 fb90 	bl	24e8 <arch_irq_disable>
	isr_cb_param = param;
    bdc8:	4b08      	ldr	r3, [pc, #32]	; (bdec <radio_isr_set+0x30>)
    bdca:	601d      	str	r5, [r3, #0]
	isr_cb = cb;
    bdcc:	4b08      	ldr	r3, [pc, #32]	; (bdf0 <radio_isr_set+0x34>)
    bdce:	601c      	str	r4, [r3, #0]
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    bdd0:	4b08      	ldr	r3, [pc, #32]	; (bdf4 <radio_isr_set+0x38>)
    bdd2:	2210      	movs	r2, #16
    bdd4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    bdd8:	4b07      	ldr	r3, [pc, #28]	; (bdf8 <radio_isr_set+0x3c>)
    bdda:	2202      	movs	r2, #2
    bddc:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
    bde0:	2001      	movs	r0, #1
}
    bde2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	irq_enable(RADIO_IRQn);
    bde6:	f7f6 bb6f 	b.w	24c8 <arch_irq_enable>
    bdea:	bf00      	nop
    bdec:	200024d0 	.word	0x200024d0
    bdf0:	200024cc 	.word	0x200024cc
    bdf4:	40001000 	.word	0x40001000
    bdf8:	e000e100 	.word	0xe000e100

0000bdfc <radio_reset>:
{
    bdfc:	b508      	push	{r3, lr}
	irq_disable(RADIO_IRQn);
    bdfe:	2001      	movs	r0, #1
    be00:	f7f6 fb72 	bl	24e8 <arch_irq_disable>
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (radio_power ? RADIO_POWER_POWER_Enabled : RADIO_POWER_POWER_Disabled)
    be04:	4a0d      	ldr	r2, [pc, #52]	; (be3c <radio_reset+0x40>)
    be06:	2300      	movs	r3, #0
    be08:	f8c2 3ffc 	str.w	r3, [r2, #4092]	; 0xffc
    be0c:	2301      	movs	r3, #1
    be0e:	f8c2 3ffc 	str.w	r3, [r2, #4092]	; 0xffc
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

static inline void hal_radio_reset(void)
{
	/* Anomalies 102, 106 and 107 */
	*(volatile uint32_t *)0x40001774 = ((*(volatile uint32_t *)0x40001774) &
    be12:	f8d2 3774 	ldr.w	r3, [r2, #1908]	; 0x774
					 0xfffffffe) | 0x01000000;
    be16:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    be1a:	f023 0301 	bic.w	r3, r3, #1
    be1e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
	*(volatile uint32_t *)0x40001774 = ((*(volatile uint32_t *)0x40001774) &
    be22:	f8c2 3774 	str.w	r3, [r2, #1908]	; 0x774
static inline void hal_radio_sw_switch_ppi_group_setup(void)
{
	/* Include the appropriate PPI channels in the two PPI Groups. */
#if !defined(CONFIG_BT_CTLR_PHY_CODED) || \
	!defined(CONFIG_HAS_HW_NRF_RADIO_BLE_CODED)
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
    be26:	4b06      	ldr	r3, [pc, #24]	; (be40 <radio_reset+0x44>)
    be28:	f44f 5290 	mov.w	r2, #4608	; 0x1200
    be2c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		BIT(HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI(0)) |
		BIT(HAL_SW_SWITCH_RADIO_ENABLE_PPI(0));
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
    be30:	f44f 5210 	mov.w	r2, #9216	; 0x2400
    be34:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
}
    be38:	bd08      	pop	{r3, pc}
    be3a:	bf00      	nop
    be3c:	40001000 	.word	0x40001000
    be40:	4001f000 	.word	0x4001f000

0000be44 <radio_phy_set>:
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
    be44:	4b06      	ldr	r3, [pc, #24]	; (be60 <radio_phy_set+0x1c>)
#endif /* CONFIG_BT_CTLR_PHY_CODED */

		break;

	case BIT(1):
		mode = RADIO_MODE_MODE_Ble_2Mbit;
    be46:	2802      	cmp	r0, #2
    be48:	bf14      	ite	ne
    be4a:	2203      	movne	r2, #3
    be4c:	2204      	moveq	r2, #4
    be4e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
    be52:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
    be56:	f042 0201 	orr.w	r2, r2, #1
    be5a:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
    be5e:	4770      	bx	lr
    be60:	40001000 	.word	0x40001000

0000be64 <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (uint32_t)power;
    be64:	4b01      	ldr	r3, [pc, #4]	; (be6c <radio_tx_power_set+0x8>)
    be66:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
    be6a:	4770      	bx	lr
    be6c:	40001000 	.word	0x40001000

0000be70 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
    be70:	4b01      	ldr	r3, [pc, #4]	; (be78 <radio_freq_chan_set+0x8>)
    be72:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
    be76:	4770      	bx	lr
    be78:	40001000 	.word	0x40001000

0000be7c <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
    be7c:	4b07      	ldr	r3, [pc, #28]	; (be9c <radio_whiten_iv_set+0x20>)
    be7e:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
    be82:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
    be86:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
    be8a:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
    be8e:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
    be92:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    be96:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
    be9a:	4770      	bx	lr
    be9c:	40001000 	.word	0x40001000

0000bea0 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
    bea0:	4a0a      	ldr	r2, [pc, #40]	; (becc <radio_aa_set+0x2c>)
    bea2:	2300      	movs	r3, #0
    bea4:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
    bea8:	2301      	movs	r3, #1
    beaa:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
    beae:	78c3      	ldrb	r3, [r0, #3]
    beb0:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
    beb4:	7843      	ldrb	r3, [r0, #1]
    beb6:	7881      	ldrb	r1, [r0, #2]
    beb8:	041b      	lsls	r3, r3, #16
    beba:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    bebe:	7801      	ldrb	r1, [r0, #0]
    bec0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    bec4:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
    bec8:	4770      	bx	lr
    beca:	bf00      	nop
    becc:	40001000 	.word	0x40001000

0000bed0 <radio_pkt_configure>:
	switch (phy) {
    bed0:	f3c2 0342 	ubfx	r3, r2, #1, #3
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
    bed4:	2b02      	cmp	r3, #2
{
    bed6:	b510      	push	{r4, lr}
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
    bed8:	bf14      	ite	ne
    beda:	2400      	movne	r4, #0
    bedc:	f04f 7480 	moveq.w	r4, #16777216	; 0x1000000
	if (dc) {
    bee0:	07d3      	lsls	r3, r2, #31
			   ((((uint32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
    bee2:	f1c0 0308 	rsb	r3, r0, #8
		extra |= (RADIO_PCNF0_S1INCL_Include <<
    bee6:	bf48      	it	mi
    bee8:	f444 1480 	orrmi.w	r4, r4, #1048576	; 0x100000
			   ((((uint32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
    beec:	041b      	lsls	r3, r3, #16
			   ((((uint32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) &
    beee:	f000 000f 	and.w	r0, r0, #15
			    RADIO_PCNF0_S1LEN_Msk) |
    bef2:	4320      	orrs	r0, r4
			   ((((uint32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
    bef4:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
    bef8:	4a09      	ldr	r2, [pc, #36]	; (bf20 <radio_pkt_configure+0x50>)
			    RADIO_PCNF0_S1LEN_Msk) |
    befa:	4303      	orrs	r3, r0
    befc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
    bf00:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
    bf04:	f8d2 0518 	ldr.w	r0, [r2, #1304]	; 0x518
    bf08:	4b06      	ldr	r3, [pc, #24]	; (bf24 <radio_pkt_configure+0x54>)
    bf0a:	4003      	ands	r3, r0
    bf0c:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((((uint32_t)max_len) << RADIO_PCNF1_MAXLEN_Pos) &
    bf10:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
    bf14:	4319      	orrs	r1, r3
    bf16:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
    bf1a:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
}
    bf1e:	bd10      	pop	{r4, pc}
    bf20:	40001000 	.word	0x40001000
    bf24:	fef80000 	.word	0xfef80000

0000bf28 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (uint32_t)rx_packet;
    bf28:	4b01      	ldr	r3, [pc, #4]	; (bf30 <radio_pkt_rx_set+0x8>)
    bf2a:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
    bf2e:	4770      	bx	lr
    bf30:	40001000 	.word	0x40001000

0000bf34 <radio_pkt_tx_set>:
    bf34:	4b01      	ldr	r3, [pc, #4]	; (bf3c <radio_pkt_tx_set+0x8>)
    bf36:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
    bf3a:	4770      	bx	lr
    bf3c:	40001000 	.word	0x40001000

0000bf40 <radio_rx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bf40:	4b01      	ldr	r3, [pc, #4]	; (bf48 <radio_rx_enable+0x8>)
    bf42:	2201      	movs	r2, #1
    bf44:	605a      	str	r2, [r3, #4]
}
    bf46:	4770      	bx	lr
    bf48:	40001000 	.word	0x40001000

0000bf4c <radio_disable>:
    p_reg->CHENCLR = mask;
    bf4c:	4a07      	ldr	r2, [pc, #28]	; (bf6c <radio_disable+0x20>)
    bf4e:	f44f 6310 	mov.w	r3, #2304	; 0x900
    bf52:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
}

NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
    bf56:	2301      	movs	r3, #1
    bf58:	6053      	str	r3, [r2, #4]
    bf5a:	60d3      	str	r3, [r2, #12]
	NRF_RADIO->SHORTS = 0;
    bf5c:	f5a2 32f0 	sub.w	r2, r2, #122880	; 0x1e000
    bf60:	2100      	movs	r1, #0
    bf62:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    bf66:	6113      	str	r3, [r2, #16]
}
    bf68:	4770      	bx	lr
    bf6a:	bf00      	nop
    bf6c:	4001f000 	.word	0x4001f000

0000bf70 <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
    bf70:	4b04      	ldr	r3, [pc, #16]	; (bf84 <radio_status_reset+0x14>)
    bf72:	2200      	movs	r2, #0
    bf74:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
    bf78:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
    bf7c:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
    bf80:	4770      	bx	lr
    bf82:	bf00      	nop
    bf84:	40001000 	.word	0x40001000

0000bf88 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
    bf88:	4b03      	ldr	r3, [pc, #12]	; (bf98 <radio_is_ready+0x10>)
    bf8a:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
    bf8e:	3800      	subs	r0, #0
    bf90:	bf18      	it	ne
    bf92:	2001      	movne	r0, #1
    bf94:	4770      	bx	lr
    bf96:	bf00      	nop
    bf98:	40001000 	.word	0x40001000

0000bf9c <radio_is_done>:
	return (NRF_RADIO->EVENTS_END != 0);
    bf9c:	4b03      	ldr	r3, [pc, #12]	; (bfac <radio_is_done+0x10>)
    bf9e:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
    bfa2:	3800      	subs	r0, #0
    bfa4:	bf18      	it	ne
    bfa6:	2001      	movne	r0, #1
    bfa8:	4770      	bx	lr
    bfaa:	bf00      	nop
    bfac:	40001000 	.word	0x40001000

0000bfb0 <radio_is_idle>:
}

uint32_t radio_is_idle(void)
{
	return (NRF_RADIO->STATE == 0);
    bfb0:	4b03      	ldr	r3, [pc, #12]	; (bfc0 <radio_is_idle+0x10>)
    bfb2:	f8d3 0550 	ldr.w	r0, [r3, #1360]	; 0x550
}
    bfb6:	fab0 f080 	clz	r0, r0
    bfba:	0940      	lsrs	r0, r0, #5
    bfbc:	4770      	bx	lr
    bfbe:	bf00      	nop
    bfc0:	40001000 	.word	0x40001000

0000bfc4 <radio_crc_configure>:

void radio_crc_configure(uint32_t polynomial, uint32_t iv)
{
	NRF_RADIO->CRCCNF =
    bfc4:	4b04      	ldr	r3, [pc, #16]	; (bfd8 <radio_crc_configure+0x14>)
    bfc6:	f240 1203 	movw	r2, #259	; 0x103
    bfca:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	    (((RADIO_CRCCNF_SKIPADDR_Skip) << RADIO_CRCCNF_SKIPADDR_Pos) &
	     RADIO_CRCCNF_SKIPADDR_Msk) |
	    (((RADIO_CRCCNF_LEN_Three) << RADIO_CRCCNF_LEN_Pos) &
	       RADIO_CRCCNF_LEN_Msk);
	NRF_RADIO->CRCPOLY = polynomial;
    bfce:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
    bfd2:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
    bfd6:	4770      	bx	lr
    bfd8:	40001000 	.word	0x40001000

0000bfdc <radio_crc_is_valid>:

uint32_t radio_crc_is_valid(void)
{
	return (NRF_RADIO->CRCSTATUS != 0);
    bfdc:	4b03      	ldr	r3, [pc, #12]	; (bfec <radio_crc_is_valid+0x10>)
    bfde:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
    bfe2:	3800      	subs	r0, #0
    bfe4:	bf18      	it	ne
    bfe6:	2001      	movne	r0, #1
    bfe8:	4770      	bx	lr
    bfea:	bf00      	nop
    bfec:	40001000 	.word	0x40001000

0000bff0 <radio_pkt_scratch_get>:
}

void *radio_pkt_scratch_get(void)
{
	return _pkt_scratch;
}
    bff0:	4800      	ldr	r0, [pc, #0]	; (bff4 <radio_pkt_scratch_get+0x4>)
    bff2:	4770      	bx	lr
    bff4:	200023c8 	.word	0x200023c8

0000bff8 <sw_switch>:

static uint8_t sw_tifs_toggle;

void sw_switch(uint8_t dir_curr, uint8_t dir_next, uint8_t phy_curr, uint8_t flags_curr,
	       uint8_t phy_next, uint8_t flags_next)
{
    bff8:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
    bffa:	4d30      	ldr	r5, [pc, #192]	; (c0bc <sw_switch+0xc4>)
    p_reg->CH[(uint32_t) channel].EEP = eep;
    bffc:	4f30      	ldr	r7, [pc, #192]	; (c0c0 <sw_switch+0xc8>)
    bffe:	782e      	ldrb	r6, [r5, #0]
    c000:	f8df e0c0 	ldr.w	lr, [pc, #192]	; c0c4 <sw_switch+0xcc>
{
    c004:	f89d c014 	ldrb.w	ip, [sp, #20]
    c008:	f8c7 e568 	str.w	lr, [r7, #1384]	; 0x568
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
    c00c:	00f3      	lsls	r3, r6, #3
	uint8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
    c00e:	f106 040c 	add.w	r4, r6, #12
    c012:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    c016:	b2e4      	uxtb	r4, r4
    c018:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c01c:	00e4      	lsls	r4, r4, #3
    c01e:	f8c7 356c 	str.w	r3, [r7, #1388]	; 0x56c
	nrf_ppi_event_endpoint_setup(
    c022:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
    c026:	4b28      	ldr	r3, [pc, #160]	; (c0c8 <sw_switch+0xd0>)
    c028:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
    c02c:	eb03 0386 	add.w	r3, r3, r6, lsl #2
    c030:	00b7      	lsls	r7, r6, #2
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c032:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510

	/* NOTE: As constants are passed to dir_curr and dir_next, the
	 *       compiler should optimize out the redundant code path
	 *       during the optimization.
	 */
	if (dir_next) {
    c036:	2900      	cmp	r1, #0
    c038:	d03a      	beq.n	c0b0 <sw_switch+0xb8>
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_2M_NS;
    c03a:	f649 73c4 	movw	r3, #40900	; 0x9fc4
		/* TX */

		/* Calculate delay with respect to current and next PHY.
		 */
		if (dir_curr) {
    c03e:	b330      	cbz	r0, c08e <sw_switch+0x96>
    c040:	f649 4240 	movw	r2, #40000	; 0x9c40
    c044:	f1bc 0f02 	cmp.w	ip, #2
    c048:	bf08      	it	eq
    c04a:	4613      	moveq	r3, r2
			delay = HAL_RADIO_NS2US_ROUND(
    c04c:	f203 434c 	addw	r3, r3, #1100	; 0x44c
			hal_radio_b2b_txen_on_sw_switch(ppi);
		} else {
			/* If RX PHY is LE Coded, calculate for S8 coding.
			 * Assumption being, S8 has higher delay.
			 */
			delay = HAL_RADIO_NS2US_ROUND(
    c050:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    c054:	fbb3 f3f2 	udiv	r3, r3, r2
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c058:	4a1c      	ldr	r2, [pc, #112]	; (c0cc <sw_switch+0xd4>)
    c05a:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
		}
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay < SW_SWITCH_TIMER->CC[cc]) {
    c05e:	f107 4280 	add.w	r2, r7, #1073741824	; 0x40000000
    c062:	f502 4210 	add.w	r2, r2, #36864	; 0x9000
    c066:	f8d2 1540 	ldr.w	r1, [r2, #1344]	; 0x540
    c06a:	4299      	cmp	r1, r3
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
				 (SW_SWITCH_TIMER->CC[cc] - delay));
    c06c:	bf8a      	itet	hi
    c06e:	f8d2 1540 	ldrhi.w	r1, [r2, #1344]	; 0x540

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
    c072:	2301      	movls	r3, #1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
    c074:	1acb      	subhi	r3, r1, r3
    c076:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
    p_reg->CHENSET = mask;
    c07a:	4b11      	ldr	r3, [pc, #68]	; (c0c0 <sw_switch+0xc8>)
    c07c:	f44f 6210 	mov.w	r2, #2304	; 0x900
    c080:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
#if !defined(CONFIG_SOC_SERIES_NRF53X)
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
#endif /* !CONFIG_SOC_SERIES_NRF53X */
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER || CONFIG_SOC_SERIES_NRF53X */

	sw_tifs_toggle += 1U;
    c084:	1c73      	adds	r3, r6, #1
	sw_tifs_toggle &= 1U;
    c086:	f003 0301 	and.w	r3, r3, #1
    c08a:	702b      	strb	r3, [r5, #0]
}
    c08c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c08e:	f649 4140 	movw	r1, #40000	; 0x9c40
    c092:	f1bc 0f02 	cmp.w	ip, #2
    c096:	bf08      	it	eq
    c098:	460b      	moveq	r3, r1
	switch (phy) {
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_1M_NS;
	case BIT(1):
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_2M_NS;
    c09a:	f241 3088 	movw	r0, #5000	; 0x1388
    c09e:	f242 41b8 	movw	r1, #9400	; 0x24b8
    c0a2:	2a02      	cmp	r2, #2
    c0a4:	bf08      	it	eq
    c0a6:	4601      	moveq	r1, r0
			delay = HAL_RADIO_NS2US_ROUND(
    c0a8:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
    c0ac:	440b      	add	r3, r1
    c0ae:	e7cf      	b.n	c050 <sw_switch+0x58>
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c0b0:	4b07      	ldr	r3, [pc, #28]	; (c0d0 <sw_switch+0xd8>)
    c0b2:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
		delay = HAL_RADIO_NS2US_CEIL(
    c0b6:	232d      	movs	r3, #45	; 0x2d
}
    c0b8:	e7d1      	b.n	c05e <sw_switch+0x66>
    c0ba:	bf00      	nop
    c0bc:	20002a7a 	.word	0x20002a7a
    c0c0:	4001f000 	.word	0x4001f000
    c0c4:	4000110c 	.word	0x4000110c
    c0c8:	40009140 	.word	0x40009140
    c0cc:	40001000 	.word	0x40001000
    c0d0:	40001004 	.word	0x40001004

0000c0d4 <radio_switch_complete_and_rx>:
#endif /* CONFIG_BT_CTLR_TIFS_HW */

void radio_switch_complete_and_rx(uint8_t phy_rx)
{
    c0d4:	b507      	push	{r0, r1, r2, lr}
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
    c0d6:	4b07      	ldr	r3, [pc, #28]	; (c0f4 <radio_switch_complete_and_rx+0x20>)
    c0d8:	2203      	movs	r2, #3
    c0da:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

	/* NOTE: As Tx chain delays are negligible constant values (~1 us)
	 *	 across nRF5x radios, sw_switch assumes the 1M chain delay for
	 *       calculations.
	 */
	sw_switch(SW_SWITCH_TX, SW_SWITCH_RX, SW_SWITCH_PHY_1M, SW_SWITCH_FLAGS_DONTCARE, phy_rx,
    c0de:	2300      	movs	r3, #0
    c0e0:	e9cd 0300 	strd	r0, r3, [sp]
    c0e4:	461a      	mov	r2, r3
    c0e6:	4619      	mov	r1, r3
    c0e8:	2001      	movs	r0, #1
    c0ea:	f7ff ff85 	bl	bff8 <sw_switch>
		  SW_SWITCH_FLAGS_DONTCARE);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    c0ee:	b003      	add	sp, #12
    c0f0:	f85d fb04 	ldr.w	pc, [sp], #4
    c0f4:	40001000 	.word	0x40001000

0000c0f8 <radio_switch_complete_and_tx>:

void radio_switch_complete_and_tx(uint8_t phy_rx, uint8_t flags_rx,
				  uint8_t phy_tx, uint8_t flags_tx)
{
    c0f8:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
    c0fa:	4c07      	ldr	r4, [pc, #28]	; (c118 <radio_switch_complete_and_tx+0x20>)
    c0fc:	2503      	movs	r5, #3
    c0fe:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;

	sw_switch(SW_SWITCH_RX, SW_SWITCH_TX, phy_rx, flags_rx, phy_tx, flags_tx);
    c102:	e9cd 2300 	strd	r2, r3, [sp]
    c106:	460b      	mov	r3, r1
    c108:	4602      	mov	r2, r0
    c10a:	2101      	movs	r1, #1
    c10c:	2000      	movs	r0, #0
    c10e:	f7ff ff73 	bl	bff8 <sw_switch>
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    c112:	b003      	add	sp, #12
    c114:	bd30      	pop	{r4, r5, pc}
    c116:	bf00      	nop
    c118:	40001000 	.word	0x40001000

0000c11c <radio_switch_complete_and_disable>:
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}

void radio_switch_complete_and_disable(void)
{
	NRF_RADIO->SHORTS =
    c11c:	4b05      	ldr	r3, [pc, #20]	; (c134 <radio_switch_complete_and_disable+0x18>)
    c11e:	2203      	movs	r2, #3
    c120:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    p_reg->CHENCLR = mask;
    c124:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
    c128:	f44f 6210 	mov.w	r2, #2304	; 0x900
    c12c:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	    (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    c130:	4770      	bx	lr
    c132:	bf00      	nop
    c134:	40001000 	.word	0x40001000

0000c138 <radio_rssi_measure>:
#endif /* !CONFIG_BT_CTLR_PHY_CODED */
}

void radio_rssi_measure(void)
{
	NRF_RADIO->SHORTS |=
    c138:	4a03      	ldr	r2, [pc, #12]	; (c148 <radio_rssi_measure+0x10>)
    c13a:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
    c13e:	f443 7388 	orr.w	r3, r3, #272	; 0x110
    c142:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	    (RADIO_SHORTS_ADDRESS_RSSISTART_Msk |
	     RADIO_SHORTS_DISABLED_RSSISTOP_Msk);
}
    c146:	4770      	bx	lr
    c148:	40001000 	.word	0x40001000

0000c14c <radio_rssi_get>:

uint32_t radio_rssi_get(void)
{
	return NRF_RADIO->RSSISAMPLE;
    c14c:	4b01      	ldr	r3, [pc, #4]	; (c154 <radio_rssi_get+0x8>)
    c14e:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}
    c152:	4770      	bx	lr
    c154:	40001000 	.word	0x40001000

0000c158 <radio_rssi_status_reset>:

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
    c158:	4b02      	ldr	r3, [pc, #8]	; (c164 <radio_rssi_status_reset+0xc>)
    c15a:	2200      	movs	r2, #0
    c15c:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
    c160:	4770      	bx	lr
    c162:	bf00      	nop
    c164:	40001000 	.word	0x40001000

0000c168 <radio_rssi_is_ready>:

uint32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
    c168:	4b03      	ldr	r3, [pc, #12]	; (c178 <radio_rssi_is_ready+0x10>)
    c16a:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
    c16e:	3800      	subs	r0, #0
    c170:	bf18      	it	ne
    c172:	2001      	movne	r0, #1
    c174:	4770      	bx	lr
    c176:	bf00      	nop
    c178:	40001000 	.word	0x40001000

0000c17c <radio_filter_configure>:

void radio_filter_configure(uint8_t bitmask_enable, uint8_t bitmask_addr_type,
			    uint8_t *bdaddr)
{
    c17c:	b5f0      	push	{r4, r5, r6, r7, lr}
    c17e:	2400      	movs	r4, #0
    c180:	2706      	movs	r7, #6
    c182:	fb07 f304 	mul.w	r3, r7, r4
    c186:	18d5      	adds	r5, r2, r3
	uint8_t index;

	for (index = 0U; index < 8; index++) {
		NRF_RADIO->DAB[index] = ((uint32_t)bdaddr[3] << 24) |
			((uint32_t)bdaddr[2] << 16) |
			((uint32_t)bdaddr[1] << 8) |
    c188:	58d6      	ldr	r6, [r2, r3]
    c18a:	00a3      	lsls	r3, r4, #2
    c18c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    c190:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
	for (index = 0U; index < 8; index++) {
    c194:	3401      	adds	r4, #1
		NRF_RADIO->DAB[index] = ((uint32_t)bdaddr[3] << 24) |
    c196:	f8c3 6600 	str.w	r6, [r3, #1536]	; 0x600
			bdaddr[0];
		NRF_RADIO->DAP[index] = ((uint32_t)bdaddr[5] << 8) | bdaddr[4];
    c19a:	88ad      	ldrh	r5, [r5, #4]
    c19c:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
	for (index = 0U; index < 8; index++) {
    c1a0:	2c08      	cmp	r4, #8
    c1a2:	d1ee      	bne.n	c182 <radio_filter_configure+0x6>
		bdaddr += 6;
	}

	NRF_RADIO->DACNF = ((uint32_t)bitmask_addr_type << 8) | bitmask_enable;
    c1a4:	4b02      	ldr	r3, [pc, #8]	; (c1b0 <radio_filter_configure+0x34>)
    c1a6:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
    c1aa:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
}
    c1ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c1b0:	40001000 	.word	0x40001000

0000c1b4 <radio_filter_disable>:

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
    c1b4:	4a03      	ldr	r2, [pc, #12]	; (c1c4 <radio_filter_disable+0x10>)
    c1b6:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
    c1ba:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    c1be:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
    c1c2:	4770      	bx	lr
    c1c4:	40001000 	.word	0x40001000

0000c1c8 <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
    c1c8:	4b02      	ldr	r3, [pc, #8]	; (c1d4 <radio_filter_status_reset+0xc>)
    c1ca:	2200      	movs	r2, #0
    c1cc:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    c1d0:	4770      	bx	lr
    c1d2:	bf00      	nop
    c1d4:	40001000 	.word	0x40001000

0000c1d8 <radio_filter_has_match>:

uint32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
    c1d8:	4b03      	ldr	r3, [pc, #12]	; (c1e8 <radio_filter_has_match+0x10>)
    c1da:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
    c1de:	3800      	subs	r0, #0
    c1e0:	bf18      	it	ne
    c1e2:	2001      	movne	r0, #1
    c1e4:	4770      	bx	lr
    c1e6:	bf00      	nop
    c1e8:	40001000 	.word	0x40001000

0000c1ec <radio_filter_match_get>:

uint32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
    c1ec:	4b01      	ldr	r3, [pc, #4]	; (c1f4 <radio_filter_match_get+0x8>)
    c1ee:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
    c1f2:	4770      	bx	lr
    c1f4:	40001000 	.word	0x40001000

0000c1f8 <radio_bc_configure>:
    p_reg->BCC = radio_bcc;
    c1f8:	4b04      	ldr	r3, [pc, #16]	; (c20c <radio_bc_configure+0x14>)
    c1fa:	f8c3 0560 	str.w	r0, [r3, #1376]	; 0x560

void radio_bc_configure(uint32_t n)
{
	nrf_radio_bcc_set(NRF_RADIO, n);
	NRF_RADIO->SHORTS |= RADIO_SHORTS_ADDRESS_BCSTART_Msk;
    c1fe:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    c202:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    c206:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
    c20a:	4770      	bx	lr
    c20c:	40001000 	.word	0x40001000

0000c210 <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    c210:	4b05      	ldr	r3, [pc, #20]	; (c228 <radio_tmr_status_reset+0x18>)
    c212:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    c216:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
    c21a:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
    c21e:	4a03      	ldr	r2, [pc, #12]	; (c22c <radio_tmr_status_reset+0x1c>)
    c220:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			BIT(HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI) |
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
    c224:	4770      	bx	lr
    c226:	bf00      	nop
    c228:	4000b000 	.word	0x4000b000
    c22c:	0e7000c0 	.word	0x0e7000c0

0000c230 <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(uint32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
    c230:	4b03      	ldr	r3, [pc, #12]	; (c240 <radio_tmr_tifs_set+0x10>)
    c232:	4a04      	ldr	r2, [pc, #16]	; (c244 <radio_tmr_tifs_set+0x14>)
    c234:	781b      	ldrb	r3, [r3, #0]
    c236:	f503 73a8 	add.w	r3, r3, #336	; 0x150
    c23a:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    c23e:	4770      	bx	lr
    c240:	20002a7a 	.word	0x20002a7a
    c244:	40009000 	.word	0x40009000

0000c248 <radio_tmr_start>:

uint32_t radio_tmr_start(uint8_t trx, uint32_t ticks_start, uint32_t remainder)
{
    c248:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
    c24a:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
    c24e:	4c2f      	ldr	r4, [pc, #188]	; (c30c <radio_tmr_start+0xc4>)
    c250:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
    c254:	42a3      	cmp	r3, r4
		ticks_start--;
		remainder += 30517578UL;
    c256:	bf88      	it	hi
    c258:	f102 72e8 	addhi.w	r2, r2, #30408704	; 0x1d00000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c25c:	4b2c      	ldr	r3, [pc, #176]	; (c310 <radio_tmr_start+0xc8>)
	}
	remainder /= 1000000UL;
    c25e:	4c2d      	ldr	r4, [pc, #180]	; (c314 <radio_tmr_start+0xcc>)
		remainder += 30517578UL;
    c260:	bf84      	itt	hi
    c262:	f502 32d4 	addhi.w	r2, r2, #108544	; 0x1a800
    c266:	f502 72a5 	addhi.w	r2, r2, #330	; 0x14a
    c26a:	f04f 0501 	mov.w	r5, #1

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
    c26e:	f04f 0600 	mov.w	r6, #0
	remainder /= 1000000UL;
    c272:	fbb2 f4f4 	udiv	r4, r2, r4
	EVENT_TIMER->PRESCALER = 4;
    c276:	f04f 0704 	mov.w	r7, #4
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
    c27a:	f04f 0202 	mov.w	r2, #2
    c27e:	60dd      	str	r5, [r3, #12]
	EVENT_TIMER->MODE = 0;
    c280:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	EVENT_TIMER->PRESCALER = 4;
    c284:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
    c288:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
    c28c:	4a22      	ldr	r2, [pc, #136]	; (c318 <radio_tmr_start+0xd0>)
    p_reg->CC[cc_channel] = cc_value;
    c28e:	f8c3 4540 	str.w	r4, [r3, #1344]	; 0x540
		ticks_start--;
    c292:	bf88      	it	hi
    c294:	f101 31ff 	addhi.w	r1, r1, #4294967295	; 0xffffffff
    c298:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
    c29c:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    c2a0:	f8c2 1344 	str.w	r1, [r2, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c2a4:	491d      	ldr	r1, [pc, #116]	; (c31c <radio_tmr_start+0xd4>)
    c2a6:	f502 72a4 	add.w	r2, r2, #328	; 0x148
    c2aa:	f8c1 2540 	str.w	r2, [r1, #1344]	; 0x540
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c2ae:	f8c1 3544 	str.w	r3, [r1, #1348]	; 0x544
    p_reg->CHENSET = mask;
    c2b2:	2340      	movs	r3, #64	; 0x40
    c2b4:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
    c2b8:	f7ff fd5c 	bl	bd74 <hal_radio_enable_on_tick_ppi_config_and_enable>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c2bc:	4b18      	ldr	r3, [pc, #96]	; (c320 <radio_tmr_start+0xd8>)
    c2be:	60dd      	str	r5, [r3, #12]
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
    c2c0:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
    c2c4:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
    c2c8:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
    c2cc:	601d      	str	r5, [r3, #0]
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c2ce:	f5a3 43fd 	sub.w	r3, r3, #32384	; 0x7e80
    c2d2:	3b74      	subs	r3, #116	; 0x74
    c2d4:	f8c1 3550 	str.w	r3, [r1, #1360]	; 0x550
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c2d8:	f503 43fe 	add.w	r3, r3, #32512	; 0x7f00
    c2dc:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c2e0:	f503 739a 	add.w	r3, r3, #308	; 0x134
    c2e4:	f8c1 3558 	str.w	r3, [r1, #1368]	; 0x558
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c2e8:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
    c2ec:	33c4      	adds	r3, #196	; 0xc4
    c2ee:	f8c1 355c 	str.w	r3, [r1, #1372]	; 0x55c
    p_reg->CH[(uint32_t) channel].EEP = eep;
    c2f2:	f5a3 33af 	sub.w	r3, r3, #89600	; 0x15e00
    c2f6:	3bc0      	subs	r3, #192	; 0xc0
    c2f8:	f8c1 3560 	str.w	r3, [r1, #1376]	; 0x560
    p_reg->CH[(uint32_t) channel].TEP = tep;
    c2fc:	f503 33af 	add.w	r3, r3, #89600	; 0x15e00
    c300:	33c8      	adds	r3, #200	; 0xc8
    c302:	f8c1 3564 	str.w	r3, [r1, #1380]	; 0x564
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
    c306:	4620      	mov	r0, r4
    c308:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c30a:	bf00      	nop
    c30c:	7ff0bdbf 	.word	0x7ff0bdbf
    c310:	40008000 	.word	0x40008000
    c314:	000f4240 	.word	0x000f4240
    c318:	4000b000 	.word	0x4000b000
    c31c:	4001f000 	.word	0x4001f000
    c320:	40009000 	.word	0x40009000

0000c324 <radio_tmr_start_us>:
    p_reg->CC[cc_channel] = cc_value;
    c324:	4b02      	ldr	r3, [pc, #8]	; (c330 <radio_tmr_start_us+0xc>)
    c326:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540

void radio_tmr_start_us(uint8_t trx, uint32_t us)
{
	nrf_timer_cc_set(EVENT_TIMER, 0, us);

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
    c32a:	f7ff bd23 	b.w	bd74 <hal_radio_enable_on_tick_ppi_config_and_enable>
    c32e:	bf00      	nop
    c330:	40008000 	.word	0x40008000

0000c334 <radio_tmr_start_now>:
#endif /* CONFIG_SOC_SERIES_NRF53X */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}

uint32_t radio_tmr_start_now(uint8_t trx)
{
    c334:	b510      	push	{r4, lr}
	uint32_t now, start;

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
    c336:	f7ff fd1d 	bl	bd74 <hal_radio_enable_on_tick_ppi_config_and_enable>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c33a:	4b08      	ldr	r3, [pc, #32]	; (c35c <radio_tmr_start_now+0x28>)
    c33c:	2401      	movs	r4, #1
    c33e:	645c      	str	r4, [r3, #68]	; 0x44
#endif /* CONFIG_SOC_SERIES_NRF53X */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	/* Capture the current time */
	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CAPTURE1);
	now = EVENT_TIMER->CC[1];
    c340:	f8d3 2544 	ldr.w	r2, [r3, #1348]	; 0x544
	start = now;
    c344:	4611      	mov	r1, r2

	/* Setup PPI while determining the latency in doing so */
	do {
		/* Set start to be, now plus the determined latency */
		start = (now << 1) - start;
    c346:	ebc1 0142 	rsb	r1, r1, r2, lsl #1

		/* Setup compare event with min. 1 us offset */
		nrf_timer_cc_set(EVENT_TIMER, 0, start + 1);
    c34a:	1c48      	adds	r0, r1, #1
    p_reg->CC[cc_channel] = cc_value;
    c34c:	f8c3 0540 	str.w	r0, [r3, #1344]	; 0x540
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    c350:	645c      	str	r4, [r3, #68]	; 0x44

		/* Capture the current time */
		nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CAPTURE1);

		now = EVENT_TIMER->CC[1];
    c352:	f8d3 2544 	ldr.w	r2, [r3, #1348]	; 0x544
	} while (now > start);
    c356:	4291      	cmp	r1, r2
    c358:	d3f5      	bcc.n	c346 <radio_tmr_start_now+0x12>

	return start + 1;
}
    c35a:	bd10      	pop	{r4, pc}
    c35c:	40008000 	.word	0x40008000

0000c360 <radio_tmr_start_get>:
    return p_reg->CC[ch];
    c360:	4b01      	ldr	r3, [pc, #4]	; (c368 <radio_tmr_start_get+0x8>)
    c362:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548

uint32_t radio_tmr_start_get(void)
{
	return nrf_rtc_cc_get(NRF_RTC0, 2);
}
    c366:	4770      	bx	lr
    c368:	4000b000 	.word	0x4000b000

0000c36c <radio_tmr_stop>:
    c36c:	4a04      	ldr	r2, [pc, #16]	; (c380 <radio_tmr_stop+0x14>)
    c36e:	2301      	movs	r3, #1
    c370:	6053      	str	r3, [r2, #4]
    c372:	6113      	str	r3, [r2, #16]
    c374:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    c378:	6053      	str	r3, [r2, #4]
    c37a:	6113      	str	r3, [r2, #16]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
    c37c:	4770      	bx	lr
    c37e:	bf00      	nop
    c380:	40008000 	.word	0x40008000

0000c384 <radio_tmr_hcto_configure>:
    p_reg->CC[cc_channel] = cc_value;
    c384:	4b04      	ldr	r3, [pc, #16]	; (c398 <radio_tmr_hcto_configure+0x14>)
    c386:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
    p_reg->CHENSET = mask;
    c38a:	f503 33b8 	add.w	r3, r3, #94208	; 0x17000
    c38e:	f04f 6288 	mov.w	r2, #71303168	; 0x4400000
    c392:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
    c396:	4770      	bx	lr
    c398:	40008000 	.word	0x40008000

0000c39c <radio_tmr_end_capture>:
    c39c:	4b02      	ldr	r3, [pc, #8]	; (c3a8 <radio_tmr_end_capture+0xc>)
    c39e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    c3a2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	 */
#if defined(CONFIG_BT_CTLR_TIFS_HW) || !defined(CONFIG_SOC_SERIES_NRF53X)
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
#endif /* CONFIG_BT_CTLR_TIFS_HW || !CONFIG_SOC_SERIES_NRF53X */
}
    c3a6:	4770      	bx	lr
    c3a8:	4001f000 	.word	0x4001f000

0000c3ac <radio_tmr_end_get>:
uint32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
    c3ac:	4b01      	ldr	r3, [pc, #4]	; (c3b4 <radio_tmr_end_get+0x8>)
    c3ae:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
    c3b2:	4770      	bx	lr
    c3b4:	40008000 	.word	0x40008000

0000c3b8 <radio_tmr_tifs_base_get>:
    c3b8:	4b01      	ldr	r3, [pc, #4]	; (c3c0 <radio_tmr_tifs_base_get+0x8>)
    c3ba:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
    c3be:	4770      	bx	lr
    c3c0:	40008000 	.word	0x40008000

0000c3c4 <radio_ar_configure>:
}

static uint8_t MALIGN(4) _aar_scratch[3];

void radio_ar_configure(uint32_t nirk, void *irk, uint8_t flags)
{
    c3c4:	b538      	push	{r3, r4, r5, lr}
    c3c6:	4604      	mov	r4, r0
	 */

	phy = flags >> 2;

	/* Check if extended PDU or non-1M and not legacy PDU */
	if (IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) &&
    c3c8:	0790      	lsls	r0, r2, #30
    c3ca:	d403      	bmi.n	c3d4 <radio_ar_configure+0x10>
    c3cc:	07d3      	lsls	r3, r2, #31
    c3ce:	d426      	bmi.n	c41e <radio_ar_configure+0x5a>
	    ((flags & BIT(1)) || (!(flags & BIT(0)) && (phy > PHY_1M)))) {
    c3d0:	2a07      	cmp	r2, #7
    c3d2:	d924      	bls.n	c41e <radio_ar_configure+0x5a>
		addrptr = NRF_RADIO->PACKETPTR + 1;
    c3d4:	4b15      	ldr	r3, [pc, #84]	; (c42c <radio_ar_configure+0x68>)
    c3d6:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
		bcc = 80;
    c3da:	2050      	movs	r0, #80	; 0x50
		addrptr = NRF_RADIO->PACKETPTR + 1;
    c3dc:	3201      	adds	r2, #1
	/* For Coded PHY adjust for CI and TERM1 */
	if (IS_ENABLED(CONFIG_BT_CTLR_PHY_CODED) && (phy == PHY_CODED)) {
		bcc += 5;
	}

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
    c3de:	4b14      	ldr	r3, [pc, #80]	; (c430 <radio_ar_configure+0x6c>)
    c3e0:	2503      	movs	r5, #3
    c3e2:	f8c3 5500 	str.w	r5, [r3, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;
	NRF_AAR->NIRK = nirk;
    c3e6:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
	NRF_AAR->IRKPTR = (uint32_t)irk;
    c3ea:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
	NRF_AAR->ADDRPTR = addrptr;
    c3ee:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_AAR->SCRATCHPTR = (uint32_t)&_aar_scratch[0];

	NRF_AAR->EVENTS_END = 0;
    c3f2:	2100      	movs	r1, #0
	NRF_AAR->SCRATCHPTR = (uint32_t)&_aar_scratch[0];
    c3f4:	4a0f      	ldr	r2, [pc, #60]	; (c434 <radio_ar_configure+0x70>)
    c3f6:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
	NRF_AAR->EVENTS_END = 0;
    c3fa:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
	NRF_AAR->EVENTS_RESOLVED = 0;
    c3fe:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
	NRF_AAR->EVENTS_NOTRESOLVED = 0;
    c402:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108

	radio_bc_configure(bcc);
    c406:	f7ff fef7 	bl	c1f8 <radio_bc_configure>
	NRF_RADIO->EVENTS_BCMATCH = 0;
    c40a:	4b08      	ldr	r3, [pc, #32]	; (c42c <radio_ar_configure+0x68>)
    c40c:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
    c410:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
    c414:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    c418:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	radio_bc_status_reset();

	hal_trigger_aar_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}
    c41c:	bd38      	pop	{r3, r4, r5, pc}
		addrptr = NRF_RADIO->PACKETPTR - 1;
    c41e:	4b03      	ldr	r3, [pc, #12]	; (c42c <radio_ar_configure+0x68>)
    c420:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
		bcc = 64;
    c424:	2040      	movs	r0, #64	; 0x40
		addrptr = NRF_RADIO->PACKETPTR - 1;
    c426:	3a01      	subs	r2, #1
		bcc = 64;
    c428:	e7d9      	b.n	c3de <radio_ar_configure+0x1a>
    c42a:	bf00      	nop
    c42c:	40001000 	.word	0x40001000
    c430:	4000f000 	.word	0x4000f000
    c434:	200023c4 	.word	0x200023c4

0000c438 <radio_ar_match_get>:

uint32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
    c438:	4b01      	ldr	r3, [pc, #4]	; (c440 <radio_ar_match_get+0x8>)
    c43a:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
    c43e:	4770      	bx	lr
    c440:	4000f000 	.word	0x4000f000

0000c444 <radio_ar_status_reset>:
	NRF_RADIO->EVENTS_BCMATCH = 0;
    c444:	4a06      	ldr	r2, [pc, #24]	; (c460 <radio_ar_status_reset+0x1c>)
    c446:	2300      	movs	r3, #0
    c448:	f8c2 3128 	str.w	r3, [r2, #296]	; 0x128

void radio_ar_status_reset(void)
{
	radio_bc_status_reset();

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
    c44c:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
    c450:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
    p_reg->CHENCLR = mask;
    c454:	4b03      	ldr	r3, [pc, #12]	; (c464 <radio_ar_status_reset+0x20>)
    c456:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    c45a:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			  AAR_ENABLE_ENABLE_Msk;

	hal_radio_nrf_ppi_channels_disable(BIT(HAL_TRIGGER_AAR_PPI));
}
    c45e:	4770      	bx	lr
    c460:	40001000 	.word	0x40001000
    c464:	4001f000 	.word	0x4001f000

0000c468 <radio_ar_has_match>:
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
    c468:	4b08      	ldr	r3, [pc, #32]	; (c48c <radio_ar_has_match+0x24>)
    c46a:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128

uint32_t radio_ar_has_match(void)
{
	return (radio_bc_has_match() &&
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
    c46e:	b160      	cbz	r0, c48a <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_END &&
    c470:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
    c474:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
    c478:	b138      	cbz	r0, c48a <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_RESOLVED &&
    c47a:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
    c47e:	b120      	cbz	r0, c48a <radio_ar_has_match+0x22>
		!NRF_AAR->EVENTS_NOTRESOLVED);
    c480:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
    c484:	fab0 f080 	clz	r0, r0
    c488:	0940      	lsrs	r0, r0, #5
}
    c48a:	4770      	bx	lr
    c48c:	40001000 	.word	0x40001000

0000c490 <radio_ar_resolve>:

void radio_ar_resolve(const uint8_t *addr)
{
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
    c490:	4b14      	ldr	r3, [pc, #80]	; (c4e4 <radio_ar_resolve+0x54>)
    c492:	2203      	movs	r2, #3
    c494:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;

	NRF_AAR->ADDRPTR = (uint32_t)addr - 3;
    c498:	3803      	subs	r0, #3

	NRF_AAR->EVENTS_END = 0;
    c49a:	2200      	movs	r2, #0
	NRF_AAR->ADDRPTR = (uint32_t)addr - 3;
    c49c:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
	NRF_AAR->EVENTS_END = 0;
    c4a0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_AAR->EVENTS_RESOLVED = 0;
    c4a4:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	NRF_AAR->EVENTS_NOTRESOLVED = 0;
    c4a8:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    c4ac:	4a0e      	ldr	r2, [pc, #56]	; (c4e8 <radio_ar_resolve+0x58>)
    c4ae:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    c4b2:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)aar_event);
}

NRF_STATIC_INLINE void nrf_aar_int_enable(NRF_AAR_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    c4b6:	2201      	movs	r2, #1
    c4b8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE void nrf_aar_task_trigger(NRF_AAR_Type * p_reg, nrf_aar_task_t task)
{
    *(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task) = 1;
    c4bc:	601a      	str	r2, [r3, #0]

	nrf_aar_int_enable(NRF_AAR, AAR_INTENSET_END_Msk);

	nrf_aar_task_trigger(NRF_AAR, NRF_AAR_TASK_START);

	while (NRF_AAR->EVENTS_END == 0) {
    c4be:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    c4c2:	b15a      	cbz	r2, c4dc <radio_ar_resolve+0x4c>
    p_reg->INTENCLR = mask;
    c4c4:	2201      	movs	r2, #1
    c4c6:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    c4ca:	4a07      	ldr	r2, [pc, #28]	; (c4e8 <radio_ar_resolve+0x58>)
    c4cc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    c4d0:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180

	nrf_aar_int_disable(NRF_AAR, AAR_INTENCLR_END_Msk);

	NVIC_ClearPendingIRQ(nrfx_get_irq_number(NRF_AAR));

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
    c4d4:	2200      	movs	r2, #0
    c4d6:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;

}
    c4da:	4770      	bx	lr
		__WFE();
    c4dc:	bf20      	wfe
		__SEV();
    c4de:	bf40      	sev
		__WFE();
    c4e0:	bf20      	wfe
    c4e2:	e7ec      	b.n	c4be <radio_ar_resolve+0x2e>
    c4e4:	4000f000 	.word	0x4000f000
    c4e8:	e000e100 	.word	0xe000e100

0000c4ec <mayfly_enable_cb>:

void mayfly_enable_cb(uint8_t caller_id, uint8_t callee_id, uint8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
    c4ec:	2902      	cmp	r1, #2
{
    c4ee:	b510      	push	{r4, lr}
    c4f0:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
    c4f2:	d00b      	beq.n	c50c <mayfly_enable_cb+0x20>
    c4f4:	4a0a      	ldr	r2, [pc, #40]	; (c520 <mayfly_enable_cb+0x34>)
    c4f6:	490b      	ldr	r1, [pc, #44]	; (c524 <mayfly_enable_cb+0x38>)
    c4f8:	480b      	ldr	r0, [pc, #44]	; (c528 <mayfly_enable_cb+0x3c>)
    c4fa:	231e      	movs	r3, #30
    c4fc:	f002 ffe3 	bl	f4c6 <printk>
    c500:	4040      	eors	r0, r0
    c502:	f380 8811 	msr	BASEPRI, r0
    c506:	f04f 0003 	mov.w	r0, #3
    c50a:	df02      	svc	2

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
    c50c:	200b      	movs	r0, #11
	if (enable) {
    c50e:	b11c      	cbz	r4, c518 <mayfly_enable_cb+0x2c>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
    c510:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
    c514:	f7f5 bfd8 	b.w	24c8 <arch_irq_enable>
}
    c518:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
    c51c:	f7f5 bfe4 	b.w	24e8 <arch_irq_disable>
    c520:	00013fae 	.word	0x00013fae
    c524:	00013ffc 	.word	0x00013ffc
    c528:	000133b6 	.word	0x000133b6

0000c52c <mayfly_is_enabled>:

uint32_t mayfly_is_enabled(uint8_t caller_id, uint8_t callee_id)
{
    c52c:	b508      	push	{r3, lr}
	(void)caller_id;

	switch (callee_id) {
    c52e:	b181      	cbz	r1, c552 <mayfly_is_enabled+0x26>
    c530:	3901      	subs	r1, #1
    c532:	2901      	cmp	r1, #1
    c534:	d912      	bls.n	c55c <mayfly_is_enabled+0x30>

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
    c536:	4a0a      	ldr	r2, [pc, #40]	; (c560 <mayfly_is_enabled+0x34>)
    c538:	490a      	ldr	r1, [pc, #40]	; (c564 <mayfly_is_enabled+0x38>)
    c53a:	480b      	ldr	r0, [pc, #44]	; (c568 <mayfly_is_enabled+0x3c>)
    c53c:	2336      	movs	r3, #54	; 0x36
    c53e:	f002 ffc2 	bl	f4c6 <printk>
    c542:	4040      	eors	r0, r0
    c544:	f380 8811 	msr	BASEPRI, r0
    c548:	f04f 0003 	mov.w	r0, #3
    c54c:	df02      	svc	2
		break;
	}

	return 0;
}
    c54e:	2000      	movs	r0, #0
    c550:	bd08      	pop	{r3, pc}
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
    c552:	2018      	movs	r0, #24
}
    c554:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
    c558:	f7f5 bfda 	b.w	2510 <arch_irq_is_enabled>
    c55c:	200b      	movs	r0, #11
    c55e:	e7f9      	b.n	c554 <mayfly_is_enabled+0x28>
    c560:	00013fae 	.word	0x00013fae
    c564:	00014086 	.word	0x00014086
    c568:	000133b6 	.word	0x000133b6

0000c56c <mayfly_pend>:

void mayfly_pend(uint8_t caller_id, uint8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
    c56c:	2901      	cmp	r1, #1
{
    c56e:	b508      	push	{r3, lr}
	switch (callee_id) {
    c570:	d008      	beq.n	c584 <mayfly_pend+0x18>
    c572:	2902      	cmp	r1, #2
    c574:	d006      	beq.n	c584 <mayfly_pend+0x18>
    c576:	b949      	cbnz	r1, c58c <mayfly_pend+0x20>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c578:	4b0b      	ldr	r3, [pc, #44]	; (c5a8 <mayfly_pend+0x3c>)
    c57a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    c57e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

	default:
		LL_ASSERT(0);
		break;
	}
}
    c582:	bd08      	pop	{r3, pc}
    c584:	4b08      	ldr	r3, [pc, #32]	; (c5a8 <mayfly_pend+0x3c>)
    c586:	f44f 6200 	mov.w	r2, #2048	; 0x800
    c58a:	e7f8      	b.n	c57e <mayfly_pend+0x12>
		LL_ASSERT(0);
    c58c:	4a07      	ldr	r2, [pc, #28]	; (c5ac <mayfly_pend+0x40>)
    c58e:	4908      	ldr	r1, [pc, #32]	; (c5b0 <mayfly_pend+0x44>)
    c590:	4808      	ldr	r0, [pc, #32]	; (c5b4 <mayfly_pend+0x48>)
    c592:	2367      	movs	r3, #103	; 0x67
    c594:	f002 ff97 	bl	f4c6 <printk>
    c598:	4040      	eors	r0, r0
    c59a:	f380 8811 	msr	BASEPRI, r0
    c59e:	f04f 0003 	mov.w	r0, #3
    c5a2:	df02      	svc	2
}
    c5a4:	e7ed      	b.n	c582 <mayfly_pend+0x16>
    c5a6:	bf00      	nop
    c5a8:	e000e100 	.word	0xe000e100
    c5ac:	00013fae 	.word	0x00013fae
    c5b0:	00014086 	.word	0x00014086
    c5b4:	000133b6 	.word	0x000133b6

0000c5b8 <hal_ticker_instance0_caller_id_get>:

uint8_t hal_ticker_instance0_caller_id_get(uint8_t user_id)
{
	uint8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
    c5b8:	2803      	cmp	r0, #3
{
    c5ba:	b510      	push	{r4, lr}
    c5bc:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
    c5be:	d90b      	bls.n	c5d8 <hal_ticker_instance0_caller_id_get+0x20>
    c5c0:	4a0e      	ldr	r2, [pc, #56]	; (c5fc <hal_ticker_instance0_caller_id_get+0x44>)
    c5c2:	490f      	ldr	r1, [pc, #60]	; (c600 <hal_ticker_instance0_caller_id_get+0x48>)
    c5c4:	480f      	ldr	r0, [pc, #60]	; (c604 <hal_ticker_instance0_caller_id_get+0x4c>)
    c5c6:	232b      	movs	r3, #43	; 0x2b
    c5c8:	f002 ff7d 	bl	f4c6 <printk>
    c5cc:	4040      	eors	r0, r0
    c5ce:	f380 8811 	msr	BASEPRI, r0
    c5d2:	f04f 0003 	mov.w	r0, #3
    c5d6:	df02      	svc	2

	caller_id = caller_id_lut[user_id];
    c5d8:	4b0b      	ldr	r3, [pc, #44]	; (c608 <hal_ticker_instance0_caller_id_get+0x50>)
    c5da:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
    c5dc:	b95c      	cbnz	r4, c5f6 <hal_ticker_instance0_caller_id_get+0x3e>
    c5de:	4a07      	ldr	r2, [pc, #28]	; (c5fc <hal_ticker_instance0_caller_id_get+0x44>)
    c5e0:	490a      	ldr	r1, [pc, #40]	; (c60c <hal_ticker_instance0_caller_id_get+0x54>)
    c5e2:	4808      	ldr	r0, [pc, #32]	; (c604 <hal_ticker_instance0_caller_id_get+0x4c>)
    c5e4:	232e      	movs	r3, #46	; 0x2e
    c5e6:	f002 ff6e 	bl	f4c6 <printk>
    c5ea:	4040      	eors	r0, r0
    c5ec:	f380 8811 	msr	BASEPRI, r0
    c5f0:	f04f 0003 	mov.w	r0, #3
    c5f4:	df02      	svc	2

	return caller_id;
}
    c5f6:	4620      	mov	r0, r4
    c5f8:	bd10      	pop	{r4, pc}
    c5fa:	bf00      	nop
    c5fc:	0001400b 	.word	0x0001400b
    c600:	00014059 	.word	0x00014059
    c604:	000133b6 	.word	0x000133b6
    c608:	00014088 	.word	0x00014088
    c60c:	00014079 	.word	0x00014079

0000c610 <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
    c610:	3801      	subs	r0, #1
{
    c612:	b510      	push	{r4, lr}
    c614:	461c      	mov	r4, r3
	switch (caller_id) {
    c616:	2804      	cmp	r0, #4
    c618:	d845      	bhi.n	c6a6 <hal_ticker_instance0_sched+0x96>
    c61a:	e8df f000 	tbb	[pc, r0]
    c61e:	1a03      	.short	0x1a03
    c620:	2c23      	.short	0x2c23
    c622:	3b          	.byte	0x3b
    c623:	00          	.byte	0x00
	case TICKER_CALL_ID_ISR:
		switch (callee_id) {
    c624:	2904      	cmp	r1, #4
    c626:	d107      	bne.n	c638 <hal_ticker_instance0_sched+0x28>
		{
			static memq_link_t link;
			static struct mayfly m = {0, 0, &link, NULL,
						  ticker_job};

			m.param = instance;
    c628:	4b20      	ldr	r3, [pc, #128]	; (c6ac <hal_ticker_instance0_sched+0x9c>)

			/* TODO: scheduler lock, if preemptive threads used */
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
    c62a:	2102      	movs	r1, #2
			m.param = instance;
    c62c:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
    c62e:	2000      	movs	r0, #0

	default:
		LL_ASSERT(0);
		break;
	}
}
    c630:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
    c634:	f7f7 bcc2 	b.w	3fbc <mayfly_enqueue>
			LL_ASSERT(0);
    c638:	234e      	movs	r3, #78	; 0x4e
		LL_ASSERT(0);
    c63a:	4a1d      	ldr	r2, [pc, #116]	; (c6b0 <hal_ticker_instance0_sched+0xa0>)
    c63c:	491d      	ldr	r1, [pc, #116]	; (c6b4 <hal_ticker_instance0_sched+0xa4>)
    c63e:	481e      	ldr	r0, [pc, #120]	; (c6b8 <hal_ticker_instance0_sched+0xa8>)
    c640:	f002 ff41 	bl	f4c6 <printk>
    c644:	4040      	eors	r0, r0
    c646:	f380 8811 	msr	BASEPRI, r0
    c64a:	f04f 0003 	mov.w	r0, #3
    c64e:	df02      	svc	2
}
    c650:	bd10      	pop	{r4, pc}
		switch (callee_id) {
    c652:	2903      	cmp	r1, #3
    c654:	d104      	bne.n	c660 <hal_ticker_instance0_sched+0x50>
			m.param = instance;
    c656:	4b19      	ldr	r3, [pc, #100]	; (c6bc <hal_ticker_instance0_sched+0xac>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
    c658:	2101      	movs	r1, #1
			m.param = instance;
    c65a:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    c65c:	4608      	mov	r0, r1
    c65e:	e7e7      	b.n	c630 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
    c660:	2365      	movs	r3, #101	; 0x65
    c662:	e7ea      	b.n	c63a <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
    c664:	2904      	cmp	r1, #4
    c666:	d104      	bne.n	c672 <hal_ticker_instance0_sched+0x62>
			m.param = instance;
    c668:	4b15      	ldr	r3, [pc, #84]	; (c6c0 <hal_ticker_instance0_sched+0xb0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
    c66a:	2102      	movs	r1, #2
			m.param = instance;
    c66c:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
    c66e:	2001      	movs	r0, #1
    c670:	e7de      	b.n	c630 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
    c672:	237c      	movs	r3, #124	; 0x7c
    c674:	e7e1      	b.n	c63a <hal_ticker_instance0_sched+0x2a>
		switch (callee_id) {
    c676:	2903      	cmp	r1, #3
    c678:	d003      	beq.n	c682 <hal_ticker_instance0_sched+0x72>
    c67a:	2904      	cmp	r1, #4
    c67c:	d006      	beq.n	c68c <hal_ticker_instance0_sched+0x7c>
			LL_ASSERT(0);
    c67e:	23a2      	movs	r3, #162	; 0xa2
    c680:	e7db      	b.n	c63a <hal_ticker_instance0_sched+0x2a>
			m.param = instance;
    c682:	4b10      	ldr	r3, [pc, #64]	; (c6c4 <hal_ticker_instance0_sched+0xb4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    c684:	2101      	movs	r1, #1
			m.param = instance;
    c686:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    c688:	2002      	movs	r0, #2
    c68a:	e7d1      	b.n	c630 <hal_ticker_instance0_sched+0x20>
			m.param = instance;
    c68c:	4b0e      	ldr	r3, [pc, #56]	; (c6c8 <hal_ticker_instance0_sched+0xb8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    c68e:	2102      	movs	r1, #2
			m.param = instance;
    c690:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
    c692:	e7e3      	b.n	c65c <hal_ticker_instance0_sched+0x4c>
		switch (callee_id) {
    c694:	2904      	cmp	r1, #4
    c696:	d104      	bne.n	c6a2 <hal_ticker_instance0_sched+0x92>
			m.param = instance;
    c698:	4b0c      	ldr	r3, [pc, #48]	; (c6cc <hal_ticker_instance0_sched+0xbc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
    c69a:	2102      	movs	r1, #2
			m.param = instance;
    c69c:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
    c69e:	2003      	movs	r0, #3
    c6a0:	e7c6      	b.n	c630 <hal_ticker_instance0_sched+0x20>
			LL_ASSERT(0);
    c6a2:	23ba      	movs	r3, #186	; 0xba
    c6a4:	e7c9      	b.n	c63a <hal_ticker_instance0_sched+0x2a>
		LL_ASSERT(0);
    c6a6:	23c0      	movs	r3, #192	; 0xc0
    c6a8:	e7c7      	b.n	c63a <hal_ticker_instance0_sched+0x2a>
    c6aa:	bf00      	nop
    c6ac:	2000046c 	.word	0x2000046c
    c6b0:	0001400b 	.word	0x0001400b
    c6b4:	00014086 	.word	0x00014086
    c6b8:	000133b6 	.word	0x000133b6
    c6bc:	2000045c 	.word	0x2000045c
    c6c0:	200004ac 	.word	0x200004ac
    c6c4:	2000049c 	.word	0x2000049c
    c6c8:	2000048c 	.word	0x2000048c
    c6cc:	2000047c 	.word	0x2000047c

0000c6d0 <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
    c6d0:	4b02      	ldr	r3, [pc, #8]	; (c6dc <net_buf_pool_get+0xc>)
    c6d2:	222c      	movs	r2, #44	; 0x2c
    c6d4:	fb02 3000 	mla	r0, r2, r0, r3
    c6d8:	4770      	bx	lr
    c6da:	bf00      	nop
    c6dc:	200005d0 	.word	0x200005d0

0000c6e0 <net_buf_id>:
	return pool - _net_buf_pool_list;
}

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    c6e0:	7982      	ldrb	r2, [r0, #6]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
				__alignof__(struct net_buf));
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
    c6e2:	4b06      	ldr	r3, [pc, #24]	; (c6fc <net_buf_id+0x1c>)
    c6e4:	212c      	movs	r1, #44	; 0x2c
    c6e6:	fb01 3302 	mla	r3, r1, r2, r3
    c6ea:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
    c6ec:	7f1b      	ldrb	r3, [r3, #28]
    c6ee:	3317      	adds	r3, #23
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
    c6f0:	1a80      	subs	r0, r0, r2
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
    c6f2:	f023 0303 	bic.w	r3, r3, #3

	return offset / struct_size;
}
    c6f6:	fbb0 f0f3 	udiv	r0, r0, r3
    c6fa:	4770      	bx	lr
    c6fc:	200005d0 	.word	0x200005d0

0000c700 <fixed_data_alloc>:
	.unref = mem_pool_data_unref,
};

static uint8_t *fixed_data_alloc(struct net_buf *buf, size_t *size,
			      k_timeout_t timeout)
{
    c700:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    c702:	4b0a      	ldr	r3, [pc, #40]	; (c72c <fixed_data_alloc+0x2c>)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    c704:	7982      	ldrb	r2, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    c706:	242c      	movs	r4, #44	; 0x2c
    c708:	fb04 3302 	mla	r3, r4, r2, r3

	*size = MIN(fixed->data_size, *size);
    c70c:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    c70e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    c710:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
    c712:	6823      	ldr	r3, [r4, #0]
    c714:	429a      	cmp	r2, r3
    c716:	bf94      	ite	ls
    c718:	600a      	strls	r2, [r1, #0]
    c71a:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    c71c:	f7ff ffe0 	bl	c6e0 <net_buf_id>
    c720:	e9d4 2300 	ldrd	r2, r3, [r4]
}
    c724:	fb02 3000 	mla	r0, r2, r0, r3
    c728:	bd10      	pop	{r4, pc}
    c72a:	bf00      	nop
    c72c:	200005d0 	.word	0x200005d0

0000c730 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
    c730:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c734:	4605      	mov	r5, r0
    c736:	9101      	str	r1, [sp, #4]
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    c738:	4610      	mov	r0, r2
    c73a:	4619      	mov	r1, r3
{
    c73c:	4691      	mov	r9, r2
    c73e:	4698      	mov	r8, r3
    c740:	4617      	mov	r7, r2
    c742:	461e      	mov	r6, r3
	uint64_t end = sys_clock_timeout_end_calc(timeout);
    c744:	f006 f98d 	bl	12a62 <sys_clock_timeout_end_calc>
    c748:	4682      	mov	sl, r0
    c74a:	468b      	mov	fp, r1
	__asm__ volatile(
    c74c:	f04f 0320 	mov.w	r3, #32
    c750:	f3ef 8111 	mrs	r1, BASEPRI
    c754:	f383 8812 	msr	BASEPRI_MAX, r3
    c758:	f3bf 8f6f 	isb	sy
	key = k_spin_lock(&pool->lock);

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
    c75c:	8b6b      	ldrh	r3, [r5, #26]
    c75e:	2b00      	cmp	r3, #0
    c760:	d05a      	beq.n	c818 <net_buf_alloc_len+0xe8>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
    c762:	8b2a      	ldrh	r2, [r5, #24]
    c764:	429a      	cmp	r2, r3
    c766:	d93e      	bls.n	c7e6 <net_buf_alloc_len+0xb6>
    c768:	9100      	str	r1, [sp, #0]
	return z_impl_k_queue_get(queue, timeout);
    c76a:	2200      	movs	r2, #0
    c76c:	2300      	movs	r3, #0
    c76e:	4628      	mov	r0, r5
    c770:	f001 ff50 	bl	e614 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
    c774:	9900      	ldr	r1, [sp, #0]
    c776:	4604      	mov	r4, r0
    c778:	2800      	cmp	r0, #0
    c77a:	d034      	beq.n	c7e6 <net_buf_alloc_len+0xb6>
	__asm__ volatile(
    c77c:	f381 8811 	msr	BASEPRI, r1
    c780:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
    c784:	9b01      	ldr	r3, [sp, #4]
    c786:	2b00      	cmp	r3, #0
    c788:	d056      	beq.n	c838 <net_buf_alloc_len+0x108>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    c78a:	ea58 0309 	orrs.w	r3, r8, r9
    c78e:	d00f      	beq.n	c7b0 <net_buf_alloc_len+0x80>
    c790:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    c794:	bf08      	it	eq
    c796:	f1b9 3fff 	cmpeq.w	r9, #4294967295	; 0xffffffff
    c79a:	d009      	beq.n	c7b0 <net_buf_alloc_len+0x80>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
    c79c:	f002 fd6e 	bl	f27c <sys_clock_tick_get>
    c7a0:	ebba 0700 	subs.w	r7, sl, r0
    c7a4:	eb6b 0601 	sbc.w	r6, fp, r1
    c7a8:	2e00      	cmp	r6, #0
    c7aa:	bfbc      	itt	lt
    c7ac:	2700      	movlt	r7, #0
    c7ae:	463e      	movlt	r6, r7
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    c7b0:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
    c7b2:	f8df 809c 	ldr.w	r8, [pc, #156]	; c850 <net_buf_alloc_len+0x120>
    c7b6:	f04f 092c 	mov.w	r9, #44	; 0x2c
    c7ba:	fb09 8303 	mla	r3, r9, r3, r8
    c7be:	463a      	mov	r2, r7
    c7c0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    c7c2:	681b      	ldr	r3, [r3, #0]
    c7c4:	a901      	add	r1, sp, #4
    c7c6:	681d      	ldr	r5, [r3, #0]
    c7c8:	4620      	mov	r0, r4
    c7ca:	4633      	mov	r3, r6
    c7cc:	47a8      	blx	r5
    c7ce:	4605      	mov	r5, r0
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
    c7d0:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
    c7d2:	2800      	cmp	r0, #0
    c7d4:	d131      	bne.n	c83a <net_buf_alloc_len+0x10a>
	k_lifo_put(&pool->free, buf);
    c7d6:	79a0      	ldrb	r0, [r4, #6]
    c7d8:	4621      	mov	r1, r4
    c7da:	fb00 8009 	mla	r0, r0, r9, r8
    c7de:	f005 ff07 	bl	125f0 <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
    c7e2:	462c      	mov	r4, r5
}
    c7e4:	e024      	b.n	c830 <net_buf_alloc_len+0x100>
		uninit_count = pool->uninit_count--;
    c7e6:	8b68      	ldrh	r0, [r5, #26]
    c7e8:	1e43      	subs	r3, r0, #1
    c7ea:	836b      	strh	r3, [r5, #26]
    c7ec:	f381 8811 	msr	BASEPRI, r1
    c7f0:	f3bf 8f6f 	isb	sy
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
    c7f4:	7f2a      	ldrb	r2, [r5, #28]
    c7f6:	f102 0417 	add.w	r4, r2, #23
    c7fa:	f024 0303 	bic.w	r3, r4, #3
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
    c7fe:	8b2c      	ldrh	r4, [r5, #24]
    c800:	1a20      	subs	r0, r4, r0
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
    c802:	6aac      	ldr	r4, [r5, #40]	; 0x28
    c804:	fb00 4403 	mla	r4, r0, r3, r4
	return pool - _net_buf_pool_list;
    c808:	4811      	ldr	r0, [pc, #68]	; (c850 <net_buf_alloc_len+0x120>)
    c80a:	4b12      	ldr	r3, [pc, #72]	; (c854 <net_buf_alloc_len+0x124>)
	buf->user_data_size = pool->user_data_size;
    c80c:	71e2      	strb	r2, [r4, #7]
	return pool - _net_buf_pool_list;
    c80e:	1a2d      	subs	r5, r5, r0
    c810:	10ad      	asrs	r5, r5, #2
    c812:	435d      	muls	r5, r3
	buf->pool_id = pool_id(pool);
    c814:	71a5      	strb	r5, [r4, #6]
		goto success;
    c816:	e7b5      	b.n	c784 <net_buf_alloc_len+0x54>
    c818:	f381 8811 	msr	BASEPRI, r1
    c81c:	f3bf 8f6f 	isb	sy
    c820:	464a      	mov	r2, r9
    c822:	4643      	mov	r3, r8
    c824:	4628      	mov	r0, r5
    c826:	f001 fef5 	bl	e614 <z_impl_k_queue_get>
	if (!buf) {
    c82a:	4604      	mov	r4, r0
    c82c:	2800      	cmp	r0, #0
    c82e:	d1a9      	bne.n	c784 <net_buf_alloc_len+0x54>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
    c830:	4620      	mov	r0, r4
    c832:	b003      	add	sp, #12
    c834:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buf->__buf = NULL;
    c838:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
    c83a:	2300      	movs	r3, #0
	buf->ref   = 1U;
    c83c:	2201      	movs	r2, #1
	buf->frags = NULL;
    c83e:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
    c840:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
    c842:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
    c844:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
    c846:	6923      	ldr	r3, [r4, #16]
    c848:	81e2      	strh	r2, [r4, #14]
    c84a:	60a3      	str	r3, [r4, #8]
	return buf;
    c84c:	e7f0      	b.n	c830 <net_buf_alloc_len+0x100>
    c84e:	bf00      	nop
    c850:	200005d0 	.word	0x200005d0
    c854:	ba2e8ba3 	.word	0xba2e8ba3

0000c858 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
    c858:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c85c:	4d16      	ldr	r5, [pc, #88]	; (c8b8 <net_buf_unref+0x60>)
    c85e:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
    c860:	2600      	movs	r6, #0
	pool->alloc->cb->unref(buf, data);
    c862:	272c      	movs	r7, #44	; 0x2c
	while (buf) {
    c864:	b90c      	cbnz	r4, c86a <net_buf_unref+0x12>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
    c866:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (--buf->ref > 0) {
    c86a:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
    c86c:	f8d4 8000 	ldr.w	r8, [r4]
		if (--buf->ref > 0) {
    c870:	3b01      	subs	r3, #1
    c872:	b2db      	uxtb	r3, r3
    c874:	7123      	strb	r3, [r4, #4]
    c876:	2b00      	cmp	r3, #0
    c878:	d1f5      	bne.n	c866 <net_buf_unref+0xe>
		if (buf->__buf) {
    c87a:	6921      	ldr	r1, [r4, #16]
    c87c:	b159      	cbz	r1, c896 <net_buf_unref+0x3e>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
    c87e:	7963      	ldrb	r3, [r4, #5]
    c880:	079b      	lsls	r3, r3, #30
    c882:	d407      	bmi.n	c894 <net_buf_unref+0x3c>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    c884:	79a3      	ldrb	r3, [r4, #6]
	pool->alloc->cb->unref(buf, data);
    c886:	fb07 5303 	mla	r3, r7, r3, r5
    c88a:	4620      	mov	r0, r4
    c88c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    c88e:	681b      	ldr	r3, [r3, #0]
    c890:	689b      	ldr	r3, [r3, #8]
    c892:	4798      	blx	r3
			buf->__buf = NULL;
    c894:	6126      	str	r6, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
    c896:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
    c898:	60a6      	str	r6, [r4, #8]
		if (pool->destroy) {
    c89a:	fb07 5300 	mla	r3, r7, r0, r5
		buf->frags = NULL;
    c89e:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
    c8a0:	6a1b      	ldr	r3, [r3, #32]
    c8a2:	b11b      	cbz	r3, c8ac <net_buf_unref+0x54>
			pool->destroy(buf);
    c8a4:	4620      	mov	r0, r4
    c8a6:	4798      	blx	r3
{
    c8a8:	4644      	mov	r4, r8
    c8aa:	e7db      	b.n	c864 <net_buf_unref+0xc>
	k_lifo_put(&pool->free, buf);
    c8ac:	4621      	mov	r1, r4
    c8ae:	fb00 5007 	mla	r0, r0, r7, r5
    c8b2:	f005 fe9d 	bl	125f0 <k_queue_prepend>
}
    c8b6:	e7f7      	b.n	c8a8 <net_buf_unref+0x50>
    c8b8:	200005d0 	.word	0x200005d0

0000c8bc <timing_init>:

static bool has_inited;
static atomic_val_t started_ref;

void timing_init(void)
{
    c8bc:	b510      	push	{r4, lr}
	if (has_inited) {
    c8be:	4c04      	ldr	r4, [pc, #16]	; (c8d0 <timing_init+0x14>)
    c8c0:	7823      	ldrb	r3, [r4, #0]
    c8c2:	b91b      	cbnz	r3, c8cc <timing_init+0x10>
#if defined(CONFIG_BOARD_HAS_TIMING_FUNCTIONS)
	board_timing_init();
#elif defined(CONFIG_SOC_HAS_TIMING_FUNCTIONS)
	soc_timing_init();
#else
	arch_timing_init();
    c8c4:	f7f6 f87a 	bl	29bc <arch_timing_init>
#endif

	has_inited = true;
    c8c8:	2301      	movs	r3, #1
    c8ca:	7023      	strb	r3, [r4, #0]
}
    c8cc:	bd10      	pop	{r4, pc}
    c8ce:	bf00      	nop
    c8d0:	20002a7b 	.word	0x20002a7b

0000c8d4 <timing_start>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    c8d4:	4b07      	ldr	r3, [pc, #28]	; (c8f4 <timing_start+0x20>)
    c8d6:	f3bf 8f5b 	dmb	ish
    c8da:	e853 2f00 	ldrex	r2, [r3]
    c8de:	1c51      	adds	r1, r2, #1
    c8e0:	e843 1000 	strex	r0, r1, [r3]
    c8e4:	2800      	cmp	r0, #0
    c8e6:	d1f8      	bne.n	c8da <timing_start+0x6>
    c8e8:	f3bf 8f5b 	dmb	ish

void timing_start(void)
{
	if (atomic_inc(&started_ref) != 0) {
    c8ec:	b90a      	cbnz	r2, c8f2 <timing_start+0x1e>
#if defined(CONFIG_BOARD_HAS_TIMING_FUNCTIONS)
	board_timing_start();
#elif defined(CONFIG_SOC_HAS_TIMING_FUNCTIONS)
	soc_timing_start();
#else
	arch_timing_start();
    c8ee:	f7f6 b879 	b.w	29e4 <arch_timing_start>
#endif
}
    c8f2:	4770      	bx	lr
    c8f4:	20002504 	.word	0x20002504

0000c8f8 <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    c8f8:	4b08      	ldr	r3, [pc, #32]	; (c91c <onoff_stop+0x24>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    c8fa:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
    c8fc:	1ac3      	subs	r3, r0, r3
{
    c8fe:	460d      	mov	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    c900:	4907      	ldr	r1, [pc, #28]	; (c920 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
    c902:	109b      	asrs	r3, r3, #2
{
    c904:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    c906:	4359      	muls	r1, r3
    c908:	4806      	ldr	r0, [pc, #24]	; (c924 <onoff_stop+0x2c>)
    c90a:	2240      	movs	r2, #64	; 0x40
    c90c:	f005 fb4c 	bl	11fa8 <stop>
	notify(mgr, res);
    c910:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    c912:	4601      	mov	r1, r0
	notify(mgr, res);
    c914:	4620      	mov	r0, r4
}
    c916:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
    c91a:	4718      	bx	r3
    c91c:	20002518 	.word	0x20002518
    c920:	b6db6db7 	.word	0xb6db6db7
    c924:	00012dbc 	.word	0x00012dbc

0000c928 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    c928:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
    c92a:	4c0c      	ldr	r4, [pc, #48]	; (c95c <onoff_start+0x34>)
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    c92c:	4a0c      	ldr	r2, [pc, #48]	; (c960 <onoff_start+0x38>)
    c92e:	2340      	movs	r3, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
    c930:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    c932:	9300      	str	r3, [sp, #0]
{
    c934:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    c936:	460b      	mov	r3, r1
    c938:	490a      	ldr	r1, [pc, #40]	; (c964 <onoff_start+0x3c>)
	size_t offset = (size_t)(mgr - data->mgr);
    c93a:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    c93c:	4361      	muls	r1, r4
{
    c93e:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    c940:	4809      	ldr	r0, [pc, #36]	; (c968 <onoff_start+0x40>)
    c942:	f005 fb5d 	bl	12000 <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    c946:	1e01      	subs	r1, r0, #0
    c948:	da05      	bge.n	c956 <onoff_start+0x2e>
		notify(mgr, err);
    c94a:	4630      	mov	r0, r6
    c94c:	462b      	mov	r3, r5
	}
}
    c94e:	b002      	add	sp, #8
    c950:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
    c954:	4718      	bx	r3
}
    c956:	b002      	add	sp, #8
    c958:	bd70      	pop	{r4, r5, r6, pc}
    c95a:	bf00      	nop
    c95c:	20002518 	.word	0x20002518
    c960:	00012071 	.word	0x00012071
    c964:	b6db6db7 	.word	0xb6db6db7
    c968:	00012dbc 	.word	0x00012dbc

0000c96c <clk_init>:
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    c96c:	2200      	movs	r2, #0
{
    c96e:	b570      	push	{r4, r5, r6, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    c970:	2101      	movs	r1, #1
{
    c972:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    c974:	4610      	mov	r0, r2
    c976:	f7f5 fdd9 	bl	252c <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
    c97a:	2000      	movs	r0, #0
    c97c:	f7f5 fda4 	bl	24c8 <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
    c980:	480f      	ldr	r0, [pc, #60]	; (c9c0 <clk_init+0x54>)
    c982:	f001 f83d 	bl	da00 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    c986:	4b0f      	ldr	r3, [pc, #60]	; (c9c4 <clk_init+0x58>)
    c988:	4298      	cmp	r0, r3
    c98a:	d115      	bne.n	c9b8 <clk_init+0x4c>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    c98c:	f005 fc78 	bl	12280 <nrfx_clock_enable>
	struct nrf_clock_control_data *data = dev->data;
    c990:	6926      	ldr	r6, [r4, #16]
	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);

		err = onoff_manager_init(get_onoff_manager(dev, i),
    c992:	490d      	ldr	r1, [pc, #52]	; (c9c8 <clk_init+0x5c>)
    c994:	4630      	mov	r0, r6
    c996:	f002 fdff 	bl	f598 <onoff_manager_init>
					 &transitions);
		if (err < 0) {
    c99a:	2800      	cmp	r0, #0
    c99c:	db0b      	blt.n	c9b6 <clk_init+0x4a>
	struct nrf_clock_control_data *data = dev->data;
    c99e:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
    c9a0:	4909      	ldr	r1, [pc, #36]	; (c9c8 <clk_init+0x5c>)
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    c9a2:	2501      	movs	r5, #1
    c9a4:	6435      	str	r5, [r6, #64]	; 0x40
		err = onoff_manager_init(get_onoff_manager(dev, i),
    c9a6:	f104 001c 	add.w	r0, r4, #28
    c9aa:	f002 fdf5 	bl	f598 <onoff_manager_init>
		if (err < 0) {
    c9ae:	2800      	cmp	r0, #0
    c9b0:	db01      	blt.n	c9b6 <clk_init+0x4a>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    c9b2:	64e5      	str	r5, [r4, #76]	; 0x4c
	}

	return 0;
    c9b4:	2000      	movs	r0, #0
}
    c9b6:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
    c9b8:	f06f 0004 	mvn.w	r0, #4
    c9bc:	e7fb      	b.n	c9b6 <clk_init+0x4a>
    c9be:	bf00      	nop
    c9c0:	0000ca01 	.word	0x0000ca01
    c9c4:	0bad0000 	.word	0x0bad0000
    c9c8:	00013114 	.word	0x00013114

0000c9cc <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
    c9cc:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
    c9ce:	230c      	movs	r3, #12
    c9d0:	4809      	ldr	r0, [pc, #36]	; (c9f8 <clkstarted_handle.constprop.0+0x2c>)
    c9d2:	434b      	muls	r3, r1
static void clkstarted_handle(const struct device *dev,
    c9d4:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
    c9d6:	18c4      	adds	r4, r0, r3
	void *user_data = sub_data->user_data;
    c9d8:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	sub_data->cb = NULL;
    c9dc:	2200      	movs	r2, #0
	set_on_state(&sub_data->flags);
    c9de:	3340      	adds	r3, #64	; 0x40
	sub_data->cb = NULL;
    c9e0:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
    c9e2:	4418      	add	r0, r3
    c9e4:	f005 facd 	bl	11f82 <set_on_state>
	if (callback) {
    c9e8:	b12d      	cbz	r5, c9f6 <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
    c9ea:	4632      	mov	r2, r6
    c9ec:	462b      	mov	r3, r5
    c9ee:	4803      	ldr	r0, [pc, #12]	; (c9fc <clkstarted_handle.constprop.0+0x30>)
}
    c9f0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
    c9f4:	4718      	bx	r3
}
    c9f6:	bd70      	pop	{r4, r5, r6, pc}
    c9f8:	20002518 	.word	0x20002518
    c9fc:	00012dbc 	.word	0x00012dbc

0000ca00 <clock_event_handler>:
	switch (event) {
    ca00:	b110      	cbz	r0, ca08 <clock_event_handler+0x8>
    ca02:	2801      	cmp	r0, #1
    ca04:	d004      	beq.n	ca10 <clock_event_handler+0x10>
    ca06:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    ca08:	4b03      	ldr	r3, [pc, #12]	; (ca18 <clock_event_handler+0x18>)
    ca0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    ca0c:	075b      	lsls	r3, r3, #29
    ca0e:	d101      	bne.n	ca14 <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    ca10:	f7ff bfdc 	b.w	c9cc <clkstarted_handle.constprop.0>
}
    ca14:	4770      	bx	lr
    ca16:	bf00      	nop
    ca18:	20002518 	.word	0x20002518

0000ca1c <generic_hfclk_start>:
{
    ca1c:	b508      	push	{r3, lr}
	__asm__ volatile(
    ca1e:	f04f 0320 	mov.w	r3, #32
    ca22:	f3ef 8111 	mrs	r1, BASEPRI
    ca26:	f383 8812 	msr	BASEPRI_MAX, r3
    ca2a:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
    ca2e:	4a12      	ldr	r2, [pc, #72]	; (ca78 <generic_hfclk_start+0x5c>)
    ca30:	6813      	ldr	r3, [r2, #0]
    ca32:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
    ca36:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
    ca3a:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    ca3c:	d00c      	beq.n	ca58 <generic_hfclk_start+0x3c>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    ca3e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    ca42:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    ca46:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    ca4a:	f013 0301 	ands.w	r3, r3, #1
    ca4e:	d003      	beq.n	ca58 <generic_hfclk_start+0x3c>
			set_on_state(get_hf_flags());
    ca50:	480a      	ldr	r0, [pc, #40]	; (ca7c <generic_hfclk_start+0x60>)
    ca52:	f005 fa96 	bl	11f82 <set_on_state>
			already_started = true;
    ca56:	2301      	movs	r3, #1
	__asm__ volatile(
    ca58:	f381 8811 	msr	BASEPRI, r1
    ca5c:	f3bf 8f6f 	isb	sy
	if (already_started) {
    ca60:	b123      	cbz	r3, ca6c <generic_hfclk_start+0x50>
}
    ca62:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
    ca66:	2000      	movs	r0, #0
    ca68:	f7ff bfb0 	b.w	c9cc <clkstarted_handle.constprop.0>
}
    ca6c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    ca70:	2001      	movs	r0, #1
    ca72:	f005 bc0f 	b.w	12294 <nrfx_clock_start>
    ca76:	bf00      	nop
    ca78:	20002568 	.word	0x20002568
    ca7c:	20002558 	.word	0x20002558

0000ca80 <api_blocking_start>:
{
    ca80:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    ca82:	2200      	movs	r2, #0
    ca84:	2301      	movs	r3, #1
    ca86:	e9cd 2302 	strd	r2, r3, [sp, #8]
    ca8a:	ab04      	add	r3, sp, #16
    ca8c:	e9cd 3304 	strd	r3, r3, [sp, #16]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    ca90:	4a09      	ldr	r2, [pc, #36]	; (cab8 <api_blocking_start+0x38>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    ca92:	f8cd d000 	str.w	sp, [sp]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    ca96:	466b      	mov	r3, sp
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    ca98:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    ca9c:	f005 fae1 	bl	12062 <api_start>
	if (err < 0) {
    caa0:	2800      	cmp	r0, #0
    caa2:	db05      	blt.n	cab0 <api_blocking_start+0x30>
	return z_impl_k_sem_take(sem, timeout);
    caa4:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    caa8:	2300      	movs	r3, #0
    caaa:	4668      	mov	r0, sp
    caac:	f001 fe0c 	bl	e6c8 <z_impl_k_sem_take>
}
    cab0:	b007      	add	sp, #28
    cab2:	f85d fb04 	ldr.w	pc, [sp], #4
    cab6:	bf00      	nop
    cab8:	0001208f 	.word	0x0001208f

0000cabc <generic_hfclk_stop>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    cabc:	4b09      	ldr	r3, [pc, #36]	; (cae4 <generic_hfclk_stop+0x28>)
    cabe:	f3bf 8f5b 	dmb	ish
    cac2:	e853 2f00 	ldrex	r2, [r3]
    cac6:	f022 0102 	bic.w	r1, r2, #2
    caca:	e843 1000 	strex	r0, r1, [r3]
    cace:	2800      	cmp	r0, #0
    cad0:	d1f7      	bne.n	cac2 <generic_hfclk_stop+0x6>
    cad2:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    cad6:	07d3      	lsls	r3, r2, #31
    cad8:	d402      	bmi.n	cae0 <generic_hfclk_stop+0x24>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    cada:	2001      	movs	r0, #1
    cadc:	f000 bfa0 	b.w	da20 <nrfx_clock_stop>
}
    cae0:	4770      	bx	lr
    cae2:	bf00      	nop
    cae4:	20002568 	.word	0x20002568

0000cae8 <z_nrf_clock_control_get_onoff>:
}
    cae8:	4a02      	ldr	r2, [pc, #8]	; (caf4 <z_nrf_clock_control_get_onoff+0xc>)
	return &data->mgr[type];
    caea:	b2c3      	uxtb	r3, r0
}
    caec:	201c      	movs	r0, #28
    caee:	fb03 2000 	mla	r0, r3, r0, r2
    caf2:	4770      	bx	lr
    caf4:	20002518 	.word	0x20002518

0000caf8 <z_nrf_clock_bt_ctlr_hf_request>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    caf8:	4b09      	ldr	r3, [pc, #36]	; (cb20 <z_nrf_clock_bt_ctlr_hf_request+0x28>)
    cafa:	f3bf 8f5b 	dmb	ish
    cafe:	e853 2f00 	ldrex	r2, [r3]
    cb02:	f042 0101 	orr.w	r1, r2, #1
    cb06:	e843 1000 	strex	r0, r1, [r3]
    cb0a:	2800      	cmp	r0, #0
    cb0c:	d1f7      	bne.n	cafe <z_nrf_clock_bt_ctlr_hf_request+0x6>
    cb0e:	f3bf 8f5b 	dmb	ish
	if (atomic_or(&hfclk_users, HF_USER_BT) & HF_USER_GENERIC) {
    cb12:	0793      	lsls	r3, r2, #30
    cb14:	d402      	bmi.n	cb1c <z_nrf_clock_bt_ctlr_hf_request+0x24>
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    cb16:	2001      	movs	r0, #1
    cb18:	f005 bbbc 	b.w	12294 <nrfx_clock_start>
}
    cb1c:	4770      	bx	lr
    cb1e:	bf00      	nop
    cb20:	20002568 	.word	0x20002568

0000cb24 <z_nrf_clock_bt_ctlr_hf_release>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    cb24:	4b09      	ldr	r3, [pc, #36]	; (cb4c <z_nrf_clock_bt_ctlr_hf_release+0x28>)
    cb26:	f3bf 8f5b 	dmb	ish
    cb2a:	e853 2f00 	ldrex	r2, [r3]
    cb2e:	f022 0101 	bic.w	r1, r2, #1
    cb32:	e843 1000 	strex	r0, r1, [r3]
    cb36:	2800      	cmp	r0, #0
    cb38:	d1f7      	bne.n	cb2a <z_nrf_clock_bt_ctlr_hf_release+0x6>
    cb3a:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_BT) & HF_USER_GENERIC) {
    cb3e:	0793      	lsls	r3, r2, #30
    cb40:	d402      	bmi.n	cb48 <z_nrf_clock_bt_ctlr_hf_release+0x24>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    cb42:	2001      	movs	r0, #1
    cb44:	f000 bf6c 	b.w	da20 <nrfx_clock_stop>
}
    cb48:	4770      	bx	lr
    cb4a:	bf00      	nop
    cb4c:	20002568 	.word	0x20002568

0000cb50 <z_nrf_clock_control_lf_on>:
{
    cb50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    cb54:	4939      	ldr	r1, [pc, #228]	; (cc3c <z_nrf_clock_control_lf_on+0xec>)
    cb56:	f3bf 8f5b 	dmb	ish
    cb5a:	4607      	mov	r7, r0
    cb5c:	2201      	movs	r2, #1
    cb5e:	e851 3f00 	ldrex	r3, [r1]
    cb62:	e841 2000 	strex	r0, r2, [r1]
    cb66:	2800      	cmp	r0, #0
    cb68:	d1f9      	bne.n	cb5e <z_nrf_clock_control_lf_on+0xe>
    cb6a:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&on, 1) == 0) {
    cb6e:	b933      	cbnz	r3, cb7e <z_nrf_clock_control_lf_on+0x2e>
    cb70:	4933      	ldr	r1, [pc, #204]	; (cc40 <z_nrf_clock_control_lf_on+0xf0>)
		err = onoff_request(mgr, &cli);
    cb72:	4834      	ldr	r0, [pc, #208]	; (cc44 <z_nrf_clock_control_lf_on+0xf4>)
    cb74:	604b      	str	r3, [r1, #4]
    cb76:	60cb      	str	r3, [r1, #12]
    cb78:	608a      	str	r2, [r1, #8]
    cb7a:	f002 fd20 	bl	f5be <onoff_request>
	switch (start_mode) {
    cb7e:	1e7b      	subs	r3, r7, #1
    cb80:	2b01      	cmp	r3, #1
    cb82:	d82f      	bhi.n	cbe4 <z_nrf_clock_control_lf_on+0x94>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    cb84:	2f01      	cmp	r7, #1
    cb86:	d107      	bne.n	cb98 <z_nrf_clock_control_lf_on+0x48>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    cb88:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    cb8c:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
    cb90:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    cb94:	2b01      	cmp	r3, #1
    cb96:	d025      	beq.n	cbe4 <z_nrf_clock_control_lf_on+0x94>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    cb98:	f005 fc9d 	bl	124d6 <k_is_in_isr>
    cb9c:	4604      	mov	r4, r0
    cb9e:	b918      	cbnz	r0, cba8 <z_nrf_clock_control_lf_on+0x58>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
    cba0:	4b29      	ldr	r3, [pc, #164]	; (cc48 <z_nrf_clock_control_lf_on+0xf8>)
	int key = isr_mode ? irq_lock() : 0;
    cba2:	781b      	ldrb	r3, [r3, #0]
    cba4:	2b00      	cmp	r3, #0
    cba6:	d141      	bne.n	cc2c <z_nrf_clock_control_lf_on+0xdc>
	__asm__ volatile(
    cba8:	f04f 0320 	mov.w	r3, #32
    cbac:	f3ef 8611 	mrs	r6, BASEPRI
    cbb0:	f383 8812 	msr	BASEPRI_MAX, r3
    cbb4:	f3bf 8f6f 	isb	sy
    cbb8:	2401      	movs	r4, #1
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    cbba:	f8df 8090 	ldr.w	r8, [pc, #144]	; cc4c <z_nrf_clock_control_lf_on+0xfc>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    cbbe:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    cbc2:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    cbc6:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
    cbca:	03d2      	lsls	r2, r2, #15
    cbcc:	d50c      	bpl.n	cbe8 <z_nrf_clock_control_lf_on+0x98>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    cbce:	f003 0303 	and.w	r3, r3, #3
	while (!(nrfx_clock_is_running(d, (void *)&type)
    cbd2:	2b01      	cmp	r3, #1
    cbd4:	d001      	beq.n	cbda <z_nrf_clock_control_lf_on+0x8a>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    cbd6:	2f01      	cmp	r7, #1
    cbd8:	d106      	bne.n	cbe8 <z_nrf_clock_control_lf_on+0x98>
	if (isr_mode) {
    cbda:	b30c      	cbz	r4, cc20 <z_nrf_clock_control_lf_on+0xd0>
	__asm__ volatile(
    cbdc:	f386 8811 	msr	BASEPRI, r6
    cbe0:	f3bf 8f6f 	isb	sy
}
    cbe4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
    cbe8:	b1ac      	cbz	r4, cc16 <z_nrf_clock_control_lf_on+0xc6>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    cbea:	4630      	mov	r0, r6
    cbec:	f7f5 fc62 	bl	24b4 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    cbf0:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    cbf4:	2b00      	cmp	r3, #0
    cbf6:	d1e4      	bne.n	cbc2 <z_nrf_clock_control_lf_on+0x72>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    cbf8:	f8d5 2104 	ldr.w	r2, [r5, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
    cbfc:	2a00      	cmp	r2, #0
    cbfe:	d0e0      	beq.n	cbc2 <z_nrf_clock_control_lf_on+0x72>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    cc00:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
    cc04:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
    cc08:	2301      	movs	r3, #1
    cc0a:	f8c5 3518 	str.w	r3, [r5, #1304]	; 0x518
    cc0e:	f8c8 3180 	str.w	r3, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    cc12:	60ab      	str	r3, [r5, #8]
}
    cc14:	e7d5      	b.n	cbc2 <z_nrf_clock_control_lf_on+0x72>
	return z_impl_k_sleep(timeout);
    cc16:	2100      	movs	r1, #0
    cc18:	2021      	movs	r0, #33	; 0x21
    cc1a:	f002 f95f 	bl	eedc <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    cc1e:	e7e7      	b.n	cbf0 <z_nrf_clock_control_lf_on+0xa0>
    p_reg->INTENSET = mask;
    cc20:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    cc24:	2202      	movs	r2, #2
    cc26:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    cc2a:	e7db      	b.n	cbe4 <z_nrf_clock_control_lf_on+0x94>
    p_reg->INTENCLR = mask;
    cc2c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    cc30:	2202      	movs	r2, #2
    cc32:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	int key = isr_mode ? irq_lock() : 0;
    cc36:	4606      	mov	r6, r0
}
    cc38:	e7bf      	b.n	cbba <z_nrf_clock_control_lf_on+0x6a>
    cc3a:	bf00      	nop
    cc3c:	2000256c 	.word	0x2000256c
    cc40:	20002508 	.word	0x20002508
    cc44:	20002534 	.word	0x20002534
    cc48:	20002e8c 	.word	0x20002e8c
    cc4c:	e000e100 	.word	0xe000e100

0000cc50 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    cc50:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    cc52:	4b08      	ldr	r3, [pc, #32]	; (cc74 <uart_console_init+0x24>)
    cc54:	4808      	ldr	r0, [pc, #32]	; (cc78 <uart_console_init+0x28>)
    cc56:	6018      	str	r0, [r3, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
    cc58:	f005 fba6 	bl	123a8 <z_device_ready>
    cc5c:	b138      	cbz	r0, cc6e <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
    cc5e:	4807      	ldr	r0, [pc, #28]	; (cc7c <uart_console_init+0x2c>)
    cc60:	f7f5 ffa6 	bl	2bb0 <__stdout_hook_install>
	__printk_hook_install(console_out);
    cc64:	4805      	ldr	r0, [pc, #20]	; (cc7c <uart_console_init+0x2c>)
    cc66:	f7f4 fe39 	bl	18dc <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
    cc6a:	2000      	movs	r0, #0
}
    cc6c:	bd08      	pop	{r3, pc}
		return -ENODEV;
    cc6e:	f06f 0012 	mvn.w	r0, #18
    cc72:	e7fb      	b.n	cc6c <uart_console_init+0x1c>
    cc74:	20002570 	.word	0x20002570
    cc78:	00012e34 	.word	0x00012e34
    cc7c:	0000cc81 	.word	0x0000cc81

0000cc80 <console_out>:
	if ('\n' == c) {
    cc80:	280a      	cmp	r0, #10
{
    cc82:	b538      	push	{r3, r4, r5, lr}
    cc84:	4d07      	ldr	r5, [pc, #28]	; (cca4 <console_out+0x24>)
    cc86:	4604      	mov	r4, r0
	if ('\n' == c) {
    cc88:	d104      	bne.n	cc94 <console_out+0x14>
		uart_poll_out(uart_console_dev, '\r');
    cc8a:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    cc8c:	6883      	ldr	r3, [r0, #8]
    cc8e:	210d      	movs	r1, #13
    cc90:	685b      	ldr	r3, [r3, #4]
    cc92:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
    cc94:	6828      	ldr	r0, [r5, #0]
    cc96:	6883      	ldr	r3, [r0, #8]
    cc98:	b2e1      	uxtb	r1, r4
    cc9a:	685b      	ldr	r3, [r3, #4]
    cc9c:	4798      	blx	r3
}
    cc9e:	4620      	mov	r0, r4
    cca0:	bd38      	pop	{r3, r4, r5, pc}
    cca2:	bf00      	nop
    cca4:	20002570 	.word	0x20002570

0000cca8 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
    cca8:	b530      	push	{r4, r5, lr}
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    ccaa:	6840      	ldr	r0, [r0, #4]
    ccac:	7a04      	ldrb	r4, [r0, #8]
    ccae:	f001 011f 	and.w	r1, r1, #31
	nrfx_err_t err;

	if (mode == GPIO_INT_MODE_DISABLED) {
    ccb2:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
{
    ccb6:	b085      	sub	sp, #20
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    ccb8:	ea41 1444 	orr.w	r4, r1, r4, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
    ccbc:	f04f 0500 	mov.w	r5, #0
    ccc0:	d104      	bne.n	cccc <gpio_nrfx_pin_interrupt_configure+0x24>
		nrfx_gpiote_trigger_disable(abs_pin);
    ccc2:	4620      	mov	r0, r4
    ccc4:	f001 f95a 	bl	df7c <nrfx_gpiote_trigger_disable>
		return -EIO;
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
    ccc8:	2000      	movs	r0, #0
    ccca:	e02d      	b.n	cd28 <gpio_nrfx_pin_interrupt_configure+0x80>
	if (mode == GPIO_INT_MODE_LEVEL) {
    cccc:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
	nrfx_gpiote_trigger_config_t trigger_config = {
    ccd0:	e9cd 5502 	strd	r5, r5, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
    ccd4:	d12a      	bne.n	cd2c <gpio_nrfx_pin_interrupt_configure+0x84>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
    ccd6:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    ccda:	bf0c      	ite	eq
    ccdc:	2304      	moveq	r3, #4
    ccde:	2305      	movne	r3, #5
	if (IS_ENABLED(CONFIG_GPIO_NRF_INT_EDGE_USING_GPIOTE) &&
    cce0:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
	nrfx_gpiote_trigger_config_t trigger_config = {
    cce4:	f88d 3008 	strb.w	r3, [sp, #8]
	if (IS_ENABLED(CONFIG_GPIO_NRF_INT_EDGE_USING_GPIOTE) &&
    cce8:	d12c      	bne.n	cd44 <gpio_nrfx_pin_interrupt_configure+0x9c>
NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;

    return pin_number >> 5;
    ccea:	0962      	lsrs	r2, r4, #5
        case 1: return NRF_P1;
    ccec:	2a01      	cmp	r2, #1
    *p_pin = pin_number & 0x1F;
    ccee:	f004 031f 	and.w	r3, r4, #31
        case 1: return NRF_P1;
    ccf2:	4a1d      	ldr	r2, [pc, #116]	; (cd68 <gpio_nrfx_pin_interrupt_configure+0xc0>)
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    ccf4:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
        case 1: return NRF_P1;
    ccf8:	bf18      	it	ne
    ccfa:	f04f 42a0 	movne.w	r2, #1342177280	; 0x50000000
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    ccfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
    cd02:	07db      	lsls	r3, r3, #31
    cd04:	d41e      	bmi.n	cd44 <gpio_nrfx_pin_interrupt_configure+0x9c>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
    cd06:	f10d 0507 	add.w	r5, sp, #7
    cd0a:	4629      	mov	r1, r5
    cd0c:	4620      	mov	r0, r4
    cd0e:	f001 f899 	bl	de44 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
    cd12:	4b16      	ldr	r3, [pc, #88]	; (cd6c <gpio_nrfx_pin_interrupt_configure+0xc4>)
    cd14:	4298      	cmp	r0, r3
    cd16:	d114      	bne.n	cd42 <gpio_nrfx_pin_interrupt_configure+0x9a>
			err = nrfx_gpiote_channel_alloc(&ch);
    cd18:	4628      	mov	r0, r5
    cd1a:	f001 f8e1 	bl	dee0 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
    cd1e:	4b14      	ldr	r3, [pc, #80]	; (cd70 <gpio_nrfx_pin_interrupt_configure+0xc8>)
    cd20:	4298      	cmp	r0, r3
    cd22:	d00e      	beq.n	cd42 <gpio_nrfx_pin_interrupt_configure+0x9a>
				return -ENOMEM;
    cd24:	f06f 000b 	mvn.w	r0, #11
}
    cd28:	b005      	add	sp, #20
    cd2a:	bd30      	pop	{r4, r5, pc}
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
    cd2c:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    cd30:	d005      	beq.n	cd3e <gpio_nrfx_pin_interrupt_configure+0x96>
    cd32:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    cd36:	bf0c      	ite	eq
    cd38:	2302      	moveq	r3, #2
    cd3a:	2301      	movne	r3, #1
    cd3c:	e7d0      	b.n	cce0 <gpio_nrfx_pin_interrupt_configure+0x38>
    cd3e:	2303      	movs	r3, #3
    cd40:	e7ce      	b.n	cce0 <gpio_nrfx_pin_interrupt_configure+0x38>
		trigger_config.p_in_channel = &ch;
    cd42:	9503      	str	r5, [sp, #12]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    cd44:	2300      	movs	r3, #0
    cd46:	4619      	mov	r1, r3
    cd48:	aa02      	add	r2, sp, #8
    cd4a:	4620      	mov	r0, r4
    cd4c:	f000 ff54 	bl	dbf8 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    cd50:	4b07      	ldr	r3, [pc, #28]	; (cd70 <gpio_nrfx_pin_interrupt_configure+0xc8>)
    cd52:	4298      	cmp	r0, r3
    cd54:	d104      	bne.n	cd60 <gpio_nrfx_pin_interrupt_configure+0xb8>
	nrfx_gpiote_trigger_enable(abs_pin, true);
    cd56:	2101      	movs	r1, #1
    cd58:	4620      	mov	r0, r4
    cd5a:	f001 f8c7 	bl	deec <nrfx_gpiote_trigger_enable>
    cd5e:	e7b3      	b.n	ccc8 <gpio_nrfx_pin_interrupt_configure+0x20>
		return -EIO;
    cd60:	f06f 0004 	mvn.w	r0, #4
    cd64:	e7e0      	b.n	cd28 <gpio_nrfx_pin_interrupt_configure+0x80>
    cd66:	bf00      	nop
    cd68:	50000300 	.word	0x50000300
    cd6c:	0bad0004 	.word	0x0bad0004
    cd70:	0bad0000 	.word	0x0bad0000

0000cd74 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    cd74:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
    cd76:	f001 f8a3 	bl	dec0 <nrfx_gpiote_is_init>
    cd7a:	4604      	mov	r4, r0
    cd7c:	b968      	cbnz	r0, cd9a <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
    cd7e:	f001 f877 	bl	de70 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
    cd82:	4b08      	ldr	r3, [pc, #32]	; (cda4 <gpio_nrfx_init+0x30>)
    cd84:	4298      	cmp	r0, r3
    cd86:	d10a      	bne.n	cd9e <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
    cd88:	4807      	ldr	r0, [pc, #28]	; (cda8 <gpio_nrfx_init+0x34>)
    cd8a:	4621      	mov	r1, r4
    cd8c:	f001 f854 	bl	de38 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    cd90:	4622      	mov	r2, r4
    cd92:	2105      	movs	r1, #5
    cd94:	2006      	movs	r0, #6
    cd96:	f7f5 fbc9 	bl	252c <z_arm_irq_priority_set>
		return 0;
    cd9a:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
    cd9c:	bd10      	pop	{r4, pc}
		return -EIO;
    cd9e:	f06f 0004 	mvn.w	r0, #4
    cda2:	e7fb      	b.n	cd9c <gpio_nrfx_init+0x28>
    cda4:	0bad0000 	.word	0x0bad0000
    cda8:	0000cdad 	.word	0x0000cdad

0000cdac <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    cdac:	0942      	lsrs	r2, r0, #5
{
    cdae:	b570      	push	{r4, r5, r6, lr}
    cdb0:	4603      	mov	r3, r0
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    cdb2:	d002      	beq.n	cdba <nrfx_gpio_handler+0xe>
    cdb4:	2a01      	cmp	r2, #1
    cdb6:	d015      	beq.n	cde4 <nrfx_gpio_handler+0x38>
}
    cdb8:	bd70      	pop	{r4, r5, r6, pc}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    cdba:	4e0b      	ldr	r6, [pc, #44]	; (cde8 <nrfx_gpio_handler+0x3c>)
	gpio_fire_callbacks(list, port, BIT(pin));
    cdbc:	6932      	ldr	r2, [r6, #16]
    cdbe:	6851      	ldr	r1, [r2, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    cdc0:	2900      	cmp	r1, #0
    cdc2:	d0f9      	beq.n	cdb8 <nrfx_gpio_handler+0xc>
    *p_pin = pin_number & 0x1F;
    cdc4:	f003 031f 	and.w	r3, r3, #31
    cdc8:	2501      	movs	r5, #1
    cdca:	680c      	ldr	r4, [r1, #0]
    cdcc:	409d      	lsls	r5, r3
		if (cb->pin_mask & pins) {
    cdce:	688a      	ldr	r2, [r1, #8]
    cdd0:	402a      	ands	r2, r5
    cdd2:	d002      	beq.n	cdda <nrfx_gpio_handler+0x2e>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
    cdd4:	684b      	ldr	r3, [r1, #4]
    cdd6:	4630      	mov	r0, r6
    cdd8:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    cdda:	2c00      	cmp	r4, #0
    cddc:	d0ec      	beq.n	cdb8 <nrfx_gpio_handler+0xc>
    cdde:	4621      	mov	r1, r4
    cde0:	6824      	ldr	r4, [r4, #0]
    cde2:	e7f4      	b.n	cdce <nrfx_gpio_handler+0x22>
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    cde4:	4e01      	ldr	r6, [pc, #4]	; (cdec <nrfx_gpio_handler+0x40>)
    cde6:	e7e9      	b.n	cdbc <nrfx_gpio_handler+0x10>
    cde8:	00012dd4 	.word	0x00012dd4
    cdec:	00012dec 	.word	0x00012dec

0000cdf0 <gpio_nrfx_pin_configure>:
{
    cdf0:	b5f0      	push	{r4, r5, r6, r7, lr}
	return port->config;
    cdf2:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    cdf4:	7a3b      	ldrb	r3, [r7, #8]
    cdf6:	f001 051f 	and.w	r5, r1, #31
{
    cdfa:	b085      	sub	sp, #20
    cdfc:	460e      	mov	r6, r1
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    cdfe:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
    ce02:	4614      	mov	r4, r2
    ce04:	b9c2      	cbnz	r2, ce38 <gpio_nrfx_pin_configure+0x48>
	err = nrfx_gpiote_channel_get(pin, &ch);
    ce06:	a902      	add	r1, sp, #8
    ce08:	4628      	mov	r0, r5
    ce0a:	f001 f81b 	bl	de44 <nrfx_gpiote_channel_get>
    ce0e:	4604      	mov	r4, r0
	err = nrfx_gpiote_pin_uninit(pin);
    ce10:	4628      	mov	r0, r5
    ce12:	f001 f8db 	bl	dfcc <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
    ce16:	4b41      	ldr	r3, [pc, #260]	; (cf1c <gpio_nrfx_pin_configure+0x12c>)
    ce18:	4298      	cmp	r0, r3
    ce1a:	d003      	beq.n	ce24 <gpio_nrfx_pin_configure+0x34>
		return -EIO;
    ce1c:	f06f 0004 	mvn.w	r0, #4
}
    ce20:	b005      	add	sp, #20
    ce22:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (free_ch) {
    ce24:	4284      	cmp	r4, r0
    ce26:	d105      	bne.n	ce34 <gpio_nrfx_pin_configure+0x44>
		err = nrfx_gpiote_channel_free(ch);
    ce28:	f89d 0008 	ldrb.w	r0, [sp, #8]
    ce2c:	f001 f852 	bl	ded4 <nrfx_gpiote_channel_free>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
    ce30:	42a0      	cmp	r0, r4
    ce32:	d1f3      	bne.n	ce1c <gpio_nrfx_pin_configure+0x2c>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    ce34:	2000      	movs	r0, #0
    ce36:	e7f3      	b.n	ce20 <gpio_nrfx_pin_configure+0x30>
	nrfx_gpiote_trigger_config_t trigger_config = {
    ce38:	2300      	movs	r3, #0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    ce3a:	4619      	mov	r1, r3
    ce3c:	aa02      	add	r2, sp, #8
    ce3e:	4628      	mov	r0, r5
	nrfx_gpiote_trigger_config_t trigger_config = {
    ce40:	e9cd 3302 	strd	r3, r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    ce44:	f000 fed8 	bl	dbf8 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    ce48:	4b34      	ldr	r3, [pc, #208]	; (cf1c <gpio_nrfx_pin_configure+0x12c>)
    ce4a:	4298      	cmp	r0, r3
    ce4c:	d002      	beq.n	ce54 <gpio_nrfx_pin_configure+0x64>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    ce4e:	f06f 0015 	mvn.w	r0, #21
    ce52:	e7e5      	b.n	ce20 <gpio_nrfx_pin_configure+0x30>
	if (flags & GPIO_OUTPUT) {
    ce54:	05a3      	lsls	r3, r4, #22
    ce56:	d54e      	bpl.n	cef6 <gpio_nrfx_pin_configure+0x106>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    ce58:	4b31      	ldr	r3, [pc, #196]	; (cf20 <gpio_nrfx_pin_configure+0x130>)
    ce5a:	4a32      	ldr	r2, [pc, #200]	; (cf24 <gpio_nrfx_pin_configure+0x134>)
    ce5c:	4023      	ands	r3, r4
    ce5e:	4293      	cmp	r3, r2
    ce60:	d03a      	beq.n	ced8 <gpio_nrfx_pin_configure+0xe8>
    ce62:	d80c      	bhi.n	ce7e <gpio_nrfx_pin_configure+0x8e>
    ce64:	2b06      	cmp	r3, #6
    ce66:	d014      	beq.n	ce92 <gpio_nrfx_pin_configure+0xa2>
    ce68:	d804      	bhi.n	ce74 <gpio_nrfx_pin_configure+0x84>
    ce6a:	b193      	cbz	r3, ce92 <gpio_nrfx_pin_configure+0xa2>
    ce6c:	2b02      	cmp	r3, #2
    ce6e:	d1ee      	bne.n	ce4e <gpio_nrfx_pin_configure+0x5e>
    ce70:	2304      	movs	r3, #4
    ce72:	e00e      	b.n	ce92 <gpio_nrfx_pin_configure+0xa2>
    ce74:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    ce78:	d1e9      	bne.n	ce4e <gpio_nrfx_pin_configure+0x5e>
		*drive = NRF_GPIO_PIN_H0S1;
    ce7a:	2301      	movs	r3, #1
    ce7c:	e009      	b.n	ce92 <gpio_nrfx_pin_configure+0xa2>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    ce7e:	4a2a      	ldr	r2, [pc, #168]	; (cf28 <gpio_nrfx_pin_configure+0x138>)
    ce80:	4293      	cmp	r3, r2
    ce82:	d02b      	beq.n	cedc <gpio_nrfx_pin_configure+0xec>
    ce84:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    ce88:	d02a      	beq.n	cee0 <gpio_nrfx_pin_configure+0xf0>
    ce8a:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    ce8e:	d1de      	bne.n	ce4e <gpio_nrfx_pin_configure+0x5e>
		*drive = NRF_GPIO_PIN_S0H1;
    ce90:	2302      	movs	r3, #2
		nrfx_gpiote_output_config_t output_config = {
    ce92:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
    ce96:	f484 7380 	eor.w	r3, r4, #256	; 0x100
    ce9a:	f3c3 2300 	ubfx	r3, r3, #8, #1
	if (flags & GPIO_PULL_UP) {
    ce9e:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
    cea0:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLDOWN;
    cea4:	bf54      	ite	pl
    cea6:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		return NRF_GPIO_PIN_PULLUP;
    ceaa:	2303      	movmi	r3, #3
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
    ceac:	0521      	lsls	r1, r4, #20
		nrfx_gpiote_output_config_t output_config = {
    ceae:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
    ceb2:	d517      	bpl.n	cee4 <gpio_nrfx_pin_configure+0xf4>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
    ceb4:	687b      	ldr	r3, [r7, #4]
    ceb6:	2101      	movs	r1, #1
    ceb8:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
    cebc:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
    cec0:	2200      	movs	r2, #0
    cec2:	a901      	add	r1, sp, #4
    cec4:	4628      	mov	r0, r5
    cec6:	f000 ff45 	bl	dd54 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    ceca:	4b14      	ldr	r3, [pc, #80]	; (cf1c <gpio_nrfx_pin_configure+0x12c>)
    cecc:	4298      	cmp	r0, r3
    cece:	bf14      	ite	ne
    ced0:	f06f 0015 	mvnne.w	r0, #21
    ced4:	2000      	moveq	r0, #0
    ced6:	e7a3      	b.n	ce20 <gpio_nrfx_pin_configure+0x30>
		*drive = NRF_GPIO_PIN_H0D1;
    ced8:	2307      	movs	r3, #7
    ceda:	e7da      	b.n	ce92 <gpio_nrfx_pin_configure+0xa2>
		*drive = NRF_GPIO_PIN_D0H1;
    cedc:	2305      	movs	r3, #5
    cede:	e7d8      	b.n	ce92 <gpio_nrfx_pin_configure+0xa2>
		*drive = NRF_GPIO_PIN_H0H1;
    cee0:	2303      	movs	r3, #3
    cee2:	e7d6      	b.n	ce92 <gpio_nrfx_pin_configure+0xa2>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
    cee4:	0562      	lsls	r2, r4, #21
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
    cee6:	bf41      	itttt	mi
    cee8:	687b      	ldrmi	r3, [r7, #4]
    ceea:	2101      	movmi	r1, #1
    ceec:	fa01 f606 	lslmi.w	r6, r1, r6
    p_reg->OUTCLR = clr_mask;
    cef0:	f8c3 650c 	strmi.w	r6, [r3, #1292]	; 0x50c
}
    cef4:	e7e4      	b.n	cec0 <gpio_nrfx_pin_configure+0xd0>
	if (flags & GPIO_PULL_UP) {
    cef6:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    cef8:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
    cefc:	bf54      	ite	pl
    cefe:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
    cf02:	2403      	movmi	r4, #3
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    cf04:	461a      	mov	r2, r3
    cf06:	a901      	add	r1, sp, #4
    cf08:	4628      	mov	r0, r5
	nrfx_gpiote_input_config_t input_config = {
    cf0a:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    cf0e:	f000 fe73 	bl	dbf8 <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    cf12:	4b02      	ldr	r3, [pc, #8]	; (cf1c <gpio_nrfx_pin_configure+0x12c>)
    cf14:	4298      	cmp	r0, r3
    cf16:	d08d      	beq.n	ce34 <gpio_nrfx_pin_configure+0x44>
    cf18:	e799      	b.n	ce4e <gpio_nrfx_pin_configure+0x5e>
    cf1a:	bf00      	nop
    cf1c:	0bad0000 	.word	0x0bad0000
    cf20:	00f00006 	.word	0x00f00006
    cf24:	00100006 	.word	0x00100006
    cf28:	00400002 	.word	0x00400002

0000cf2c <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
    cf2c:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
    cf2e:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    cf32:	095b      	lsrs	r3, r3, #5
        case 1: return NRF_P1;
    cf34:	2b01      	cmp	r3, #1
    *p_pin = pin_number & 0x1F;
    cf36:	6002      	str	r2, [r0, #0]
}
    cf38:	4802      	ldr	r0, [pc, #8]	; (cf44 <nrf_gpio_pin_port_decode+0x18>)
    cf3a:	bf18      	it	ne
    cf3c:	f04f 40a0 	movne.w	r0, #1342177280	; 0x50000000
    cf40:	4770      	bx	lr
    cf42:	bf00      	nop
    cf44:	50000300 	.word	0x50000300

0000cf48 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
    cf48:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
    cf4a:	794b      	ldrb	r3, [r1, #5]
    cf4c:	2b01      	cmp	r3, #1
    cf4e:	d026      	beq.n	cf9e <uarte_nrfx_configure+0x56>
    cf50:	2b03      	cmp	r3, #3
    cf52:	d121      	bne.n	cf98 <uarte_nrfx_configure+0x50>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
    cf54:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    cf56:	798b      	ldrb	r3, [r1, #6]
    cf58:	2b03      	cmp	r3, #3
    cf5a:	d11d      	bne.n	cf98 <uarte_nrfx_configure+0x50>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    cf5c:	79cc      	ldrb	r4, [r1, #7]
    cf5e:	b10c      	cbz	r4, cf64 <uarte_nrfx_configure+0x1c>
    cf60:	2c01      	cmp	r4, #1
    cf62:	d119      	bne.n	cf98 <uarte_nrfx_configure+0x50>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
    cf64:	790a      	ldrb	r2, [r1, #4]
    cf66:	b112      	cbz	r2, cf6e <uarte_nrfx_configure+0x26>
    cf68:	2a02      	cmp	r2, #2
    cf6a:	d115      	bne.n	cf98 <uarte_nrfx_configure+0x50>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
    cf6c:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
    cf6e:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
    cf70:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
    cf72:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
    cf76:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
    cf78:	d065      	beq.n	d046 <uarte_nrfx_configure+0xfe>
    cf7a:	d82d      	bhi.n	cfd8 <uarte_nrfx_configure+0x90>
    cf7c:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    cf80:	d064      	beq.n	d04c <uarte_nrfx_configure+0x104>
    cf82:	d816      	bhi.n	cfb2 <uarte_nrfx_configure+0x6a>
    cf84:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    cf88:	d062      	beq.n	d050 <uarte_nrfx_configure+0x108>
    cf8a:	d80a      	bhi.n	cfa2 <uarte_nrfx_configure+0x5a>
    cf8c:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    cf90:	d061      	beq.n	d056 <uarte_nrfx_configure+0x10e>
    cf92:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    cf96:	d061      	beq.n	d05c <uarte_nrfx_configure+0x114>
    cf98:	f06f 0085 	mvn.w	r0, #133	; 0x85
    cf9c:	e052      	b.n	d044 <uarte_nrfx_configure+0xfc>
	switch (cfg->stop_bits) {
    cf9e:	2600      	movs	r6, #0
    cfa0:	e7d9      	b.n	cf56 <uarte_nrfx_configure+0xe>
	switch (baudrate) {
    cfa2:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    cfa6:	d05c      	beq.n	d062 <uarte_nrfx_configure+0x11a>
    cfa8:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    cfac:	d1f4      	bne.n	cf98 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    cfae:	4b37      	ldr	r3, [pc, #220]	; (d08c <uarte_nrfx_configure+0x144>)
    cfb0:	e03c      	b.n	d02c <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    cfb2:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    cfb6:	d057      	beq.n	d068 <uarte_nrfx_configure+0x120>
    cfb8:	d807      	bhi.n	cfca <uarte_nrfx_configure+0x82>
    cfba:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    cfbe:	d055      	beq.n	d06c <uarte_nrfx_configure+0x124>
    cfc0:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    cfc4:	d1e8      	bne.n	cf98 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    cfc6:	4b32      	ldr	r3, [pc, #200]	; (d090 <uarte_nrfx_configure+0x148>)
    cfc8:	e030      	b.n	d02c <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    cfca:	f647 2712 	movw	r7, #31250	; 0x7a12
    cfce:	42bb      	cmp	r3, r7
    cfd0:	d1e2      	bne.n	cf98 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    cfd2:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    cfd6:	e029      	b.n	d02c <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    cfd8:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    cfdc:	d048      	beq.n	d070 <uarte_nrfx_configure+0x128>
    cfde:	d813      	bhi.n	d008 <uarte_nrfx_configure+0xc0>
    cfe0:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    cfe4:	d047      	beq.n	d076 <uarte_nrfx_configure+0x12e>
    cfe6:	d809      	bhi.n	cffc <uarte_nrfx_configure+0xb4>
    cfe8:	f64d 27c0 	movw	r7, #56000	; 0xdac0
    cfec:	42bb      	cmp	r3, r7
    cfee:	d044      	beq.n	d07a <uarte_nrfx_configure+0x132>
    cff0:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    cff4:	d1d0      	bne.n	cf98 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    cff6:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    cffa:	e017      	b.n	d02c <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    cffc:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    d000:	d1ca      	bne.n	cf98 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    d002:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    d006:	e011      	b.n	d02c <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    d008:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    d00c:	d038      	beq.n	d080 <uarte_nrfx_configure+0x138>
    d00e:	d808      	bhi.n	d022 <uarte_nrfx_configure+0xda>
    d010:	4f20      	ldr	r7, [pc, #128]	; (d094 <uarte_nrfx_configure+0x14c>)
    d012:	42bb      	cmp	r3, r7
    d014:	d037      	beq.n	d086 <uarte_nrfx_configure+0x13e>
    d016:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    d01a:	d1bd      	bne.n	cf98 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    d01c:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    d020:	e004      	b.n	d02c <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    d022:	4f1d      	ldr	r7, [pc, #116]	; (d098 <uarte_nrfx_configure+0x150>)
    d024:	42bb      	cmp	r3, r7
    d026:	d1b7      	bne.n	cf98 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    d028:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    d02c:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
    d030:	6903      	ldr	r3, [r0, #16]
    d032:	c903      	ldmia	r1, {r0, r1}
                    | (uint32_t)p_cfg->hwfc;
    d034:	4334      	orrs	r4, r6
    d036:	4322      	orrs	r2, r4
    d038:	3304      	adds	r3, #4
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    d03a:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
    d03e:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
    d042:	2000      	movs	r0, #0
}
    d044:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    d046:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    d04a:	e7ef      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    d04c:	4b13      	ldr	r3, [pc, #76]	; (d09c <uarte_nrfx_configure+0x154>)
    d04e:	e7ed      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    d050:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    d054:	e7ea      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = 0x00014000;
    d056:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    d05a:	e7e7      	b.n	d02c <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
    d05c:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    d060:	e7e4      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    d062:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    d066:	e7e1      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    d068:	4b0d      	ldr	r3, [pc, #52]	; (d0a0 <uarte_nrfx_configure+0x158>)
    d06a:	e7df      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    d06c:	4b0d      	ldr	r3, [pc, #52]	; (d0a4 <uarte_nrfx_configure+0x15c>)
    d06e:	e7dd      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    d070:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    d074:	e7da      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    d076:	4b0c      	ldr	r3, [pc, #48]	; (d0a8 <uarte_nrfx_configure+0x160>)
    d078:	e7d8      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    d07a:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    d07e:	e7d5      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    d080:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    d084:	e7d2      	b.n	d02c <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    d086:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    d08a:	e7cf      	b.n	d02c <uarte_nrfx_configure+0xe4>
    d08c:	0013b000 	.word	0x0013b000
    d090:	004ea000 	.word	0x004ea000
    d094:	0003d090 	.word	0x0003d090
    d098:	000f4240 	.word	0x000f4240
    d09c:	00275000 	.word	0x00275000
    d0a0:	0075c000 	.word	0x0075c000
    d0a4:	003af000 	.word	0x003af000
    d0a8:	013a9000 	.word	0x013a9000

0000d0ac <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
    d0ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return dev->data;
    d0ae:	6906      	ldr	r6, [r0, #16]
{
    d0b0:	4605      	mov	r5, r0
    d0b2:	460f      	mov	r7, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    d0b4:	f005 fa0f 	bl	124d6 <k_is_in_isr>
    d0b8:	b910      	cbnz	r0, d0c0 <uarte_nrfx_poll_out+0x14>
	return !z_sys_post_kernel;
    d0ba:	4b2c      	ldr	r3, [pc, #176]	; (d16c <uarte_nrfx_poll_out+0xc0>)
	int key;

	if (isr_mode) {
    d0bc:	781b      	ldrb	r3, [r3, #0]
    d0be:	b983      	cbnz	r3, d0e2 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
    d0c0:	f04f 0320 	mov.w	r3, #32
    d0c4:	f3ef 8411 	mrs	r4, BASEPRI
    d0c8:	f383 8812 	msr	BASEPRI_MAX, r3
    d0cc:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
    d0d0:	6868      	ldr	r0, [r5, #4]
    d0d2:	f005 f860 	bl	12196 <is_tx_ready.isra.0>
    d0d6:	bb28      	cbnz	r0, d124 <uarte_nrfx_poll_out+0x78>
	__asm__ volatile(
    d0d8:	f384 8811 	msr	BASEPRI, r4
    d0dc:	f3bf 8f6f 	isb	sy
}
    d0e0:	e7ee      	b.n	d0c0 <uarte_nrfx_poll_out+0x14>
{
    d0e2:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
    d0e4:	6868      	ldr	r0, [r5, #4]
    d0e6:	f005 f856 	bl	12196 <is_tx_ready.isra.0>
    d0ea:	b970      	cbnz	r0, d10a <uarte_nrfx_poll_out+0x5e>
    d0ec:	2001      	movs	r0, #1
    d0ee:	f005 f8c5 	bl	1227c <nrfx_busy_wait>
    d0f2:	3c01      	subs	r4, #1
    d0f4:	d1f6      	bne.n	d0e4 <uarte_nrfx_poll_out+0x38>
    d0f6:	2100      	movs	r1, #0
    d0f8:	2021      	movs	r0, #33	; 0x21
    d0fa:	f001 feef 	bl	eedc <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    d0fe:	e7f0      	b.n	d0e2 <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
    d100:	f384 8811 	msr	BASEPRI, r4
    d104:	f3bf 8f6f 	isb	sy
}
    d108:	e7f5      	b.n	d0f6 <uarte_nrfx_poll_out+0x4a>
	__asm__ volatile(
    d10a:	f04f 0320 	mov.w	r3, #32
    d10e:	f3ef 8411 	mrs	r4, BASEPRI
    d112:	f383 8812 	msr	BASEPRI_MAX, r3
    d116:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
    d11a:	6868      	ldr	r0, [r5, #4]
    d11c:	f005 f83b 	bl	12196 <is_tx_ready.isra.0>
    d120:	2800      	cmp	r0, #0
    d122:	d0ed      	beq.n	d100 <uarte_nrfx_poll_out+0x54>
		}
	} else {
		key = wait_tx_ready(dev);
	}

	data->char_out = c;
    d124:	f806 7f10 	strb.w	r7, [r6, #16]!
	tx_start(dev, &data->char_out, 1);
    d128:	6869      	ldr	r1, [r5, #4]
	return config->uarte_regs;
    d12a:	680b      	ldr	r3, [r1, #0]
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
    d12c:	2201      	movs	r2, #1
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    d12e:	f8c3 6544 	str.w	r6, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    d132:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    d136:	2200      	movs	r2, #0
    d138:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    d13c:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
    d140:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
    d144:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
    d148:	684a      	ldr	r2, [r1, #4]
    d14a:	06d2      	lsls	r2, r2, #27
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    d14c:	bf41      	itttt	mi
    d14e:	2208      	movmi	r2, #8
    d150:	f8c3 2500 	strmi.w	r2, [r3, #1280]	; 0x500
    p_reg->INTENSET = mask;
    d154:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
    d158:	f8c3 2304 	strmi.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    d15c:	2201      	movs	r2, #1
    d15e:	609a      	str	r2, [r3, #8]
	__asm__ volatile(
    d160:	f384 8811 	msr	BASEPRI, r4
    d164:	f3bf 8f6f 	isb	sy

	irq_unlock(key);
}
    d168:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d16a:	bf00      	nop
    d16c:	20002e8c 	.word	0x20002e8c

0000d170 <uarte_instance_init.constprop.0>:
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));

	return 0;
}

static int uarte_instance_init(const struct device *dev,
    d170:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	return dev->config;
    d174:	f8d0 8004 	ldr.w	r8, [r0, #4]
	return dev->data;
    d178:	6907      	ldr	r7, [r0, #16]
	return config->uarte_regs;
    d17a:	f8d8 4000 	ldr.w	r4, [r8]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
    d17e:	2300      	movs	r3, #0
    d180:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	struct uarte_nrfx_data *data = get_dev_data(dev);
	const struct uarte_nrfx_config *cfg = get_dev_config(dev);

	nrf_uarte_disable(uarte);

	data->dev = dev;
    d184:	6038      	str	r0, [r7, #0]
	err = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
	if (err < 0) {
		return err;
	}
#else
	uarte_nrfx_pins_configure(dev, false);
    d186:	6845      	ldr	r5, [r0, #4]
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    d188:	68eb      	ldr	r3, [r5, #12]
    d18a:	1c5a      	adds	r2, r3, #1
static int uarte_instance_init(const struct device *dev,
    d18c:	4606      	mov	r6, r0
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    d18e:	d013      	beq.n	d1b8 <uarte_instance_init.constprop.0+0x48>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    d190:	a801      	add	r0, sp, #4
    d192:	9301      	str	r3, [sp, #4]
    d194:	f7ff feca 	bl	cf2c <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    d198:	9a01      	ldr	r2, [sp, #4]
    d19a:	2301      	movs	r3, #1
    d19c:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    d19e:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
    nrf_gpio_cfg(
    d1a2:	68eb      	ldr	r3, [r5, #12]
    d1a4:	9301      	str	r3, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    d1a6:	a801      	add	r0, sp, #4
    d1a8:	f7ff fec0 	bl	cf2c <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    d1ac:	9b01      	ldr	r3, [sp, #4]
    d1ae:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    d1b2:	2203      	movs	r2, #3
    d1b4:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
		if (cfg->rx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    d1b8:	6928      	ldr	r0, [r5, #16]
    d1ba:	1c43      	adds	r3, r0, #1
    d1bc:	d006      	beq.n	d1cc <uarte_instance_init.constprop.0+0x5c>
			nrf_gpio_cfg_input(cfg->rx_pin,
    d1be:	7f2b      	ldrb	r3, [r5, #28]
    d1c0:	2b00      	cmp	r3, #0
    d1c2:	bf14      	ite	ne
    d1c4:	2103      	movne	r1, #3
    d1c6:	2100      	moveq	r1, #0
    d1c8:	f004 ffd7 	bl	1217a <nrf_gpio_cfg_input>
		if (cfg->rts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    d1cc:	696b      	ldr	r3, [r5, #20]
    d1ce:	1c5a      	adds	r2, r3, #1
    d1d0:	d013      	beq.n	d1fa <uarte_instance_init.constprop.0+0x8a>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    d1d2:	a801      	add	r0, sp, #4
    d1d4:	9301      	str	r3, [sp, #4]
    d1d6:	f7ff fea9 	bl	cf2c <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    d1da:	9a01      	ldr	r2, [sp, #4]
    d1dc:	2301      	movs	r3, #1
    d1de:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    d1e0:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
    nrf_gpio_cfg(
    d1e4:	696b      	ldr	r3, [r5, #20]
    d1e6:	9301      	str	r3, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    d1e8:	a801      	add	r0, sp, #4
    d1ea:	f7ff fe9f 	bl	cf2c <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    d1ee:	9b01      	ldr	r3, [sp, #4]
    d1f0:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    d1f4:	2203      	movs	r2, #3
    d1f6:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
		if (cfg->cts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
    d1fa:	69a8      	ldr	r0, [r5, #24]
    d1fc:	1c43      	adds	r3, r0, #1
    d1fe:	d006      	beq.n	d20e <uarte_instance_init.constprop.0+0x9e>
			nrf_gpio_cfg_input(cfg->cts_pin,
    d200:	7f6b      	ldrb	r3, [r5, #29]
    d202:	2b00      	cmp	r3, #0
    d204:	bf14      	ite	ne
    d206:	2103      	movne	r1, #3
    d208:	2100      	moveq	r1, #0
    d20a:	f004 ffb6 	bl	1217a <nrf_gpio_cfg_input>
	nrf_uarte_txrx_pins_set(cfg->uarte_regs, cfg->tx_pin, cfg->rx_pin);
    d20e:	e9d5 1203 	ldrd	r1, r2, [r5, #12]
    d212:	682b      	ldr	r3, [r5, #0]
    p_reg->PSEL.TXD = pseltxd;
    d214:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    d218:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
	nrf_uarte_hwfc_pins_set(cfg->uarte_regs, cfg->rts_pin, cfg->cts_pin);
    d21c:	e9d5 1205 	ldrd	r1, r2, [r5, #20]
    p_reg->PSEL.RTS = pselrts;
    d220:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
#endif /* CONFIG_PINCTRL */

	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    d224:	6931      	ldr	r1, [r6, #16]
    p_reg->PSEL.CTS = pselcts;
    d226:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    d22a:	3104      	adds	r1, #4
    d22c:	4630      	mov	r0, r6
    d22e:	f7ff fe8b 	bl	cf48 <uarte_nrfx_configure>
	if (err) {
    d232:	4605      	mov	r5, r0
    d234:	2800      	cmp	r0, #0
    d236:	d146      	bne.n	d2c6 <uarte_instance_init.constprop.0+0x156>
		return err;
	}

	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
    d238:	f8d8 3004 	ldr.w	r3, [r8, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
    d23c:	0799      	lsls	r1, r3, #30
    d23e:	d519      	bpl.n	d274 <uarte_instance_init.constprop.0+0x104>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
    d240:	f107 0012 	add.w	r0, r7, #18
    d244:	f000 ffbc 	bl	e1c0 <nrfx_ppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
    d248:	4b22      	ldr	r3, [pc, #136]	; (d2d4 <uarte_instance_init.constprop.0+0x164>)
    d24a:	4298      	cmp	r0, r3
    d24c:	d13f      	bne.n	d2ce <uarte_instance_init.constprop.0+0x15e>
	nrfx_gppi_channel_endpoints_setup(data->ppi_ch_endtx,
    d24e:	7cb8      	ldrb	r0, [r7, #18]
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
    d250:	00c3      	lsls	r3, r0, #3
    d252:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    d256:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
    return (uint32_t)p_reg + (uint32_t)task;
    d25a:	f104 020c 	add.w	r2, r4, #12
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
    d25e:	f504 7190 	add.w	r1, r4, #288	; 0x120
    p_reg->CH[(uint32_t) channel].EEP = eep;
    d262:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
    p_reg->CH[(uint32_t) channel].TEP = tep;
    d266:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
    p_reg->CHENSET = mask;
    d26a:	4a1b      	ldr	r2, [pc, #108]	; (d2d8 <uarte_instance_init.constprop.0+0x168>)
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
    d26c:	2301      	movs	r3, #1
    d26e:	4083      	lsls	r3, r0
    d270:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    d274:	2308      	movs	r3, #8
    d276:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
#endif
	{
		/* Enable receiver and transmitter */
		nrf_uarte_enable(uarte);

		if (!cfg->disable_rx) {
    d27a:	f898 3008 	ldrb.w	r3, [r8, #8]
    d27e:	b95b      	cbnz	r3, d298 <uarte_instance_init.constprop.0+0x128>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    d280:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
    d284:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);

			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    d288:	f107 0311 	add.w	r3, r7, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    d28c:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    d290:	2301      	movs	r3, #1
    d292:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    d296:	6023      	str	r3, [r4, #0]
			nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STARTRX);
		}
	}

	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
    d298:	f8d8 3004 	ldr.w	r3, [r8, #4]
    d29c:	079a      	lsls	r2, r3, #30
    p_reg->INTENSET = mask;
    d29e:	bf5c      	itt	pl
    d2a0:	f44f 7280 	movpl.w	r2, #256	; 0x100
    d2a4:	f8c4 2304 	strpl.w	r2, [r4, #772]	; 0x304
		nrf_uarte_int_enable(uarte, NRF_UARTE_INT_ENDTX_MASK);
	}

	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
    d2a8:	06db      	lsls	r3, r3, #27
    d2aa:	bf44      	itt	mi
    d2ac:	f44f 0380 	movmi.w	r3, #4194304	; 0x400000
    d2b0:	f8c4 3304 	strmi.w	r3, [r4, #772]	; 0x304

	/* Set TXSTOPPED event by requesting fake (zero-length) transfer.
	 * Pointer to RAM variable (data->tx_buffer) is set because otherwise
	 * such operation may result in HardFault or RAM corruption.
	 */
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
    d2b4:	3710      	adds	r7, #16
    p_reg->TXD.MAXCNT = length;
    d2b6:	2300      	movs	r3, #0
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    d2b8:	f8c4 7544 	str.w	r7, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    d2bc:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    d2c0:	2301      	movs	r3, #1
    d2c2:	60a3      	str	r3, [r4, #8]
    d2c4:	60e3      	str	r3, [r4, #12]

	/* switch off transmitter to save an energy */
	nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPTX);

	return 0;
}
    d2c6:	4628      	mov	r0, r5
    d2c8:	b002      	add	sp, #8
    d2ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -EIO;
    d2ce:	f06f 0504 	mvn.w	r5, #4
    d2d2:	e7f8      	b.n	d2c6 <uarte_instance_init.constprop.0+0x156>
    d2d4:	0bad0000 	.word	0x0bad0000
    d2d8:	4001f000 	.word	0x4001f000

0000d2dc <random_byte_get>:
	__asm__ volatile(
    d2dc:	f04f 0320 	mov.w	r3, #32
    d2e0:	f3ef 8211 	mrs	r2, BASEPRI
    d2e4:	f383 8812 	msr	BASEPRI_MAX, r3
    d2e8:	f3bf 8f6f 	isb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)rng_event);
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    d2ec:	4b09      	ldr	r3, [pc, #36]	; (d314 <random_byte_get+0x38>)
    d2ee:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
	int retval = -EAGAIN;
	unsigned int key;

	key = irq_lock();

	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
    d2f2:	b161      	cbz	r1, d30e <random_byte_get+0x32>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    d2f4:	2100      	movs	r1, #0
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
    d2f6:	f8d3 0508 	ldr.w	r0, [r3, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    d2fa:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    d2fe:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
		retval = nrf_rng_random_value_get(NRF_RNG);
    d302:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
    d304:	f382 8811 	msr	BASEPRI, r2
    d308:	f3bf 8f6f 	isb	sy
	}

	irq_unlock(key);

	return retval;
}
    d30c:	4770      	bx	lr
	int retval = -EAGAIN;
    d30e:	f06f 000a 	mvn.w	r0, #10
    d312:	e7f7      	b.n	d304 <random_byte_get+0x28>
    d314:	4000d000 	.word	0x4000d000

0000d318 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static uint16_t rng_pool_get(struct rng_pool *rngp, uint8_t *buf, uint16_t len)
{
    d318:	b5f0      	push	{r4, r5, r6, r7, lr}
    d31a:	4603      	mov	r3, r0
	uint32_t last  = rngp->last;
    d31c:	7884      	ldrb	r4, [r0, #2]
	uint32_t mask  = rngp->mask;
    d31e:	78c7      	ldrb	r7, [r0, #3]
	__asm__ volatile(
    d320:	f04f 0020 	mov.w	r0, #32
    d324:	f3ef 8e11 	mrs	lr, BASEPRI
    d328:	f380 8812 	msr	BASEPRI_MAX, r0
    d32c:	f3bf 8f6f 	isb	sy
	uint32_t first, available;
	uint32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
    d330:	781e      	ldrb	r6, [r3, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
    d332:	f893 c001 	ldrb.w	ip, [r3, #1]

	available = (last - first) & mask;
    d336:	1ba4      	subs	r4, r4, r6
    d338:	403c      	ands	r4, r7
	if (available < len) {
    d33a:	42a2      	cmp	r2, r4
		len = available;
    d33c:	bf88      	it	hi
    d33e:	b2a2      	uxthhi	r2, r4

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
    d340:	18b0      	adds	r0, r6, r2
    d342:	4038      	ands	r0, r7
	first = rngp->first_alloc;
    d344:	4635      	mov	r5, r6
	rngp->first_alloc = (first + len) & mask;
    d346:	7018      	strb	r0, [r3, #0]
	__asm__ volatile(
    d348:	f38e 8811 	msr	BASEPRI, lr
    d34c:	f3bf 8f6f 	isb	sy
    d350:	1888      	adds	r0, r1, r2
	uint8_t *dst   = buf;
    d352:	460a      	mov	r2, r1
	irq_unlock(key);

	while (likely(len--)) {
    d354:	4290      	cmp	r0, r2
    d356:	d119      	bne.n	d38c <rng_pool_get+0x74>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
    d358:	4566      	cmp	r6, ip
    d35a:	d10d      	bne.n	d378 <rng_pool_get+0x60>
	__asm__ volatile(
    d35c:	f04f 0520 	mov.w	r5, #32
    d360:	f3ef 8011 	mrs	r0, BASEPRI
    d364:	f385 8812 	msr	BASEPRI_MAX, r5
    d368:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
    d36c:	781d      	ldrb	r5, [r3, #0]
    d36e:	705d      	strb	r5, [r3, #1]
	__asm__ volatile(
    d370:	f380 8811 	msr	BASEPRI, r0
    d374:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
    d378:	1a52      	subs	r2, r2, r1
	available = available - len;
	if (available <= rngp->threshold) {
    d37a:	791b      	ldrb	r3, [r3, #4]
	len = dst - buf;
    d37c:	b290      	uxth	r0, r2
	available = available - len;
    d37e:	1a22      	subs	r2, r4, r0
	if (available <= rngp->threshold) {
    d380:	4293      	cmp	r3, r2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    d382:	bf22      	ittt	cs
    d384:	4b06      	ldrcs	r3, [pc, #24]	; (d3a0 <rng_pool_get+0x88>)
    d386:	2201      	movcs	r2, #1
    d388:	601a      	strcs	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
    d38a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
    d38c:	eb03 0e05 	add.w	lr, r3, r5
		first = (first + 1) & mask;
    d390:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
    d392:	f89e e005 	ldrb.w	lr, [lr, #5]
    d396:	f802 eb01 	strb.w	lr, [r2], #1
		first = (first + 1) & mask;
    d39a:	403d      	ands	r5, r7
    d39c:	e7da      	b.n	d354 <rng_pool_get+0x3c>
    d39e:	bf00      	nop
    d3a0:	4000d000 	.word	0x4000d000

0000d3a4 <entropy_nrf5_get_entropy_isr>:
	uint16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    d3a4:	43db      	mvns	r3, r3
{
    d3a6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    d3aa:	f013 0501 	ands.w	r5, r3, #1
{
    d3ae:	460e      	mov	r6, r1
    d3b0:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    d3b2:	d004      	beq.n	d3be <entropy_nrf5_get_entropy_isr+0x1a>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
    d3b4:	4821      	ldr	r0, [pc, #132]	; (d43c <entropy_nrf5_get_entropy_isr+0x98>)
    d3b6:	f7ff ffaf 	bl	d318 <rng_pool_get>
			irq_enable(IRQN);
		}
	}

	return cnt;
}
    d3ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
    d3be:	b3a2      	cbz	r2, d42a <entropy_nrf5_get_entropy_isr+0x86>
	__asm__ volatile(
    d3c0:	f04f 0320 	mov.w	r3, #32
    d3c4:	f3ef 8811 	mrs	r8, BASEPRI
    d3c8:	f383 8812 	msr	BASEPRI_MAX, r3
    d3cc:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(IRQN);
    d3d0:	200d      	movs	r0, #13
    d3d2:	f7f5 f89d 	bl	2510 <arch_irq_is_enabled>
    d3d6:	4607      	mov	r7, r0
		irq_disable(IRQN);
    d3d8:	200d      	movs	r0, #13
    d3da:	f7f5 f885 	bl	24e8 <arch_irq_disable>
	__asm__ volatile(
    d3de:	f388 8811 	msr	BASEPRI, r8
    d3e2:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    d3e6:	f8df 8058 	ldr.w	r8, [pc, #88]	; d440 <entropy_nrf5_get_entropy_isr+0x9c>
    d3ea:	f8df 9058 	ldr.w	r9, [pc, #88]	; d444 <entropy_nrf5_get_entropy_isr+0xa0>
    d3ee:	f8c8 5100 	str.w	r5, [r8, #256]	; 0x100
    d3f2:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
    d3f6:	f44f 5a00 	mov.w	sl, #8192	; 0x2000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    d3fa:	2301      	movs	r3, #1
    d3fc:	f8c8 3000 	str.w	r3, [r8]
    d400:	4625      	mov	r5, r4
    d402:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
    d406:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
			while (!nrf_rng_event_check(NRF_RNG,
    d40a:	b183      	cbz	r3, d42e <entropy_nrf5_get_entropy_isr+0x8a>
			byte = random_byte_get();
    d40c:	f7ff ff66 	bl	d2dc <random_byte_get>
			if (byte < 0) {
    d410:	1e03      	subs	r3, r0, #0
    d412:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
    d416:	dbf6      	blt.n	d406 <entropy_nrf5_get_entropy_isr+0x62>
			buf[--len] = byte;
    d418:	3d01      	subs	r5, #1
    d41a:	b2ad      	uxth	r5, r5
    d41c:	5573      	strb	r3, [r6, r5]
		} while (len);
    d41e:	2d00      	cmp	r5, #0
    d420:	d1f1      	bne.n	d406 <entropy_nrf5_get_entropy_isr+0x62>
		if (irq_enabled) {
    d422:	b117      	cbz	r7, d42a <entropy_nrf5_get_entropy_isr+0x86>
			irq_enable(IRQN);
    d424:	200d      	movs	r0, #13
    d426:	f7f5 f84f 	bl	24c8 <arch_irq_enable>
	return cnt;
    d42a:	4620      	mov	r0, r4
    d42c:	e7c5      	b.n	d3ba <entropy_nrf5_get_entropy_isr+0x16>
  __ASM volatile ("dsb 0xF":::"memory");
    d42e:	f3bf 8f4f 	dsb	sy
				__WFE();
    d432:	bf20      	wfe
				__SEV();
    d434:	bf40      	sev
				__WFE();
    d436:	bf20      	wfe
    d438:	e7e5      	b.n	d406 <entropy_nrf5_get_entropy_isr+0x62>
    d43a:	bf00      	nop
    d43c:	200025bc 	.word	0x200025bc
    d440:	4000d000 	.word	0x4000d000
    d444:	e000e100 	.word	0xe000e100

0000d448 <entropy_nrf5_get_entropy>:
{
    d448:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return z_impl_k_sem_take(sem, timeout);
    d44c:	4f13      	ldr	r7, [pc, #76]	; (d49c <entropy_nrf5_get_entropy+0x54>)
    d44e:	460d      	mov	r5, r1
    d450:	4614      	mov	r4, r2
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
    d452:	f107 0845 	add.w	r8, r7, #69	; 0x45
    d456:	f107 0918 	add.w	r9, r7, #24
	while (len) {
    d45a:	b914      	cbnz	r4, d462 <entropy_nrf5_get_entropy+0x1a>
}
    d45c:	4620      	mov	r0, r4
    d45e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    d462:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d466:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    d46a:	4638      	mov	r0, r7
    d46c:	f001 f92c 	bl	e6c8 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
    d470:	4622      	mov	r2, r4
    d472:	4629      	mov	r1, r5
    d474:	4640      	mov	r0, r8
    d476:	f7ff ff4f 	bl	d318 <rng_pool_get>
    d47a:	4606      	mov	r6, r0
	z_impl_k_sem_give(sem);
    d47c:	4638      	mov	r0, r7
    d47e:	f001 f8fd 	bl	e67c <z_impl_k_sem_give>
		if (bytes == 0U) {
    d482:	b93e      	cbnz	r6, d494 <entropy_nrf5_get_entropy+0x4c>
	return z_impl_k_sem_take(sem, timeout);
    d484:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    d488:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d48c:	4648      	mov	r0, r9
    d48e:	f001 f91b 	bl	e6c8 <z_impl_k_sem_take>
			continue;
    d492:	e7e2      	b.n	d45a <entropy_nrf5_get_entropy+0x12>
		len -= bytes;
    d494:	1ba4      	subs	r4, r4, r6
    d496:	b2a4      	uxth	r4, r4
		buf += bytes;
    d498:	4435      	add	r5, r6
    d49a:	e7de      	b.n	d45a <entropy_nrf5_get_entropy+0x12>
    d49c:	2000258c 	.word	0x2000258c

0000d4a0 <entropy_nrf5_init>:
		    &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_ENTROPY_INIT_PRIORITY,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(const struct device *dev)
{
    d4a0:	b538      	push	{r3, r4, r5, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
    d4a2:	4c19      	ldr	r4, [pc, #100]	; (d508 <entropy_nrf5_init+0x68>)
    d4a4:	2201      	movs	r2, #1
    d4a6:	4611      	mov	r1, r2
    d4a8:	4620      	mov	r0, r4
    d4aa:	f005 f8e7 	bl	1267c <z_impl_k_sem_init>
    d4ae:	2201      	movs	r2, #1
    d4b0:	2100      	movs	r1, #0
    d4b2:	f104 0018 	add.w	r0, r4, #24
    d4b6:	f005 f8e1 	bl	1267c <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
    d4ba:	f240 4307 	movw	r3, #1031	; 0x407
    d4be:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
    d4c2:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    d4c6:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
    d4c8:	230c      	movs	r3, #12
    d4ca:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	rngp->first_alloc = 0U;
    d4ce:	2500      	movs	r5, #0
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
    d4d0:	4b0e      	ldr	r3, [pc, #56]	; (d50c <entropy_nrf5_init+0x6c>)
    d4d2:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
    d4d6:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
    d4da:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
    d4de:	f042 0201 	orr.w	r2, r2, #1
    d4e2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    p_reg->INTENSET = mask;
    d4e6:	2101      	movs	r1, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
    d4e8:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
    d4ec:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
    d4f0:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(IRQN, IRQ_PRIO, isr, &entropy_nrf5_data, 0);
    d4f4:	462a      	mov	r2, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
    d4f6:	6019      	str	r1, [r3, #0]
    d4f8:	200d      	movs	r0, #13
    d4fa:	f7f5 f817 	bl	252c <z_arm_irq_priority_set>
	irq_enable(IRQN);
    d4fe:	200d      	movs	r0, #13
    d500:	f7f4 ffe2 	bl	24c8 <arch_irq_enable>

	return 0;
}
    d504:	4628      	mov	r0, r5
    d506:	bd38      	pop	{r3, r4, r5, pc}
    d508:	2000258c 	.word	0x2000258c
    d50c:	4000d000 	.word	0x4000d000

0000d510 <isr>:
{
    d510:	b510      	push	{r4, lr}
	byte = random_byte_get();
    d512:	f7ff fee3 	bl	d2dc <random_byte_get>
	if (byte < 0) {
    d516:	2800      	cmp	r0, #0
    d518:	db20      	blt.n	d55c <isr+0x4c>
	uint8_t last  = rngp->last;
    d51a:	4b17      	ldr	r3, [pc, #92]	; (d578 <isr+0x68>)
    d51c:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
    d520:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	uint8_t mask  = rngp->mask;
    d524:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
    d528:	1a51      	subs	r1, r2, r1
    d52a:	ea34 0101 	bics.w	r1, r4, r1
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
    d52e:	b2c0      	uxtb	r0, r0
	if (((last - first) & mask) == mask) {
    d530:	d10d      	bne.n	d54e <isr+0x3e>
	uint8_t last  = rngp->last;
    d532:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
    d536:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	uint8_t mask  = rngp->mask;
    d53a:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
    d53e:	1a51      	subs	r1, r2, r1
    d540:	ea34 0101 	bics.w	r1, r4, r1
    d544:	d10b      	bne.n	d55e <isr+0x4e>
    d546:	4b0d      	ldr	r3, [pc, #52]	; (d57c <isr+0x6c>)
    d548:	2201      	movs	r2, #1
    d54a:	605a      	str	r2, [r3, #4]
}
    d54c:	e00e      	b.n	d56c <isr+0x5c>
	rngp->buffer[last] = byte;
    d54e:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
    d550:	3201      	adds	r2, #1
    d552:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
    d554:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
    d558:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
    d55c:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
    d55e:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
    d560:	3201      	adds	r2, #1
    d562:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
    d564:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
    d568:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
    d56c:	4804      	ldr	r0, [pc, #16]	; (d580 <isr+0x70>)
}
    d56e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    d572:	f001 b883 	b.w	e67c <z_impl_k_sem_give>
    d576:	bf00      	nop
    d578:	2000258c 	.word	0x2000258c
    d57c:	4000d000 	.word	0x4000d000
    d580:	200025a4 	.word	0x200025a4

0000d584 <sys_clock_timeout_handler>:

static void sys_clock_timeout_handler(int32_t chan,
				      uint32_t cc_value,
				      void *user_data)
{
	uint32_t dticks = counter_sub(cc_value, last_count) / CYC_PER_TICK;
    d584:	4a04      	ldr	r2, [pc, #16]	; (d598 <sys_clock_timeout_handler+0x14>)
    d586:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    d588:	1ac8      	subs	r0, r1, r3
    d58a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    d58e:	4403      	add	r3, r0
    d590:	6013      	str	r3, [r2, #0]
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
    d592:	f001 be17 	b.w	f1c4 <sys_clock_announce>
    d596:	bf00      	nop
    d598:	200025ec 	.word	0x200025ec

0000d59c <sys_clock_driver_init>:
	k_spin_unlock(&lock, key);
	return ret;
}

static int sys_clock_driver_init(const struct device *dev)
{
    d59c:	b538      	push	{r3, r4, r5, lr}
    p_reg->PRESCALER = val;
    d59e:	4c0f      	ldr	r4, [pc, #60]	; (d5dc <sys_clock_driver_init+0x40>)
    d5a0:	2500      	movs	r5, #0
    p_reg->INTENSET = mask;
    d5a2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->PRESCALER = val;
    d5a6:	f8c4 5508 	str.w	r5, [r4, #1288]	; 0x508
    p_reg->INTENSET = mask;
    d5aa:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    d5ae:	4b0c      	ldr	r3, [pc, #48]	; (d5e0 <sys_clock_driver_init+0x44>)
    d5b0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    d5b4:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
	}

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    d5b8:	2101      	movs	r1, #1
    d5ba:	462a      	mov	r2, r5
    d5bc:	2011      	movs	r0, #17
    d5be:	f7f4 ffb5 	bl	252c <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    d5c2:	2011      	movs	r0, #17
    d5c4:	f7f4 ff80 	bl	24c8 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    d5c8:	2301      	movs	r3, #1

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
    d5ca:	4a06      	ldr	r2, [pc, #24]	; (d5e4 <sys_clock_driver_init+0x48>)
    d5cc:	60a3      	str	r3, [r4, #8]
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		compare_set(0, counter() + CYC_PER_TICK,
			    sys_clock_timeout_handler, NULL);
	}

	z_nrf_clock_control_lf_on(mode);
    d5ce:	2002      	movs	r0, #2
    d5d0:	6023      	str	r3, [r4, #0]
	int_mask = BIT_MASK(CHAN_COUNT);
    d5d2:	6013      	str	r3, [r2, #0]
	z_nrf_clock_control_lf_on(mode);
    d5d4:	f7ff fabc 	bl	cb50 <z_nrf_clock_control_lf_on>

	return 0;
}
    d5d8:	4628      	mov	r0, r5
    d5da:	bd38      	pop	{r3, r4, r5, pc}
    d5dc:	40011000 	.word	0x40011000
    d5e0:	e000e100 	.word	0xe000e100
    d5e4:	200025e8 	.word	0x200025e8

0000d5e8 <set_absolute_alarm>:
{
    d5e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d5ec:	0086      	lsls	r6, r0, #2
    d5ee:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    d5f2:	f100 0450 	add.w	r4, r0, #80	; 0x50
    d5f6:	f506 3688 	add.w	r6, r6, #69632	; 0x11000
    d5fa:	00a4      	lsls	r4, r4, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    d5fc:	b2a4      	uxth	r4, r4
    d5fe:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    d602:	f44f 3780 	mov.w	r7, #65536	; 0x10000
    return p_reg->CC[ch];
    d606:	f8d6 3540 	ldr.w	r3, [r6, #1344]	; 0x540
     return p_reg->COUNTER;
    d60a:	f8df 806c 	ldr.w	r8, [pc, #108]	; d678 <set_absolute_alarm+0x90>
	uint32_t cc_val = abs_val & COUNTER_MAX;
    d60e:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    d612:	f504 3488 	add.w	r4, r4, #69632	; 0x11000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    d616:	4087      	lsls	r7, r0
     return p_reg->COUNTER;
    d618:	f8d8 9504 	ldr.w	r9, [r8, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    d61c:	eba3 0309 	sub.w	r3, r3, r9
    d620:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    d624:	f029 427f 	bic.w	r2, r9, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
    d628:	2b01      	cmp	r3, #1
    p_reg->CC[ch] = cc_val;
    d62a:	f8c6 2540 	str.w	r2, [r6, #1344]	; 0x540
    d62e:	d102      	bne.n	d636 <set_absolute_alarm+0x4e>
	z_impl_k_busy_wait(usec_to_wait);
    d630:	2013      	movs	r0, #19
    d632:	f005 fa12 	bl	12a5a <z_impl_k_busy_wait>
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
    d636:	f109 0202 	add.w	r2, r9, #2
	return (a - b) & COUNTER_MAX;
    d63a:	1aab      	subs	r3, r5, r2
    d63c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
			cc_val = now + 2;
    d640:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    d644:	bf88      	it	hi
    d646:	4615      	movhi	r5, r2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    d648:	2300      	movs	r3, #0
    d64a:	6023      	str	r3, [r4, #0]
    d64c:	6823      	ldr	r3, [r4, #0]
    p_reg->EVTENSET = mask;
    d64e:	f8c8 7344 	str.w	r7, [r8, #836]	; 0x344
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    d652:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    d656:	f8c6 3540 	str.w	r3, [r6, #1344]	; 0x540
     return p_reg->COUNTER;
    d65a:	f8d8 3504 	ldr.w	r3, [r8, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
    d65e:	4599      	cmp	r9, r3
    d660:	d006      	beq.n	d670 <set_absolute_alarm+0x88>
	return (a - b) & COUNTER_MAX;
    d662:	1aeb      	subs	r3, r5, r3
    d664:	3b02      	subs	r3, #2
    d666:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	} while ((now2 != now) &&
    d66a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    d66e:	d801      	bhi.n	d674 <set_absolute_alarm+0x8c>
}
    d670:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		prev_cc = cc_val;
    d674:	462b      	mov	r3, r5
    d676:	e7cf      	b.n	d618 <set_absolute_alarm+0x30>
    d678:	40011000 	.word	0x40011000

0000d67c <rtc_nrf_isr>:
{
    d67c:	b570      	push	{r4, r5, r6, lr}
    d67e:	4d15      	ldr	r5, [pc, #84]	; (d6d4 <rtc_nrf_isr+0x58>)
    return p_reg->INTENSET & mask;
    d680:	4c15      	ldr	r4, [pc, #84]	; (d6d8 <rtc_nrf_isr+0x5c>)
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    d682:	2600      	movs	r6, #0
    d684:	682b      	ldr	r3, [r5, #0]
    d686:	2000      	movs	r0, #0
    d688:	b106      	cbz	r6, d68c <rtc_nrf_isr+0x10>
}
    d68a:	bd70      	pop	{r4, r5, r6, pc}
    d68c:	f8d4 2304 	ldr.w	r2, [r4, #772]	; 0x304
		if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan)) &&
    d690:	03d2      	lsls	r2, r2, #15
    d692:	d5fa      	bpl.n	d68a <rtc_nrf_isr+0xe>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    d694:	f8d4 2140 	ldr.w	r2, [r4, #320]	; 0x140
    d698:	2a00      	cmp	r2, #0
    d69a:	d0f6      	beq.n	d68a <rtc_nrf_isr+0xe>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    d69c:	f8c4 6140 	str.w	r6, [r4, #320]	; 0x140
    d6a0:	f8d4 2140 	ldr.w	r2, [r4, #320]	; 0x140
    p_reg->EVTENCLR = mask;
    d6a4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    d6a8:	f8c4 2348 	str.w	r2, [r4, #840]	; 0x348
    return p_reg->CC[ch];
    d6ac:	f8d4 1540 	ldr.w	r1, [r4, #1344]	; 0x540
     return p_reg->COUNTER;
    d6b0:	f8d4 6504 	ldr.w	r6, [r4, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    d6b4:	1a72      	subs	r2, r6, r1
    d6b6:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
				cc_val = now;
    d6ba:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    d6be:	bf88      	it	hi
    d6c0:	4631      	movhi	r1, r6
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    d6c2:	2601      	movs	r6, #1
			if (handler) {
    d6c4:	b11b      	cbz	r3, d6ce <rtc_nrf_isr+0x52>
				handler(chan, cc_val,
    d6c6:	686a      	ldr	r2, [r5, #4]
    d6c8:	6028      	str	r0, [r5, #0]
    d6ca:	4798      	blx	r3
    d6cc:	e7da      	b.n	d684 <rtc_nrf_isr+0x8>
    d6ce:	602b      	str	r3, [r5, #0]
}
    d6d0:	e7db      	b.n	d68a <rtc_nrf_isr+0xe>
    d6d2:	bf00      	nop
    d6d4:	200025e0 	.word	0x200025e0
    d6d8:	40011000 	.word	0x40011000

0000d6dc <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    d6dc:	4a13      	ldr	r2, [pc, #76]	; (d72c <sys_clock_set_timeout+0x50>)
    d6de:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    d6e2:	bf14      	ite	ne
    d6e4:	4603      	movne	r3, r0
    d6e6:	4613      	moveq	r3, r2
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    d6e8:	3b01      	subs	r3, #1
    d6ea:	2b00      	cmp	r3, #0
    d6ec:	dd1c      	ble.n	d728 <sys_clock_set_timeout+0x4c>
    d6ee:	4293      	cmp	r3, r2
    d6f0:	bfa8      	it	ge
    d6f2:	4613      	movge	r3, r2
    d6f4:	4a0e      	ldr	r2, [pc, #56]	; (d730 <sys_clock_set_timeout+0x54>)
    d6f6:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	uint32_t unannounced = counter_sub(counter(), last_count);
    d6fa:	4a0e      	ldr	r2, [pc, #56]	; (d734 <sys_clock_set_timeout+0x58>)
    d6fc:	6811      	ldr	r1, [r2, #0]
	return (a - b) & COUNTER_MAX;
    d6fe:	1a40      	subs	r0, r0, r1
		ticks = 0;
    d700:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
	return (a - b) & COUNTER_MAX;
    d704:	f020 427f 	bic.w	r2, r0, #4278190080	; 0xff000000
		ticks = 0;
    d708:	bf18      	it	ne
    d70a:	2300      	movne	r3, #0
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    d70c:	3201      	adds	r2, #1
    d70e:	4413      	add	r3, r2
	cc_data[chan].callback = handler;
    d710:	4a09      	ldr	r2, [pc, #36]	; (d738 <sys_clock_set_timeout+0x5c>)
    d712:	480a      	ldr	r0, [pc, #40]	; (d73c <sys_clock_set_timeout+0x60>)
    d714:	6010      	str	r0, [r2, #0]
	cc_data[chan].user_context = user_data;
    d716:	2000      	movs	r0, #0
    d718:	6050      	str	r0, [r2, #4]
	set_absolute_alarm(chan, cc_value);
    d71a:	4a04      	ldr	r2, [pc, #16]	; (d72c <sys_clock_set_timeout+0x50>)
    d71c:	4293      	cmp	r3, r2
    d71e:	bf94      	ite	ls
    d720:	18c9      	addls	r1, r1, r3
    d722:	1889      	addhi	r1, r1, r2
    d724:	f7ff bf60 	b.w	d5e8 <set_absolute_alarm>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    d728:	2300      	movs	r3, #0
    d72a:	e7e3      	b.n	d6f4 <sys_clock_set_timeout+0x18>
    d72c:	007fffff 	.word	0x007fffff
    d730:	40011000 	.word	0x40011000
    d734:	200025ec 	.word	0x200025ec
    d738:	200025e0 	.word	0x200025e0
    d73c:	0000d585 	.word	0x0000d585

0000d740 <sys_clock_elapsed>:
    d740:	4b04      	ldr	r3, [pc, #16]	; (d754 <sys_clock_elapsed+0x14>)
    d742:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	return counter_sub(counter(), last_count) / CYC_PER_TICK;
    d746:	4b04      	ldr	r3, [pc, #16]	; (d758 <sys_clock_elapsed+0x18>)
	return (a - b) & COUNTER_MAX;
    d748:	681b      	ldr	r3, [r3, #0]
    d74a:	1ac0      	subs	r0, r0, r3
}
    d74c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    d750:	4770      	bx	lr
    d752:	bf00      	nop
    d754:	40011000 	.word	0x40011000
    d758:	200025ec 	.word	0x200025ec

0000d75c <nrf52_errata_103>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    d75c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
    d760:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
    d764:	2a08      	cmp	r2, #8
    d766:	d106      	bne.n	d776 <nrf52_errata_103+0x1a>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    d768:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                switch(var2)
    d76c:	2b05      	cmp	r3, #5
    d76e:	d802      	bhi.n	d776 <nrf52_errata_103+0x1a>
    d770:	4a02      	ldr	r2, [pc, #8]	; (d77c <nrf52_errata_103+0x20>)
    d772:	5cd0      	ldrb	r0, [r2, r3]
    d774:	4770      	bx	lr
        return false;
    d776:	2000      	movs	r0, #0
}
    d778:	4770      	bx	lr
    d77a:	bf00      	nop
    d77c:	000140b4 	.word	0x000140b4

0000d780 <nvmc_wait>:

/* -- NVMC utility functions -- */
/* Waits until NVMC is done with the current pending action */
void nvmc_wait(void)
{
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    d780:	4a02      	ldr	r2, [pc, #8]	; (d78c <nvmc_wait+0xc>)
    d782:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    d786:	2b00      	cmp	r3, #0
    d788:	d0fb      	beq.n	d782 <nvmc_wait+0x2>
}
    d78a:	4770      	bx	lr
    d78c:	4001e000 	.word	0x4001e000

0000d790 <SystemCoreClockUpdate>:
    nvmc_wait();
}

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    d790:	4b01      	ldr	r3, [pc, #4]	; (d798 <SystemCoreClockUpdate+0x8>)
    d792:	4a02      	ldr	r2, [pc, #8]	; (d79c <SystemCoreClockUpdate+0xc>)
    d794:	601a      	str	r2, [r3, #0]
}
    d796:	4770      	bx	lr
    d798:	200004e4 	.word	0x200004e4
    d79c:	03d09000 	.word	0x03d09000

0000d7a0 <SystemInit>:

void SystemInit(void)
{
    d7a0:	b510      	push	{r4, lr}
    #endif

    #if NRF52_ERRATA_36_ENABLE_WORKAROUND
        /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_36()){
    d7a2:	f004 fd61 	bl	12268 <nrf52_errata_136>
    d7a6:	b140      	cbz	r0, d7ba <SystemInit+0x1a>
            NRF_CLOCK->EVENTS_DONE = 0;
    d7a8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    d7ac:	2200      	movs	r2, #0
    d7ae:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
            NRF_CLOCK->EVENTS_CTTO = 0;
    d7b2:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            NRF_CLOCK->CTIV = 0;
    d7b6:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    #endif

    #if NRF52_ERRATA_66_ENABLE_WORKAROUND
        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_66()){
    d7ba:	f004 fd55 	bl	12268 <nrf52_errata_136>
    d7be:	2800      	cmp	r0, #0
    d7c0:	d046      	beq.n	d850 <SystemInit+0xb0>
            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    d7c2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d7c6:	4b60      	ldr	r3, [pc, #384]	; (d948 <SystemInit+0x1a8>)
    d7c8:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    d7cc:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    d7d0:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    d7d4:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    d7d8:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    d7dc:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    d7e0:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    d7e4:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    d7e8:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    d7ec:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    d7f0:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    d7f4:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    d7f8:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    d7fc:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    d800:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    d804:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    d808:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    d80c:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    d810:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    d814:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    d818:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    d81c:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    d820:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    d824:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    d828:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    d82c:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    d830:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    d834:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    d838:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    d83c:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    d840:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    d844:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    d848:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    d84c:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    #endif

    #if NRF52_ERRATA_98_ENABLE_WORKAROUND
        /* Workaround for Errata 98 "NFCT: Not able to communicate with the peer" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_98()){
    d850:	f7ff ff84 	bl	d75c <nrf52_errata_103>
    d854:	b118      	cbz	r0, d85e <SystemInit+0xbe>
            *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
    d856:	4b3d      	ldr	r3, [pc, #244]	; (d94c <SystemInit+0x1ac>)
    d858:	4a3d      	ldr	r2, [pc, #244]	; (d950 <SystemInit+0x1b0>)
    d85a:	f8c3 268c 	str.w	r2, [r3, #1676]	; 0x68c
    #endif

    #if NRF52_ERRATA_103_ENABLE_WORKAROUND && defined(CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos)
        /* Workaround for Errata 103 "CCM: Wrong reset value of CCM MAXPACKETSIZE" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_103()){
    d85e:	f7ff ff7d 	bl	d75c <nrf52_errata_103>
    d862:	b118      	cbz	r0, d86c <SystemInit+0xcc>
            NRF_CCM->MAXPACKETSIZE = 0xFBul;
    d864:	4b3b      	ldr	r3, [pc, #236]	; (d954 <SystemInit+0x1b4>)
    d866:	22fb      	movs	r2, #251	; 0xfb
    d868:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    #endif

    #if NRF52_ERRATA_115_ENABLE_WORKAROUND
        /* Workaround for Errata 115 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_115()){
    d86c:	f7ff ff76 	bl	d75c <nrf52_errata_103>
    d870:	b170      	cbz	r0, d890 <SystemInit+0xf0>
            *(volatile uint32_t *)0x40000EE4 = (*(volatile uint32_t *)0x40000EE4 & 0xFFFFFFF0) | (*(uint32_t *)0x10000258 & 0x0000000F);
    d872:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    d876:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    d87a:	f8d1 2ee4 	ldr.w	r2, [r1, #3812]	; 0xee4
    d87e:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
    d882:	f022 020f 	bic.w	r2, r2, #15
    d886:	f003 030f 	and.w	r3, r3, #15
    d88a:	4313      	orrs	r3, r2
    d88c:	f8c1 3ee4 	str.w	r3, [r1, #3812]	; 0xee4
    #endif

    #if NRF52_ERRATA_120_ENABLE_WORKAROUND
        /* Workaround for Errata 120 "QSPI: Data read or written is corrupted" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_120()){
    d890:	f7ff ff64 	bl	d75c <nrf52_errata_103>
    d894:	b120      	cbz	r0, d8a0 <SystemInit+0x100>
            *(volatile uint32_t *)0x40029640ul = 0x200ul;
    d896:	4b30      	ldr	r3, [pc, #192]	; (d958 <SystemInit+0x1b8>)
    d898:	f44f 7200 	mov.w	r2, #512	; 0x200
    d89c:	f8c3 2640 	str.w	r2, [r3, #1600]	; 0x640
    #endif

    #if NRF52_ERRATA_136_ENABLE_WORKAROUND
        /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_136()){
    d8a0:	f004 fce2 	bl	12268 <nrf52_errata_136>
    d8a4:	b148      	cbz	r0, d8ba <SystemInit+0x11a>
            if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    d8a6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    d8aa:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    d8ae:	07d2      	lsls	r2, r2, #31
                NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
    d8b0:	bf44      	itt	mi
    d8b2:	f06f 0201 	mvnmi.w	r2, #1
    d8b6:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
         || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    d8ba:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                        return true;
                }
            }
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
    d8be:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
    d8c2:	2a08      	cmp	r2, #8
    d8c4:	d10e      	bne.n	d8e4 <SystemInit+0x144>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    d8c6:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            {
                switch(var2)
    d8ca:	2b05      	cmp	r3, #5
    d8cc:	d802      	bhi.n	d8d4 <SystemInit+0x134>
            {
                /* Prevent processor from unlocking APPROTECT soft branch after this point. */
                NRF_APPROTECT->FORCEPROTECT = APPROTECT_FORCEPROTECT_FORCEPROTECT_Force;
            }
        #else
            if (nrf52_configuration_249())
    d8ce:	4a23      	ldr	r2, [pc, #140]	; (d95c <SystemInit+0x1bc>)
    d8d0:	5cd3      	ldrb	r3, [r2, r3]
    d8d2:	b13b      	cbz	r3, d8e4 <SystemInit+0x144>
            {
                /* Load APPROTECT soft branch from UICR.
                   If UICR->APPROTECT is disabled, POWER->APPROTECT will be disabled. */
                NRF_APPROTECT->DISABLE = NRF_UICR->APPROTECT;
    d8d4:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    d8d8:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
    d8dc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    d8e0:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    d8e4:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    d8e8:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    d8ec:	2a00      	cmp	r2, #0
    d8ee:	db03      	blt.n	d8f8 <SystemInit+0x158>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
    d8f0:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    d8f4:	2b00      	cmp	r3, #0
    d8f6:	da22      	bge.n	d93e <SystemInit+0x19e>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    d8f8:	4919      	ldr	r1, [pc, #100]	; (d960 <SystemInit+0x1c0>)
    d8fa:	2301      	movs	r3, #1
            nvmc_config(NVMC_CONFIG_WEN_Wen);
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    d8fc:	f04f 2010 	mov.w	r0, #268439552	; 0x10001000
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    d900:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    d904:	2412      	movs	r4, #18
    nvmc_wait();
    d906:	f7ff ff3b 	bl	d780 <nvmc_wait>
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    d90a:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
            nvmc_wait();
    d90e:	f7ff ff37 	bl	d780 <nvmc_wait>
            NRF_UICR->PSELRESET[1] = RESET_PIN;
    d912:	f8c0 4204 	str.w	r4, [r0, #516]	; 0x204
            nvmc_wait();
    d916:	f7ff ff33 	bl	d780 <nvmc_wait>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    d91a:	2300      	movs	r3, #0
    d91c:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
    nvmc_wait();
    d920:	f7ff ff2e 	bl	d780 <nvmc_wait>
    d924:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    d928:	490e      	ldr	r1, [pc, #56]	; (d964 <SystemInit+0x1c4>)
    d92a:	4b0f      	ldr	r3, [pc, #60]	; (d968 <SystemInit+0x1c8>)
    d92c:	68ca      	ldr	r2, [r1, #12]
    d92e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    d932:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    d934:	60cb      	str	r3, [r1, #12]
    d936:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    d93a:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    d93c:	e7fd      	b.n	d93a <SystemInit+0x19a>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    d93e:	4b0b      	ldr	r3, [pc, #44]	; (d96c <SystemInit+0x1cc>)
    d940:	4a0b      	ldr	r2, [pc, #44]	; (d970 <SystemInit+0x1d0>)
    d942:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
    d944:	bd10      	pop	{r4, pc}
    d946:	bf00      	nop
    d948:	4000c000 	.word	0x4000c000
    d94c:	40005000 	.word	0x40005000
    d950:	00038148 	.word	0x00038148
    d954:	4000f000 	.word	0x4000f000
    d958:	40029000 	.word	0x40029000
    d95c:	000140ae 	.word	0x000140ae
    d960:	4001e000 	.word	0x4001e000
    d964:	e000ed00 	.word	0xe000ed00
    d968:	05fa0004 	.word	0x05fa0004
    d96c:	200004e4 	.word	0x200004e4
    d970:	03d09000 	.word	0x03d09000

0000d974 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
    d974:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
    d976:	2501      	movs	r5, #1
        prev_mask = *p_mask;
    d978:	6803      	ldr	r3, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
    d97a:	fab3 f283 	clz	r2, r3
        if (idx < 0) {
    d97e:	2a20      	cmp	r2, #32
        idx = 31 - NRF_CLZ(prev_mask);
    d980:	f1c2 041f 	rsb	r4, r2, #31
        if (idx < 0) {
    d984:	d014      	beq.n	d9b0 <nrfx_flag32_alloc+0x3c>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    d986:	f3bf 8f5b 	dmb	ish
        new_mask = prev_mask & ~NRFX_BIT(idx);
    d98a:	fa05 f204 	lsl.w	r2, r5, r4
    d98e:	ea23 0202 	bic.w	r2, r3, r2
    d992:	e850 6f00 	ldrex	r6, [r0]
    d996:	429e      	cmp	r6, r3
    d998:	d104      	bne.n	d9a4 <nrfx_flag32_alloc+0x30>
    d99a:	e840 2c00 	strex	ip, r2, [r0]
    d99e:	f1bc 0f00 	cmp.w	ip, #0
    d9a2:	d1f6      	bne.n	d992 <nrfx_flag32_alloc+0x1e>
    d9a4:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    d9a8:	d1e6      	bne.n	d978 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
    d9aa:	4802      	ldr	r0, [pc, #8]	; (d9b4 <nrfx_flag32_alloc+0x40>)
    *p_flag = idx;
    d9ac:	700c      	strb	r4, [r1, #0]
}
    d9ae:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_NO_MEM;
    d9b0:	4801      	ldr	r0, [pc, #4]	; (d9b8 <nrfx_flag32_alloc+0x44>)
    d9b2:	e7fc      	b.n	d9ae <nrfx_flag32_alloc+0x3a>
    d9b4:	0bad0000 	.word	0x0bad0000
    d9b8:	0bad0002 	.word	0x0bad0002

0000d9bc <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
    d9bc:	6803      	ldr	r3, [r0, #0]
    d9be:	40cb      	lsrs	r3, r1
    d9c0:	07db      	lsls	r3, r3, #31
{
    d9c2:	b510      	push	{r4, lr}
    if ((NRFX_BIT(flag) & *p_mask))
    d9c4:	d415      	bmi.n	d9f2 <nrfx_flag32_free+0x36>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
    d9c6:	2301      	movs	r3, #1
    d9c8:	fa03 f101 	lsl.w	r1, r3, r1
        prev_mask = *p_mask;
    d9cc:	6803      	ldr	r3, [r0, #0]
    d9ce:	f3bf 8f5b 	dmb	ish
        new_mask = prev_mask | NRFX_BIT(flag);
    d9d2:	ea41 0203 	orr.w	r2, r1, r3
    d9d6:	e850 4f00 	ldrex	r4, [r0]
    d9da:	429c      	cmp	r4, r3
    d9dc:	d104      	bne.n	d9e8 <nrfx_flag32_free+0x2c>
    d9de:	e840 2c00 	strex	ip, r2, [r0]
    d9e2:	f1bc 0f00 	cmp.w	ip, #0
    d9e6:	d1f6      	bne.n	d9d6 <nrfx_flag32_free+0x1a>
    d9e8:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    d9ec:	d1ee      	bne.n	d9cc <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
    d9ee:	4802      	ldr	r0, [pc, #8]	; (d9f8 <nrfx_flag32_free+0x3c>)
}
    d9f0:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
    d9f2:	4802      	ldr	r0, [pc, #8]	; (d9fc <nrfx_flag32_free+0x40>)
    d9f4:	e7fc      	b.n	d9f0 <nrfx_flag32_free+0x34>
    d9f6:	bf00      	nop
    d9f8:	0bad0000 	.word	0x0bad0000
    d9fc:	0bad0004 	.word	0x0bad0004

0000da00 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    da00:	4b04      	ldr	r3, [pc, #16]	; (da14 <nrfx_clock_init+0x14>)
    da02:	791a      	ldrb	r2, [r3, #4]
    da04:	b922      	cbnz	r2, da10 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
    da06:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
    da08:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    da0a:	809a      	strh	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
    da0c:	4802      	ldr	r0, [pc, #8]	; (da18 <nrfx_clock_init+0x18>)
    da0e:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    da10:	4802      	ldr	r0, [pc, #8]	; (da1c <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    da12:	4770      	bx	lr
    da14:	200025f0 	.word	0x200025f0
    da18:	0bad0000 	.word	0x0bad0000
    da1c:	0bad000c 	.word	0x0bad000c

0000da20 <nrfx_clock_stop>:
            break;
    }
}

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    da20:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    da22:	b110      	cbz	r0, da2a <nrfx_clock_stop+0xa>
    da24:	2801      	cmp	r0, #1
    da26:	d017      	beq.n	da58 <nrfx_clock_stop+0x38>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    da28:	bd38      	pop	{r3, r4, r5, pc}
    p_reg->INTENCLR = mask;
    da2a:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
    da2e:	2302      	movs	r3, #2
    da30:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    da34:	f8c4 0104 	str.w	r0, [r4, #260]	; 0x104
    da38:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    da3c:	2301      	movs	r3, #1
    da3e:	60e3      	str	r3, [r4, #12]
    da40:	f242 7510 	movw	r5, #10000	; 0x2710
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    da44:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
    da48:	03db      	lsls	r3, r3, #15
    da4a:	d5ed      	bpl.n	da28 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    da4c:	2001      	movs	r0, #1
    da4e:	f004 fc15 	bl	1227c <nrfx_busy_wait>
    da52:	3d01      	subs	r5, #1
    da54:	d1f6      	bne.n	da44 <nrfx_clock_stop+0x24>
    da56:	e7e7      	b.n	da28 <nrfx_clock_stop+0x8>
    p_reg->INTENCLR = mask;
    da58:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    da5c:	2300      	movs	r3, #0
    p_reg->INTENCLR = mask;
    da5e:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    da62:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
    da66:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    da6a:	6060      	str	r0, [r4, #4]
    da6c:	f242 7510 	movw	r5, #10000	; 0x2710
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    da70:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    da74:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
    da78:	03d2      	lsls	r2, r2, #15
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    da7a:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    da7e:	d505      	bpl.n	da8c <nrfx_clock_stop+0x6c>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
    da80:	b123      	cbz	r3, da8c <nrfx_clock_stop+0x6c>
    da82:	2001      	movs	r0, #1
    da84:	f004 fbfa 	bl	1227c <nrfx_busy_wait>
    da88:	3d01      	subs	r5, #1
    da8a:	d1f1      	bne.n	da70 <nrfx_clock_stop+0x50>
            m_clock_cb.hfclk_started = false;
    da8c:	4b01      	ldr	r3, [pc, #4]	; (da94 <nrfx_clock_stop+0x74>)
    da8e:	2200      	movs	r2, #0
    da90:	715a      	strb	r2, [r3, #5]
    da92:	e7c9      	b.n	da28 <nrfx_clock_stop+0x8>
    da94:	200025f0 	.word	0x200025f0

0000da98 <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    da98:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    da9c:	b510      	push	{r4, lr}
    da9e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    daa2:	b16a      	cbz	r2, dac0 <nrfx_power_clock_irq_handler+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    daa4:	2200      	movs	r2, #0
    daa6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    daaa:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
    daae:	2201      	movs	r2, #1
    dab0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);

#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        if (!m_clock_cb.hfclk_started)
    dab4:	4b11      	ldr	r3, [pc, #68]	; (dafc <nrfx_power_clock_irq_handler+0x64>)
    dab6:	7958      	ldrb	r0, [r3, #5]
    dab8:	b910      	cbnz	r0, dac0 <nrfx_power_clock_irq_handler+0x28>
        {
            m_clock_cb.hfclk_started = true;
    daba:	715a      	strb	r2, [r3, #5]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    dabc:	681b      	ldr	r3, [r3, #0]
    dabe:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    dac0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    dac4:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    dac8:	b172      	cbz	r2, dae8 <nrfx_power_clock_irq_handler+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    daca:	2200      	movs	r2, #0
    dacc:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    dad0:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    dad4:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    dad8:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    dadc:	0792      	lsls	r2, r2, #30
    dade:	d104      	bne.n	daea <nrfx_power_clock_irq_handler+0x52>
    p_reg->LFCLKSRC = (uint32_t)(source);
    dae0:	2201      	movs	r2, #1
    dae2:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    dae6:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    dae8:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
    daea:	2202      	movs	r2, #2
    daec:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    daf0:	4b02      	ldr	r3, [pc, #8]	; (dafc <nrfx_power_clock_irq_handler+0x64>)
}
    daf2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    daf6:	681b      	ldr	r3, [r3, #0]
    daf8:	2001      	movs	r0, #1
    dafa:	4718      	bx	r3
    dafc:	200025f0 	.word	0x200025f0

0000db00 <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
    db00:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
    db02:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    db06:	095b      	lsrs	r3, r3, #5
        case 1: return NRF_P1;
    db08:	2b01      	cmp	r3, #1
    *p_pin = pin_number & 0x1F;
    db0a:	6002      	str	r2, [r0, #0]
}
    db0c:	4802      	ldr	r0, [pc, #8]	; (db18 <nrf_gpio_pin_port_decode+0x18>)
    db0e:	bf18      	it	ne
    db10:	f04f 40a0 	movne.w	r0, #1342177280	; 0x50000000
    db14:	4770      	bx	lr
    db16:	bf00      	nop
    db18:	50000300 	.word	0x50000300

0000db1c <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
    db1c:	4b03      	ldr	r3, [pc, #12]	; (db2c <pin_in_use_by_te+0x10>)
    db1e:	3008      	adds	r0, #8
    db20:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    db24:	f3c0 1040 	ubfx	r0, r0, #5, #1
    db28:	4770      	bx	lr
    db2a:	bf00      	nop
    db2c:	200004e8 	.word	0x200004e8

0000db30 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
    db30:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    db32:	f100 0308 	add.w	r3, r0, #8
    db36:	4c0c      	ldr	r4, [pc, #48]	; (db68 <call_handler+0x38>)
    db38:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
    db3c:	05da      	lsls	r2, r3, #23
{
    db3e:	4605      	mov	r5, r0
    db40:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    db42:	d507      	bpl.n	db54 <call_handler+0x24>
    db44:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
    db48:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    db4c:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
    db50:	6852      	ldr	r2, [r2, #4]
    db52:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
    db54:	68a3      	ldr	r3, [r4, #8]
    db56:	b12b      	cbz	r3, db64 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
    db58:	68e2      	ldr	r2, [r4, #12]
    db5a:	4631      	mov	r1, r6
    db5c:	4628      	mov	r0, r5
    }
}
    db5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
    db62:	4718      	bx	r3
}
    db64:	bd70      	pop	{r4, r5, r6, pc}
    db66:	bf00      	nop
    db68:	200004e8 	.word	0x200004e8

0000db6c <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    db6c:	4a12      	ldr	r2, [pc, #72]	; (dbb8 <release_handler+0x4c>)
    db6e:	3008      	adds	r0, #8
{
    db70:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    db72:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
    db76:	05d9      	lsls	r1, r3, #23
    db78:	d51b      	bpl.n	dbb2 <release_handler+0x46>
    db7a:	f3c3 2143 	ubfx	r1, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
    db7e:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
    db82:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    db86:	f102 0410 	add.w	r4, r2, #16
    db8a:	2000      	movs	r0, #0
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
    db8c:	f834 3b02 	ldrh.w	r3, [r4], #2
    db90:	f413 7f80 	tst.w	r3, #256	; 0x100
    db94:	d003      	beq.n	db9e <release_handler+0x32>
    db96:	f3c3 2343 	ubfx	r3, r3, #9, #4
    db9a:	4299      	cmp	r1, r3
    db9c:	d009      	beq.n	dbb2 <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    db9e:	3001      	adds	r0, #1
    dba0:	2830      	cmp	r0, #48	; 0x30
    dba2:	d1f3      	bne.n	db8c <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
    dba4:	2300      	movs	r3, #0
    dba6:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
    dbaa:	4804      	ldr	r0, [pc, #16]	; (dbbc <release_handler+0x50>)
}
    dbac:	bc10      	pop	{r4}
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
    dbae:	f7ff bf05 	b.w	d9bc <nrfx_flag32_free>
}
    dbb2:	bc10      	pop	{r4}
    dbb4:	4770      	bx	lr
    dbb6:	bf00      	nop
    dbb8:	200004e8 	.word	0x200004e8
    dbbc:	2000055c 	.word	0x2000055c

0000dbc0 <pin_handler_trigger_uninit>:
{
    dbc0:	b538      	push	{r3, r4, r5, lr}
    dbc2:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
    dbc4:	f7ff ffaa 	bl	db1c <pin_in_use_by_te>
    dbc8:	4c09      	ldr	r4, [pc, #36]	; (dbf0 <pin_handler_trigger_uninit+0x30>)
    dbca:	f102 0508 	add.w	r5, r2, #8
    dbce:	b140      	cbz	r0, dbe2 <pin_handler_trigger_uninit+0x22>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    dbd0:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
    dbd4:	4907      	ldr	r1, [pc, #28]	; (dbf4 <pin_handler_trigger_uninit+0x34>)
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
    dbd6:	0b5b      	lsrs	r3, r3, #13
    dbd8:	f503 73a2 	add.w	r3, r3, #324	; 0x144
    dbdc:	2000      	movs	r0, #0
    dbde:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
    release_handler(pin);
    dbe2:	4610      	mov	r0, r2
    dbe4:	f7ff ffc2 	bl	db6c <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
    dbe8:	2300      	movs	r3, #0
    dbea:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
    dbee:	bd38      	pop	{r3, r4, r5, pc}
    dbf0:	200004e8 	.word	0x200004e8
    dbf4:	40006000 	.word	0x40006000

0000dbf8 <nrfx_gpiote_input_configure>:
{
    dbf8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    dbfc:	4604      	mov	r4, r0
    dbfe:	4617      	mov	r7, r2
    dc00:	461d      	mov	r5, r3
    if (p_input_config)
    dc02:	b321      	cbz	r1, dc4e <nrfx_gpiote_input_configure+0x56>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    dc04:	4e4e      	ldr	r6, [pc, #312]	; (dd40 <nrfx_gpiote_input_configure+0x148>)
    dc06:	f100 0808 	add.w	r8, r0, #8
    return pin_is_output(pin) && pin_in_use_by_te(pin);
    dc0a:	f836 3018 	ldrh.w	r3, [r6, r8, lsl #1]
    dc0e:	079b      	lsls	r3, r3, #30
    dc10:	d506      	bpl.n	dc20 <nrfx_gpiote_input_configure+0x28>
    dc12:	f7ff ff83 	bl	db1c <pin_in_use_by_te>
        if (pin_is_task_output(pin))
    dc16:	b118      	cbz	r0, dc20 <nrfx_gpiote_input_configure+0x28>
                return NRFX_ERROR_INVALID_PARAM;
    dc18:	484a      	ldr	r0, [pc, #296]	; (dd44 <nrfx_gpiote_input_configure+0x14c>)
}
    dc1a:	b004      	add	sp, #16
    dc1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
    dc20:	2300      	movs	r3, #0
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
    dc22:	e9cd 3300 	strd	r3, r3, [sp]
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
    dc26:	f88d 300e 	strb.w	r3, [sp, #14]
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
    dc2a:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
    dc2e:	f10d 020f 	add.w	r2, sp, #15
    dc32:	460b      	mov	r3, r1
    dc34:	4620      	mov	r0, r4
    dc36:	f10d 010e 	add.w	r1, sp, #14
    dc3a:	f004 fb57 	bl	122ec <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
    dc3e:	f836 3018 	ldrh.w	r3, [r6, r8, lsl #1]
    dc42:	f023 0302 	bic.w	r3, r3, #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
    dc46:	f043 0301 	orr.w	r3, r3, #1
    dc4a:	f826 3018 	strh.w	r3, [r6, r8, lsl #1]
    if (p_trigger_config)
    dc4e:	b197      	cbz	r7, dc76 <nrfx_gpiote_input_configure+0x7e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    dc50:	4b3b      	ldr	r3, [pc, #236]	; (dd40 <nrfx_gpiote_input_configure+0x148>)
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
    dc52:	783e      	ldrb	r6, [r7, #0]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
    dc54:	687a      	ldr	r2, [r7, #4]
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    dc56:	f104 0008 	add.w	r0, r4, #8
    dc5a:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
        if (pin_is_output(pin))
    dc5e:	078f      	lsls	r7, r1, #30
    dc60:	d50c      	bpl.n	dc7c <nrfx_gpiote_input_configure+0x84>
            if (use_evt)
    dc62:	2a00      	cmp	r2, #0
    dc64:	d1d8      	bne.n	dc18 <nrfx_gpiote_input_configure+0x20>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
    dc66:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
    dc6a:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
    dc6e:	ea42 0286 	orr.w	r2, r2, r6, lsl #2
    dc72:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
    if (p_handler_config)
    dc76:	bbcd      	cbnz	r5, dcec <nrfx_gpiote_input_configure+0xf4>
    return NRFX_SUCCESS;
    dc78:	4833      	ldr	r0, [pc, #204]	; (dd48 <nrfx_gpiote_input_configure+0x150>)
    dc7a:	e7ce      	b.n	dc1a <nrfx_gpiote_input_configure+0x22>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
    dc7c:	f021 0120 	bic.w	r1, r1, #32
    dc80:	04c9      	lsls	r1, r1, #19
    dc82:	0cc9      	lsrs	r1, r1, #19
    dc84:	f823 1010 	strh.w	r1, [r3, r0, lsl #1]
            if (use_evt)
    dc88:	2a00      	cmp	r2, #0
    dc8a:	d0ec      	beq.n	dc66 <nrfx_gpiote_input_configure+0x6e>
                if (!edge)
    dc8c:	2e03      	cmp	r6, #3
    dc8e:	d8c3      	bhi.n	dc18 <nrfx_gpiote_input_configure+0x20>
                uint8_t ch = *p_trigger_config->p_in_channel;
    dc90:	7817      	ldrb	r7, [r2, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
    dc92:	b92e      	cbnz	r6, dca0 <nrfx_gpiote_input_configure+0xa8>
    dc94:	4a2d      	ldr	r2, [pc, #180]	; (dd4c <nrfx_gpiote_input_configure+0x154>)
    dc96:	f507 71a2 	add.w	r1, r7, #324	; 0x144
    dc9a:	f842 6021 	str.w	r6, [r2, r1, lsl #2]
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
#endif
}
    dc9e:	e7e2      	b.n	dc66 <nrfx_gpiote_input_configure+0x6e>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    dca0:	00ba      	lsls	r2, r7, #2
    dca2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    dca6:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    dcaa:	ea41 3147 	orr.w	r1, r1, r7, lsl #13
    dcae:	f8d2 c510 	ldr.w	ip, [r2, #1296]	; 0x510
    dcb2:	f02c 0c03 	bic.w	ip, ip, #3
    dcb6:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    dcba:	f8d2 c510 	ldr.w	ip, [r2, #1296]	; 0x510
    dcbe:	f42c 3c4f 	bic.w	ip, ip, #211968	; 0x33c00
    dcc2:	f42c 7c40 	bic.w	ip, ip, #768	; 0x300
    dcc6:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    dcca:	f8d2 e510 	ldr.w	lr, [r2, #1296]	; 0x510
    dcce:	ea4f 2c04 	mov.w	ip, r4, lsl #8
    dcd2:	f40c 5c7c 	and.w	ip, ip, #16128	; 0x3f00
    dcd6:	ea4e 4e06 	orr.w	lr, lr, r6, lsl #16
    dcda:	ea4c 0c0e 	orr.w	ip, ip, lr
    dcde:	f041 0120 	orr.w	r1, r1, #32
    dce2:	f823 1010 	strh.w	r1, [r3, r0, lsl #1]
    dce6:	f8c2 c510 	str.w	ip, [r2, #1296]	; 0x510
    dcea:	e7bc      	b.n	dc66 <nrfx_gpiote_input_configure+0x6e>
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
    dcec:	e9d5 6700 	ldrd	r6, r7, [r5]
    release_handler(pin);
    dcf0:	4620      	mov	r0, r4
    dcf2:	f7ff ff3b 	bl	db6c <release_handler>
    if (!handler)
    dcf6:	2e00      	cmp	r6, #0
    dcf8:	d0be      	beq.n	dc78 <nrfx_gpiote_input_configure+0x80>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
    dcfa:	4d11      	ldr	r5, [pc, #68]	; (dd40 <nrfx_gpiote_input_configure+0x148>)
    dcfc:	682b      	ldr	r3, [r5, #0]
    dcfe:	429e      	cmp	r6, r3
    dd00:	d104      	bne.n	dd0c <nrfx_gpiote_input_configure+0x114>
    dd02:	686b      	ldr	r3, [r5, #4]
    dd04:	429f      	cmp	r7, r3
    dd06:	d101      	bne.n	dd0c <nrfx_gpiote_input_configure+0x114>
    dd08:	2200      	movs	r2, #0
    dd0a:	e00a      	b.n	dd22 <nrfx_gpiote_input_configure+0x12a>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
    dd0c:	4810      	ldr	r0, [pc, #64]	; (dd50 <nrfx_gpiote_input_configure+0x158>)
    dd0e:	f10d 010f 	add.w	r1, sp, #15
    dd12:	f7ff fe2f 	bl	d974 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
    dd16:	4b0c      	ldr	r3, [pc, #48]	; (dd48 <nrfx_gpiote_input_configure+0x150>)
    dd18:	4298      	cmp	r0, r3
    dd1a:	f47f af7e 	bne.w	dc1a <nrfx_gpiote_input_configure+0x22>
        handler_id = (int32_t)id;
    dd1e:	f89d 200f 	ldrb.w	r2, [sp, #15]
    m_cb.handlers[handler_id].handler = handler;
    dd22:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.handlers[handler_id].p_context = p_context;
    dd26:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
    dd2a:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
    dd2c:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
    dd2e:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    dd32:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
    dd36:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    dd3a:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
    dd3e:	e79b      	b.n	dc78 <nrfx_gpiote_input_configure+0x80>
    dd40:	200004e8 	.word	0x200004e8
    dd44:	0bad0004 	.word	0x0bad0004
    dd48:	0bad0000 	.word	0x0bad0000
    dd4c:	40006000 	.word	0x40006000
    dd50:	2000055c 	.word	0x2000055c

0000dd54 <nrfx_gpiote_output_configure>:
{
    dd54:	b5f0      	push	{r4, r5, r6, r7, lr}
    dd56:	4604      	mov	r4, r0
    dd58:	b085      	sub	sp, #20
    dd5a:	4615      	mov	r5, r2
    if (p_config)
    dd5c:	b319      	cbz	r1, dda6 <nrfx_gpiote_output_configure+0x52>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    dd5e:	4e33      	ldr	r6, [pc, #204]	; (de2c <nrfx_gpiote_output_configure+0xd8>)
    dd60:	f100 0708 	add.w	r7, r0, #8
    dd64:	f836 2017 	ldrh.w	r2, [r6, r7, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
    dd68:	0793      	lsls	r3, r2, #30
    dd6a:	d403      	bmi.n	dd74 <nrfx_gpiote_output_configure+0x20>
    dd6c:	f7ff fed6 	bl	db1c <pin_in_use_by_te>
    dd70:	2800      	cmp	r0, #0
    dd72:	d158      	bne.n	de26 <nrfx_gpiote_output_configure+0xd2>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
    dd74:	f012 0f1c 	tst.w	r2, #28
    dd78:	d002      	beq.n	dd80 <nrfx_gpiote_output_configure+0x2c>
    dd7a:	784b      	ldrb	r3, [r1, #1]
    dd7c:	2b01      	cmp	r3, #1
    dd7e:	d052      	beq.n	de26 <nrfx_gpiote_output_configure+0xd2>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
    dd80:	2301      	movs	r3, #1
    dd82:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
    dd86:	2300      	movs	r3, #0
    dd88:	e9cd 1300 	strd	r1, r3, [sp]
    dd8c:	1c4a      	adds	r2, r1, #1
    dd8e:	1c8b      	adds	r3, r1, #2
    dd90:	4620      	mov	r0, r4
    dd92:	f10d 010f 	add.w	r1, sp, #15
    dd96:	f004 faa9 	bl	122ec <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
    dd9a:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
    dd9e:	f043 0303 	orr.w	r3, r3, #3
    dda2:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_task_config)
    dda6:	b915      	cbnz	r5, ddae <nrfx_gpiote_output_configure+0x5a>
    return NRFX_SUCCESS;
    dda8:	4821      	ldr	r0, [pc, #132]	; (de30 <nrfx_gpiote_output_configure+0xdc>)
}
    ddaa:	b005      	add	sp, #20
    ddac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    ddae:	4e1f      	ldr	r6, [pc, #124]	; (de2c <nrfx_gpiote_output_configure+0xd8>)
    ddb0:	f104 0708 	add.w	r7, r4, #8
    ddb4:	f836 0017 	ldrh.w	r0, [r6, r7, lsl #1]
        if (pin_is_input(pin))
    ddb8:	0783      	lsls	r3, r0, #30
    ddba:	d534      	bpl.n	de26 <nrfx_gpiote_output_configure+0xd2>
        uint32_t ch = p_task_config->task_ch;
    ddbc:	f895 c000 	ldrb.w	ip, [r5]
    p_reg->CONFIG[idx] = 0;
    ddc0:	4661      	mov	r1, ip
    ddc2:	0089      	lsls	r1, r1, #2
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
    ddc4:	f020 0020 	bic.w	r0, r0, #32
    ddc8:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
    ddcc:	04c0      	lsls	r0, r0, #19
    ddce:	f501 41c0 	add.w	r1, r1, #24576	; 0x6000
    ddd2:	0cc0      	lsrs	r0, r0, #19
    ddd4:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
    ddd8:	2300      	movs	r3, #0
    ddda:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
    ddde:	786a      	ldrb	r2, [r5, #1]
    dde0:	2a00      	cmp	r2, #0
    dde2:	d0e1      	beq.n	dda8 <nrfx_gpiote_output_configure+0x54>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
    dde4:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
    dde8:	78ad      	ldrb	r5, [r5, #2]
    ddea:	f423 1399 	bic.w	r3, r3, #1253376	; 0x132000
    ddee:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
    ddf2:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    ddf6:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
    ddfa:	0223      	lsls	r3, r4, #8
    ddfc:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
    de00:	0412      	lsls	r2, r2, #16
    de02:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    de06:	ea43 030e 	orr.w	r3, r3, lr
    de0a:	4313      	orrs	r3, r2
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
    de0c:	052a      	lsls	r2, r5, #20
    de0e:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    de12:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    de16:	4313      	orrs	r3, r2
    de18:	f040 0020 	orr.w	r0, r0, #32
    de1c:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
    de20:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
    de24:	e7c0      	b.n	dda8 <nrfx_gpiote_output_configure+0x54>
            return NRFX_ERROR_INVALID_PARAM;
    de26:	4803      	ldr	r0, [pc, #12]	; (de34 <nrfx_gpiote_output_configure+0xe0>)
    de28:	e7bf      	b.n	ddaa <nrfx_gpiote_output_configure+0x56>
    de2a:	bf00      	nop
    de2c:	200004e8 	.word	0x200004e8
    de30:	0bad0000 	.word	0x0bad0000
    de34:	0bad0004 	.word	0x0bad0004

0000de38 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
    de38:	4b01      	ldr	r3, [pc, #4]	; (de40 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
    de3a:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
    de3e:	4770      	bx	lr
    de40:	200004e8 	.word	0x200004e8

0000de44 <nrfx_gpiote_channel_get>:
{
    de44:	b508      	push	{r3, lr}
    de46:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
    de48:	f7ff fe68 	bl	db1c <pin_in_use_by_te>
    de4c:	b138      	cbz	r0, de5e <nrfx_gpiote_channel_get+0x1a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    de4e:	4b05      	ldr	r3, [pc, #20]	; (de64 <nrfx_gpiote_channel_get+0x20>)
        return NRFX_SUCCESS;
    de50:	4805      	ldr	r0, [pc, #20]	; (de68 <nrfx_gpiote_channel_get+0x24>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    de52:	3208      	adds	r2, #8
    de54:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    de58:	0b5b      	lsrs	r3, r3, #13
    de5a:	700b      	strb	r3, [r1, #0]
}
    de5c:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_PARAM;
    de5e:	4803      	ldr	r0, [pc, #12]	; (de6c <nrfx_gpiote_channel_get+0x28>)
    de60:	e7fc      	b.n	de5c <nrfx_gpiote_channel_get+0x18>
    de62:	bf00      	nop
    de64:	200004e8 	.word	0x200004e8
    de68:	0bad0000 	.word	0x0bad0000
    de6c:	0bad0004 	.word	0x0bad0004

0000de70 <nrfx_gpiote_init>:
{
    de70:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
    de72:	4c0f      	ldr	r4, [pc, #60]	; (deb0 <nrfx_gpiote_init+0x40>)
    de74:	f894 5078 	ldrb.w	r5, [r4, #120]	; 0x78
    de78:	b9bd      	cbnz	r5, deaa <nrfx_gpiote_init+0x3a>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
    de7a:	2260      	movs	r2, #96	; 0x60
    de7c:	4629      	mov	r1, r5
    de7e:	f104 0010 	add.w	r0, r4, #16
    de82:	f001 fe9b 	bl	fbbc <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
    de86:	2006      	movs	r0, #6
    de88:	f7f4 fb1e 	bl	24c8 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    de8c:	4b09      	ldr	r3, [pc, #36]	; (deb4 <nrfx_gpiote_init+0x44>)
    return err_code;
    de8e:	480a      	ldr	r0, [pc, #40]	; (deb8 <nrfx_gpiote_init+0x48>)
    de90:	f8c3 517c 	str.w	r5, [r3, #380]	; 0x17c
    de94:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
    de98:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    de9c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
    dea0:	2301      	movs	r3, #1
    dea2:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
    dea6:	6763      	str	r3, [r4, #116]	; 0x74
}
    dea8:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
    deaa:	4804      	ldr	r0, [pc, #16]	; (debc <nrfx_gpiote_init+0x4c>)
    deac:	e7fc      	b.n	dea8 <nrfx_gpiote_init+0x38>
    deae:	bf00      	nop
    deb0:	200004e8 	.word	0x200004e8
    deb4:	40006000 	.word	0x40006000
    deb8:	0bad0000 	.word	0x0bad0000
    debc:	0bad0005 	.word	0x0bad0005

0000dec0 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
    dec0:	4b03      	ldr	r3, [pc, #12]	; (ded0 <nrfx_gpiote_is_init+0x10>)
    dec2:	f893 0078 	ldrb.w	r0, [r3, #120]	; 0x78
}
    dec6:	3800      	subs	r0, #0
    dec8:	bf18      	it	ne
    deca:	2001      	movne	r0, #1
    decc:	4770      	bx	lr
    dece:	bf00      	nop
    ded0:	200004e8 	.word	0x200004e8

0000ded4 <nrfx_gpiote_channel_free>:
{
    ded4:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
    ded6:	4801      	ldr	r0, [pc, #4]	; (dedc <nrfx_gpiote_channel_free+0x8>)
    ded8:	f7ff bd70 	b.w	d9bc <nrfx_flag32_free>
    dedc:	20000558 	.word	0x20000558

0000dee0 <nrfx_gpiote_channel_alloc>:
{
    dee0:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
    dee2:	4801      	ldr	r0, [pc, #4]	; (dee8 <nrfx_gpiote_channel_alloc+0x8>)
    dee4:	f7ff bd46 	b.w	d974 <nrfx_flag32_alloc>
    dee8:	20000558 	.word	0x20000558

0000deec <nrfx_gpiote_trigger_enable>:
{
    deec:	b537      	push	{r0, r1, r2, r4, r5, lr}
    deee:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    def0:	f7ff fe14 	bl	db1c <pin_in_use_by_te>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    def4:	f104 0208 	add.w	r2, r4, #8
    def8:	4b1e      	ldr	r3, [pc, #120]	; (df74 <nrfx_gpiote_trigger_enable+0x88>)
    defa:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    defe:	b1e8      	cbz	r0, df3c <nrfx_gpiote_trigger_enable+0x50>
    df00:	f013 0502 	ands.w	r5, r3, #2
    df04:	d11a      	bne.n	df3c <nrfx_gpiote_trigger_enable+0x50>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    df06:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
    df08:	009a      	lsls	r2, r3, #2
    return ((uint32_t)p_reg + event);
    df0a:	f102 4080 	add.w	r0, r2, #1073741824	; 0x40000000
    df0e:	f500 40c2 	add.w	r0, r0, #24832	; 0x6100
    df12:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    df16:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    df1a:	6005      	str	r5, [r0, #0]
    df1c:	6800      	ldr	r0, [r0, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    df1e:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
    df22:	f040 0001 	orr.w	r0, r0, #1
    df26:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
    df2a:	b129      	cbz	r1, df38 <nrfx_gpiote_trigger_enable+0x4c>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
    df2c:	2201      	movs	r2, #1
    df2e:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
    df32:	4a11      	ldr	r2, [pc, #68]	; (df78 <nrfx_gpiote_trigger_enable+0x8c>)
    df34:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
    df38:	b003      	add	sp, #12
    df3a:	bd30      	pop	{r4, r5, pc}
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    df3c:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
    df40:	2b04      	cmp	r3, #4
    df42:	d012      	beq.n	df6a <nrfx_gpiote_trigger_enable+0x7e>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
    df44:	2b05      	cmp	r3, #5
    df46:	d012      	beq.n	df6e <nrfx_gpiote_trigger_enable+0x82>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    df48:	a801      	add	r0, sp, #4
    df4a:	9401      	str	r4, [sp, #4]
    df4c:	f7ff fdd8 	bl	db00 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
    df50:	9b01      	ldr	r3, [sp, #4]
    return p_reg->IN;
    df52:	f8d0 1510 	ldr.w	r1, [r0, #1296]	; 0x510
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
    df56:	40d9      	lsrs	r1, r3
    df58:	f001 0101 	and.w	r1, r1, #1
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    df5c:	3102      	adds	r1, #2
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
    df5e:	4620      	mov	r0, r4
}
    df60:	b003      	add	sp, #12
    df62:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
    df66:	f004 ba08 	b.w	1237a <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
    df6a:	2103      	movs	r1, #3
    df6c:	e7f7      	b.n	df5e <nrfx_gpiote_trigger_enable+0x72>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
    df6e:	2102      	movs	r1, #2
    df70:	e7f5      	b.n	df5e <nrfx_gpiote_trigger_enable+0x72>
    df72:	bf00      	nop
    df74:	200004e8 	.word	0x200004e8
    df78:	40006000 	.word	0x40006000

0000df7c <nrfx_gpiote_trigger_disable>:
{
    df7c:	b508      	push	{r3, lr}
    df7e:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    df80:	f7ff fdcc 	bl	db1c <pin_in_use_by_te>
    df84:	b1c0      	cbz	r0, dfb8 <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    df86:	f102 0108 	add.w	r1, r2, #8
    df8a:	4b0e      	ldr	r3, [pc, #56]	; (dfc4 <nrfx_gpiote_trigger_disable+0x48>)
    df8c:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    df90:	0799      	lsls	r1, r3, #30
    df92:	d411      	bmi.n	dfb8 <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    df94:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
    df96:	2201      	movs	r2, #1
    df98:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
    df9a:	009b      	lsls	r3, r3, #2
    df9c:	490a      	ldr	r1, [pc, #40]	; (dfc8 <nrfx_gpiote_trigger_disable+0x4c>)
    df9e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    dfa2:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    dfa6:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    dfaa:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    dfae:	f022 0203 	bic.w	r2, r2, #3
    dfb2:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
    dfb6:	bd08      	pop	{r3, pc}
    dfb8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
    dfbc:	2100      	movs	r1, #0
    dfbe:	4610      	mov	r0, r2
    dfc0:	f004 b9db 	b.w	1237a <nrf_gpio_cfg_sense_set>
    dfc4:	200004e8 	.word	0x200004e8
    dfc8:	40006000 	.word	0x40006000

0000dfcc <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    dfcc:	4b0e      	ldr	r3, [pc, #56]	; (e008 <nrfx_gpiote_pin_uninit+0x3c>)
    dfce:	f100 0208 	add.w	r2, r0, #8
{
    dfd2:	b513      	push	{r0, r1, r4, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    dfd4:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (!pin_in_use(pin))
    dfd8:	07db      	lsls	r3, r3, #31
{
    dfda:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
    dfdc:	d511      	bpl.n	e002 <nrfx_gpiote_pin_uninit+0x36>
    nrfx_gpiote_trigger_disable(pin);
    dfde:	f7ff ffcd 	bl	df7c <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
    dfe2:	4620      	mov	r0, r4
    dfe4:	f7ff fdec 	bl	dbc0 <pin_handler_trigger_uninit>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    dfe8:	a801      	add	r0, sp, #4
    dfea:	9401      	str	r4, [sp, #4]
    dfec:	f7ff fd88 	bl	db00 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    dff0:	9b01      	ldr	r3, [sp, #4]
    dff2:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    dff6:	2202      	movs	r2, #2
    dff8:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    nrf_gpio_cfg(
    dffc:	4803      	ldr	r0, [pc, #12]	; (e00c <nrfx_gpiote_pin_uninit+0x40>)
}
    dffe:	b002      	add	sp, #8
    e000:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
    e002:	4803      	ldr	r0, [pc, #12]	; (e010 <nrfx_gpiote_pin_uninit+0x44>)
    e004:	e7fb      	b.n	dffe <nrfx_gpiote_pin_uninit+0x32>
    e006:	bf00      	nop
    e008:	200004e8 	.word	0x200004e8
    e00c:	0bad0000 	.word	0x0bad0000
    e010:	0bad0004 	.word	0x0bad0004

0000e014 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
    e014:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e018:	4b64      	ldr	r3, [pc, #400]	; (e1ac <nrfx_gpiote_irq_handler+0x198>)
    return p_reg->INTENSET & mask;
    e01a:	4865      	ldr	r0, [pc, #404]	; (e1b0 <nrfx_gpiote_irq_handler+0x19c>)
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    e01c:	4965      	ldr	r1, [pc, #404]	; (e1b4 <nrfx_gpiote_irq_handler+0x1a0>)
    uint32_t status = 0;
    e01e:	2600      	movs	r6, #0
{
    e020:	b087      	sub	sp, #28
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
    e022:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    e024:	4634      	mov	r4, r6
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e026:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
    e028:	b135      	cbz	r5, e038 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
    e02a:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
    e02e:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    e030:	bf1e      	ittt	ne
    e032:	601c      	strne	r4, [r3, #0]
    e034:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
    e036:	4316      	orrne	r6, r2
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    e038:	3304      	adds	r3, #4
    e03a:	428b      	cmp	r3, r1
        }
        mask <<= 1;
    e03c:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    e040:	d1f1      	bne.n	e026 <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e042:	f8df 816c 	ldr.w	r8, [pc, #364]	; e1b0 <nrfx_gpiote_irq_handler+0x19c>
    e046:	f8d8 317c 	ldr.w	r3, [r8, #380]	; 0x17c
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
    e04a:	2b00      	cmp	r3, #0
    e04c:	f000 8091 	beq.w	e172 <nrfx_gpiote_irq_handler+0x15e>
        *p_masks = gpio_regs[i]->LATCH;
    e050:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    e054:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
    e058:	9204      	str	r2, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
    e05a:	f8c3 2520 	str.w	r2, [r3, #1312]	; 0x520
        *p_masks = gpio_regs[i]->LATCH;
    e05e:	f8d3 2820 	ldr.w	r2, [r3, #2080]	; 0x820
    e062:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
    e064:	f8c3 2820 	str.w	r2, [r3, #2080]	; 0x820
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
    e068:	2700      	movs	r7, #0
            while (latch[i])
    e06a:	f10d 0910 	add.w	r9, sp, #16
    e06e:	017b      	lsls	r3, r7, #5
    e070:	9300      	str	r3, [sp, #0]
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
    e072:	f04f 0a01 	mov.w	sl, #1
    e076:	e049      	b.n	e10c <nrfx_gpiote_irq_handler+0xf8>
                pin += 32 * i;
    e078:	9b00      	ldr	r3, [sp, #0]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    e07a:	4a4f      	ldr	r2, [pc, #316]	; (e1b8 <nrfx_gpiote_irq_handler+0x1a4>)
                uint32_t pin = NRF_CTZ(latch[i]);
    e07c:	fa94 f4a4 	rbit	r4, r4
    e080:	fab4 f484 	clz	r4, r4
                pin += 32 * i;
    e084:	441c      	add	r4, r3
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    e086:	f104 0308 	add.w	r3, r4, #8
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    e08a:	08e0      	lsrs	r0, r4, #3
    e08c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
    e090:	9403      	str	r4, [sp, #12]
    bit = BITMASK_RELBIT_GET(bit);
    e092:	f004 0207 	and.w	r2, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
    e096:	fa0a fc02 	lsl.w	ip, sl, r2
    e09a:	f819 2000 	ldrb.w	r2, [r9, r0]
    e09e:	ea22 020c 	bic.w	r2, r2, ip
    e0a2:	f809 2000 	strb.w	r2, [r9, r0]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    e0a6:	a803      	add	r0, sp, #12
    e0a8:	f3c3 0582 	ubfx	r5, r3, #2, #3
    e0ac:	0899      	lsrs	r1, r3, #2
    e0ae:	f7ff fd27 	bl	db00 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    e0b2:	9a03      	ldr	r2, [sp, #12]
    e0b4:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    if (is_level(trigger))
    e0b8:	074b      	lsls	r3, r1, #29
    e0ba:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    e0be:	46ab      	mov	fp, r5
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
    e0c0:	f3c2 4201 	ubfx	r2, r2, #16, #2
    if (is_level(trigger))
    e0c4:	d529      	bpl.n	e11a <nrfx_gpiote_irq_handler+0x106>
        call_handler(pin, trigger);
    e0c6:	4620      	mov	r0, r4
    e0c8:	4659      	mov	r1, fp
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    e0ca:	b2d5      	uxtb	r5, r2
    e0cc:	f7ff fd30 	bl	db30 <call_handler>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    e0d0:	a803      	add	r0, sp, #12
    e0d2:	9403      	str	r4, [sp, #12]
    e0d4:	f7ff fd14 	bl	db00 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    e0d8:	9b03      	ldr	r3, [sp, #12]
    e0da:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    e0de:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
        if (nrf_gpio_pin_sense_get(pin) == sense)
    e0e2:	f3c3 4301 	ubfx	r3, r3, #16, #2
    e0e6:	429d      	cmp	r5, r3
    e0e8:	d107      	bne.n	e0fa <nrfx_gpiote_irq_handler+0xe6>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
    e0ea:	2100      	movs	r1, #0
    e0ec:	4620      	mov	r0, r4
    e0ee:	f004 f944 	bl	1237a <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
    e0f2:	4629      	mov	r1, r5
    e0f4:	4620      	mov	r0, r4
    e0f6:	f004 f940 	bl	1237a <nrf_gpio_cfg_sense_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    e0fa:	a803      	add	r0, sp, #12
    e0fc:	9403      	str	r4, [sp, #12]
    e0fe:	f7ff fcff 	bl	db00 <nrf_gpio_pin_port_decode>
    reg->LATCH = (1 << pin_number);
    e102:	9b03      	ldr	r3, [sp, #12]
    e104:	fa0a f303 	lsl.w	r3, sl, r3
    e108:	f8c0 3520 	str.w	r3, [r0, #1312]	; 0x520
            while (latch[i])
    e10c:	f859 4027 	ldr.w	r4, [r9, r7, lsl #2]
    e110:	2c00      	cmp	r4, #0
    e112:	d1b1      	bne.n	e078 <nrfx_gpiote_irq_handler+0x64>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
    e114:	b9cf      	cbnz	r7, e14a <nrfx_gpiote_irq_handler+0x136>
    e116:	2701      	movs	r7, #1
    e118:	e7a9      	b.n	e06e <nrfx_gpiote_irq_handler+0x5a>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    e11a:	2a02      	cmp	r2, #2
        nrf_gpio_cfg_sense_set(pin, next_sense);
    e11c:	bf0c      	ite	eq
    e11e:	2103      	moveq	r1, #3
    e120:	2102      	movne	r1, #2
    e122:	4620      	mov	r0, r4
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    e124:	9201      	str	r2, [sp, #4]
        nrf_gpio_cfg_sense_set(pin, next_sense);
    e126:	f004 f928 	bl	1237a <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
    e12a:	2d03      	cmp	r5, #3
    e12c:	d004      	beq.n	e138 <nrfx_gpiote_irq_handler+0x124>
    e12e:	9a01      	ldr	r2, [sp, #4]
    e130:	2a02      	cmp	r2, #2
    e132:	d106      	bne.n	e142 <nrfx_gpiote_irq_handler+0x12e>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
    e134:	2d01      	cmp	r5, #1
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
    e136:	d1e0      	bne.n	e0fa <nrfx_gpiote_irq_handler+0xe6>
            call_handler(pin, trigger);
    e138:	4659      	mov	r1, fp
    e13a:	4620      	mov	r0, r4
    e13c:	f7ff fcf8 	bl	db30 <call_handler>
    e140:	e7db      	b.n	e0fa <nrfx_gpiote_irq_handler+0xe6>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
    e142:	2a03      	cmp	r2, #3
    e144:	d1d9      	bne.n	e0fa <nrfx_gpiote_irq_handler+0xe6>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
    e146:	2d02      	cmp	r5, #2
    e148:	e7f5      	b.n	e136 <nrfx_gpiote_irq_handler+0x122>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    e14a:	f8c8 417c 	str.w	r4, [r8, #380]	; 0x17c
    e14e:	f8d8 317c 	ldr.w	r3, [r8, #380]	; 0x17c
        *p_masks = gpio_regs[i]->LATCH;
    e152:	491a      	ldr	r1, [pc, #104]	; (e1bc <nrfx_gpiote_irq_handler+0x1a8>)
    e154:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    e158:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
    e15c:	9204      	str	r2, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
    e15e:	f8c3 2520 	str.w	r2, [r3, #1312]	; 0x520
        *p_masks = gpio_regs[i]->LATCH;
    e162:	f8d1 3520 	ldr.w	r3, [r1, #1312]	; 0x520
    e166:	9305      	str	r3, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
    e168:	f8c1 3520 	str.w	r3, [r1, #1312]	; 0x520
        if (latch[port_idx])
    e16c:	4313      	orrs	r3, r2
    e16e:	f47f af7b 	bne.w	e068 <nrfx_gpiote_irq_handler+0x54>
        mask &= ~NRFX_BIT(ch);
    e172:	2401      	movs	r4, #1
    while (mask)
    e174:	b916      	cbnz	r6, e17c <nrfx_gpiote_irq_handler+0x168>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
    e176:	b007      	add	sp, #28
    e178:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        uint32_t ch = NRF_CTZ(mask);
    e17c:	fa96 f3a6 	rbit	r3, r6
    e180:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
    e184:	fa04 f203 	lsl.w	r2, r4, r3
    e188:	009b      	lsls	r3, r3, #2
    e18a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    e18e:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    e192:	ea26 0602 	bic.w	r6, r6, r2
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    e196:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
    e19a:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    e19e:	f3c0 2005 	ubfx	r0, r0, #8, #6
    e1a2:	f3c1 4101 	ubfx	r1, r1, #16, #2
    e1a6:	f7ff fcc3 	bl	db30 <call_handler>
    e1aa:	e7e3      	b.n	e174 <nrfx_gpiote_irq_handler+0x160>
    e1ac:	40006100 	.word	0x40006100
    e1b0:	40006000 	.word	0x40006000
    e1b4:	40006120 	.word	0x40006120
    e1b8:	200004e8 	.word	0x200004e8
    e1bc:	50000300 	.word	0x50000300

0000e1c0 <nrfx_ppi_channel_alloc>:
    nrfx_flag32_init(&m_groups_allocated, NRFX_PPI_ALL_APP_GROUPS_MASK);
}


nrfx_err_t nrfx_ppi_channel_alloc(nrf_ppi_channel_t * p_channel)
{
    e1c0:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_channels_allocated, (uint8_t *)p_channel);
    e1c2:	4801      	ldr	r0, [pc, #4]	; (e1c8 <nrfx_ppi_channel_alloc+0x8>)
    e1c4:	f7ff bbd6 	b.w	d974 <nrfx_flag32_alloc>
    e1c8:	20000564 	.word	0x20000564

0000e1cc <_DoInit>:
                      _DoInit();                                                                     \
                    }                                                                                \
                  } while (0);                                                                       \
                }

static void _DoInit(void) {
    e1cc:	b510      	push	{r4, lr}
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    e1ce:	4c14      	ldr	r4, [pc, #80]	; (e220 <_DoInit+0x54>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    e1d0:	4a14      	ldr	r2, [pc, #80]	; (e224 <_DoInit+0x58>)
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
    e1d2:	4915      	ldr	r1, [pc, #84]	; (e228 <_DoInit+0x5c>)
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    e1d4:	2303      	movs	r3, #3
    e1d6:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    e1d8:	6163      	str	r3, [r4, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
    e1da:	4b14      	ldr	r3, [pc, #80]	; (e22c <_DoInit+0x60>)
  p->aUp[0].sName         = "Terminal";
    e1dc:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
    e1de:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
    e1e0:	f44f 6380 	mov.w	r3, #1024	; 0x400
    e1e4:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
    e1e6:	2300      	movs	r3, #0
    e1e8:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    e1ea:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    e1ec:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].sName         = "Terminal";
    e1ee:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    e1f0:	4a0f      	ldr	r2, [pc, #60]	; (e230 <_DoInit+0x64>)
    e1f2:	6662      	str	r2, [r4, #100]	; 0x64
  STRCPY((char*)&p->acID[7], "RTT");
    e1f4:	1de0      	adds	r0, r4, #7
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
    e1f6:	2210      	movs	r2, #16
    e1f8:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
    e1fa:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    e1fc:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    e1fe:	6763      	str	r3, [r4, #116]	; 0x74
  STRCPY((char*)&p->acID[7], "RTT");
    e200:	f001 fc82 	bl	fb08 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
    e204:	f3bf 8f5f 	dmb	sy
  STRCPY((char*)&p->acID[0], "SEGGER");
    e208:	490a      	ldr	r1, [pc, #40]	; (e234 <_DoInit+0x68>)
    e20a:	4620      	mov	r0, r4
    e20c:	f001 fc7c 	bl	fb08 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
    e210:	f3bf 8f5f 	dmb	sy
  p->acID[6] = ' ';
    e214:	2320      	movs	r3, #32
    e216:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
    e218:	f3bf 8f5f 	dmb	sy
}
    e21c:	bd10      	pop	{r4, pc}
    e21e:	bf00      	nop
    e220:	200025f8 	.word	0x200025f8
    e224:	000140ba 	.word	0x000140ba
    e228:	000140c3 	.word	0x000140c3
    e22c:	20002a8c 	.word	0x20002a8c
    e230:	20002a7c 	.word	0x20002a7c
    e234:	000140c7 	.word	0x000140c7

0000e238 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    e238:	4b0e      	ldr	r3, [pc, #56]	; (e274 <z_sys_init_run_level+0x3c>)
{
    e23a:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    e23c:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    e240:	3001      	adds	r0, #1
    e242:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
    e246:	42a6      	cmp	r6, r4
    e248:	d800      	bhi.n	e24c <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
    e24a:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
    e24c:	e9d4 3500 	ldrd	r3, r5, [r4]
    e250:	4628      	mov	r0, r5
    e252:	4798      	blx	r3
		if (dev != NULL) {
    e254:	b165      	cbz	r5, e270 <z_sys_init_run_level+0x38>
				dev->state->init_res = rc;
    e256:	68eb      	ldr	r3, [r5, #12]
			if (rc != 0) {
    e258:	b130      	cbz	r0, e268 <z_sys_init_run_level+0x30>
				if (rc < 0) {
    e25a:	2800      	cmp	r0, #0
    e25c:	bfb8      	it	lt
    e25e:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
    e260:	28ff      	cmp	r0, #255	; 0xff
    e262:	bfa8      	it	ge
    e264:	20ff      	movge	r0, #255	; 0xff
    e266:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
    e268:	785a      	ldrb	r2, [r3, #1]
    e26a:	f042 0201 	orr.w	r2, r2, #1
    e26e:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    e270:	3408      	adds	r4, #8
    e272:	e7e8      	b.n	e246 <z_sys_init_run_level+0xe>
    e274:	000131b8 	.word	0x000131b8

0000e278 <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
    e278:	b570      	push	{r4, r5, r6, lr}
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
    e27a:	4605      	mov	r5, r0
    e27c:	b910      	cbnz	r0, e284 <z_impl_device_get_binding+0xc>
		return NULL;
    e27e:	2400      	movs	r4, #0
			return dev;
		}
	}

	return NULL;
}
    e280:	4620      	mov	r0, r4
    e282:	bd70      	pop	{r4, r5, r6, pc}
	if ((name == NULL) || (name[0] == '\0')) {
    e284:	7803      	ldrb	r3, [r0, #0]
    e286:	2b00      	cmp	r3, #0
    e288:	d0f9      	beq.n	e27e <z_impl_device_get_binding+0x6>
	for (dev = __device_start; dev != __device_end; dev++) {
    e28a:	4c0e      	ldr	r4, [pc, #56]	; (e2c4 <z_impl_device_get_binding+0x4c>)
    e28c:	4e0e      	ldr	r6, [pc, #56]	; (e2c8 <z_impl_device_get_binding+0x50>)
    e28e:	42b4      	cmp	r4, r6
    e290:	d108      	bne.n	e2a4 <z_impl_device_get_binding+0x2c>
	for (dev = __device_start; dev != __device_end; dev++) {
    e292:	4c0c      	ldr	r4, [pc, #48]	; (e2c4 <z_impl_device_get_binding+0x4c>)
    e294:	42b4      	cmp	r4, r6
    e296:	d0f2      	beq.n	e27e <z_impl_device_get_binding+0x6>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    e298:	4620      	mov	r0, r4
    e29a:	f004 f885 	bl	123a8 <z_device_ready>
    e29e:	b950      	cbnz	r0, e2b6 <z_impl_device_get_binding+0x3e>
	for (dev = __device_start; dev != __device_end; dev++) {
    e2a0:	3418      	adds	r4, #24
    e2a2:	e7f7      	b.n	e294 <z_impl_device_get_binding+0x1c>
		if (z_device_ready(dev) && (dev->name == name)) {
    e2a4:	4620      	mov	r0, r4
    e2a6:	f004 f87f 	bl	123a8 <z_device_ready>
    e2aa:	b110      	cbz	r0, e2b2 <z_impl_device_get_binding+0x3a>
    e2ac:	6823      	ldr	r3, [r4, #0]
    e2ae:	42ab      	cmp	r3, r5
    e2b0:	d0e6      	beq.n	e280 <z_impl_device_get_binding+0x8>
	for (dev = __device_start; dev != __device_end; dev++) {
    e2b2:	3418      	adds	r4, #24
    e2b4:	e7eb      	b.n	e28e <z_impl_device_get_binding+0x16>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    e2b6:	6821      	ldr	r1, [r4, #0]
    e2b8:	4628      	mov	r0, r5
    e2ba:	f001 fc3f 	bl	fb3c <strcmp>
    e2be:	2800      	cmp	r0, #0
    e2c0:	d1ee      	bne.n	e2a0 <z_impl_device_get_binding+0x28>
    e2c2:	e7dd      	b.n	e280 <z_impl_device_get_binding+0x8>
    e2c4:	00012dbc 	.word	0x00012dbc
    e2c8:	00012e4c 	.word	0x00012e4c

0000e2cc <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    e2cc:	b530      	push	{r4, r5, lr}
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
    e2ce:	2300      	movs	r3, #0
{
    e2d0:	b087      	sub	sp, #28
	z_setup_new_thread(thread, stack,
    e2d2:	2201      	movs	r2, #1
    e2d4:	e9cd 2304 	strd	r2, r3, [sp, #16]
    e2d8:	220f      	movs	r2, #15
    e2da:	e9cd 3202 	strd	r3, r2, [sp, #8]
    e2de:	9301      	str	r3, [sp, #4]
	struct k_thread *thread = &z_idle_threads[i];
    e2e0:	4c0c      	ldr	r4, [pc, #48]	; (e314 <init_idle_thread+0x48>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    e2e2:	4b0d      	ldr	r3, [pc, #52]	; (e318 <init_idle_thread+0x4c>)
	z_setup_new_thread(thread, stack,
    e2e4:	490d      	ldr	r1, [pc, #52]	; (e31c <init_idle_thread+0x50>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    e2e6:	2218      	movs	r2, #24
	struct k_thread *thread = &z_idle_threads[i];
    e2e8:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    e2ec:	fb02 3300 	mla	r3, r2, r0, r3
	z_setup_new_thread(thread, stack,
    e2f0:	f44f 75b0 	mov.w	r5, #352	; 0x160
    e2f4:	9300      	str	r3, [sp, #0]
    e2f6:	fb05 1100 	mla	r1, r5, r0, r1
    e2fa:	4b09      	ldr	r3, [pc, #36]	; (e320 <init_idle_thread+0x54>)
    e2fc:	f44f 72a0 	mov.w	r2, #320	; 0x140
    e300:	4620      	mov	r0, r4
    e302:	f000 f8b7 	bl	e474 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    e306:	7b63      	ldrb	r3, [r4, #13]
    e308:	f023 0304 	bic.w	r3, r3, #4
    e30c:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    e30e:	b007      	add	sp, #28
    e310:	bd30      	pop	{r4, r5, pc}
    e312:	bf00      	nop
    e314:	20000860 	.word	0x20000860
    e318:	200026a0 	.word	0x200026a0
    e31c:	20003b60 	.word	0x20003b60
    e320:	0000e5e9 	.word	0x0000e5e9

0000e324 <bg_thread_main>:
{
    e324:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
    e326:	4b0a      	ldr	r3, [pc, #40]	; (e350 <bg_thread_main+0x2c>)
    e328:	2201      	movs	r2, #1
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    e32a:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
    e32c:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    e32e:	f7ff ff83 	bl	e238 <z_sys_init_run_level>
	boot_banner();
    e332:	f001 f85f 	bl	f3f4 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    e336:	2003      	movs	r0, #3
    e338:	f7ff ff7e 	bl	e238 <z_sys_init_run_level>
	z_init_static_threads();
    e33c:	f000 f8f8 	bl	e530 <z_init_static_threads>
	main();
    e340:	f7f3 f9e6 	bl	1710 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    e344:	4a03      	ldr	r2, [pc, #12]	; (e354 <bg_thread_main+0x30>)
    e346:	7b13      	ldrb	r3, [r2, #12]
    e348:	f023 0301 	bic.w	r3, r3, #1
    e34c:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    e34e:	bd08      	pop	{r3, pc}
    e350:	20002e8c 	.word	0x20002e8c
    e354:	200008e0 	.word	0x200008e0

0000e358 <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    e358:	4802      	ldr	r0, [pc, #8]	; (e364 <z_bss_zero+0xc>)
    e35a:	4a03      	ldr	r2, [pc, #12]	; (e368 <z_bss_zero+0x10>)
    e35c:	2100      	movs	r1, #0
    e35e:	1a12      	subs	r2, r2, r0
    e360:	f001 bc2c 	b.w	fbbc <memset>
    e364:	20000658 	.word	0x20000658
    e368:	20002e90 	.word	0x20002e90

0000e36c <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    e36c:	b580      	push	{r7, lr}
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
    e36e:	f8df 80c0 	ldr.w	r8, [pc, #192]	; e430 <z_cstart+0xc4>
    e372:	b0a6      	sub	sp, #152	; 0x98
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    e374:	f388 8808 	msr	MSP, r8
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    e378:	4d2e      	ldr	r5, [pc, #184]	; (e434 <z_cstart+0xc8>)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    e37a:	4e2f      	ldr	r6, [pc, #188]	; (e438 <z_cstart+0xcc>)
    e37c:	696b      	ldr	r3, [r5, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    e37e:	f8df 90bc 	ldr.w	r9, [pc, #188]	; e43c <z_cstart+0xd0>
    e382:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    e386:	2400      	movs	r4, #0
    e388:	616b      	str	r3, [r5, #20]
    e38a:	23e0      	movs	r3, #224	; 0xe0
    e38c:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
    e390:	77ec      	strb	r4, [r5, #31]
    e392:	762c      	strb	r4, [r5, #24]
    e394:	766c      	strb	r4, [r5, #25]
    e396:	76ac      	strb	r4, [r5, #26]
    e398:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    e39c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    e39e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    e3a2:	626b      	str	r3, [r5, #36]	; 0x24
    e3a4:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    e3a8:	f7f4 fac0 	bl	292c <z_arm_fault_init>
	z_arm_cpu_idle_init();
    e3ac:	f7f4 f86e 	bl	248c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    e3b0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    e3b4:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    e3b6:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
    e3b8:	f7f4 fbca 	bl	2b50 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    e3bc:	f7f4 fb32 	bl	2a24 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
    e3c0:	f240 1301 	movw	r3, #257	; 0x101
    e3c4:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
    e3c8:	ab06      	add	r3, sp, #24
    e3ca:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
    e3cc:	e9cd 4420 	strd	r4, r4, [sp, #128]	; 0x80
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    e3d0:	f003 ffe9 	bl	123a6 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    e3d4:	4620      	mov	r0, r4
    e3d6:	f7ff ff2f 	bl	e238 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    e3da:	2001      	movs	r0, #1
	_kernel.ready_q.cache = &z_main_thread;
    e3dc:	4d18      	ldr	r5, [pc, #96]	; (e440 <z_cstart+0xd4>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    e3de:	f7ff ff2b 	bl	e238 <z_sys_init_run_level>
	z_sched_init();
    e3e2:	f000 fce7 	bl	edb4 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    e3e6:	4b17      	ldr	r3, [pc, #92]	; (e444 <z_cstart+0xd8>)
    e3e8:	9305      	str	r3, [sp, #20]
    e3ea:	2301      	movs	r3, #1
    e3ec:	4916      	ldr	r1, [pc, #88]	; (e448 <z_cstart+0xdc>)
    e3ee:	9400      	str	r4, [sp, #0]
    e3f0:	e9cd 4303 	strd	r4, r3, [sp, #12]
    e3f4:	f44f 6280 	mov.w	r2, #1024	; 0x400
    e3f8:	464b      	mov	r3, r9
    e3fa:	e9cd 4401 	strd	r4, r4, [sp, #4]
    e3fe:	4628      	mov	r0, r5
	_kernel.ready_q.cache = &z_main_thread;
    e400:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    e402:	f000 f837 	bl	e474 <z_setup_new_thread>
    e406:	7b6a      	ldrb	r2, [r5, #13]
    e408:	4607      	mov	r7, r0
    e40a:	f022 0204 	bic.w	r2, r2, #4
	z_ready_thread(&z_main_thread);
    e40e:	4628      	mov	r0, r5
    e410:	736a      	strb	r2, [r5, #13]
    e412:	f004 fa3b 	bl	1288c <z_ready_thread>
		init_idle_thread(i);
    e416:	4620      	mov	r0, r4
    e418:	f7ff ff58 	bl	e2cc <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    e41c:	4b0b      	ldr	r3, [pc, #44]	; (e44c <z_cstart+0xe0>)
    e41e:	60f3      	str	r3, [r6, #12]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    e420:	464a      	mov	r2, r9
    e422:	4639      	mov	r1, r7
    e424:	4628      	mov	r0, r5
		_kernel.cpus[i].id = i;
    e426:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
    e428:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    e42c:	f7f4 f952 	bl	26d4 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    e430:	200044e0 	.word	0x200044e0
    e434:	e000ed00 	.word	0xe000ed00
    e438:	200026a0 	.word	0x200026a0
    e43c:	0000e325 	.word	0x0000e325
    e440:	200008e0 	.word	0x200008e0
    e444:	000140ce 	.word	0x000140ce
    e448:	20003740 	.word	0x20003740
    e44c:	20000860 	.word	0x20000860

0000e450 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
    e450:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
    e452:	4c06      	ldr	r4, [pc, #24]	; (e46c <statics_init+0x1c>)
    e454:	4d06      	ldr	r5, [pc, #24]	; (e470 <statics_init+0x20>)
    e456:	42ac      	cmp	r4, r5
    e458:	d301      	bcc.n	e45e <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
    e45a:	2000      	movs	r0, #0
    e45c:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    e45e:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
    e462:	4620      	mov	r0, r4
    e464:	f003 ffd1 	bl	1240a <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
    e468:	3414      	adds	r4, #20
    e46a:	e7f4      	b.n	e456 <statics_init+0x6>
    e46c:	200005a0 	.word	0x200005a0
    e470:	200005a0 	.word	0x200005a0

0000e474 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    e474:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    e478:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    e47a:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
    e47c:	2604      	movs	r6, #4
    e47e:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
    e480:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    e482:	7386      	strb	r6, [r0, #14]
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    e484:	f100 0558 	add.w	r5, r0, #88	; 0x58
{
    e488:	460f      	mov	r7, r1
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    e48a:	1dd6      	adds	r6, r2, #7
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
    e48c:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    e490:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	thread_base->pended_on = NULL;
    e492:	2500      	movs	r5, #0
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    e494:	f026 0607 	bic.w	r6, r6, #7

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
    e498:	3720      	adds	r7, #32
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
    e49a:	e9c0 5506 	strd	r5, r5, [r0, #24]
	new_thread->stack_info.size = stack_buf_size;
    e49e:	e9c0 761a 	strd	r7, r6, [r0, #104]	; 0x68
	thread_base->pended_on = NULL;
    e4a2:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
    e4a4:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
    e4a6:	6705      	str	r5, [r0, #112]	; 0x70
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    e4a8:	f106 0820 	add.w	r8, r6, #32
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    e4ac:	9202      	str	r2, [sp, #8]
    e4ae:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    e4b0:	9201      	str	r2, [sp, #4]
	stack_ptr = (char *)stack + stack_obj_size;
    e4b2:	4488      	add	r8, r1
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    e4b4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    e4b6:	9200      	str	r2, [sp, #0]
    e4b8:	4642      	mov	r2, r8
{
    e4ba:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    e4bc:	f7f4 f8d8 	bl	2670 <arch_new_thread>
	if (!_current) {
    e4c0:	4b04      	ldr	r3, [pc, #16]	; (e4d4 <z_setup_new_thread+0x60>)
	new_thread->init_data = NULL;
    e4c2:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
    e4c4:	689b      	ldr	r3, [r3, #8]
    e4c6:	b103      	cbz	r3, e4ca <z_setup_new_thread+0x56>
	new_thread->resource_pool = _current->resource_pool;
    e4c8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
	return stack_ptr;
    e4ca:	6763      	str	r3, [r4, #116]	; 0x74
}
    e4cc:	4640      	mov	r0, r8
    e4ce:	b004      	add	sp, #16
    e4d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e4d4:	200026a0 	.word	0x200026a0

0000e4d8 <z_impl_k_thread_create>:
{
    e4d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    e4da:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    e4dc:	2700      	movs	r7, #0
    e4de:	9705      	str	r7, [sp, #20]
    e4e0:	9f10      	ldr	r7, [sp, #64]	; 0x40
    e4e2:	9704      	str	r7, [sp, #16]
    e4e4:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    e4e6:	9703      	str	r7, [sp, #12]
    e4e8:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    e4ea:	9702      	str	r7, [sp, #8]
{
    e4ec:	e9dd 6512 	ldrd	r6, r5, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    e4f0:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    e4f2:	9701      	str	r7, [sp, #4]
    e4f4:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    e4f6:	9700      	str	r7, [sp, #0]
{
    e4f8:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    e4fa:	f7ff ffbb 	bl	e474 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    e4fe:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
    e502:	bf08      	it	eq
    e504:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
    e508:	d005      	beq.n	e516 <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    e50a:	ea55 0306 	orrs.w	r3, r5, r6
    e50e:	d105      	bne.n	e51c <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
    e510:	4620      	mov	r0, r4
    e512:	f000 fb91 	bl	ec38 <z_sched_start>
}
    e516:	4620      	mov	r0, r4
    e518:	b007      	add	sp, #28
    e51a:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    e51c:	4903      	ldr	r1, [pc, #12]	; (e52c <z_impl_k_thread_create+0x54>)
    e51e:	4632      	mov	r2, r6
    e520:	462b      	mov	r3, r5
    e522:	f104 0018 	add.w	r0, r4, #24
    e526:	f000 fdd3 	bl	f0d0 <z_add_timeout>
    e52a:	e7f4      	b.n	e516 <z_impl_k_thread_create+0x3e>
    e52c:	000128ad 	.word	0x000128ad

0000e530 <z_init_static_threads>:
{
    e530:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e534:	4c29      	ldr	r4, [pc, #164]	; (e5dc <z_init_static_threads+0xac>)
	_FOREACH_STATIC_THREAD(thread_data) {
    e536:	4d2a      	ldr	r5, [pc, #168]	; (e5e0 <z_init_static_threads+0xb0>)
{
    e538:	b087      	sub	sp, #28
    e53a:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
    e53c:	42ae      	cmp	r6, r5
    e53e:	f104 0430 	add.w	r4, r4, #48	; 0x30
    e542:	d30f      	bcc.n	e564 <z_init_static_threads+0x34>
	k_sched_lock();
    e544:	f000 fa94 	bl	ea70 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    e548:	4c24      	ldr	r4, [pc, #144]	; (e5dc <z_init_static_threads+0xac>)
    e54a:	f8df 9098 	ldr.w	r9, [pc, #152]	; e5e4 <z_init_static_threads+0xb4>
    e54e:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    e552:	f240 37e7 	movw	r7, #999	; 0x3e7
    e556:	42ac      	cmp	r4, r5
    e558:	d320      	bcc.n	e59c <z_init_static_threads+0x6c>
}
    e55a:	b007      	add	sp, #28
    e55c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
    e560:	f000 bc0c 	b.w	ed7c <k_sched_unlock>
		z_setup_new_thread(
    e564:	f854 3c04 	ldr.w	r3, [r4, #-4]
    e568:	9305      	str	r3, [sp, #20]
    e56a:	f854 3c10 	ldr.w	r3, [r4, #-16]
    e56e:	9304      	str	r3, [sp, #16]
    e570:	f854 3c14 	ldr.w	r3, [r4, #-20]
    e574:	9303      	str	r3, [sp, #12]
    e576:	f854 3c18 	ldr.w	r3, [r4, #-24]
    e57a:	9302      	str	r3, [sp, #8]
    e57c:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    e580:	9301      	str	r3, [sp, #4]
    e582:	f854 3c20 	ldr.w	r3, [r4, #-32]
    e586:	9300      	str	r3, [sp, #0]
    e588:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
    e58c:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
    e590:	f7ff ff70 	bl	e474 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    e594:	f854 3c30 	ldr.w	r3, [r4, #-48]
    e598:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
    e59a:	e7ce      	b.n	e53a <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    e59c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    e59e:	1c5a      	adds	r2, r3, #1
    e5a0:	d00d      	beq.n	e5be <z_init_static_threads+0x8e>
					    K_MSEC(thread_data->init_delay));
    e5a2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    e5a6:	2100      	movs	r1, #0
    e5a8:	4638      	mov	r0, r7
    e5aa:	fbc3 0106 	smlal	r0, r1, r3, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    e5ae:	ea51 33c3 	orrs.w	r3, r1, r3, lsl #15
			schedule_new_thread(thread_data->init_thread,
    e5b2:	f8d4 8000 	ldr.w	r8, [r4]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    e5b6:	d104      	bne.n	e5c2 <z_init_static_threads+0x92>
	z_sched_start(thread);
    e5b8:	4640      	mov	r0, r8
    e5ba:	f000 fb3d 	bl	ec38 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    e5be:	3430      	adds	r4, #48	; 0x30
    e5c0:	e7c9      	b.n	e556 <z_init_static_threads+0x26>
    e5c2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    e5c6:	2300      	movs	r3, #0
    e5c8:	f7f1 fd9a 	bl	100 <__aeabi_uldivmod>
    e5cc:	4602      	mov	r2, r0
    e5ce:	460b      	mov	r3, r1
    e5d0:	f108 0018 	add.w	r0, r8, #24
    e5d4:	4649      	mov	r1, r9
    e5d6:	f000 fd7b 	bl	f0d0 <z_add_timeout>
    e5da:	e7f0      	b.n	e5be <z_init_static_threads+0x8e>
    e5dc:	200005a0 	.word	0x200005a0
    e5e0:	200005a0 	.word	0x200005a0
    e5e4:	000128ad 	.word	0x000128ad

0000e5e8 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    e5e8:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
    e5ea:	4c09      	ldr	r4, [pc, #36]	; (e610 <idle+0x28>)
	__asm__ volatile(
    e5ec:	f04f 0220 	mov.w	r2, #32
    e5f0:	f3ef 8311 	mrs	r3, BASEPRI
    e5f4:	f382 8812 	msr	BASEPRI_MAX, r2
    e5f8:	f3bf 8f6f 	isb	sy
    e5fc:	f004 f9fd 	bl	129fa <z_get_next_timeout_expiry>
    e600:	61a0      	str	r0, [r4, #24]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (pm_system_suspend(_kernel.idle) == false) {
    e602:	f7f3 fec3 	bl	238c <pm_system_suspend>
    e606:	2800      	cmp	r0, #0
    e608:	d1f0      	bne.n	e5ec <idle+0x4>
	arch_cpu_idle();
    e60a:	f7f3 ff45 	bl	2498 <arch_cpu_idle>
}
    e60e:	e7ed      	b.n	e5ec <idle+0x4>
    e610:	200026a0 	.word	0x200026a0

0000e614 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
    e614:	b537      	push	{r0, r1, r2, r4, r5, lr}
    e616:	4611      	mov	r1, r2
    e618:	f04f 0220 	mov.w	r2, #32
    e61c:	f3ef 8511 	mrs	r5, BASEPRI
    e620:	f382 8812 	msr	BASEPRI_MAX, r2
    e624:	f3bf 8f6f 	isb	sy
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
	return list->head;
    e628:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
    e62a:	b19c      	cbz	r4, e654 <z_impl_k_queue_get+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    e62c:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    e62e:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    e630:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    e634:	4294      	cmp	r4, r2
	list->head = node;
    e636:	6003      	str	r3, [r0, #0]
	list->tail = node;
    e638:	bf08      	it	eq
    e63a:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
    e63c:	2101      	movs	r1, #1
    e63e:	4620      	mov	r0, r4
    e640:	f003 ffbf 	bl	125c2 <z_queue_node_peek>
    e644:	4604      	mov	r4, r0
	__asm__ volatile(
    e646:	f385 8811 	msr	BASEPRI, r5
    e64a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
    e64e:	4620      	mov	r0, r4
    e650:	b003      	add	sp, #12
    e652:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    e654:	ea51 0203 	orrs.w	r2, r1, r3
    e658:	d0f5      	beq.n	e646 <z_impl_k_queue_get+0x32>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    e65a:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
    e65e:	e9cd 1300 	strd	r1, r3, [sp]
    e662:	4610      	mov	r0, r2
    e664:	4629      	mov	r1, r5
    e666:	f000 fb43 	bl	ecf0 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
    e66a:	2800      	cmp	r0, #0
    e66c:	d1ef      	bne.n	e64e <z_impl_k_queue_get+0x3a>
    e66e:	4b02      	ldr	r3, [pc, #8]	; (e678 <z_impl_k_queue_get+0x64>)
    e670:	689b      	ldr	r3, [r3, #8]
    e672:	695c      	ldr	r4, [r3, #20]
    e674:	e7eb      	b.n	e64e <z_impl_k_queue_get+0x3a>
    e676:	bf00      	nop
    e678:	200026a0 	.word	0x200026a0

0000e67c <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    e67c:	b538      	push	{r3, r4, r5, lr}
    e67e:	4604      	mov	r4, r0
	__asm__ volatile(
    e680:	f04f 0320 	mov.w	r3, #32
    e684:	f3ef 8511 	mrs	r5, BASEPRI
    e688:	f383 8812 	msr	BASEPRI_MAX, r3
    e68c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    e690:	f004 f958 	bl	12944 <z_unpend_first_thread>

	if (thread != NULL) {
    e694:	b148      	cbz	r0, e6aa <z_impl_k_sem_give+0x2e>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    e696:	2200      	movs	r2, #0
    e698:	67c2      	str	r2, [r0, #124]	; 0x7c
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    e69a:	f004 f8f7 	bl	1288c <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    e69e:	4629      	mov	r1, r5
    e6a0:	4808      	ldr	r0, [pc, #32]	; (e6c4 <z_impl_k_sem_give+0x48>)

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    e6a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
    e6a6:	f000 b9d1 	b.w	ea4c <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    e6aa:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    e6ae:	429a      	cmp	r2, r3
    e6b0:	bf18      	it	ne
    e6b2:	3301      	addne	r3, #1
    e6b4:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    e6b6:	2102      	movs	r1, #2
    e6b8:	f104 0010 	add.w	r0, r4, #16
    e6bc:	f004 fb2e 	bl	12d1c <z_handle_obj_poll_events>
}
    e6c0:	e7ed      	b.n	e69e <z_impl_k_sem_give+0x22>
    e6c2:	bf00      	nop
    e6c4:	20002e8d 	.word	0x20002e8d

0000e6c8 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    e6c8:	b513      	push	{r0, r1, r4, lr}
    e6ca:	f04f 0420 	mov.w	r4, #32
    e6ce:	f3ef 8111 	mrs	r1, BASEPRI
    e6d2:	f384 8812 	msr	BASEPRI_MAX, r4
    e6d6:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    e6da:	6884      	ldr	r4, [r0, #8]
    e6dc:	b144      	cbz	r4, e6f0 <z_impl_k_sem_take+0x28>
		sem->count--;
    e6de:	3c01      	subs	r4, #1
    e6e0:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
    e6e2:	f381 8811 	msr	BASEPRI, r1
    e6e6:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
    e6ea:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    e6ec:	b002      	add	sp, #8
    e6ee:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    e6f0:	ea52 0403 	orrs.w	r4, r2, r3
    e6f4:	d106      	bne.n	e704 <z_impl_k_sem_take+0x3c>
    e6f6:	f381 8811 	msr	BASEPRI, r1
    e6fa:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
    e6fe:	f06f 000f 	mvn.w	r0, #15
    e702:	e7f3      	b.n	e6ec <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    e704:	e9cd 2300 	strd	r2, r3, [sp]
    e708:	4602      	mov	r2, r0
    e70a:	4802      	ldr	r0, [pc, #8]	; (e714 <z_impl_k_sem_take+0x4c>)
    e70c:	f000 faf0 	bl	ecf0 <z_pend_curr>
	return ret;
    e710:	e7ec      	b.n	e6ec <z_impl_k_sem_take+0x24>
    e712:	bf00      	nop
    e714:	20002e8d 	.word	0x20002e8d

0000e718 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
    e718:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return list->head;
    e71c:	4e47      	ldr	r6, [pc, #284]	; (e83c <work_queue_main+0x124>)
    e71e:	b085      	sub	sp, #20
    e720:	4604      	mov	r4, r0
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
    e722:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    e726:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	__asm__ volatile(
    e72a:	f04f 0320 	mov.w	r3, #32
    e72e:	f3ef 8711 	mrs	r7, BASEPRI
    e732:	f383 8812 	msr	BASEPRI_MAX, r3
    e736:	f3bf 8f6f 	isb	sy
    e73a:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    e73e:	b98d      	cbnz	r5, e764 <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
    e740:	2102      	movs	r1, #2
    e742:	f104 0098 	add.w	r0, r4, #152	; 0x98
    e746:	f003 ffa9 	bl	1269c <flag_test_and_clear>
    e74a:	2800      	cmp	r0, #0
    e74c:	d135      	bne.n	e7ba <work_queue_main+0xa2>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
    e74e:	2300      	movs	r3, #0
    e750:	e9cd 8900 	strd	r8, r9, [sp]
    e754:	9302      	str	r3, [sp, #8]
    e756:	f104 0288 	add.w	r2, r4, #136	; 0x88
    e75a:	4639      	mov	r1, r7
    e75c:	4838      	ldr	r0, [pc, #224]	; (e840 <work_queue_main+0x128>)
    e75e:	f000 fc3f 	bl	efe0 <z_sched_wait>
			continue;
    e762:	e7e2      	b.n	e72a <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    e764:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	return node->next;
    e768:	682b      	ldr	r3, [r5, #0]
	list->head = node;
    e76a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    e76e:	4295      	cmp	r5, r2
    e770:	d101      	bne.n	e776 <work_queue_main+0x5e>
	list->tail = node;
    e772:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	*flagp |= BIT(bit);
    e776:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    e77a:	f043 0302 	orr.w	r3, r3, #2
    e77e:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*flagp &= ~BIT(bit);
    e782:	68eb      	ldr	r3, [r5, #12]
    e784:	f023 0304 	bic.w	r3, r3, #4
    e788:	f043 0301 	orr.w	r3, r3, #1
    e78c:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
    e78e:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
    e790:	f387 8811 	msr	BASEPRI, r7
    e794:	f3bf 8f6f 	isb	sy
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
		handler(work);
    e798:	4628      	mov	r0, r5
    e79a:	4798      	blx	r3
	__asm__ volatile(
    e79c:	f04f 0320 	mov.w	r3, #32
    e7a0:	f3ef 8b11 	mrs	fp, BASEPRI
    e7a4:	f383 8812 	msr	BASEPRI_MAX, r3
    e7a8:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
    e7ac:	68eb      	ldr	r3, [r5, #12]
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    e7ae:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
    e7b0:	f023 0201 	bic.w	r2, r3, #1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    e7b4:	d40b      	bmi.n	e7ce <work_queue_main+0xb6>
	*flagp &= ~BIT(bit);
    e7b6:	60ea      	str	r2, [r5, #12]
    e7b8:	e00e      	b.n	e7d8 <work_queue_main+0xc0>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
    e7ba:	f104 0590 	add.w	r5, r4, #144	; 0x90
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
    e7be:	2200      	movs	r2, #0
    e7c0:	2101      	movs	r1, #1
    e7c2:	4628      	mov	r0, r5
    e7c4:	f004 f8e6 	bl	12994 <z_sched_wake>
    e7c8:	2800      	cmp	r0, #0
    e7ca:	d1f8      	bne.n	e7be <work_queue_main+0xa6>
    e7cc:	e7bf      	b.n	e74e <work_queue_main+0x36>
	return list->head;
    e7ce:	6830      	ldr	r0, [r6, #0]
	*flagp &= ~BIT(bit);
    e7d0:	f023 0303 	bic.w	r3, r3, #3
    e7d4:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    e7d6:	b970      	cbnz	r0, e7f6 <work_queue_main+0xde>
	*flagp &= ~BIT(bit);
    e7d8:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    e7dc:	f023 0302 	bic.w	r3, r3, #2
    e7e0:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	__asm__ volatile(
    e7e4:	f38b 8811 	msr	BASEPRI, fp
    e7e8:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
    e7ec:	05d8      	lsls	r0, r3, #23
    e7ee:	d49c      	bmi.n	e72a <work_queue_main+0x12>
	z_impl_k_yield();
    e7f0:	f000 faec 	bl	edcc <z_impl_k_yield>
}
    e7f4:	e799      	b.n	e72a <work_queue_main+0x12>
	return node->next;
    e7f6:	2700      	movs	r7, #0
    e7f8:	f8d0 a000 	ldr.w	sl, [r0]
	parent->next = child;
    e7fc:	463b      	mov	r3, r7
		if (wc->work == work) {
    e7fe:	6842      	ldr	r2, [r0, #4]
    e800:	4295      	cmp	r5, r2
			sys_slist_remove(&pending_cancels, prev, &wc->node);
    e802:	4601      	mov	r1, r0
		if (wc->work == work) {
    e804:	d10c      	bne.n	e820 <work_queue_main+0x108>
	return node->next;
    e806:	6801      	ldr	r1, [r0, #0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
    e808:	b997      	cbnz	r7, e830 <work_queue_main+0x118>
    e80a:	6872      	ldr	r2, [r6, #4]
	list->head = node;
    e80c:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
    e80e:	4282      	cmp	r2, r0
    e810:	d100      	bne.n	e814 <work_queue_main+0xfc>
	list->tail = node;
    e812:	6071      	str	r1, [r6, #4]
	parent->next = child;
    e814:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
    e818:	f7ff ff30 	bl	e67c <z_impl_k_sem_give>
}
    e81c:	4639      	mov	r1, r7
    e81e:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    e820:	f1ba 0f00 	cmp.w	sl, #0
    e824:	d0d8      	beq.n	e7d8 <work_queue_main+0xc0>
	return node->next;
    e826:	4650      	mov	r0, sl
    e828:	460f      	mov	r7, r1
    e82a:	f8da a000 	ldr.w	sl, [sl]
    e82e:	e7e6      	b.n	e7fe <work_queue_main+0xe6>
	return list->tail;
    e830:	6872      	ldr	r2, [r6, #4]
	parent->next = child;
    e832:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
    e834:	4290      	cmp	r0, r2
	list->tail = node;
    e836:	bf08      	it	eq
    e838:	6077      	streq	r7, [r6, #4]
}
    e83a:	e7eb      	b.n	e814 <work_queue_main+0xfc>
    e83c:	200026c8 	.word	0x200026c8
    e840:	20002e8d 	.word	0x20002e8d

0000e844 <submit_to_queue_locked>:
{
    e844:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
    e846:	68c3      	ldr	r3, [r0, #12]
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    e848:	079a      	lsls	r2, r3, #30
{
    e84a:	4604      	mov	r4, r0
    e84c:	460e      	mov	r6, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    e84e:	f3c3 0540 	ubfx	r5, r3, #1, #1
    e852:	d41f      	bmi.n	e894 <submit_to_queue_locked+0x50>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
    e854:	075f      	lsls	r7, r3, #29
    e856:	d41f      	bmi.n	e898 <submit_to_queue_locked+0x54>
		if (*queuep == NULL) {
    e858:	680a      	ldr	r2, [r1, #0]
    e85a:	b90a      	cbnz	r2, e860 <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
    e85c:	6882      	ldr	r2, [r0, #8]
    e85e:	600a      	str	r2, [r1, #0]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
    e860:	07d8      	lsls	r0, r3, #31
			*queuep = work->queue;
    e862:	bf44      	itt	mi
    e864:	68a3      	ldrmi	r3, [r4, #8]
    e866:	6033      	strmi	r3, [r6, #0]
		int rc = queue_submit_locked(*queuep, work);
    e868:	6837      	ldr	r7, [r6, #0]
			ret = 2;
    e86a:	bf4c      	ite	mi
    e86c:	2502      	movmi	r5, #2
		ret = 1;
    e86e:	2501      	movpl	r5, #1
	if (queue == NULL) {
    e870:	b37f      	cbz	r7, e8d2 <submit_to_queue_locked+0x8e>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    e872:	4b1b      	ldr	r3, [pc, #108]	; (e8e0 <submit_to_queue_locked+0x9c>)
    e874:	689b      	ldr	r3, [r3, #8]
    e876:	42bb      	cmp	r3, r7
    e878:	d111      	bne.n	e89e <submit_to_queue_locked+0x5a>
    e87a:	f003 fe2c 	bl	124d6 <k_is_in_isr>
    e87e:	f080 0001 	eor.w	r0, r0, #1
    e882:	b2c0      	uxtb	r0, r0
	return (*flagp & BIT(bit)) != 0U;
    e884:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
    e888:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
    e88a:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
    e88e:	d523      	bpl.n	e8d8 <submit_to_queue_locked+0x94>
	} else if (draining && !chained) {
    e890:	b13a      	cbz	r2, e8a2 <submit_to_queue_locked+0x5e>
    e892:	b940      	cbnz	r0, e8a6 <submit_to_queue_locked+0x62>
		ret = -EBUSY;
    e894:	f06f 050f 	mvn.w	r5, #15
		*queuep = NULL;
    e898:	2300      	movs	r3, #0
    e89a:	6033      	str	r3, [r6, #0]
	return ret;
    e89c:	e013      	b.n	e8c6 <submit_to_queue_locked+0x82>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    e89e:	2000      	movs	r0, #0
    e8a0:	e7f0      	b.n	e884 <submit_to_queue_locked+0x40>
	} else if (plugged && !draining) {
    e8a2:	071b      	lsls	r3, r3, #28
    e8a4:	d4f6      	bmi.n	e894 <submit_to_queue_locked+0x50>
	parent->next = child;
    e8a6:	2300      	movs	r3, #0
    e8a8:	6023      	str	r3, [r4, #0]
	return list->tail;
    e8aa:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
Z_GENLIST_APPEND(slist, snode)
    e8ae:	b963      	cbnz	r3, e8ca <submit_to_queue_locked+0x86>
	list->head = node;
    e8b0:	e9c7 4420 	strd	r4, r4, [r7, #128]	; 0x80
		(void)notify_queue_locked(queue);
    e8b4:	4638      	mov	r0, r7
    e8b6:	f003 ff0a 	bl	126ce <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
    e8ba:	68e3      	ldr	r3, [r4, #12]
    e8bc:	f043 0304 	orr.w	r3, r3, #4
    e8c0:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
    e8c2:	6833      	ldr	r3, [r6, #0]
    e8c4:	60a3      	str	r3, [r4, #8]
}
    e8c6:	4628      	mov	r0, r5
    e8c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
    e8ca:	601c      	str	r4, [r3, #0]
	list->tail = node;
    e8cc:	f8c7 4084 	str.w	r4, [r7, #132]	; 0x84
}
    e8d0:	e7f0      	b.n	e8b4 <submit_to_queue_locked+0x70>
		return -EINVAL;
    e8d2:	f06f 0515 	mvn.w	r5, #21
    e8d6:	e7df      	b.n	e898 <submit_to_queue_locked+0x54>
		ret = -ENODEV;
    e8d8:	f06f 0512 	mvn.w	r5, #18
    e8dc:	e7dc      	b.n	e898 <submit_to_queue_locked+0x54>
    e8de:	bf00      	nop
    e8e0:	200026a0 	.word	0x200026a0

0000e8e4 <k_work_submit>:
{
    e8e4:	4601      	mov	r1, r0
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
    e8e6:	4801      	ldr	r0, [pc, #4]	; (e8ec <k_work_submit+0x8>)
    e8e8:	f003 bf48 	b.w	1277c <k_work_submit_to_queue>
    e8ec:	20000968 	.word	0x20000968

0000e8f0 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
    e8f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    e8f2:	b089      	sub	sp, #36	; 0x24
    e8f4:	4604      	mov	r4, r0
	list->head = NULL;
    e8f6:	2000      	movs	r0, #0
	list->tail = NULL;
    e8f8:	e9c4 0020 	strd	r0, r0, [r4, #128]	; 0x80
    e8fc:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e8fe:	f104 0088 	add.w	r0, r4, #136	; 0x88
	list->tail = (sys_dnode_t *)list;
    e902:	e9c4 0022 	strd	r0, r0, [r4, #136]	; 0x88
    e906:	f104 0090 	add.w	r0, r4, #144	; 0x90
    e90a:	e9c4 0024 	strd	r0, r0, [r4, #144]	; 0x90

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
    e90e:	b31d      	cbz	r5, e958 <k_work_queue_start+0x68>
    e910:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
    e912:	2800      	cmp	r0, #0
    e914:	f240 1001 	movw	r0, #257	; 0x101
    e918:	bf08      	it	eq
    e91a:	2001      	moveq	r0, #1
	*flagp = flags;
    e91c:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    e920:	2000      	movs	r0, #0
    e922:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    e926:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    e92a:	e9cd 3003 	strd	r3, r0, [sp, #12]
    e92e:	e9cd 0001 	strd	r0, r0, [sp, #4]
    e932:	e9cd 6706 	strd	r6, r7, [sp, #24]
    e936:	4b09      	ldr	r3, [pc, #36]	; (e95c <k_work_queue_start+0x6c>)
    e938:	9400      	str	r4, [sp, #0]
    e93a:	4620      	mov	r0, r4
    e93c:	f7ff fdcc 	bl	e4d8 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
    e940:	b125      	cbz	r5, e94c <k_work_queue_start+0x5c>
    e942:	6829      	ldr	r1, [r5, #0]
    e944:	b111      	cbz	r1, e94c <k_work_queue_start+0x5c>
	return z_impl_k_thread_name_set(thread, str);
    e946:	4620      	mov	r0, r4
    e948:	f003 fdcb 	bl	124e2 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
    e94c:	4620      	mov	r0, r4
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
    e94e:	b009      	add	sp, #36	; 0x24
    e950:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    e954:	f003 bdc8 	b.w	124e8 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
    e958:	2001      	movs	r0, #1
    e95a:	e7df      	b.n	e91c <k_work_queue_start+0x2c>
    e95c:	0000e719 	.word	0x0000e719

0000e960 <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
    e960:	b513      	push	{r0, r1, r4, lr}
    e962:	9001      	str	r0, [sp, #4]
    e964:	4608      	mov	r0, r1
	__asm__ volatile(
    e966:	f04f 0120 	mov.w	r1, #32
    e96a:	f3ef 8411 	mrs	r4, BASEPRI
    e96e:	f381 8812 	msr	BASEPRI_MAX, r1
    e972:	f3bf 8f6f 	isb	sy
	return *flagp;
    e976:	68c1      	ldr	r1, [r0, #12]
	struct k_work *work = &dwork->work;
	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
    e978:	f011 0f0e 	tst.w	r1, #14
    e97c:	d116      	bne.n	e9ac <k_work_schedule_for_queue+0x4c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    e97e:	ea53 0c02 	orrs.w	ip, r3, r2
    e982:	d108      	bne.n	e996 <k_work_schedule_for_queue+0x36>
		return submit_to_queue_locked(work, queuep);
    e984:	a901      	add	r1, sp, #4
    e986:	f7ff ff5d 	bl	e844 <submit_to_queue_locked>
	__asm__ volatile(
    e98a:	f384 8811 	msr	BASEPRI, r4
    e98e:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
    e992:	b002      	add	sp, #8
    e994:	bd10      	pop	{r4, pc}
	*flagp |= BIT(bit);
    e996:	f041 0108 	orr.w	r1, r1, #8
    e99a:	60c1      	str	r1, [r0, #12]
	dwork->queue = *queuep;
    e99c:	9901      	ldr	r1, [sp, #4]
    e99e:	6281      	str	r1, [r0, #40]	; 0x28
	z_add_timeout(&dwork->timeout, work_timeout, delay);
    e9a0:	3010      	adds	r0, #16
    e9a2:	4903      	ldr	r1, [pc, #12]	; (e9b0 <k_work_schedule_for_queue+0x50>)
    e9a4:	f000 fb94 	bl	f0d0 <z_add_timeout>
	return ret;
    e9a8:	2001      	movs	r0, #1
    e9aa:	e7ee      	b.n	e98a <k_work_schedule_for_queue+0x2a>
	int ret = 0;
    e9ac:	2000      	movs	r0, #0
    e9ae:	e7ec      	b.n	e98a <k_work_schedule_for_queue+0x2a>
    e9b0:	0001273f 	.word	0x0001273f

0000e9b4 <k_work_schedule>:

int k_work_schedule(struct k_work_delayable *dwork,
				   k_timeout_t delay)
{
    e9b4:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, schedule, dwork, delay);

	int ret = k_work_schedule_for_queue(&k_sys_work_q, dwork, delay);
    e9b6:	4801      	ldr	r0, [pc, #4]	; (e9bc <k_work_schedule+0x8>)
    e9b8:	f7ff bfd2 	b.w	e960 <k_work_schedule_for_queue>
    e9bc:	20000968 	.word	0x20000968

0000e9c0 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    e9c0:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    e9c2:	4c08      	ldr	r4, [pc, #32]	; (e9e4 <z_reset_time_slice+0x24>)
    e9c4:	6823      	ldr	r3, [r4, #0]
    e9c6:	b15b      	cbz	r3, e9e0 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    e9c8:	f7fe feba 	bl	d740 <sys_clock_elapsed>
    e9cc:	4603      	mov	r3, r0
    e9ce:	6820      	ldr	r0, [r4, #0]
    e9d0:	4a05      	ldr	r2, [pc, #20]	; (e9e8 <z_reset_time_slice+0x28>)
    e9d2:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
	}
}
    e9d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    e9d8:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    e9da:	2100      	movs	r1, #0
    e9dc:	f004 b81d 	b.w	12a1a <z_set_timeout_expiry>
}
    e9e0:	bd10      	pop	{r4, pc}
    e9e2:	bf00      	nop
    e9e4:	200026d8 	.word	0x200026d8
    e9e8:	200026a0 	.word	0x200026a0

0000e9ec <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
    e9ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e9ee:	4604      	mov	r4, r0
    e9f0:	460d      	mov	r5, r1
	__asm__ volatile(
    e9f2:	f04f 0320 	mov.w	r3, #32
    e9f6:	f3ef 8611 	mrs	r6, BASEPRI
    e9fa:	f383 8812 	msr	BASEPRI_MAX, r3
    e9fe:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    ea02:	4b0f      	ldr	r3, [pc, #60]	; (ea40 <k_sched_time_slice_set+0x54>)
    ea04:	2100      	movs	r1, #0
			return (uint32_t)((t * to_hz + off) / from_hz);
    ea06:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    ea0a:	f240 30e7 	movw	r0, #999	; 0x3e7
    ea0e:	6119      	str	r1, [r3, #16]
    ea10:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    ea14:	2300      	movs	r3, #0
    ea16:	fbe4 0107 	umlal	r0, r1, r4, r7
    ea1a:	f7f1 fb71 	bl	100 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    ea1e:	2c00      	cmp	r4, #0
    ea20:	4b08      	ldr	r3, [pc, #32]	; (ea44 <k_sched_time_slice_set+0x58>)
    ea22:	dc09      	bgt.n	ea38 <k_sched_time_slice_set+0x4c>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
    ea24:	6018      	str	r0, [r3, #0]
		}
		slice_max_prio = prio;
    ea26:	4b08      	ldr	r3, [pc, #32]	; (ea48 <k_sched_time_slice_set+0x5c>)
    ea28:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
    ea2a:	f7ff ffc9 	bl	e9c0 <z_reset_time_slice>
	__asm__ volatile(
    ea2e:	f386 8811 	msr	BASEPRI, r6
    ea32:	f3bf 8f6f 	isb	sy
	}
}
    ea36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			slice_time = MAX(2, slice_time);
    ea38:	2802      	cmp	r0, #2
    ea3a:	bfb8      	it	lt
    ea3c:	2002      	movlt	r0, #2
    ea3e:	e7f1      	b.n	ea24 <k_sched_time_slice_set+0x38>
    ea40:	200026a0 	.word	0x200026a0
    ea44:	200026d8 	.word	0x200026d8
    ea48:	200026d4 	.word	0x200026d4

0000ea4c <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
    ea4c:	b949      	cbnz	r1, ea62 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    ea4e:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
    ea52:	b930      	cbnz	r0, ea62 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
    ea54:	4b05      	ldr	r3, [pc, #20]	; (ea6c <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
    ea56:	69da      	ldr	r2, [r3, #28]
    ea58:	689b      	ldr	r3, [r3, #8]
    ea5a:	429a      	cmp	r2, r3
    ea5c:	d001      	beq.n	ea62 <z_reschedule+0x16>
	ret = arch_swap(key);
    ea5e:	f7f3 bdb3 	b.w	25c8 <arch_swap>
    ea62:	f381 8811 	msr	BASEPRI, r1
    ea66:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
    ea6a:	4770      	bx	lr
    ea6c:	200026a0 	.word	0x200026a0

0000ea70 <k_sched_lock>:
	__asm__ volatile(
    ea70:	f04f 0320 	mov.w	r3, #32
    ea74:	f3ef 8111 	mrs	r1, BASEPRI
    ea78:	f383 8812 	msr	BASEPRI_MAX, r3
    ea7c:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
    ea80:	4b04      	ldr	r3, [pc, #16]	; (ea94 <k_sched_lock+0x24>)
    ea82:	689a      	ldr	r2, [r3, #8]
    ea84:	7bd3      	ldrb	r3, [r2, #15]
    ea86:	3b01      	subs	r3, #1
    ea88:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    ea8a:	f381 8811 	msr	BASEPRI, r1
    ea8e:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
    ea92:	4770      	bx	lr
    ea94:	200026a0 	.word	0x200026a0

0000ea98 <update_cache>:
{
    ea98:	b538      	push	{r3, r4, r5, lr}
    ea9a:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
    ea9c:	480c      	ldr	r0, [pc, #48]	; (ead0 <update_cache+0x38>)
    ea9e:	4d0d      	ldr	r5, [pc, #52]	; (ead4 <update_cache+0x3c>)
    eaa0:	f003 feee 	bl	12880 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    eaa4:	4604      	mov	r4, r0
    eaa6:	b900      	cbnz	r0, eaaa <update_cache+0x12>
    eaa8:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
    eaaa:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
    eaac:	b94a      	cbnz	r2, eac2 <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
    eaae:	7b5a      	ldrb	r2, [r3, #13]
    eab0:	06d2      	lsls	r2, r2, #27
    eab2:	d106      	bne.n	eac2 <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    eab4:	69a2      	ldr	r2, [r4, #24]
    eab6:	b922      	cbnz	r2, eac2 <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
    eab8:	89da      	ldrh	r2, [r3, #14]
    eaba:	2a7f      	cmp	r2, #127	; 0x7f
    eabc:	d901      	bls.n	eac2 <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
    eabe:	61eb      	str	r3, [r5, #28]
}
    eac0:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
    eac2:	429c      	cmp	r4, r3
    eac4:	d001      	beq.n	eaca <update_cache+0x32>
			z_reset_time_slice();
    eac6:	f7ff ff7b 	bl	e9c0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    eaca:	61ec      	str	r4, [r5, #28]
}
    eacc:	e7f8      	b.n	eac0 <update_cache+0x28>
    eace:	bf00      	nop
    ead0:	200026c0 	.word	0x200026c0
    ead4:	200026a0 	.word	0x200026a0

0000ead8 <move_thread_to_end_of_prio_q>:
{
    ead8:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
    eada:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
    eade:	7b43      	ldrb	r3, [r0, #13]
    eae0:	2a00      	cmp	r2, #0
{
    eae2:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
    eae4:	da04      	bge.n	eaf0 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    eae6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    eaea:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    eaec:	f003 fe83 	bl	127f6 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    eaf0:	7b4b      	ldrb	r3, [r1, #13]
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    eaf2:	4a15      	ldr	r2, [pc, #84]	; (eb48 <move_thread_to_end_of_prio_q+0x70>)
    eaf4:	f063 037f 	orn	r3, r3, #127	; 0x7f
    eaf8:	734b      	strb	r3, [r1, #13]
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
    eafa:	e9d2 3408 	ldrd	r3, r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    eafe:	f102 0520 	add.w	r5, r2, #32
    eb02:	42ab      	cmp	r3, r5
    eb04:	d01b      	beq.n	eb3e <move_thread_to_end_of_prio_q+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    eb06:	b1d3      	cbz	r3, eb3e <move_thread_to_end_of_prio_q+0x66>
	int32_t b1 = thread_1->base.prio;
    eb08:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
    eb0c:	f993 000e 	ldrsb.w	r0, [r3, #14]
	if (b1 != b2) {
    eb10:	4286      	cmp	r6, r0
    eb12:	d00f      	beq.n	eb34 <move_thread_to_end_of_prio_q+0x5c>
		return b2 - b1;
    eb14:	1b80      	subs	r0, r0, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
    eb16:	2800      	cmp	r0, #0
    eb18:	dd0c      	ble.n	eb34 <move_thread_to_end_of_prio_q+0x5c>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
    eb1a:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
    eb1c:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
    eb20:	6001      	str	r1, [r0, #0]
	successor->prev = node;
    eb22:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
    eb24:	6890      	ldr	r0, [r2, #8]
    eb26:	1a43      	subs	r3, r0, r1
    eb28:	4258      	negs	r0, r3
}
    eb2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
    eb2e:	4158      	adcs	r0, r3
    eb30:	f7ff bfb2 	b.w	ea98 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    eb34:	42a3      	cmp	r3, r4
    eb36:	d002      	beq.n	eb3e <move_thread_to_end_of_prio_q+0x66>
    eb38:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    eb3a:	2b00      	cmp	r3, #0
    eb3c:	d1e6      	bne.n	eb0c <move_thread_to_end_of_prio_q+0x34>
	node->prev = tail;
    eb3e:	e9c1 5400 	strd	r5, r4, [r1]
	tail->next = node;
    eb42:	6021      	str	r1, [r4, #0]
	list->tail = node;
    eb44:	6251      	str	r1, [r2, #36]	; 0x24
}
    eb46:	e7ed      	b.n	eb24 <move_thread_to_end_of_prio_q+0x4c>
    eb48:	200026a0 	.word	0x200026a0

0000eb4c <z_time_slice>:
{
    eb4c:	b538      	push	{r3, r4, r5, lr}
    eb4e:	4601      	mov	r1, r0
	__asm__ volatile(
    eb50:	f04f 0320 	mov.w	r3, #32
    eb54:	f3ef 8411 	mrs	r4, BASEPRI
    eb58:	f383 8812 	msr	BASEPRI_MAX, r3
    eb5c:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
    eb60:	4b15      	ldr	r3, [pc, #84]	; (ebb8 <z_time_slice+0x6c>)
    eb62:	4a16      	ldr	r2, [pc, #88]	; (ebbc <z_time_slice+0x70>)
    eb64:	6898      	ldr	r0, [r3, #8]
    eb66:	6815      	ldr	r5, [r2, #0]
    eb68:	42a8      	cmp	r0, r5
    eb6a:	d106      	bne.n	eb7a <z_time_slice+0x2e>
			z_reset_time_slice();
    eb6c:	f7ff ff28 	bl	e9c0 <z_reset_time_slice>
	__asm__ volatile(
    eb70:	f384 8811 	msr	BASEPRI, r4
    eb74:	f3bf 8f6f 	isb	sy
}
    eb78:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
    eb7a:	2500      	movs	r5, #0
    eb7c:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
    eb7e:	4a10      	ldr	r2, [pc, #64]	; (ebc0 <z_time_slice+0x74>)
    eb80:	6812      	ldr	r2, [r2, #0]
    eb82:	b1ba      	cbz	r2, ebb4 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
    eb84:	89c2      	ldrh	r2, [r0, #14]
    eb86:	2a7f      	cmp	r2, #127	; 0x7f
    eb88:	d814      	bhi.n	ebb4 <z_time_slice+0x68>
		&& !z_is_thread_prevented_from_running(thread)
    eb8a:	7b42      	ldrb	r2, [r0, #13]
    eb8c:	06d2      	lsls	r2, r2, #27
    eb8e:	d111      	bne.n	ebb4 <z_time_slice+0x68>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    eb90:	4a0c      	ldr	r2, [pc, #48]	; (ebc4 <z_time_slice+0x78>)
    eb92:	f990 500e 	ldrsb.w	r5, [r0, #14]
    eb96:	6812      	ldr	r2, [r2, #0]
    eb98:	4295      	cmp	r5, r2
    eb9a:	db0b      	blt.n	ebb4 <z_time_slice+0x68>
		&& !z_is_idle_thread_object(thread);
    eb9c:	4a0a      	ldr	r2, [pc, #40]	; (ebc8 <z_time_slice+0x7c>)
    eb9e:	4290      	cmp	r0, r2
    eba0:	d008      	beq.n	ebb4 <z_time_slice+0x68>
		if (ticks >= _current_cpu->slice_ticks) {
    eba2:	691a      	ldr	r2, [r3, #16]
    eba4:	428a      	cmp	r2, r1
    eba6:	dc02      	bgt.n	ebae <z_time_slice+0x62>
			move_thread_to_end_of_prio_q(_current);
    eba8:	f7ff ff96 	bl	ead8 <move_thread_to_end_of_prio_q>
    ebac:	e7de      	b.n	eb6c <z_time_slice+0x20>
			_current_cpu->slice_ticks -= ticks;
    ebae:	1a52      	subs	r2, r2, r1
		_current_cpu->slice_ticks = 0;
    ebb0:	611a      	str	r2, [r3, #16]
    ebb2:	e7dd      	b.n	eb70 <z_time_slice+0x24>
    ebb4:	2200      	movs	r2, #0
    ebb6:	e7fb      	b.n	ebb0 <z_time_slice+0x64>
    ebb8:	200026a0 	.word	0x200026a0
    ebbc:	200026d0 	.word	0x200026d0
    ebc0:	200026d8 	.word	0x200026d8
    ebc4:	200026d4 	.word	0x200026d4
    ebc8:	20000860 	.word	0x20000860

0000ebcc <ready_thread>:
{
    ebcc:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    ebce:	f990 200d 	ldrsb.w	r2, [r0, #13]
    ebd2:	7b43      	ldrb	r3, [r0, #13]
    ebd4:	2a00      	cmp	r2, #0
    ebd6:	db2a      	blt.n	ec2e <ready_thread+0x62>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    ebd8:	06da      	lsls	r2, r3, #27
    ebda:	d128      	bne.n	ec2e <ready_thread+0x62>
    ebdc:	6982      	ldr	r2, [r0, #24]
    ebde:	bb32      	cbnz	r2, ec2e <ready_thread+0x62>
	return list->head == list;
    ebe0:	4a14      	ldr	r2, [pc, #80]	; (ec34 <ready_thread+0x68>)
	thread->base.thread_state |= _THREAD_QUEUED;
    ebe2:	f063 037f 	orn	r3, r3, #127	; 0x7f
    ebe6:	7343      	strb	r3, [r0, #13]
	return (node == list->tail) ? NULL : node->next;
    ebe8:	e9d2 3408 	ldrd	r3, r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    ebec:	f102 0520 	add.w	r5, r2, #32
    ebf0:	42ab      	cmp	r3, r5
    ebf2:	d017      	beq.n	ec24 <ready_thread+0x58>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    ebf4:	b1b3      	cbz	r3, ec24 <ready_thread+0x58>
	int32_t b1 = thread_1->base.prio;
    ebf6:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
    ebfa:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
    ebfe:	428e      	cmp	r6, r1
    ec00:	d00b      	beq.n	ec1a <ready_thread+0x4e>
		return b2 - b1;
    ec02:	1b89      	subs	r1, r1, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
    ec04:	2900      	cmp	r1, #0
    ec06:	dd08      	ble.n	ec1a <ready_thread+0x4e>
	sys_dnode_t *const prev = successor->prev;
    ec08:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    ec0a:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
    ec0e:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    ec10:	6058      	str	r0, [r3, #4]
}
    ec12:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
    ec14:	2000      	movs	r0, #0
    ec16:	f7ff bf3f 	b.w	ea98 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    ec1a:	42a3      	cmp	r3, r4
    ec1c:	d002      	beq.n	ec24 <ready_thread+0x58>
    ec1e:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    ec20:	2b00      	cmp	r3, #0
    ec22:	d1ea      	bne.n	ebfa <ready_thread+0x2e>
	node->prev = tail;
    ec24:	e9c0 5400 	strd	r5, r4, [r0]
	tail->next = node;
    ec28:	6020      	str	r0, [r4, #0]
	list->tail = node;
    ec2a:	6250      	str	r0, [r2, #36]	; 0x24
}
    ec2c:	e7f1      	b.n	ec12 <ready_thread+0x46>
}
    ec2e:	bc70      	pop	{r4, r5, r6}
    ec30:	4770      	bx	lr
    ec32:	bf00      	nop
    ec34:	200026a0 	.word	0x200026a0

0000ec38 <z_sched_start>:
{
    ec38:	b510      	push	{r4, lr}
	__asm__ volatile(
    ec3a:	f04f 0220 	mov.w	r2, #32
    ec3e:	f3ef 8411 	mrs	r4, BASEPRI
    ec42:	f382 8812 	msr	BASEPRI_MAX, r2
    ec46:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    ec4a:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
    ec4c:	0751      	lsls	r1, r2, #29
    ec4e:	d404      	bmi.n	ec5a <z_sched_start+0x22>
	__asm__ volatile(
    ec50:	f384 8811 	msr	BASEPRI, r4
    ec54:	f3bf 8f6f 	isb	sy
}
    ec58:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    ec5a:	f022 0204 	bic.w	r2, r2, #4
    ec5e:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
    ec60:	f7ff ffb4 	bl	ebcc <ready_thread>
	z_reschedule(&sched_spinlock, key);
    ec64:	4621      	mov	r1, r4
    ec66:	4802      	ldr	r0, [pc, #8]	; (ec70 <z_sched_start+0x38>)
}
    ec68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
    ec6c:	f7ff beee 	b.w	ea4c <z_reschedule>
    ec70:	20002e8d 	.word	0x20002e8d

0000ec74 <unready_thread>:
{
    ec74:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
    ec76:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
    ec7a:	7b43      	ldrb	r3, [r0, #13]
    ec7c:	2a00      	cmp	r2, #0
{
    ec7e:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
    ec80:	da04      	bge.n	ec8c <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    ec82:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    ec86:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    ec88:	f003 fdb5 	bl	127f6 <sys_dlist_remove>
	update_cache(thread == _current);
    ec8c:	4b04      	ldr	r3, [pc, #16]	; (eca0 <unready_thread+0x2c>)
    ec8e:	6898      	ldr	r0, [r3, #8]
    ec90:	1a43      	subs	r3, r0, r1
    ec92:	4258      	negs	r0, r3
    ec94:	4158      	adcs	r0, r3
}
    ec96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
    ec9a:	f7ff befd 	b.w	ea98 <update_cache>
    ec9e:	bf00      	nop
    eca0:	200026a0 	.word	0x200026a0

0000eca4 <pend>:
{
    eca4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    eca8:	4606      	mov	r6, r0
    ecaa:	4615      	mov	r5, r2
    ecac:	461c      	mov	r4, r3
	__asm__ volatile(
    ecae:	f04f 0320 	mov.w	r3, #32
    ecb2:	f3ef 8711 	mrs	r7, BASEPRI
    ecb6:	f383 8812 	msr	BASEPRI_MAX, r3
    ecba:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
    ecbe:	f003 fe17 	bl	128f0 <add_to_waitq_locked>
	__asm__ volatile(
    ecc2:	f387 8811 	msr	BASEPRI, r7
    ecc6:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    ecca:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
    ecce:	bf08      	it	eq
    ecd0:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
    ecd4:	d008      	beq.n	ece8 <pend+0x44>
    ecd6:	462a      	mov	r2, r5
    ecd8:	4623      	mov	r3, r4
    ecda:	f106 0018 	add.w	r0, r6, #24
    ecde:	4903      	ldr	r1, [pc, #12]	; (ecec <pend+0x48>)
}
    ece0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    ece4:	f000 b9f4 	b.w	f0d0 <z_add_timeout>
    ece8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ecec:	000128ad 	.word	0x000128ad

0000ecf0 <z_pend_curr>:
{
    ecf0:	b510      	push	{r4, lr}
	pending_current = _current;
    ecf2:	4b07      	ldr	r3, [pc, #28]	; (ed10 <z_pend_curr+0x20>)
    ecf4:	6898      	ldr	r0, [r3, #8]
    ecf6:	4b07      	ldr	r3, [pc, #28]	; (ed14 <z_pend_curr+0x24>)
{
    ecf8:	460c      	mov	r4, r1
	pending_current = _current;
    ecfa:	6018      	str	r0, [r3, #0]
{
    ecfc:	4611      	mov	r1, r2
	pend(_current, wait_q, timeout);
    ecfe:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    ed02:	f7ff ffcf 	bl	eca4 <pend>
    ed06:	4620      	mov	r0, r4
}
    ed08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ed0c:	f7f3 bc5c 	b.w	25c8 <arch_swap>
    ed10:	200026a0 	.word	0x200026a0
    ed14:	200026d0 	.word	0x200026d0

0000ed18 <z_impl_k_thread_suspend>:
{
    ed18:	b570      	push	{r4, r5, r6, lr}
    ed1a:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    ed1c:	3018      	adds	r0, #24
    ed1e:	f003 fe56 	bl	129ce <z_abort_timeout>
	__asm__ volatile(
    ed22:	f04f 0320 	mov.w	r3, #32
    ed26:	f3ef 8611 	mrs	r6, BASEPRI
    ed2a:	f383 8812 	msr	BASEPRI_MAX, r3
    ed2e:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    ed32:	f994 200d 	ldrsb.w	r2, [r4, #13]
    ed36:	7b63      	ldrb	r3, [r4, #13]
    ed38:	2a00      	cmp	r2, #0
    ed3a:	da05      	bge.n	ed48 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    ed3c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    ed40:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    ed42:	4620      	mov	r0, r4
    ed44:	f003 fd57 	bl	127f6 <sys_dlist_remove>
		update_cache(thread == _current);
    ed48:	4d0b      	ldr	r5, [pc, #44]	; (ed78 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
    ed4a:	7b63      	ldrb	r3, [r4, #13]
    ed4c:	68a8      	ldr	r0, [r5, #8]
    ed4e:	f043 0310 	orr.w	r3, r3, #16
    ed52:	7363      	strb	r3, [r4, #13]
    ed54:	1b03      	subs	r3, r0, r4
    ed56:	4258      	negs	r0, r3
    ed58:	4158      	adcs	r0, r3
    ed5a:	f7ff fe9d 	bl	ea98 <update_cache>
	__asm__ volatile(
    ed5e:	f386 8811 	msr	BASEPRI, r6
    ed62:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
    ed66:	68ab      	ldr	r3, [r5, #8]
    ed68:	42a3      	cmp	r3, r4
    ed6a:	d103      	bne.n	ed74 <z_impl_k_thread_suspend+0x5c>
}
    ed6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
    ed70:	f003 bd7c 	b.w	1286c <z_reschedule_unlocked>
}
    ed74:	bd70      	pop	{r4, r5, r6, pc}
    ed76:	bf00      	nop
    ed78:	200026a0 	.word	0x200026a0

0000ed7c <k_sched_unlock>:
{
    ed7c:	b510      	push	{r4, lr}
	__asm__ volatile(
    ed7e:	f04f 0320 	mov.w	r3, #32
    ed82:	f3ef 8411 	mrs	r4, BASEPRI
    ed86:	f383 8812 	msr	BASEPRI_MAX, r3
    ed8a:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
    ed8e:	4b08      	ldr	r3, [pc, #32]	; (edb0 <k_sched_unlock+0x34>)
    ed90:	689a      	ldr	r2, [r3, #8]
    ed92:	7bd3      	ldrb	r3, [r2, #15]
    ed94:	3301      	adds	r3, #1
    ed96:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    ed98:	2000      	movs	r0, #0
    ed9a:	f7ff fe7d 	bl	ea98 <update_cache>
	__asm__ volatile(
    ed9e:	f384 8811 	msr	BASEPRI, r4
    eda2:	f3bf 8f6f 	isb	sy
}
    eda6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
    edaa:	f003 bd5f 	b.w	1286c <z_reschedule_unlocked>
    edae:	bf00      	nop
    edb0:	200026a0 	.word	0x200026a0

0000edb4 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    edb4:	4b04      	ldr	r3, [pc, #16]	; (edc8 <z_sched_init+0x14>)
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    edb6:	2100      	movs	r1, #0
    edb8:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
    edbc:	e9c3 2208 	strd	r2, r2, [r3, #32]
    edc0:	4608      	mov	r0, r1
    edc2:	f7ff be13 	b.w	e9ec <k_sched_time_slice_set>
    edc6:	bf00      	nop
    edc8:	200026a0 	.word	0x200026a0

0000edcc <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
    edcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    edce:	f04f 0320 	mov.w	r3, #32
    edd2:	f3ef 8511 	mrs	r5, BASEPRI
    edd6:	f383 8812 	msr	BASEPRI_MAX, r3
    edda:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
    edde:	491a      	ldr	r1, [pc, #104]	; (ee48 <z_impl_k_yield+0x7c>)
    ede0:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    ede2:	7b43      	ldrb	r3, [r0, #13]
    ede4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    ede8:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    edea:	f003 fd04 	bl	127f6 <sys_dlist_remove>
	}
	queue_thread(_current);
    edee:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
    edf0:	7b5a      	ldrb	r2, [r3, #13]
	return list->head == list;
    edf2:	4608      	mov	r0, r1
    edf4:	f062 027f 	orn	r2, r2, #127	; 0x7f
    edf8:	735a      	strb	r2, [r3, #13]
    edfa:	f850 2f20 	ldr.w	r2, [r0, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    edfe:	4282      	cmp	r2, r0
    ee00:	d01c      	beq.n	ee3c <z_impl_k_yield+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    ee02:	b1da      	cbz	r2, ee3c <z_impl_k_yield+0x70>
	return (node == list->tail) ? NULL : node->next;
    ee04:	6a4f      	ldr	r7, [r1, #36]	; 0x24
	int32_t b1 = thread_1->base.prio;
    ee06:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
    ee0a:	f992 400e 	ldrsb.w	r4, [r2, #14]
	if (b1 != b2) {
    ee0e:	42a6      	cmp	r6, r4
    ee10:	d00f      	beq.n	ee32 <z_impl_k_yield+0x66>
		return b2 - b1;
    ee12:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
    ee14:	2c00      	cmp	r4, #0
    ee16:	dd0c      	ble.n	ee32 <z_impl_k_yield+0x66>
	sys_dnode_t *const prev = successor->prev;
    ee18:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    ee1a:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
    ee1e:	600b      	str	r3, [r1, #0]
	successor->prev = node;
    ee20:	6053      	str	r3, [r2, #4]
	update_cache(1);
    ee22:	2001      	movs	r0, #1
    ee24:	f7ff fe38 	bl	ea98 <update_cache>
    ee28:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
    ee2a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    ee2e:	f7f3 bbcb 	b.w	25c8 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
    ee32:	42ba      	cmp	r2, r7
    ee34:	d002      	beq.n	ee3c <z_impl_k_yield+0x70>
    ee36:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    ee38:	2a00      	cmp	r2, #0
    ee3a:	d1e6      	bne.n	ee0a <z_impl_k_yield+0x3e>
	sys_dnode_t *const tail = list->tail;
    ee3c:	6a4a      	ldr	r2, [r1, #36]	; 0x24
	node->prev = tail;
    ee3e:	e9c3 0200 	strd	r0, r2, [r3]
	tail->next = node;
    ee42:	6013      	str	r3, [r2, #0]
	list->tail = node;
    ee44:	624b      	str	r3, [r1, #36]	; 0x24
}
    ee46:	e7ec      	b.n	ee22 <z_impl_k_yield+0x56>
    ee48:	200026a0 	.word	0x200026a0

0000ee4c <z_tick_sleep>:
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
    ee4c:	ea50 0301 	orrs.w	r3, r0, r1
{
    ee50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ee54:	4605      	mov	r5, r0
    ee56:	460e      	mov	r6, r1
	if (ticks == 0) {
    ee58:	d103      	bne.n	ee62 <z_tick_sleep+0x16>
	z_impl_k_yield();
    ee5a:	f7ff ffb7 	bl	edcc <z_impl_k_yield>
	if (ticks > 0) {
		return ticks;
	}
#endif

	return 0;
    ee5e:	2000      	movs	r0, #0
    ee60:	e033      	b.n	eeca <z_tick_sleep+0x7e>
	if (Z_TICK_ABS(ticks) <= 0) {
    ee62:	f06f 0401 	mvn.w	r4, #1
    ee66:	1a24      	subs	r4, r4, r0
    ee68:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    ee6c:	eb63 0301 	sbc.w	r3, r3, r1
    ee70:	2c01      	cmp	r4, #1
    ee72:	f173 0300 	sbcs.w	r3, r3, #0
    ee76:	da02      	bge.n	ee7e <z_tick_sleep+0x32>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    ee78:	f003 fde9 	bl	12a4e <sys_clock_tick_get_32>
    ee7c:	1944      	adds	r4, r0, r5
    ee7e:	f04f 0320 	mov.w	r3, #32
    ee82:	f3ef 8811 	mrs	r8, BASEPRI
    ee86:	f383 8812 	msr	BASEPRI_MAX, r3
    ee8a:	f3bf 8f6f 	isb	sy
	pending_current = _current;
    ee8e:	4f10      	ldr	r7, [pc, #64]	; (eed0 <z_tick_sleep+0x84>)
    ee90:	4b10      	ldr	r3, [pc, #64]	; (eed4 <z_tick_sleep+0x88>)
    ee92:	68b8      	ldr	r0, [r7, #8]
    ee94:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
    ee96:	f7ff feed 	bl	ec74 <unready_thread>
	z_add_thread_timeout(_current, timeout);
    ee9a:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    ee9c:	490e      	ldr	r1, [pc, #56]	; (eed8 <z_tick_sleep+0x8c>)
    ee9e:	462a      	mov	r2, r5
    eea0:	4633      	mov	r3, r6
    eea2:	3018      	adds	r0, #24
    eea4:	f000 f914 	bl	f0d0 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    eea8:	68ba      	ldr	r2, [r7, #8]
    eeaa:	7b53      	ldrb	r3, [r2, #13]
    eeac:	f043 0310 	orr.w	r3, r3, #16
    eeb0:	7353      	strb	r3, [r2, #13]
    eeb2:	4640      	mov	r0, r8
    eeb4:	f7f3 fb88 	bl	25c8 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    eeb8:	f003 fdc9 	bl	12a4e <sys_clock_tick_get_32>
    eebc:	1a20      	subs	r0, r4, r0
    eebe:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
    eec2:	2801      	cmp	r0, #1
    eec4:	f173 0300 	sbcs.w	r3, r3, #0
    eec8:	dbc9      	blt.n	ee5e <z_tick_sleep+0x12>
}
    eeca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    eece:	bf00      	nop
    eed0:	200026a0 	.word	0x200026a0
    eed4:	200026d0 	.word	0x200026d0
    eed8:	000128ad 	.word	0x000128ad

0000eedc <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    eedc:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    eee0:	bf08      	it	eq
    eee2:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
    eee6:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    eee8:	d106      	bne.n	eef8 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
    eeea:	4b08      	ldr	r3, [pc, #32]	; (ef0c <z_impl_k_sleep+0x30>)
    eeec:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    eeee:	f7ff ff13 	bl	ed18 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
    eef2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
    eef6:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
    eef8:	f7ff ffa8 	bl	ee4c <z_tick_sleep>
			return (t * to_hz + off) / from_hz;
    eefc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    ef00:	fb80 0303 	smull	r0, r3, r0, r3
    ef04:	0bc0      	lsrs	r0, r0, #15
    ef06:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
    ef0a:	e7f4      	b.n	eef6 <z_impl_k_sleep+0x1a>
    ef0c:	200026a0 	.word	0x200026a0

0000ef10 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    ef10:	4b01      	ldr	r3, [pc, #4]	; (ef18 <z_impl_z_current_get+0x8>)
    ef12:	6898      	ldr	r0, [r3, #8]
    ef14:	4770      	bx	lr
    ef16:	bf00      	nop
    ef18:	200026a0 	.word	0x200026a0

0000ef1c <z_impl_k_is_preempt_thread>:
    ef1c:	f3ef 8305 	mrs	r3, IPSR
#include <syscalls/z_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
	return !arch_is_in_isr() && is_preempt(_current);
    ef20:	b93b      	cbnz	r3, ef32 <z_impl_k_is_preempt_thread+0x16>
    ef22:	4b05      	ldr	r3, [pc, #20]	; (ef38 <z_impl_k_is_preempt_thread+0x1c>)
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    ef24:	689b      	ldr	r3, [r3, #8]
	return !arch_is_in_isr() && is_preempt(_current);
    ef26:	89d8      	ldrh	r0, [r3, #14]
    ef28:	287f      	cmp	r0, #127	; 0x7f
    ef2a:	bf8c      	ite	hi
    ef2c:	2000      	movhi	r0, #0
    ef2e:	2001      	movls	r0, #1
    ef30:	4770      	bx	lr
    ef32:	2000      	movs	r0, #0
}
    ef34:	4770      	bx	lr
    ef36:	bf00      	nop
    ef38:	200026a0 	.word	0x200026a0

0000ef3c <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    ef3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ef40:	4604      	mov	r4, r0
    ef42:	f04f 0320 	mov.w	r3, #32
    ef46:	f3ef 8611 	mrs	r6, BASEPRI
    ef4a:	f383 8812 	msr	BASEPRI_MAX, r3
    ef4e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    ef52:	7b43      	ldrb	r3, [r0, #13]
    ef54:	071a      	lsls	r2, r3, #28
    ef56:	d505      	bpl.n	ef64 <z_thread_abort+0x28>
	__asm__ volatile(
    ef58:	f386 8811 	msr	BASEPRI, r6
    ef5c:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    ef60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
    ef64:	f023 0220 	bic.w	r2, r3, #32
    ef68:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
    ef6c:	09d2      	lsrs	r2, r2, #7
    ef6e:	d120      	bne.n	efb2 <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    ef70:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
    ef72:	68a3      	ldr	r3, [r4, #8]
    ef74:	b113      	cbz	r3, ef7c <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
    ef76:	4620      	mov	r0, r4
    ef78:	f003 fc45 	bl	12806 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
    ef7c:	f104 0018 	add.w	r0, r4, #24
    ef80:	f003 fd25 	bl	129ce <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    ef84:	f104 0758 	add.w	r7, r4, #88	; 0x58
    ef88:	f04f 0800 	mov.w	r8, #0
	return list->head == list;
    ef8c:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
    ef8e:	42bd      	cmp	r5, r7
    ef90:	d000      	beq.n	ef94 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    ef92:	b9b5      	cbnz	r5, efc2 <z_thread_abort+0x86>
		update_cache(1);
    ef94:	2001      	movs	r0, #1
    ef96:	f7ff fd7f 	bl	ea98 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
    ef9a:	4b10      	ldr	r3, [pc, #64]	; (efdc <z_thread_abort+0xa0>)
    ef9c:	689b      	ldr	r3, [r3, #8]
    ef9e:	42a3      	cmp	r3, r4
    efa0:	d1da      	bne.n	ef58 <z_thread_abort+0x1c>
    efa2:	f3ef 8305 	mrs	r3, IPSR
    efa6:	2b00      	cmp	r3, #0
    efa8:	d1d6      	bne.n	ef58 <z_thread_abort+0x1c>
    efaa:	4630      	mov	r0, r6
    efac:	f7f3 fb0c 	bl	25c8 <arch_swap>
	return ret;
    efb0:	e7d2      	b.n	ef58 <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    efb2:	f003 035f 	and.w	r3, r3, #95	; 0x5f
    efb6:	f043 0308 	orr.w	r3, r3, #8
    efba:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
    efbc:	f003 fc1b 	bl	127f6 <sys_dlist_remove>
}
    efc0:	e7d7      	b.n	ef72 <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
    efc2:	4628      	mov	r0, r5
    efc4:	f003 fc1f 	bl	12806 <unpend_thread_no_timeout>
    efc8:	f105 0018 	add.w	r0, r5, #24
    efcc:	f003 fcff 	bl	129ce <z_abort_timeout>
    efd0:	f8c5 807c 	str.w	r8, [r5, #124]	; 0x7c
		ready_thread(thread);
    efd4:	4628      	mov	r0, r5
    efd6:	f7ff fdf9 	bl	ebcc <ready_thread>
    efda:	e7d7      	b.n	ef8c <z_thread_abort+0x50>
    efdc:	200026a0 	.word	0x200026a0

0000efe0 <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
    efe0:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
    efe2:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
    efe6:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
    efe8:	e9cd 6700 	strd	r6, r7, [sp]
    efec:	f7ff fe80 	bl	ecf0 <z_pend_curr>

	if (data != NULL) {
    eff0:	b11c      	cbz	r4, effa <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
    eff2:	4b03      	ldr	r3, [pc, #12]	; (f000 <z_sched_wait+0x20>)
    eff4:	689b      	ldr	r3, [r3, #8]
    eff6:	695b      	ldr	r3, [r3, #20]
    eff8:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
    effa:	b002      	add	sp, #8
    effc:	bdd0      	pop	{r4, r6, r7, pc}
    effe:	bf00      	nop
    f000:	200026a0 	.word	0x200026a0

0000f004 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    f004:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
    f006:	4806      	ldr	r0, [pc, #24]	; (f020 <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
    f008:	4a06      	ldr	r2, [pc, #24]	; (f024 <z_data_copy+0x20>)
    f00a:	4907      	ldr	r1, [pc, #28]	; (f028 <z_data_copy+0x24>)
    f00c:	1a12      	subs	r2, r2, r0
    f00e:	f000 fdca 	bl	fba6 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    f012:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
    f016:	4a05      	ldr	r2, [pc, #20]	; (f02c <z_data_copy+0x28>)
    f018:	4905      	ldr	r1, [pc, #20]	; (f030 <z_data_copy+0x2c>)
    f01a:	4806      	ldr	r0, [pc, #24]	; (f034 <z_data_copy+0x30>)
    f01c:	f000 bdc3 	b.w	fba6 <memcpy>
    f020:	20000000 	.word	0x20000000
    f024:	20000654 	.word	0x20000654
    f028:	00014120 	.word	0x00014120
    f02c:	00000000 	.word	0x00000000
    f030:	00014120 	.word	0x00014120
    f034:	20000000 	.word	0x20000000

0000f038 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    f038:	4b03      	ldr	r3, [pc, #12]	; (f048 <elapsed+0x10>)
    f03a:	681b      	ldr	r3, [r3, #0]
    f03c:	b90b      	cbnz	r3, f042 <elapsed+0xa>
    f03e:	f7fe bb7f 	b.w	d740 <sys_clock_elapsed>
}
    f042:	2000      	movs	r0, #0
    f044:	4770      	bx	lr
    f046:	bf00      	nop
    f048:	200026dc 	.word	0x200026dc

0000f04c <next_timeout>:
	return list->head == list;
    f04c:	4b11      	ldr	r3, [pc, #68]	; (f094 <next_timeout+0x48>)

static int32_t next_timeout(void)
{
    f04e:	b510      	push	{r4, lr}
    f050:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f052:	429c      	cmp	r4, r3
    f054:	bf08      	it	eq
    f056:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    f058:	f7ff ffee 	bl	f038 <elapsed>
    f05c:	4603      	mov	r3, r0
	int32_t ret = to == NULL ? MAX_WAIT
    f05e:	b16c      	cbz	r4, f07c <next_timeout+0x30>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    f060:	e9d4 0204 	ldrd	r0, r2, [r4, #16]
    f064:	1ac0      	subs	r0, r0, r3
    f066:	eb62 73e3 	sbc.w	r3, r2, r3, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
    f06a:	2801      	cmp	r0, #1
    f06c:	f173 0200 	sbcs.w	r2, r3, #0
    f070:	db0d      	blt.n	f08e <next_timeout+0x42>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    f072:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
    f076:	f173 0300 	sbcs.w	r3, r3, #0
    f07a:	db01      	blt.n	f080 <next_timeout+0x34>
	int32_t ret = to == NULL ? MAX_WAIT
    f07c:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    f080:	4b05      	ldr	r3, [pc, #20]	; (f098 <next_timeout+0x4c>)
    f082:	691b      	ldr	r3, [r3, #16]
    f084:	b113      	cbz	r3, f08c <next_timeout+0x40>
    f086:	4298      	cmp	r0, r3
    f088:	bfa8      	it	ge
    f08a:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    f08c:	bd10      	pop	{r4, pc}
	int32_t ret = to == NULL ? MAX_WAIT
    f08e:	2000      	movs	r0, #0
    f090:	e7f6      	b.n	f080 <next_timeout+0x34>
    f092:	bf00      	nop
    f094:	20000568 	.word	0x20000568
    f098:	200026a0 	.word	0x200026a0

0000f09c <remove_timeout>:
{
    f09c:	b530      	push	{r4, r5, lr}
	return (node == list->tail) ? NULL : node->next;
    f09e:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    f0a0:	b168      	cbz	r0, f0be <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
    f0a2:	4a0a      	ldr	r2, [pc, #40]	; (f0cc <remove_timeout+0x30>)
    f0a4:	6852      	ldr	r2, [r2, #4]
    f0a6:	4290      	cmp	r0, r2
    f0a8:	d009      	beq.n	f0be <remove_timeout+0x22>
	if (next(t) != NULL) {
    f0aa:	b143      	cbz	r3, f0be <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
    f0ac:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
    f0b0:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
    f0b4:	1912      	adds	r2, r2, r4
    f0b6:	eb41 0105 	adc.w	r1, r1, r5
    f0ba:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    f0be:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
    f0c0:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    f0c2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    f0c4:	2300      	movs	r3, #0
	node->prev = NULL;
    f0c6:	e9c0 3300 	strd	r3, r3, [r0]
}
    f0ca:	bd30      	pop	{r4, r5, pc}
    f0cc:	20000568 	.word	0x20000568

0000f0d0 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    f0d0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    f0d4:	bf08      	it	eq
    f0d6:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
    f0da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f0dc:	4604      	mov	r4, r0
    f0de:	461f      	mov	r7, r3
    f0e0:	4615      	mov	r5, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    f0e2:	d067      	beq.n	f1b4 <z_add_timeout+0xe4>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    f0e4:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
    f0e6:	f04f 0320 	mov.w	r3, #32
    f0ea:	f3ef 8611 	mrs	r6, BASEPRI
    f0ee:	f383 8812 	msr	BASEPRI_MAX, r3
    f0f2:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    f0f6:	f06f 0201 	mvn.w	r2, #1
    f0fa:	1b53      	subs	r3, r2, r5
    f0fc:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    f100:	eb6c 0307 	sbc.w	r3, ip, r7
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    f104:	2b00      	cmp	r3, #0
    f106:	db1b      	blt.n	f140 <z_add_timeout+0x70>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    f108:	4b2b      	ldr	r3, [pc, #172]	; (f1b8 <z_add_timeout+0xe8>)
    f10a:	e9d3 1300 	ldrd	r1, r3, [r3]
    f10e:	1a52      	subs	r2, r2, r1
    f110:	eb6c 0303 	sbc.w	r3, ip, r3
    f114:	1b55      	subs	r5, r2, r5

			to->dticks = MAX(1, ticks);
    f116:	eb63 0307 	sbc.w	r3, r3, r7
    f11a:	2d01      	cmp	r5, #1
    f11c:	f173 0200 	sbcs.w	r2, r3, #0
    f120:	bfbc      	itt	lt
    f122:	2501      	movlt	r5, #1
    f124:	2300      	movlt	r3, #0
    f126:	e9c0 5304 	strd	r5, r3, [r0, #16]
	return list->head == list;
    f12a:	4824      	ldr	r0, [pc, #144]	; (f1bc <z_add_timeout+0xec>)
	sys_dnode_t *const tail = list->tail;
    f12c:	e9d0 3c00 	ldrd	r3, ip, [r0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f130:	4283      	cmp	r3, r0
    f132:	d118      	bne.n	f166 <z_add_timeout+0x96>
	node->prev = tail;
    f134:	e9c4 0c00 	strd	r0, ip, [r4]
	tail->next = node;
    f138:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
    f13c:	6044      	str	r4, [r0, #4]
}
    f13e:	e026      	b.n	f18e <z_add_timeout+0xbe>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    f140:	f7ff ff7a 	bl	f038 <elapsed>
    f144:	3501      	adds	r5, #1
    f146:	f147 0700 	adc.w	r7, r7, #0
    f14a:	182d      	adds	r5, r5, r0
    f14c:	eb47 77e0 	adc.w	r7, r7, r0, asr #31
    f150:	e9c4 5704 	strd	r5, r7, [r4, #16]
    f154:	e7e9      	b.n	f12a <z_add_timeout+0x5a>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
    f156:	1a52      	subs	r2, r2, r1
    f158:	eb65 0507 	sbc.w	r5, r5, r7
	return (node == list->tail) ? NULL : node->next;
    f15c:	459c      	cmp	ip, r3
    f15e:	e9c4 2504 	strd	r2, r5, [r4, #16]
    f162:	d0e7      	beq.n	f134 <z_add_timeout+0x64>
    f164:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
    f166:	2b00      	cmp	r3, #0
    f168:	d0e4      	beq.n	f134 <z_add_timeout+0x64>
			if (t->dticks > to->dticks) {
    f16a:	e9d3 1704 	ldrd	r1, r7, [r3, #16]
    f16e:	e9d4 2504 	ldrd	r2, r5, [r4, #16]
    f172:	428a      	cmp	r2, r1
    f174:	eb75 0e07 	sbcs.w	lr, r5, r7
    f178:	daed      	bge.n	f156 <z_add_timeout+0x86>
				t->dticks -= to->dticks;
    f17a:	1a8a      	subs	r2, r1, r2
    f17c:	eb67 0505 	sbc.w	r5, r7, r5
    f180:	e9c3 2504 	strd	r2, r5, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
    f184:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    f186:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
    f18a:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    f18c:	605c      	str	r4, [r3, #4]
	return list->head == list;
    f18e:	6803      	ldr	r3, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f190:	4283      	cmp	r3, r0
    f192:	d00b      	beq.n	f1ac <z_add_timeout+0xdc>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    f194:	429c      	cmp	r4, r3
    f196:	d109      	bne.n	f1ac <z_add_timeout+0xdc>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    f198:	f7ff ff58 	bl	f04c <next_timeout>

			if (next_time == 0 ||
    f19c:	b118      	cbz	r0, f1a6 <z_add_timeout+0xd6>
			    _current_cpu->slice_ticks != next_time) {
    f19e:	4b08      	ldr	r3, [pc, #32]	; (f1c0 <z_add_timeout+0xf0>)
			if (next_time == 0 ||
    f1a0:	691b      	ldr	r3, [r3, #16]
    f1a2:	4283      	cmp	r3, r0
    f1a4:	d002      	beq.n	f1ac <z_add_timeout+0xdc>
				sys_clock_set_timeout(next_time, false);
    f1a6:	2100      	movs	r1, #0
    f1a8:	f7fe fa98 	bl	d6dc <sys_clock_set_timeout>
	__asm__ volatile(
    f1ac:	f386 8811 	msr	BASEPRI, r6
    f1b0:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    f1b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f1b6:	bf00      	nop
    f1b8:	20000960 	.word	0x20000960
    f1bc:	20000568 	.word	0x20000568
    f1c0:	200026a0 	.word	0x200026a0

0000f1c4 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
    f1c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f1c8:	4605      	mov	r5, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    f1ca:	f7ff fcbf 	bl	eb4c <z_time_slice>
	__asm__ volatile(
    f1ce:	f04f 0320 	mov.w	r3, #32
    f1d2:	f3ef 8411 	mrs	r4, BASEPRI
    f1d6:	f383 8812 	msr	BASEPRI_MAX, r3
    f1da:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    f1de:	4e24      	ldr	r6, [pc, #144]	; (f270 <sys_clock_announce+0xac>)
	return list->head == list;
    f1e0:	f8df 8090 	ldr.w	r8, [pc, #144]	; f274 <sys_clock_announce+0xb0>
    f1e4:	6035      	str	r5, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    f1e6:	4d24      	ldr	r5, [pc, #144]	; (f278 <sys_clock_announce+0xb4>)
    f1e8:	f8d8 0000 	ldr.w	r0, [r8]
	while (first() != NULL && first()->dticks <= announce_remaining) {
    f1ec:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f1ee:	4540      	cmp	r0, r8
		curr_tick += dt;
    f1f0:	e9d5 1e00 	ldrd	r1, lr, [r5]
    f1f4:	ea4f 77e2 	mov.w	r7, r2, asr #31
    f1f8:	d00b      	beq.n	f212 <sys_clock_announce+0x4e>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    f1fa:	b150      	cbz	r0, f212 <sys_clock_announce+0x4e>
    f1fc:	e9d0 3c04 	ldrd	r3, ip, [r0, #16]
    f200:	429a      	cmp	r2, r3
    f202:	eb77 090c 	sbcs.w	r9, r7, ip
    f206:	da16      	bge.n	f236 <sys_clock_announce+0x72>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    f208:	1a9b      	subs	r3, r3, r2
    f20a:	eb6c 0c07 	sbc.w	ip, ip, r7
    f20e:	e9c0 3c04 	strd	r3, ip, [r0, #16]
	}

	curr_tick += announce_remaining;
    f212:	1852      	adds	r2, r2, r1
    f214:	eb4e 0707 	adc.w	r7, lr, r7
    f218:	e9c5 2700 	strd	r2, r7, [r5]
	announce_remaining = 0;
    f21c:	2500      	movs	r5, #0
    f21e:	6035      	str	r5, [r6, #0]

	sys_clock_set_timeout(next_timeout(), false);
    f220:	f7ff ff14 	bl	f04c <next_timeout>
    f224:	4629      	mov	r1, r5
    f226:	f7fe fa59 	bl	d6dc <sys_clock_set_timeout>
	__asm__ volatile(
    f22a:	f384 8811 	msr	BASEPRI, r4
    f22e:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    f232:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		curr_tick += dt;
    f236:	1859      	adds	r1, r3, r1
    f238:	eb4e 77e3 	adc.w	r7, lr, r3, asr #31
		announce_remaining -= dt;
    f23c:	1ad3      	subs	r3, r2, r3
    f23e:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
    f240:	2200      	movs	r2, #0
    f242:	2300      	movs	r3, #0
    f244:	e9c0 2304 	strd	r2, r3, [r0, #16]
		curr_tick += dt;
    f248:	e9c5 1700 	strd	r1, r7, [r5]
		remove_timeout(t);
    f24c:	f7ff ff26 	bl	f09c <remove_timeout>
    f250:	f384 8811 	msr	BASEPRI, r4
    f254:	f3bf 8f6f 	isb	sy
		t->fn(t);
    f258:	6883      	ldr	r3, [r0, #8]
    f25a:	4798      	blx	r3
	__asm__ volatile(
    f25c:	f04f 0320 	mov.w	r3, #32
    f260:	f3ef 8411 	mrs	r4, BASEPRI
    f264:	f383 8812 	msr	BASEPRI_MAX, r3
    f268:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    f26c:	e7bc      	b.n	f1e8 <sys_clock_announce+0x24>
    f26e:	bf00      	nop
    f270:	200026dc 	.word	0x200026dc
    f274:	20000568 	.word	0x20000568
    f278:	20000960 	.word	0x20000960

0000f27c <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    f27c:	b510      	push	{r4, lr}
    f27e:	f04f 0320 	mov.w	r3, #32
    f282:	f3ef 8411 	mrs	r4, BASEPRI
    f286:	f383 8812 	msr	BASEPRI_MAX, r3
    f28a:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
    f28e:	f7fe fa57 	bl	d740 <sys_clock_elapsed>
    f292:	4a05      	ldr	r2, [pc, #20]	; (f2a8 <sys_clock_tick_get+0x2c>)
    f294:	e9d2 3100 	ldrd	r3, r1, [r2]
    f298:	18c0      	adds	r0, r0, r3
    f29a:	f141 0100 	adc.w	r1, r1, #0
	__asm__ volatile(
    f29e:	f384 8811 	msr	BASEPRI, r4
    f2a2:	f3bf 8f6f 	isb	sy
	}
	return t;
}
    f2a6:	bd10      	pop	{r4, pc}
    f2a8:	20000960 	.word	0x20000960

0000f2ac <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
    f2ac:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    f2b0:	461d      	mov	r5, r3
	int events_registered;
	k_spinlock_key_t key;
	struct z_poller *poller = &_current->poller;
    f2b2:	4b29      	ldr	r3, [pc, #164]	; (f358 <z_impl_k_poll+0xac>)
    f2b4:	689f      	ldr	r7, [r3, #8]

	poller->is_polling = true;
    f2b6:	2301      	movs	r3, #1
    f2b8:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
	poller->mode = MODE_POLL;
    f2bc:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	SYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);

	events_registered = register_events(events, num_events, poller,
    f2c0:	ea52 0305 	orrs.w	r3, r2, r5
{
    f2c4:	4616      	mov	r6, r2
	events_registered = register_events(events, num_events, poller,
    f2c6:	bf0c      	ite	eq
    f2c8:	2301      	moveq	r3, #1
    f2ca:	2300      	movne	r3, #0
    f2cc:	f107 0260 	add.w	r2, r7, #96	; 0x60
{
    f2d0:	4680      	mov	r8, r0
	events_registered = register_events(events, num_events, poller,
    f2d2:	f003 fc23 	bl	12b1c <register_events>
    f2d6:	4681      	mov	r9, r0
	__asm__ volatile(
    f2d8:	f04f 0320 	mov.w	r3, #32
    f2dc:	f3ef 8a11 	mrs	sl, BASEPRI
    f2e0:	f383 8812 	msr	BASEPRI_MAX, r3
    f2e4:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller->is_polling) {
    f2e8:	f897 4060 	ldrb.w	r4, [r7, #96]	; 0x60
    f2ec:	b964      	cbnz	r4, f308 <z_impl_k_poll+0x5c>
		clear_event_registrations(events, events_registered, key);
    f2ee:	4601      	mov	r1, r0
    f2f0:	4652      	mov	r2, sl
    f2f2:	4640      	mov	r0, r8
    f2f4:	f003 fce3 	bl	12cbe <clear_event_registrations>
	__asm__ volatile(
    f2f8:	f38a 8811 	msr	BASEPRI, sl
    f2fc:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);

	return swap_rc;
}
    f300:	4620      	mov	r0, r4
    f302:	b002      	add	sp, #8
    f304:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	poller->is_polling = false;
    f308:	2300      	movs	r3, #0
    f30a:	f887 3060 	strb.w	r3, [r7, #96]	; 0x60
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    f30e:	ea56 0305 	orrs.w	r3, r6, r5
    f312:	d106      	bne.n	f322 <z_impl_k_poll+0x76>
    f314:	f38a 8811 	msr	BASEPRI, sl
    f318:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
    f31c:	f06f 040a 	mvn.w	r4, #10
    f320:	e7ee      	b.n	f300 <z_impl_k_poll+0x54>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
    f322:	e9cd 6500 	strd	r6, r5, [sp]
    f326:	4a0d      	ldr	r2, [pc, #52]	; (f35c <z_impl_k_poll+0xb0>)
    f328:	480d      	ldr	r0, [pc, #52]	; (f360 <z_impl_k_poll+0xb4>)
    f32a:	4651      	mov	r1, sl
    f32c:	f7ff fce0 	bl	ecf0 <z_pend_curr>
    f330:	4604      	mov	r4, r0
	__asm__ volatile(
    f332:	f04f 0320 	mov.w	r3, #32
    f336:	f3ef 8511 	mrs	r5, BASEPRI
    f33a:	f383 8812 	msr	BASEPRI_MAX, r3
    f33e:	f3bf 8f6f 	isb	sy
	clear_event_registrations(events, events_registered, key);
    f342:	462a      	mov	r2, r5
    f344:	4649      	mov	r1, r9
    f346:	4640      	mov	r0, r8
    f348:	f003 fcb9 	bl	12cbe <clear_event_registrations>
	__asm__ volatile(
    f34c:	f385 8811 	msr	BASEPRI, r5
    f350:	f3bf 8f6f 	isb	sy
	return swap_rc;
    f354:	e7d4      	b.n	f300 <z_impl_k_poll+0x54>
    f356:	bf00      	nop
    f358:	200026a0 	.word	0x200026a0
    f35c:	20000570 	.word	0x20000570
    f360:	20002e8d 	.word	0x20002e8d

0000f364 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)
{
    f364:	b538      	push	{r3, r4, r5, lr}
    f366:	4603      	mov	r3, r0
	__asm__ volatile(
    f368:	f04f 0220 	mov.w	r2, #32
    f36c:	f3ef 8511 	mrs	r5, BASEPRI
    f370:	f382 8812 	msr	BASEPRI_MAX, r2
    f374:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	sig->result = result;
    f378:	60c1      	str	r1, [r0, #12]
	sig->signaled = 1U;
    f37a:	2101      	movs	r1, #1
    f37c:	6081      	str	r1, [r0, #8]
	return list->head == list;
    f37e:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
    f380:	4283      	cmp	r3, r0
    f382:	d106      	bne.n	f392 <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
    f384:	f385 8811 	msr	BASEPRI, r5
    f388:	f3bf 8f6f 	isb	sy
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);

		return 0;
    f38c:	2400      	movs	r4, #0

	SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);

	z_reschedule(&lock, key);
	return rc;
}
    f38e:	4620      	mov	r0, r4
    f390:	bd38      	pop	{r3, r4, r5, pc}
	sys_dnode_t *const next = node->next;
    f392:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
    f396:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    f398:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    f39a:	2300      	movs	r3, #0
	node->prev = NULL;
    f39c:	e9c0 3300 	strd	r3, r3, [r0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
    f3a0:	f003 fc33 	bl	12c0a <signal_poll_event>
	z_reschedule(&lock, key);
    f3a4:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
    f3a6:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
    f3a8:	4801      	ldr	r0, [pc, #4]	; (f3b0 <z_impl_k_poll_signal_raise+0x4c>)
    f3aa:	f7ff fb4f 	bl	ea4c <z_reschedule>
	return rc;
    f3ae:	e7ee      	b.n	f38e <z_impl_k_poll_signal_raise+0x2a>
    f3b0:	20002e8d 	.word	0x20002e8d

0000f3b4 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
    f3b4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    f3b6:	4606      	mov	r6, r0
    f3b8:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
    f3ba:	f003 f88c 	bl	124d6 <k_is_in_isr>
    f3be:	b978      	cbnz	r0, f3e0 <z_thread_aligned_alloc+0x2c>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
    f3c0:	4b0b      	ldr	r3, [pc, #44]	; (f3f0 <z_thread_aligned_alloc+0x3c>)
    f3c2:	689b      	ldr	r3, [r3, #8]
    f3c4:	6f5c      	ldr	r4, [r3, #116]	; 0x74
	}

	if (heap != NULL) {
    f3c6:	b17c      	cbz	r4, f3e8 <z_thread_aligned_alloc+0x34>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
    f3c8:	1d2a      	adds	r2, r5, #4
    f3ca:	d209      	bcs.n	f3e0 <z_thread_aligned_alloc+0x2c>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
    f3cc:	2000      	movs	r0, #0
    f3ce:	2100      	movs	r1, #0
    f3d0:	e9cd 0100 	strd	r0, r1, [sp]
    f3d4:	f046 0104 	orr.w	r1, r6, #4
    f3d8:	4620      	mov	r0, r4
    f3da:	f003 f81e 	bl	1241a <k_heap_aligned_alloc>
	if (mem == NULL) {
    f3de:	b908      	cbnz	r0, f3e4 <z_thread_aligned_alloc+0x30>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
    f3e0:	2400      	movs	r4, #0
	}

	return ret;
    f3e2:	e001      	b.n	f3e8 <z_thread_aligned_alloc+0x34>
	*heap_ref = heap;
    f3e4:	6004      	str	r4, [r0, #0]
	mem = ++heap_ref;
    f3e6:	1d04      	adds	r4, r0, #4
}
    f3e8:	4620      	mov	r0, r4
    f3ea:	b002      	add	sp, #8
    f3ec:	bd70      	pop	{r4, r5, r6, pc}
    f3ee:	bf00      	nop
    f3f0:	200026a0 	.word	0x200026a0

0000f3f4 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    f3f4:	4a02      	ldr	r2, [pc, #8]	; (f400 <boot_banner+0xc>)
    f3f6:	4903      	ldr	r1, [pc, #12]	; (f404 <boot_banner+0x10>)
    f3f8:	4803      	ldr	r0, [pc, #12]	; (f408 <boot_banner+0x14>)
    f3fa:	f000 b864 	b.w	f4c6 <printk>
    f3fe:	bf00      	nop
    f400:	000132ce 	.word	0x000132ce
    f404:	000140d3 	.word	0x000140d3
    f408:	000140ee 	.word	0x000140ee

0000f40c <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
    f40c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
    f40e:	4b09      	ldr	r3, [pc, #36]	; (f434 <k_sys_work_q_init+0x28>)
    f410:	9302      	str	r3, [sp, #8]
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
    f412:	ab02      	add	r3, sp, #8
	struct k_work_queue_config cfg = {
    f414:	2400      	movs	r4, #0
	k_work_queue_start(&k_sys_work_q,
    f416:	9300      	str	r3, [sp, #0]
    f418:	4907      	ldr	r1, [pc, #28]	; (f438 <k_sys_work_q_init+0x2c>)
    f41a:	4808      	ldr	r0, [pc, #32]	; (f43c <k_sys_work_q_init+0x30>)
	struct k_work_queue_config cfg = {
    f41c:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
    f420:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    f424:	f44f 6280 	mov.w	r2, #1024	; 0x400
    f428:	f7ff fa62 	bl	e8f0 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
    f42c:	4620      	mov	r0, r4
    f42e:	b004      	add	sp, #16
    f430:	bd10      	pop	{r4, pc}
    f432:	bf00      	nop
    f434:	00014115 	.word	0x00014115
    f438:	200044e0 	.word	0x200044e0
    f43c:	20000968 	.word	0x20000968

0000f440 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
    f440:	4770      	bx	lr

0000f442 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
    f442:	4603      	mov	r3, r0
    f444:	b140      	cbz	r0, f458 <sys_notify_validate+0x16>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    f446:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    f448:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
    f44c:	2a02      	cmp	r2, #2
    f44e:	d006      	beq.n	f45e <sys_notify_validate+0x1c>
    f450:	2a03      	cmp	r2, #3
    f452:	d004      	beq.n	f45e <sys_notify_validate+0x1c>
    f454:	2a01      	cmp	r2, #1
    f456:	d005      	beq.n	f464 <sys_notify_validate+0x22>
		return -EINVAL;
    f458:	f06f 0015 	mvn.w	r0, #21
	if (rv == 0) {
		notify->result = 0;
	}

	return rv;
}
    f45c:	4770      	bx	lr
		if (notify->method.signal == NULL) {
    f45e:	681a      	ldr	r2, [r3, #0]
    f460:	2a00      	cmp	r2, #0
    f462:	d0f9      	beq.n	f458 <sys_notify_validate+0x16>
		notify->result = 0;
    f464:	2000      	movs	r0, #0
    f466:	6098      	str	r0, [r3, #8]
    f468:	4770      	bx	lr

0000f46a <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    f46a:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    f46c:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
    f470:	2a02      	cmp	r2, #2
{
    f472:	b510      	push	{r4, lr}
    f474:	4603      	mov	r3, r0
	notify->result = res;
    f476:	6081      	str	r1, [r0, #8]
	switch (method) {
    f478:	d00a      	beq.n	f490 <sys_notify_finalize+0x26>
    f47a:	2a03      	cmp	r2, #3
    f47c:	d10b      	bne.n	f496 <sys_notify_finalize+0x2c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
    f47e:	6804      	ldr	r4, [r0, #0]
	struct k_poll_signal *sig = NULL;
    f480:	2000      	movs	r0, #0
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
    f482:	2200      	movs	r2, #0
    f484:	605a      	str	r2, [r3, #4]

	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
    f486:	b108      	cbz	r0, f48c <sys_notify_finalize+0x22>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sig, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
    f488:	f7ff ff6c 	bl	f364 <z_impl_k_poll_signal_raise>
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
    f48c:	4620      	mov	r0, r4
    f48e:	bd10      	pop	{r4, pc}
		sig = notify->method.signal;
    f490:	6800      	ldr	r0, [r0, #0]
	sys_notify_generic_callback rv = NULL;
    f492:	2400      	movs	r4, #0
		break;
    f494:	e7f5      	b.n	f482 <sys_notify_finalize+0x18>
	switch (method) {
    f496:	2400      	movs	r4, #0
    f498:	4620      	mov	r0, r4
    f49a:	e7f2      	b.n	f482 <sys_notify_finalize+0x18>

0000f49c <arch_printk_char_out>:
}
    f49c:	2000      	movs	r0, #0
    f49e:	4770      	bx	lr

0000f4a0 <str_out>:
{
    f4a0:	b530      	push	{r4, r5, lr}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    f4a2:	688a      	ldr	r2, [r1, #8]
    f4a4:	680c      	ldr	r4, [r1, #0]
		ctx->str[ctx->count++] = '\0';
    f4a6:	1c55      	adds	r5, r2, #1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    f4a8:	b114      	cbz	r4, f4b0 <str_out+0x10>
    f4aa:	684b      	ldr	r3, [r1, #4]
    f4ac:	4293      	cmp	r3, r2
    f4ae:	dc01      	bgt.n	f4b4 <str_out+0x14>
		ctx->count++;
    f4b0:	608d      	str	r5, [r1, #8]
}
    f4b2:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
    f4b4:	3b01      	subs	r3, #1
    f4b6:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
    f4b8:	bf08      	it	eq
    f4ba:	2200      	moveq	r2, #0
    f4bc:	608d      	str	r5, [r1, #8]
    f4be:	bf0c      	ite	eq
    f4c0:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
    f4c2:	54a0      	strbne	r0, [r4, r2]
    f4c4:	e7f5      	b.n	f4b2 <str_out+0x12>

0000f4c6 <printk>:
{
    f4c6:	b40f      	push	{r0, r1, r2, r3}
    f4c8:	b507      	push	{r0, r1, r2, lr}
    f4ca:	a904      	add	r1, sp, #16
    f4cc:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
    f4d0:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
    f4d2:	f7f2 fa09 	bl	18e8 <vprintk>
}
    f4d6:	b003      	add	sp, #12
    f4d8:	f85d eb04 	ldr.w	lr, [sp], #4
    f4dc:	b004      	add	sp, #16
    f4de:	4770      	bx	lr

0000f4e0 <snprintk>:
{
    f4e0:	b40c      	push	{r2, r3}
    f4e2:	b507      	push	{r0, r1, r2, lr}
    f4e4:	ab04      	add	r3, sp, #16
    f4e6:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
    f4ea:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
    f4ec:	f7f2 fa0a 	bl	1904 <vsnprintk>
}
    f4f0:	b003      	add	sp, #12
    f4f2:	f85d eb04 	ldr.w	lr, [sp], #4
    f4f6:	b002      	add	sp, #8
    f4f8:	4770      	bx	lr

0000f4fa <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    f4fa:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
    f4fc:	f013 0307 	ands.w	r3, r3, #7
    f500:	d105      	bne.n	f50e <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
    f502:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
    f504:	2b00      	cmp	r3, #0
    f506:	bf0c      	ite	eq
    f508:	2000      	moveq	r0, #0
    f50a:	2003      	movne	r0, #3
    f50c:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
    f50e:	2b02      	cmp	r3, #2
    f510:	d105      	bne.n	f51e <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
    f512:	8b43      	ldrh	r3, [r0, #26]
		evt = EVT_STOP;
    f514:	2b00      	cmp	r3, #0
    f516:	bf14      	ite	ne
    f518:	2000      	movne	r0, #0
    f51a:	2004      	moveq	r0, #4
    f51c:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
    f51e:	2b01      	cmp	r3, #1
    f520:	d105      	bne.n	f52e <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
    f522:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
    f524:	2b00      	cmp	r3, #0
    f526:	bf0c      	ite	eq
    f528:	2000      	moveq	r0, #0
    f52a:	2005      	movne	r0, #5
    f52c:	4770      	bx	lr
	int evt = EVT_NOP;
    f52e:	2000      	movs	r0, #0
}
    f530:	4770      	bx	lr

0000f532 <notify_one>:
{
    f532:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f536:	460d      	mov	r5, r1
    f538:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    f53a:	4619      	mov	r1, r3
    f53c:	1d28      	adds	r0, r5, #4
{
    f53e:	4690      	mov	r8, r2
    f540:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    f542:	f7ff ff92 	bl	f46a <sys_notify_finalize>
	if (cb) {
    f546:	4604      	mov	r4, r0
    f548:	b138      	cbz	r0, f55a <notify_one+0x28>
		cb(mgr, cli, state, res);
    f54a:	4633      	mov	r3, r6
    f54c:	4642      	mov	r2, r8
    f54e:	4629      	mov	r1, r5
    f550:	4638      	mov	r0, r7
    f552:	46a4      	mov	ip, r4
}
    f554:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
    f558:	4760      	bx	ip
}
    f55a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000f55e <transition_complete>:
{
    f55e:	b410      	push	{r4}
	__asm__ volatile(
    f560:	f04f 0420 	mov.w	r4, #32
    f564:	f3ef 8211 	mrs	r2, BASEPRI
    f568:	f384 8812 	msr	BASEPRI_MAX, r4
    f56c:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
    f570:	6141      	str	r1, [r0, #20]
}
    f572:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
    f574:	2101      	movs	r1, #1
    f576:	f7f2 b9d9 	b.w	192c <process_event>

0000f57a <validate_args>:
{
    f57a:	b510      	push	{r4, lr}
    f57c:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
    f57e:	b140      	cbz	r0, f592 <validate_args+0x18>
    f580:	b139      	cbz	r1, f592 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
    f582:	1d08      	adds	r0, r1, #4
    f584:	f7ff ff5d 	bl	f442 <sys_notify_validate>
	if ((rv == 0)
    f588:	b928      	cbnz	r0, f596 <validate_args+0x1c>
	    && ((cli->notify.flags
    f58a:	68a3      	ldr	r3, [r4, #8]
    f58c:	f033 0303 	bics.w	r3, r3, #3
    f590:	d001      	beq.n	f596 <validate_args+0x1c>
		rv = -EINVAL;
    f592:	f06f 0015 	mvn.w	r0, #21
}
    f596:	bd10      	pop	{r4, pc}

0000f598 <onoff_manager_init>:
{
    f598:	b538      	push	{r3, r4, r5, lr}
    f59a:	460c      	mov	r4, r1
	if ((mgr == NULL)
    f59c:	4605      	mov	r5, r0
    f59e:	b158      	cbz	r0, f5b8 <onoff_manager_init+0x20>
	    || (transitions == NULL)
    f5a0:	b151      	cbz	r1, f5b8 <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
    f5a2:	680b      	ldr	r3, [r1, #0]
    f5a4:	b143      	cbz	r3, f5b8 <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
    f5a6:	684b      	ldr	r3, [r1, #4]
    f5a8:	b133      	cbz	r3, f5b8 <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
    f5aa:	221c      	movs	r2, #28
    f5ac:	2100      	movs	r1, #0
    f5ae:	f000 fb05 	bl	fbbc <memset>
    f5b2:	612c      	str	r4, [r5, #16]
	return 0;
    f5b4:	2000      	movs	r0, #0
}
    f5b6:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    f5b8:	f06f 0015 	mvn.w	r0, #21
    f5bc:	e7fb      	b.n	f5b6 <onoff_manager_init+0x1e>

0000f5be <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
    f5be:	b570      	push	{r4, r5, r6, lr}
    f5c0:	4604      	mov	r4, r0
    f5c2:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
    f5c4:	f7ff ffd9 	bl	f57a <validate_args>

	if (rv < 0) {
    f5c8:	1e05      	subs	r5, r0, #0
    f5ca:	db31      	blt.n	f630 <onoff_request+0x72>
    f5cc:	f04f 0320 	mov.w	r3, #32
    f5d0:	f3ef 8111 	mrs	r1, BASEPRI
    f5d4:	f383 8812 	msr	BASEPRI_MAX, r3
    f5d8:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
    f5dc:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    f5de:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
    f5e0:	f64f 75ff 	movw	r5, #65535	; 0xffff
    f5e4:	42ab      	cmp	r3, r5
    f5e6:	f000 0207 	and.w	r2, r0, #7
    f5ea:	d02e      	beq.n	f64a <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
    f5ec:	2a02      	cmp	r2, #2
    f5ee:	d10e      	bne.n	f60e <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
    f5f0:	3301      	adds	r3, #1
    f5f2:	8363      	strh	r3, [r4, #26]
	rv = state;
    f5f4:	4615      	mov	r5, r2
		notify = true;
    f5f6:	2301      	movs	r3, #1
	__asm__ volatile(
    f5f8:	f381 8811 	msr	BASEPRI, r1
    f5fc:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
    f600:	b1b3      	cbz	r3, f630 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
    f602:	2300      	movs	r3, #0
    f604:	4631      	mov	r1, r6
    f606:	4620      	mov	r0, r4
    f608:	f7ff ff93 	bl	f532 <notify_one>
    f60c:	e010      	b.n	f630 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
    f60e:	0783      	lsls	r3, r0, #30
    f610:	d001      	beq.n	f616 <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
    f612:	2a06      	cmp	r2, #6
    f614:	d10e      	bne.n	f634 <onoff_request+0x76>
	parent->next = child;
    f616:	2300      	movs	r3, #0
    f618:	6033      	str	r3, [r6, #0]
	return list->tail;
    f61a:	6863      	ldr	r3, [r4, #4]
Z_GENLIST_APPEND(slist, snode)
    f61c:	b993      	cbnz	r3, f644 <onoff_request+0x86>
	list->head = node;
    f61e:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
    f622:	4615      	mov	r5, r2
    f624:	b962      	cbnz	r2, f640 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
    f626:	460a      	mov	r2, r1
    f628:	4620      	mov	r0, r4
    f62a:	2102      	movs	r1, #2
    f62c:	f7f2 f97e 	bl	192c <process_event>
		}
	}

	return rv;
}
    f630:	4628      	mov	r0, r5
    f632:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
    f634:	2a05      	cmp	r2, #5
    f636:	bf0c      	ite	eq
    f638:	f06f 0585 	mvneq.w	r5, #133	; 0x85
    f63c:	f06f 0504 	mvnne.w	r5, #4
    f640:	2300      	movs	r3, #0
    f642:	e7d9      	b.n	f5f8 <onoff_request+0x3a>
	parent->next = child;
    f644:	601e      	str	r6, [r3, #0]
	list->tail = node;
    f646:	6066      	str	r6, [r4, #4]
}
    f648:	e7eb      	b.n	f622 <onoff_request+0x64>
		rv = -EAGAIN;
    f64a:	f06f 050a 	mvn.w	r5, #10
    f64e:	e7f7      	b.n	f640 <onoff_request+0x82>

0000f650 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    f650:	4604      	mov	r4, r0
    f652:	b508      	push	{r3, lr}
    f654:	4608      	mov	r0, r1
    f656:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    f658:	461a      	mov	r2, r3
    f65a:	47a0      	blx	r4
	return z_impl_z_current_get();
    f65c:	f7ff fc58 	bl	ef10 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
    f660:	f7f3 f99a 	bl	2998 <z_impl_k_thread_abort>

0000f664 <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
    f664:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
    f668:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
    f66a:	0840      	lsrs	r0, r0, #1
    f66c:	4770      	bx	lr

0000f66e <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    f66e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f670:	4603      	mov	r3, r0
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
    f672:	f7ff fff7 	bl	f664 <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
    f676:	fab0 f080 	clz	r0, r0
    f67a:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
    f67e:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
	void *cmem = &buf[c];
    f682:	00ca      	lsls	r2, r1, #3
    f684:	f8dc 6010 	ldr.w	r6, [ip, #16]
		((uint16_t *)cmem)[f] = val;
    f688:	1d17      	adds	r7, r2, #4
{
    f68a:	460c      	mov	r4, r1
    f68c:	3206      	adds	r2, #6
    f68e:	b28d      	uxth	r5, r1
	if (b->next == 0U) {
    f690:	b956      	cbnz	r6, f6a8 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
    f692:	2101      	movs	r1, #1
    f694:	fa01 f000 	lsl.w	r0, r1, r0
    f698:	68d9      	ldr	r1, [r3, #12]
    f69a:	4301      	orrs	r1, r0
    f69c:	60d9      	str	r1, [r3, #12]
		b->next = c;
    f69e:	f8cc 4010 	str.w	r4, [ip, #16]
    f6a2:	53dd      	strh	r5, [r3, r7]
    f6a4:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
    f6a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
    f6a8:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
    f6aa:	3104      	adds	r1, #4
    f6ac:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
    f6ae:	53d8      	strh	r0, [r3, r7]
    f6b0:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    f6b4:	529e      	strh	r6, [r3, r2]
    f6b6:	80c5      	strh	r5, [r0, #6]
    f6b8:	525d      	strh	r5, [r3, r1]
    f6ba:	e7f4      	b.n	f6a6 <free_list_add+0x38>

0000f6bc <free_list_remove_bidx>:
{
    f6bc:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
    f6be:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
    f6c2:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
    f6c4:	4299      	cmp	r1, r3
    f6c6:	f102 0104 	add.w	r1, r2, #4
    f6ca:	d10a      	bne.n	f6e2 <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
    f6cc:	2301      	movs	r3, #1
    f6ce:	fa03 f202 	lsl.w	r2, r3, r2
    f6d2:	68c3      	ldr	r3, [r0, #12]
    f6d4:	ea23 0302 	bic.w	r3, r3, r2
    f6d8:	60c3      	str	r3, [r0, #12]
		b->next = 0;
    f6da:	2300      	movs	r3, #0
    f6dc:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
    f6e0:	bd10      	pop	{r4, pc}
    f6e2:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
    f6e4:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
    f6e8:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
    f6ec:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
    f6f0:	80cb      	strh	r3, [r1, #6]
    f6f2:	8082      	strh	r2, [r0, #4]
}
    f6f4:	e7f4      	b.n	f6e0 <free_list_remove_bidx+0x24>

0000f6f6 <free_list_remove>:
{
    f6f6:	b508      	push	{r3, lr}
    f6f8:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
    f6fa:	f7ff ffb3 	bl	f664 <chunk_size>
	return 31 - __builtin_clz(usable_sz);
    f6fe:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
    f702:	f1c2 021f 	rsb	r2, r2, #31
    f706:	4618      	mov	r0, r3
}
    f708:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		free_list_remove_bidx(h, c, bidx);
    f70c:	f7ff bfd6 	b.w	f6bc <free_list_remove_bidx>

0000f710 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
    f710:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f714:	fab1 f581 	clz	r5, r1
    f718:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
    f71c:	eb00 0789 	add.w	r7, r0, r9, lsl #2
{
    f720:	4603      	mov	r3, r0
	if (b->next) {
    f722:	693a      	ldr	r2, [r7, #16]
{
    f724:	460e      	mov	r6, r1
	if (b->next) {
    f726:	b1c2      	cbz	r2, f75a <alloc_chunk+0x4a>
    f728:	f04f 0803 	mov.w	r8, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
    f72c:	693c      	ldr	r4, [r7, #16]
			if (chunk_size(h, c) >= sz) {
    f72e:	4618      	mov	r0, r3
    f730:	4621      	mov	r1, r4
    f732:	f7ff ff97 	bl	f664 <chunk_size>
    f736:	42b0      	cmp	r0, r6
    f738:	d306      	bcc.n	f748 <alloc_chunk+0x38>
				free_list_remove_bidx(h, c, bi);
    f73a:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
    f73c:	4618      	mov	r0, r3
    f73e:	f7ff ffbd 	bl	f6bc <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
    f742:	4620      	mov	r0, r4
    f744:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
    f748:	eb03 00c4 	add.w	r0, r3, r4, lsl #3
		} while (--i && b->next != first);
    f74c:	f1b8 0801 	subs.w	r8, r8, #1
    f750:	88c0      	ldrh	r0, [r0, #6]
			b->next = next_free_chunk(h, c);
    f752:	6138      	str	r0, [r7, #16]
		} while (--i && b->next != first);
    f754:	d001      	beq.n	f75a <alloc_chunk+0x4a>
    f756:	4282      	cmp	r2, r0
    f758:	d1e8      	bne.n	f72c <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
    f75a:	f1c5 0220 	rsb	r2, r5, #32
    f75e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    f762:	4094      	lsls	r4, r2
    f764:	68da      	ldr	r2, [r3, #12]
	if (bmask != 0U) {
    f766:	4014      	ands	r4, r2
    f768:	d0eb      	beq.n	f742 <alloc_chunk+0x32>
		int minbucket = __builtin_ctz(bmask);
    f76a:	fa94 f2a4 	rbit	r2, r4
    f76e:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
    f772:	1d11      	adds	r1, r2, #4
    f774:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
    f778:	4621      	mov	r1, r4
    f77a:	e7df      	b.n	f73c <alloc_chunk+0x2c>

0000f77c <merge_chunks>:
{
    f77c:	b538      	push	{r3, r4, r5, lr}
    f77e:	4603      	mov	r3, r0
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    f780:	f7ff ff70 	bl	f664 <chunk_size>
{
    f784:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    f786:	4604      	mov	r4, r0
    f788:	4611      	mov	r1, r2
    f78a:	4618      	mov	r0, r3
    f78c:	f7ff ff6a 	bl	f664 <chunk_size>
		((uint16_t *)cmem)[f] = val;
    f790:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
    f794:	4404      	add	r4, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    f796:	0060      	lsls	r0, r4, #1
		((uint16_t *)cmem)[f] = val;
    f798:	8068      	strh	r0, [r5, #2]
	return c + chunk_size(h, c);
    f79a:	4618      	mov	r0, r3
    f79c:	f7ff ff62 	bl	f664 <chunk_size>
	void *cmem = &buf[c];
    f7a0:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
    f7a2:	f823 4031 	strh.w	r4, [r3, r1, lsl #3]
}
    f7a6:	bd38      	pop	{r3, r4, r5, pc}

0000f7a8 <split_chunks>:
{
    f7a8:	b538      	push	{r3, r4, r5, lr}
    f7aa:	4603      	mov	r3, r0
	chunksz_t sz0 = chunk_size(h, lc);
    f7ac:	f7ff ff5a 	bl	f664 <chunk_size>
{
    f7b0:	460c      	mov	r4, r1
	chunksz_t rsz = sz0 - lsz;
    f7b2:	1aa5      	subs	r5, r4, r2
	chunksz_t lsz = rc - lc;
    f7b4:	1a51      	subs	r1, r2, r1
    f7b6:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunksz_t rsz = sz0 - lsz;
    f7ba:	4405      	add	r5, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    f7bc:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
    f7be:	8060      	strh	r0, [r4, #2]
    f7c0:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    f7c4:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
    f7c6:	8044      	strh	r4, [r0, #2]
    f7c8:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
    f7cc:	4618      	mov	r0, r3
    f7ce:	4611      	mov	r1, r2
    f7d0:	f7ff ff48 	bl	f664 <chunk_size>
	void *cmem = &buf[c];
    f7d4:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
    f7d6:	f823 5031 	strh.w	r5, [r3, r1, lsl #3]
}
    f7da:	bd38      	pop	{r3, r4, r5, pc}

0000f7dc <free_chunk>:
{
    f7dc:	b538      	push	{r3, r4, r5, lr}
    f7de:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
    f7e0:	f7ff ff40 	bl	f664 <chunk_size>
    f7e4:	460c      	mov	r4, r1
    f7e6:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
    f7e8:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    f7ec:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
    f7ee:	07da      	lsls	r2, r3, #31
    f7f0:	d40a      	bmi.n	f808 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
    f7f2:	4628      	mov	r0, r5
    f7f4:	f7ff ff7f 	bl	f6f6 <free_list_remove>
	return c + chunk_size(h, c);
    f7f8:	4621      	mov	r1, r4
    f7fa:	4628      	mov	r0, r5
    f7fc:	f7ff ff32 	bl	f664 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
    f800:	1822      	adds	r2, r4, r0
    f802:	4628      	mov	r0, r5
    f804:	f7ff ffba 	bl	f77c <merge_chunks>
		return ((uint16_t *)cmem)[f];
    f808:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
    f80c:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
    f80e:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    f812:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
    f814:	07db      	lsls	r3, r3, #31
    f816:	d40c      	bmi.n	f832 <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
    f818:	4628      	mov	r0, r5
    f81a:	f7ff ff6c 	bl	f6f6 <free_list_remove>
		return ((uint16_t *)cmem)[f];
    f81e:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
    f822:	4622      	mov	r2, r4
    f824:	1a61      	subs	r1, r4, r1
    f826:	4628      	mov	r0, r5
    f828:	f7ff ffa8 	bl	f77c <merge_chunks>
    f82c:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
    f830:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
    f832:	4621      	mov	r1, r4
    f834:	4628      	mov	r0, r5
}
    f836:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
    f83a:	f7ff bf18 	b.w	f66e <free_list_add>

0000f83e <sys_heap_free>:
	if (mem == NULL) {
    f83e:	b161      	cbz	r1, f85a <sys_heap_free+0x1c>
    f840:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    f842:	3904      	subs	r1, #4
    f844:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
    f846:	f021 0307 	bic.w	r3, r1, #7
    f84a:	4403      	add	r3, r0
	free_chunk(h, c);
    f84c:	08c9      	lsrs	r1, r1, #3
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
    f84e:	885a      	ldrh	r2, [r3, #2]
    f850:	f022 0201 	bic.w	r2, r2, #1
    f854:	805a      	strh	r2, [r3, #2]
    f856:	f7ff bfc1 	b.w	f7dc <free_chunk>
}
    f85a:	4770      	bx	lr

0000f85c <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
    f85c:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
    f85e:	6805      	ldr	r5, [r0, #0]

	if (bytes == 0U || size_too_big(h, bytes)) {
    f860:	b909      	cbnz	r1, f866 <sys_heap_alloc+0xa>
		return NULL;
    f862:	2000      	movs	r0, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return chunk_mem(h, c);
}
    f864:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
    f866:	68ab      	ldr	r3, [r5, #8]
    f868:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
    f86c:	d9f9      	bls.n	f862 <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    f86e:	310b      	adds	r1, #11
    f870:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
    f872:	4621      	mov	r1, r4
    f874:	4628      	mov	r0, r5
    f876:	f7ff ff4b 	bl	f710 <alloc_chunk>
	if (c == 0U) {
    f87a:	4606      	mov	r6, r0
    f87c:	2800      	cmp	r0, #0
    f87e:	d0f0      	beq.n	f862 <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
    f880:	4601      	mov	r1, r0
    f882:	4628      	mov	r0, r5
    f884:	f7ff feee 	bl	f664 <chunk_size>
    f888:	42a0      	cmp	r0, r4
    f88a:	d907      	bls.n	f89c <sys_heap_alloc+0x40>
		split_chunks(h, c, c + chunk_sz);
    f88c:	1932      	adds	r2, r6, r4
    f88e:	4628      	mov	r0, r5
    f890:	f7ff ff8a 	bl	f7a8 <split_chunks>
		free_list_add(h, c + chunk_sz);
    f894:	4611      	mov	r1, r2
    f896:	4628      	mov	r0, r5
    f898:	f7ff fee9 	bl	f66e <free_list_add>
	void *cmem = &buf[c];
    f89c:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
    f8a0:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    f8a2:	8853      	ldrh	r3, [r2, #2]
    f8a4:	f043 0301 	orr.w	r3, r3, #1
    f8a8:	8053      	strh	r3, [r2, #2]
    f8aa:	3004      	adds	r0, #4
	return chunk_mem(h, c);
    f8ac:	e7da      	b.n	f864 <sys_heap_alloc+0x8>

0000f8ae <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
    f8ae:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f8b2:	4614      	mov	r4, r2
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
    f8b4:	424a      	negs	r2, r1
    f8b6:	ea02 0701 	and.w	r7, r2, r1
	if (align != rew) {
    f8ba:	ea31 0202 	bics.w	r2, r1, r2
{
    f8be:	4603      	mov	r3, r0
	if (align != rew) {
    f8c0:	d00a      	beq.n	f8d8 <sys_heap_aligned_alloc+0x2a>
		return false;
    f8c2:	2f04      	cmp	r7, #4
    f8c4:	463a      	mov	r2, r7
    f8c6:	46b9      	mov	r9, r7
    f8c8:	bf28      	it	cs
    f8ca:	2204      	movcs	r2, #4
		align -= rew;
    f8cc:	1bcf      	subs	r7, r1, r7
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
    f8ce:	b974      	cbnz	r4, f8ee <sys_heap_aligned_alloc+0x40>
		return NULL;
    f8d0:	2500      	movs	r5, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return mem;
}
    f8d2:	4628      	mov	r0, r5
    f8d4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
    f8d8:	2904      	cmp	r1, #4
    f8da:	d804      	bhi.n	f8e6 <sys_heap_aligned_alloc+0x38>
			return sys_heap_alloc(heap, bytes);
    f8dc:	4621      	mov	r1, r4
}
    f8de:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
    f8e2:	f7ff bfbb 	b.w	f85c <sys_heap_alloc>
		rew = 0;
    f8e6:	f04f 0900 	mov.w	r9, #0
		gap = chunk_header_bytes(h);
    f8ea:	2204      	movs	r2, #4
    f8ec:	e7ef      	b.n	f8ce <sys_heap_aligned_alloc+0x20>
	struct z_heap *h = heap->heap;
    f8ee:	681e      	ldr	r6, [r3, #0]
	if (bytes == 0 || size_too_big(h, bytes)) {
    f8f0:	68b3      	ldr	r3, [r6, #8]
    f8f2:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
    f8f6:	d9eb      	bls.n	f8d0 <sys_heap_aligned_alloc+0x22>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    f8f8:	f104 010b 	add.w	r1, r4, #11
    f8fc:	4439      	add	r1, r7
    f8fe:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
    f900:	08c9      	lsrs	r1, r1, #3
    f902:	4630      	mov	r0, r6
    f904:	f7ff ff04 	bl	f710 <alloc_chunk>
	if (c0 == 0) {
    f908:	4680      	mov	r8, r0
    f90a:	2800      	cmp	r0, #0
    f90c:	d0e0      	beq.n	f8d0 <sys_heap_aligned_alloc+0x22>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
    f90e:	f109 0504 	add.w	r5, r9, #4
    f912:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
    f916:	1e7b      	subs	r3, r7, #1
    f918:	4435      	add	r5, r6
    f91a:	441d      	add	r5, r3
    f91c:	427f      	negs	r7, r7
    f91e:	403d      	ands	r5, r7
    f920:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    f924:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    f926:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    f928:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    f92a:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    f92c:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
    f930:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
    f932:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    f936:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
    f93a:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
    f93e:	d208      	bcs.n	f952 <sys_heap_aligned_alloc+0xa4>
		split_chunks(h, c0, c);
    f940:	4601      	mov	r1, r0
    f942:	463a      	mov	r2, r7
    f944:	4630      	mov	r0, r6
    f946:	f7ff ff2f 	bl	f7a8 <split_chunks>
		free_list_add(h, c0);
    f94a:	4641      	mov	r1, r8
    f94c:	4630      	mov	r0, r6
    f94e:	f7ff fe8e 	bl	f66e <free_list_add>
	return c + chunk_size(h, c);
    f952:	4639      	mov	r1, r7
    f954:	4630      	mov	r0, r6
    f956:	f7ff fe85 	bl	f664 <chunk_size>
    f95a:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
    f95c:	4284      	cmp	r4, r0
    f95e:	d207      	bcs.n	f970 <sys_heap_aligned_alloc+0xc2>
		split_chunks(h, c, c_end);
    f960:	4630      	mov	r0, r6
    f962:	4622      	mov	r2, r4
    f964:	f7ff ff20 	bl	f7a8 <split_chunks>
		free_list_add(h, c_end);
    f968:	4621      	mov	r1, r4
    f96a:	4630      	mov	r0, r6
    f96c:	f7ff fe7f 	bl	f66e <free_list_add>
	void *cmem = &buf[c];
    f970:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    f974:	8873      	ldrh	r3, [r6, #2]
    f976:	f043 0301 	orr.w	r3, r3, #1
    f97a:	8073      	strh	r3, [r6, #2]
    f97c:	e7a9      	b.n	f8d2 <sys_heap_aligned_alloc+0x24>

0000f97e <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
    f97e:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    f980:	1dcb      	adds	r3, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    f982:	4411      	add	r1, r2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    f984:	f023 0307 	bic.w	r3, r3, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    f988:	f021 0107 	bic.w	r1, r1, #7
{
    f98c:	b4f0      	push	{r4, r5, r6, r7}
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    f98e:	1acd      	subs	r5, r1, r3
    f990:	08ea      	lsrs	r2, r5, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
    f992:	6003      	str	r3, [r0, #0]
	return 31 - __builtin_clz(usable_sz);
    f994:	fab2 f082 	clz	r0, r2
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
    f998:	f1c0 0424 	rsb	r4, r0, #36	; 0x24
    f99c:	00a4      	lsls	r4, r4, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    f99e:	3407      	adds	r4, #7
	h->avail_buckets = 0;
    f9a0:	2600      	movs	r6, #0
    f9a2:	08e1      	lsrs	r1, r4, #3
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    f9a4:	f1c0 0020 	rsb	r0, r0, #32
    f9a8:	f103 0410 	add.w	r4, r3, #16
	h->end_chunk = heap_sz;
    f9ac:	609a      	str	r2, [r3, #8]
	h->avail_buckets = 0;
    f9ae:	60de      	str	r6, [r3, #12]
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    f9b0:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    f9b4:	4284      	cmp	r4, r0
    f9b6:	d118      	bne.n	f9ea <sys_heap_init+0x6c>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    f9b8:	0048      	lsls	r0, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    f9ba:	f040 0001 	orr.w	r0, r0, #1
    f9be:	8058      	strh	r0, [r3, #2]
		((uint16_t *)cmem)[f] = val;
    f9c0:	eb03 04c1 	add.w	r4, r3, r1, lsl #3
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    f9c4:	1a50      	subs	r0, r2, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    f9c6:	0047      	lsls	r7, r0, #1
		((uint16_t *)cmem)[f] = val;
    f9c8:	801e      	strh	r6, [r3, #0]
    f9ca:	8067      	strh	r7, [r4, #2]
    f9cc:	195c      	adds	r4, r3, r5
    f9ce:	f823 1031 	strh.w	r1, [r3, r1, lsl #3]
	void *cmem = &buf[c];
    f9d2:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
		((uint16_t *)cmem)[f] = val;
    f9d6:	8066      	strh	r6, [r4, #2]
    f9d8:	5358      	strh	r0, [r3, r5]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    f9da:	8850      	ldrh	r0, [r2, #2]
    f9dc:	f040 0001 	orr.w	r0, r0, #1
    f9e0:	8050      	strh	r0, [r2, #2]
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
    f9e2:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
    f9e4:	4618      	mov	r0, r3
    f9e6:	f7ff be42 	b.w	f66e <free_list_add>
		h->buckets[i].next = 0;
    f9ea:	f844 6b04 	str.w	r6, [r4], #4
	for (int i = 0; i < nb_buckets; i++) {
    f9ee:	e7e1      	b.n	f9b4 <sys_heap_init+0x36>

0000f9f0 <encode_uint>:
{
    f9f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f9f4:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier);
    f9f6:	78d3      	ldrb	r3, [r2, #3]
	switch (specifier) {
    f9f8:	2b6f      	cmp	r3, #111	; 0x6f
{
    f9fa:	4680      	mov	r8, r0
    f9fc:	460f      	mov	r7, r1
    f9fe:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    fa00:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
    fa04:	d029      	beq.n	fa5a <encode_uint+0x6a>
    fa06:	d824      	bhi.n	fa52 <encode_uint+0x62>
		return 16;
    fa08:	2b58      	cmp	r3, #88	; 0x58
    fa0a:	bf14      	ite	ne
    fa0c:	260a      	movne	r6, #10
    fa0e:	2610      	moveq	r6, #16
	char *bp = bps + (bpe - bps);
    fa10:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
    fa14:	4632      	mov	r2, r6
    fa16:	2300      	movs	r3, #0
    fa18:	4640      	mov	r0, r8
    fa1a:	4639      	mov	r1, r7
    fa1c:	f7f0 fb70 	bl	100 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    fa20:	2a09      	cmp	r2, #9
    fa22:	b2d4      	uxtb	r4, r2
    fa24:	d81e      	bhi.n	fa64 <encode_uint+0x74>
    fa26:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
    fa28:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
    fa2a:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
    fa2c:	f177 0300 	sbcs.w	r3, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
    fa30:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
    fa34:	d301      	bcc.n	fa3a <encode_uint+0x4a>
    fa36:	45d1      	cmp	r9, sl
    fa38:	d811      	bhi.n	fa5e <encode_uint+0x6e>
	if (conv->flag_hash) {
    fa3a:	782b      	ldrb	r3, [r5, #0]
    fa3c:	069b      	lsls	r3, r3, #26
    fa3e:	d505      	bpl.n	fa4c <encode_uint+0x5c>
		if (radix == 8) {
    fa40:	2e08      	cmp	r6, #8
    fa42:	d115      	bne.n	fa70 <encode_uint+0x80>
			conv->altform_0 = true;
    fa44:	78ab      	ldrb	r3, [r5, #2]
    fa46:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
    fa4a:	70ab      	strb	r3, [r5, #2]
}
    fa4c:	4648      	mov	r0, r9
    fa4e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
    fa52:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
    fa56:	2b70      	cmp	r3, #112	; 0x70
    fa58:	e7d7      	b.n	fa0a <encode_uint+0x1a>
	switch (specifier) {
    fa5a:	2608      	movs	r6, #8
    fa5c:	e7d8      	b.n	fa10 <encode_uint+0x20>
		value /= radix;
    fa5e:	4680      	mov	r8, r0
    fa60:	460f      	mov	r7, r1
    fa62:	e7d7      	b.n	fa14 <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    fa64:	f1bb 0f19 	cmp.w	fp, #25
    fa68:	bf94      	ite	ls
    fa6a:	3437      	addls	r4, #55	; 0x37
    fa6c:	3457      	addhi	r4, #87	; 0x57
    fa6e:	e7db      	b.n	fa28 <encode_uint+0x38>
		} else if (radix == 16) {
    fa70:	2e10      	cmp	r6, #16
    fa72:	d1eb      	bne.n	fa4c <encode_uint+0x5c>
			conv->altform_0c = true;
    fa74:	78ab      	ldrb	r3, [r5, #2]
    fa76:	f043 0310 	orr.w	r3, r3, #16
    fa7a:	e7e6      	b.n	fa4a <encode_uint+0x5a>

0000fa7c <outs>:
{
    fa7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fa80:	4607      	mov	r7, r0
    fa82:	4688      	mov	r8, r1
    fa84:	4615      	mov	r5, r2
    fa86:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    fa88:	4614      	mov	r4, r2
    fa8a:	42b4      	cmp	r4, r6
    fa8c:	eba4 0005 	sub.w	r0, r4, r5
    fa90:	d302      	bcc.n	fa98 <outs+0x1c>
    fa92:	b93e      	cbnz	r6, faa4 <outs+0x28>
    fa94:	7823      	ldrb	r3, [r4, #0]
    fa96:	b12b      	cbz	r3, faa4 <outs+0x28>
		int rc = out((int)*sp++, ctx);
    fa98:	f814 0b01 	ldrb.w	r0, [r4], #1
    fa9c:	4641      	mov	r1, r8
    fa9e:	47b8      	blx	r7
		if (rc < 0) {
    faa0:	2800      	cmp	r0, #0
    faa2:	daf2      	bge.n	fa8a <outs+0xe>
}
    faa4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000faa8 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_EXPERIMENTAL, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    faa8:	4770      	bx	lr

0000faaa <pm_policy_next_state>:
		}
	}

error:
	LOG_DBG("No suitable power state found for cpu: %d!", cpu);
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
    faaa:	2200      	movs	r2, #0
    faac:	e9c0 2200 	strd	r2, r2, [r0]
    fab0:	6082      	str	r2, [r0, #8]
}
    fab2:	4770      	bx	lr

0000fab4 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    fab4:	f002 bc8e 	b.w	123d4 <z_fatal_error>

0000fab8 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    fab8:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
    faba:	6800      	ldr	r0, [r0, #0]
    fabc:	f002 bc8a 	b.w	123d4 <z_fatal_error>

0000fac0 <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    fac0:	2100      	movs	r1, #0
    fac2:	2001      	movs	r0, #1
    fac4:	f7ff bff6 	b.w	fab4 <z_arm_fatal_error>

0000fac8 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    fac8:	b508      	push	{r3, lr}
	handler();
    faca:	f7f2 fd55 	bl	2578 <z_SysNmiOnReset>
	z_arm_int_exit();
}
    face:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
    fad2:	f7f2 be35 	b.w	2740 <z_arm_exc_exit>

0000fad6 <arch_timing_cycles_get>:
{
    fad6:	b530      	push	{r4, r5, lr}
	return (*end - *start);
    fad8:	e9d1 4500 	ldrd	r4, r5, [r1]
    fadc:	e9d0 2300 	ldrd	r2, r3, [r0]
    fae0:	1aa0      	subs	r0, r4, r2
    fae2:	eb65 0103 	sbc.w	r1, r5, r3
}
    fae6:	bd30      	pop	{r4, r5, pc}

0000fae8 <arch_timing_cycles_to_ns>:
{
    fae8:	b570      	push	{r4, r5, r6, lr}
    faea:	460d      	mov	r5, r1
    faec:	4604      	mov	r4, r0
	return (cycles) * (NSEC_PER_USEC) / arch_timing_freq_get_mhz();
    faee:	f7f2 ff89 	bl	2a04 <arch_timing_freq_get_mhz>
    faf2:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
    faf6:	4602      	mov	r2, r0
    faf8:	fba4 0106 	umull	r0, r1, r4, r6
    fafc:	2300      	movs	r3, #0
    fafe:	fb06 1105 	mla	r1, r6, r5, r1
    fb02:	f7f0 fafd 	bl	100 <__aeabi_uldivmod>
}
    fb06:	bd70      	pop	{r4, r5, r6, pc}

0000fb08 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
    fb08:	3901      	subs	r1, #1
    fb0a:	4603      	mov	r3, r0
    fb0c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    fb10:	b90a      	cbnz	r2, fb16 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
    fb12:	701a      	strb	r2, [r3, #0]

	return dest;
}
    fb14:	4770      	bx	lr
		*d = *s;
    fb16:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
    fb1a:	e7f7      	b.n	fb0c <strcpy+0x4>

0000fb1c <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    fb1c:	4603      	mov	r3, r0
	size_t n = 0;
    fb1e:	2000      	movs	r0, #0

	while (*s != '\0') {
    fb20:	5c1a      	ldrb	r2, [r3, r0]
    fb22:	b902      	cbnz	r2, fb26 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
    fb24:	4770      	bx	lr
		n++;
    fb26:	3001      	adds	r0, #1
    fb28:	e7fa      	b.n	fb20 <strlen+0x4>

0000fb2a <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    fb2a:	4603      	mov	r3, r0
	size_t n = 0;
    fb2c:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
    fb2e:	5c1a      	ldrb	r2, [r3, r0]
    fb30:	b10a      	cbz	r2, fb36 <strnlen+0xc>
    fb32:	4288      	cmp	r0, r1
    fb34:	d100      	bne.n	fb38 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
    fb36:	4770      	bx	lr
		n++;
    fb38:	3001      	adds	r0, #1
    fb3a:	e7f8      	b.n	fb2e <strnlen+0x4>

0000fb3c <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    fb3c:	1e43      	subs	r3, r0, #1
    fb3e:	3901      	subs	r1, #1
    fb40:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    fb44:	f811 0f01 	ldrb.w	r0, [r1, #1]!
    fb48:	4282      	cmp	r2, r0
    fb4a:	d101      	bne.n	fb50 <strcmp+0x14>
    fb4c:	2a00      	cmp	r2, #0
    fb4e:	d1f7      	bne.n	fb40 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    fb50:	1a10      	subs	r0, r2, r0
    fb52:	4770      	bx	lr

0000fb54 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
    fb54:	b510      	push	{r4, lr}
    fb56:	4603      	mov	r3, r0
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
    fb58:	b15a      	cbz	r2, fb72 <memcmp+0x1e>
    fb5a:	3901      	subs	r1, #1
    fb5c:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
    fb5e:	f813 0b01 	ldrb.w	r0, [r3], #1
    fb62:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    fb66:	42a3      	cmp	r3, r4
    fb68:	d001      	beq.n	fb6e <memcmp+0x1a>
    fb6a:	4290      	cmp	r0, r2
    fb6c:	d0f7      	beq.n	fb5e <memcmp+0xa>
		c1++;
		c2++;
	}

	return *c1 - *c2;
    fb6e:	1a80      	subs	r0, r0, r2
}
    fb70:	bd10      	pop	{r4, pc}
		return 0;
    fb72:	4610      	mov	r0, r2
    fb74:	e7fc      	b.n	fb70 <memcmp+0x1c>

0000fb76 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
    fb76:	1a43      	subs	r3, r0, r1
    fb78:	4293      	cmp	r3, r2
{
    fb7a:	b510      	push	{r4, lr}
    fb7c:	eb00 0302 	add.w	r3, r0, r2
	if ((size_t) (dest - src) < n) {
    fb80:	d308      	bcc.n	fb94 <memmove+0x1e>
    fb82:	3901      	subs	r1, #1
	char *dest = d;
    fb84:	4602      	mov	r2, r0
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
    fb86:	429a      	cmp	r2, r3
    fb88:	d007      	beq.n	fb9a <memmove+0x24>
			*dest = *src;
    fb8a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    fb8e:	f802 4b01 	strb.w	r4, [r2], #1
			dest++;
			src++;
			n--;
    fb92:	e7f8      	b.n	fb86 <memmove+0x10>
    fb94:	440a      	add	r2, r1
		while (n > 0) {
    fb96:	428a      	cmp	r2, r1
    fb98:	d100      	bne.n	fb9c <memmove+0x26>
		}
	}

	return d;
}
    fb9a:	bd10      	pop	{r4, pc}
			dest[n] = src[n];
    fb9c:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
    fba0:	f803 4d01 	strb.w	r4, [r3, #-1]!
    fba4:	e7f7      	b.n	fb96 <memmove+0x20>

0000fba6 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
    fba6:	b510      	push	{r4, lr}
    fba8:	1e43      	subs	r3, r0, #1
    fbaa:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
    fbac:	4291      	cmp	r1, r2
    fbae:	d100      	bne.n	fbb2 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    fbb0:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
    fbb2:	f811 4b01 	ldrb.w	r4, [r1], #1
    fbb6:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
    fbba:	e7f7      	b.n	fbac <memcpy+0x6>

0000fbbc <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    fbbc:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    fbbe:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
    fbc0:	4603      	mov	r3, r0
	while (n > 0) {
    fbc2:	4293      	cmp	r3, r2
    fbc4:	d100      	bne.n	fbc8 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    fbc6:	4770      	bx	lr
		*(d_byte++) = c_byte;
    fbc8:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    fbcc:	e7f9      	b.n	fbc2 <memset+0x6>

0000fbce <_stdout_hook_default>:
}
    fbce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    fbd2:	4770      	bx	lr

0000fbd4 <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
    fbd4:	b084      	sub	sp, #16
    fbd6:	ab04      	add	r3, sp, #16
    fbd8:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
    fbdc:	f89d 3004 	ldrb.w	r3, [sp, #4]
    fbe0:	2b06      	cmp	r3, #6
    fbe2:	d108      	bne.n	fbf6 <pm_power_state_set+0x22>
    p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
    fbe4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    fbe8:	2201      	movs	r2, #1
    fbea:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
    fbee:	f3bf 8f4f 	dsb	sy
        __WFE();
    fbf2:	bf20      	wfe
    while (true)
    fbf4:	e7fd      	b.n	fbf2 <pm_power_state_set+0x1e>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
    fbf6:	b004      	add	sp, #16
    fbf8:	4770      	bx	lr

0000fbfa <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
    fbfa:	b084      	sub	sp, #16
    fbfc:	ab04      	add	r3, sp, #16
    fbfe:	e903 0007 	stmdb	r3, {r0, r1, r2}
    fc02:	2300      	movs	r3, #0
    fc04:	f383 8811 	msr	BASEPRI, r3
    fc08:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
    fc0c:	b004      	add	sp, #16
    fc0e:	4770      	bx	lr

0000fc10 <ah>:
	return bt_encrypt_le(key, plaintext, enc_data);
#endif
}

static int ah(const uint8_t irk[16], const uint8_t r[3], uint8_t out[3])
{
    fc10:	b530      	push	{r4, r5, lr}
    fc12:	b085      	sub	sp, #20
    fc14:	4604      	mov	r4, r0
    fc16:	4615      	mov	r5, r2

	BT_DBG("irk %s", bt_hex(irk, 16));
	BT_DBG("r %s", bt_hex(r, 3));

	/* r' = padding || r */
	memcpy(res, r, 3);
    fc18:	4668      	mov	r0, sp
    fc1a:	2203      	movs	r2, #3
    fc1c:	f7ff ffc3 	bl	fba6 <memcpy>
	(void)memset(res + 3, 0, 13);
    fc20:	220d      	movs	r2, #13
    fc22:	2100      	movs	r1, #0
    fc24:	f10d 0003 	add.w	r0, sp, #3
    fc28:	f7ff ffc8 	bl	fbbc <memset>
	return bt_encrypt_le(key, plaintext, enc_data);
    fc2c:	4620      	mov	r0, r4
    fc2e:	466a      	mov	r2, sp
    fc30:	4669      	mov	r1, sp
    fc32:	f001 f9ba 	bl	10faa <bt_encrypt_le>

	err = internal_encrypt_le(irk, res, res);
	if (err) {
    fc36:	4604      	mov	r4, r0
    fc38:	b920      	cbnz	r0, fc44 <ah+0x34>
	 *      ah(h, r) = e(k, r') mod 2^24
	 * The output of the security function e is then truncated to 24 bits
	 * by taking the least significant 24 bits of the output of e as the
	 * result of ah.
	 */
	memcpy(out, res, 3);
    fc3a:	2203      	movs	r2, #3
    fc3c:	4669      	mov	r1, sp
    fc3e:	4628      	mov	r0, r5
    fc40:	f7ff ffb1 	bl	fba6 <memcpy>

	return 0;
}
    fc44:	4620      	mov	r0, r4
    fc46:	b005      	add	sp, #20
    fc48:	bd30      	pop	{r4, r5, pc}

0000fc4a <bt_rpa_irk_matches>:

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CTLR_PRIVACY)
bool bt_rpa_irk_matches(const uint8_t irk[16], const bt_addr_t *addr)
{
    fc4a:	b513      	push	{r0, r1, r4, lr}
    fc4c:	460c      	mov	r4, r1
	uint8_t hash[3];
	int err;

	BT_DBG("IRK %s bdaddr %s", bt_hex(irk, 16), bt_addr_str(addr));

	err = ah(irk, addr->val + 3, hash);
    fc4e:	aa01      	add	r2, sp, #4
    fc50:	3103      	adds	r1, #3
    fc52:	f7ff ffdd 	bl	fc10 <ah>
	if (err) {
    fc56:	b948      	cbnz	r0, fc6c <bt_rpa_irk_matches+0x22>
		return false;
	}

	return !memcmp(addr->val, hash, 3);
    fc58:	2203      	movs	r2, #3
    fc5a:	a901      	add	r1, sp, #4
    fc5c:	4620      	mov	r0, r4
    fc5e:	f7ff ff79 	bl	fb54 <memcmp>
    fc62:	fab0 f080 	clz	r0, r0
    fc66:	0940      	lsrs	r0, r0, #5
}
    fc68:	b002      	add	sp, #8
    fc6a:	bd10      	pop	{r4, pc}
		return false;
    fc6c:	2000      	movs	r0, #0
    fc6e:	e7fb      	b.n	fc68 <bt_rpa_irk_matches+0x1e>

0000fc70 <bt_rpa_create>:
#endif

#if defined(CONFIG_BT_PRIVACY) || defined(CONFIG_BT_CTLR_PRIVACY)
int bt_rpa_create(const uint8_t irk[16], bt_addr_t *rpa)
{
    fc70:	b570      	push	{r4, r5, r6, lr}
	int err;

	err = internal_rand(rpa->val + 3, 3);
    fc72:	1cce      	adds	r6, r1, #3
{
    fc74:	4605      	mov	r5, r0
    fc76:	460c      	mov	r4, r1
	return bt_rand(buf, len);
    fc78:	4630      	mov	r0, r6
    fc7a:	2103      	movs	r1, #3
    fc7c:	f001 f993 	bl	10fa6 <bt_rand>
	if (err) {
    fc80:	b960      	cbnz	r0, fc9c <bt_rpa_create+0x2c>
		return err;
	}

	BT_ADDR_SET_RPA(rpa);
    fc82:	7963      	ldrb	r3, [r4, #5]
    fc84:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    fc88:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    fc8c:	7163      	strb	r3, [r4, #5]

	err = ah(irk, rpa->val + 3, rpa->val);
    fc8e:	4622      	mov	r2, r4
    fc90:	4631      	mov	r1, r6
    fc92:	4628      	mov	r0, r5
	}

	BT_DBG("Created RPA %s", bt_addr_str((bt_addr_t *)rpa->val));

	return 0;
}
    fc94:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	err = ah(irk, rpa->val + 3, rpa->val);
    fc98:	f7ff bfba 	b.w	fc10 <ah>
}
    fc9c:	bd70      	pop	{r4, r5, r6, pc}

0000fc9e <bt_addr_le_create_static>:
#include <bluetooth/addr.h>
#include <bluetooth/crypto.h>

static inline int create_random_addr(bt_addr_le_t *addr)
{
	addr->type = BT_ADDR_LE_RANDOM;
    fc9e:	2301      	movs	r3, #1

	return 0;
}

int bt_addr_le_create_static(bt_addr_le_t *addr)
{
    fca0:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
    fca2:	2106      	movs	r1, #6
{
    fca4:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
    fca6:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
    fcaa:	f001 f97c 	bl	10fa6 <bt_rand>
	int err;

	err = create_random_addr(addr);
	if (err) {
    fcae:	b918      	cbnz	r0, fcb8 <bt_addr_le_create_static+0x1a>
		return err;
	}

	BT_ADDR_SET_STATIC(&addr->a);
    fcb0:	79a3      	ldrb	r3, [r4, #6]
    fcb2:	f063 033f 	orn	r3, r3, #63	; 0x3f
    fcb6:	71a3      	strb	r3, [r4, #6]

	return 0;
}
    fcb8:	bd10      	pop	{r4, pc}

0000fcba <handle_event>:
{
    fcba:	b410      	push	{r4}
    fcbc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    fcc0:	4604      	mov	r4, r0
    fcc2:	4608      	mov	r0, r1
		if (handler->event != event) {
    fcc4:	7811      	ldrb	r1, [r2, #0]
    fcc6:	42a1      	cmp	r1, r4
    fcc8:	d004      	beq.n	fcd4 <handle_event+0x1a>
	for (i = 0; i < num_handlers; i++) {
    fcca:	3208      	adds	r2, #8
    fccc:	429a      	cmp	r2, r3
    fcce:	d1f9      	bne.n	fcc4 <handle_event+0xa>
}
    fcd0:	bc10      	pop	{r4}
    fcd2:	4770      	bx	lr
		if (buf->len < handler->min_len) {
    fcd4:	8981      	ldrh	r1, [r0, #12]
    fcd6:	7853      	ldrb	r3, [r2, #1]
    fcd8:	4299      	cmp	r1, r3
    fcda:	d3f9      	bcc.n	fcd0 <handle_event+0x16>
		handler->handler(buf);
    fcdc:	6853      	ldr	r3, [r2, #4]
}
    fcde:	bc10      	pop	{r4}
		handler->handler(buf);
    fce0:	4718      	bx	r3

0000fce2 <hci_vendor_event>:
}
    fce2:	4770      	bx	lr

0000fce4 <hci_hardware_error>:
	return net_buf_simple_pull_mem(&buf->b, len);
    fce4:	2101      	movs	r1, #1
    fce6:	3008      	adds	r0, #8
    fce8:	f002 b92e 	b.w	11f48 <net_buf_simple_pull_mem>

0000fcec <bt_hci_evt_create>:
#include <stdint.h>
#include <sys/byteorder.h>
#include <drivers/bluetooth/hci_driver.h>

struct net_buf *bt_hci_evt_create(uint8_t evt, uint8_t len)
{
    fcec:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_hdr *hdr;
	struct net_buf *buf;

	buf = bt_buf_get_evt(evt, false, K_FOREVER);
    fcee:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
    fcf2:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
    fcf4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    fcf8:	2100      	movs	r1, #0
{
    fcfa:	4606      	mov	r6, r0
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
    fcfc:	f7f2 ffc2 	bl	2c84 <bt_buf_get_evt>
	return net_buf_simple_add(&buf->b, len);
    fd00:	2102      	movs	r1, #2
    fd02:	4604      	mov	r4, r0
    fd04:	3008      	adds	r0, #8
    fd06:	f002 f8f6 	bl	11ef6 <net_buf_simple_add>

	hdr = net_buf_add(buf, sizeof(*hdr));
	hdr->evt = evt;
    fd0a:	7006      	strb	r6, [r0, #0]
	hdr->len = len;
    fd0c:	7045      	strb	r5, [r0, #1]

	return buf;
}
    fd0e:	4620      	mov	r0, r4
    fd10:	bd70      	pop	{r4, r5, r6, pc}

0000fd12 <bt_hci_cmd_complete_create>:
struct net_buf *bt_hci_cmd_complete_create(uint16_t op, uint8_t plen)
{
	struct net_buf *buf;
	struct bt_hci_evt_cmd_complete *cc;

	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
    fd12:	3103      	adds	r1, #3
{
    fd14:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
    fd16:	b2c9      	uxtb	r1, r1
{
    fd18:	4605      	mov	r5, r0
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
    fd1a:	200e      	movs	r0, #14
    fd1c:	f7ff ffe6 	bl	fcec <bt_hci_evt_create>
    fd20:	2103      	movs	r1, #3
    fd22:	4604      	mov	r4, r0
    fd24:	3008      	adds	r0, #8
    fd26:	f002 f8e6 	bl	11ef6 <net_buf_simple_add>

	cc = net_buf_add(buf, sizeof(*cc));
	cc->ncmd = 1U;
    fd2a:	2301      	movs	r3, #1
    fd2c:	7003      	strb	r3, [r0, #0]
	cc->opcode = sys_cpu_to_le16(op);
    fd2e:	f8a0 5001 	strh.w	r5, [r0, #1]

	return buf;
}
    fd32:	4620      	mov	r0, r4
    fd34:	bd38      	pop	{r3, r4, r5, pc}

0000fd36 <bt_hci_cmd_status_create>:

struct net_buf *bt_hci_cmd_status_create(uint16_t op, uint8_t status)
{
    fd36:	b570      	push	{r4, r5, r6, lr}
    fd38:	4605      	mov	r5, r0
    fd3a:	460e      	mov	r6, r1
	struct net_buf *buf;
	struct bt_hci_evt_cmd_status *cs;

	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
    fd3c:	200f      	movs	r0, #15
    fd3e:	2104      	movs	r1, #4
    fd40:	f7ff ffd4 	bl	fcec <bt_hci_evt_create>
    fd44:	2104      	movs	r1, #4
    fd46:	4604      	mov	r4, r0
    fd48:	3008      	adds	r0, #8
    fd4a:	f002 f8d4 	bl	11ef6 <net_buf_simple_add>

	cs = net_buf_add(buf, sizeof(*cs));
	cs->status = status;
	cs->ncmd = 1U;
    fd4e:	2201      	movs	r2, #1
	cs->status = status;
    fd50:	7006      	strb	r6, [r0, #0]
	cs->ncmd = 1U;
    fd52:	7042      	strb	r2, [r0, #1]
	cs->opcode = sys_cpu_to_le16(op);
    fd54:	8045      	strh	r5, [r0, #2]

	return buf;
}
    fd56:	4620      	mov	r0, r4
    fd58:	bd70      	pop	{r4, r5, r6, pc}

0000fd5a <bt_lookup_id_addr>:
}
    fd5a:	4608      	mov	r0, r1
    fd5c:	4770      	bx	lr

0000fd5e <bt_id_set_adv_random_addr>:
{
    fd5e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    fd60:	f3bf 8f5b 	dmb	ish
    fd64:	6903      	ldr	r3, [r0, #16]
    fd66:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_bit(adv->flags, BT_ADV_PARAMS_SET)) {
    fd6a:	f3c3 0540 	ubfx	r5, r3, #1, #1
    fd6e:	079b      	lsls	r3, r3, #30
{
    fd70:	4604      	mov	r4, r0
    fd72:	460e      	mov	r6, r1
	if (!atomic_test_bit(adv->flags, BT_ADV_PARAMS_SET)) {
    fd74:	f100 0710 	add.w	r7, r0, #16
    fd78:	d413      	bmi.n	fda2 <bt_id_set_adv_random_addr+0x44>
    fd7a:	2206      	movs	r2, #6
    fd7c:	3003      	adds	r0, #3
    fd7e:	f7ff ff12 	bl	fba6 <memcpy>
		adv->random_addr.type = BT_ADDR_LE_RANDOM;
    fd82:	2301      	movs	r3, #1
    fd84:	70a3      	strb	r3, [r4, #2]
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    fd86:	f3bf 8f5b 	dmb	ish
    fd8a:	e857 3f00 	ldrex	r3, [r7]
    fd8e:	f043 0308 	orr.w	r3, r3, #8
    fd92:	e847 3200 	strex	r2, r3, [r7]
    fd96:	2a00      	cmp	r2, #0
    fd98:	d1f7      	bne.n	fd8a <bt_id_set_adv_random_addr+0x2c>
    fd9a:	f3bf 8f5b 	dmb	ish
}
    fd9e:	4628      	mov	r0, r5
    fda0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_SET_RANDOM_ADDR,
    fda2:	2107      	movs	r1, #7
    fda4:	f242 0035 	movw	r0, #8245	; 0x2035
    fda8:	f7f3 f84c 	bl	2e44 <bt_hci_cmd_create>
	if (!buf) {
    fdac:	4605      	mov	r5, r0
    fdae:	b1e8      	cbz	r0, fdec <bt_id_set_adv_random_addr+0x8e>
    fdb0:	2107      	movs	r1, #7
    fdb2:	3008      	adds	r0, #8
    fdb4:	f002 f89f 	bl	11ef6 <net_buf_simple_add>
	cp->handle = adv->handle;
    fdb8:	7863      	ldrb	r3, [r4, #1]
    fdba:	f800 3b01 	strb.w	r3, [r0], #1
    fdbe:	2206      	movs	r2, #6
    fdc0:	4631      	mov	r1, r6
    fdc2:	f7ff fef0 	bl	fba6 <memcpy>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_SET_RANDOM_ADDR, buf,
    fdc6:	4629      	mov	r1, r5
    fdc8:	2200      	movs	r2, #0
    fdca:	f242 0035 	movw	r0, #8245	; 0x2035
    fdce:	f7f3 f873 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
    fdd2:	4605      	mov	r5, r0
    fdd4:	2800      	cmp	r0, #0
    fdd6:	d1e2      	bne.n	fd9e <bt_id_set_adv_random_addr+0x40>
	if (&adv->random_addr.a != addr) {
    fdd8:	1ce0      	adds	r0, r4, #3
    fdda:	4286      	cmp	r6, r0
    fddc:	d003      	beq.n	fde6 <bt_id_set_adv_random_addr+0x88>
    fdde:	2206      	movs	r2, #6
    fde0:	4631      	mov	r1, r6
    fde2:	f7ff fee0 	bl	fba6 <memcpy>
	adv->random_addr.type = BT_ADDR_LE_RANDOM;
    fde6:	2301      	movs	r3, #1
    fde8:	70a3      	strb	r3, [r4, #2]
	return 0;
    fdea:	e7d8      	b.n	fd9e <bt_id_set_adv_random_addr+0x40>
		return -ENOBUFS;
    fdec:	f06f 0568 	mvn.w	r5, #104	; 0x68
    fdf0:	e7d5      	b.n	fd9e <bt_id_set_adv_random_addr+0x40>

0000fdf2 <bt_id_set_adv_private_addr>:
{
    fdf2:	b513      	push	{r0, r1, r4, lr}
    fdf4:	4604      	mov	r4, r0
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
    fdf6:	2106      	movs	r1, #6
    fdf8:	4668      	mov	r0, sp
    fdfa:	f001 f8d4 	bl	10fa6 <bt_rand>
	if (err) {
    fdfe:	b948      	cbnz	r0, fe14 <bt_id_set_adv_private_addr+0x22>
	BT_ADDR_SET_NRPA(&nrpa);
    fe00:	f89d 3005 	ldrb.w	r3, [sp, #5]
	err = bt_id_set_adv_random_addr(adv, &nrpa);
    fe04:	4669      	mov	r1, sp
	BT_ADDR_SET_NRPA(&nrpa);
    fe06:	f003 033f 	and.w	r3, r3, #63	; 0x3f
	err = bt_id_set_adv_random_addr(adv, &nrpa);
    fe0a:	4620      	mov	r0, r4
	BT_ADDR_SET_NRPA(&nrpa);
    fe0c:	f88d 3005 	strb.w	r3, [sp, #5]
	err = bt_id_set_adv_random_addr(adv, &nrpa);
    fe10:	f7ff ffa5 	bl	fd5e <bt_id_set_adv_random_addr>
}
    fe14:	b002      	add	sp, #8
    fe16:	bd10      	pop	{r4, pc}

0000fe18 <get_adv_channel_map>:
{
    fe18:	4603      	mov	r3, r0
		channel_map &= ~0x01;
    fe1a:	f410 4f00 	tst.w	r0, #32768	; 0x8000
    fe1e:	bf0c      	ite	eq
    fe20:	2007      	moveq	r0, #7
    fe22:	2006      	movne	r0, #6
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_38) {
    fe24:	03da      	lsls	r2, r3, #15
		channel_map &= ~0x02;
    fe26:	bf48      	it	mi
    fe28:	f000 0005 	andmi.w	r0, r0, #5
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_39) {
    fe2c:	039b      	lsls	r3, r3, #14
		channel_map &= ~0x04;
    fe2e:	bf48      	it	mi
    fe30:	f000 00fb 	andmi.w	r0, r0, #251	; 0xfb
}
    fe34:	4770      	bx	lr

0000fe36 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    fe36:	f3bf 8f5b 	dmb	ish
    fe3a:	6800      	ldr	r0, [r0, #0]
    fe3c:	f3bf 8f5b 	dmb	ish
}
    fe40:	4770      	bx	lr

0000fe42 <atomic_test_bit>:
{
    fe42:	b508      	push	{r3, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    fe44:	f7ff fff7 	bl	fe36 <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    fe48:	4108      	asrs	r0, r1
}
    fe4a:	f000 0001 	and.w	r0, r0, #1
    fe4e:	bd08      	pop	{r3, pc}

0000fe50 <atomic_and>:
{
    fe50:	4603      	mov	r3, r0
}
    fe52:	f3bf 8f5b 	dmb	ish
    fe56:	e853 0f00 	ldrex	r0, [r3]
    fe5a:	ea00 0201 	and.w	r2, r0, r1
    fe5e:	e843 2c00 	strex	ip, r2, [r3]
    fe62:	f1bc 0f00 	cmp.w	ip, #0
    fe66:	d1f6      	bne.n	fe56 <atomic_and+0x6>
    fe68:	f3bf 8f5b 	dmb	ish
    fe6c:	4770      	bx	lr

0000fe6e <hci_set_ad_ext>:
{
    fe6e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fe72:	b087      	sub	sp, #28
    fe74:	e9cd 0101 	strd	r0, r1, [sp, #4]
    fe78:	4614      	mov	r4, r2
	for (size_t i = 0; i < ad_len; i++) {
    fe7a:	f04f 0800 	mov.w	r8, #0
{
    fe7e:	461e      	mov	r6, r3
	size_t total_len_bytes = 0;
    fe80:	4642      	mov	r2, r8
		for (size_t j = 0; j < ad[i].len; j++) {
    fe82:	1d25      	adds	r5, r4, #4
    fe84:	f855 0038 	ldr.w	r0, [r5, r8, lsl #3]
    fe88:	2300      	movs	r3, #0
    fe8a:	e007      	b.n	fe9c <hci_set_ad_ext+0x2e>
			total_len_bytes += ad[i].data[j].data_len + 2;
    fe8c:	f854 1038 	ldr.w	r1, [r4, r8, lsl #3]
    fe90:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
		for (size_t j = 0; j < ad[i].len; j++) {
    fe94:	3301      	adds	r3, #1
			total_len_bytes += ad[i].data[j].data_len + 2;
    fe96:	7849      	ldrb	r1, [r1, #1]
    fe98:	3102      	adds	r1, #2
    fe9a:	440a      	add	r2, r1
		for (size_t j = 0; j < ad[i].len; j++) {
    fe9c:	4298      	cmp	r0, r3
    fe9e:	d1f5      	bne.n	fe8c <hci_set_ad_ext+0x1e>
	for (size_t i = 0; i < ad_len; i++) {
    fea0:	f108 0301 	add.w	r3, r8, #1
    fea4:	429e      	cmp	r6, r3
    fea6:	9304      	str	r3, [sp, #16]
    fea8:	d001      	beq.n	feae <hci_set_ad_ext+0x40>
    feaa:	4698      	mov	r8, r3
    feac:	e7ea      	b.n	fe84 <hci_set_ad_ext+0x16>
	if ((total_len_bytes > BT_HCI_LE_EXT_ADV_FRAG_MAX_LEN) &&
    feae:	2afb      	cmp	r2, #251	; 0xfb
    feb0:	f240 80c9 	bls.w	10046 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x47>
	    atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    feb4:	9b01      	ldr	r3, [sp, #4]
    feb6:	2106      	movs	r1, #6
    feb8:	f103 0010 	add.w	r0, r3, #16
    febc:	f7ff ffc1 	bl	fe42 <atomic_test_bit>
	if ((total_len_bytes > BT_HCI_LE_EXT_ADV_FRAG_MAX_LEN) &&
    fec0:	4606      	mov	r6, r0
    fec2:	b390      	cbz	r0, ff2a <hci_set_ad_ext+0xbc>
		return -EAGAIN;
    fec4:	f06f 000a 	mvn.w	r0, #10
    fec8:	e052      	b.n	ff70 <hci_set_ad_ext+0x102>
			size_t len = data[j].data_len;
    feca:	f899 2001 	ldrb.w	r2, [r9, #1]
			uint8_t type = data[j].type;
    fece:	f899 c000 	ldrb.w	ip, [r9]
			if ((set_data_len + len + 2) > set_data_len_max) {
    fed2:	1cb0      	adds	r0, r6, #2
    fed4:	1811      	adds	r1, r2, r0
    fed6:	4299      	cmp	r1, r3
    fed8:	d90b      	bls.n	fef2 <hci_set_ad_ext+0x84>
				ssize_t shortened_len = set_data_len_max -
    feda:	9a04      	ldr	r2, [sp, #16]
				if (!(type == BT_DATA_NAME_COMPLETE &&
    fedc:	f1bc 0f09 	cmp.w	ip, #9
				ssize_t shortened_len = set_data_len_max -
    fee0:	eba2 0206 	sub.w	r2, r2, r6
				if (!(type == BT_DATA_NAME_COMPLETE &&
    fee4:	f040 80a9 	bne.w	1003a <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x3b>
    fee8:	2a00      	cmp	r2, #0
    feea:	f340 80a6 	ble.w	1003a <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x3b>
				type = BT_DATA_NAME_SHORTENED;
    feee:	f04f 0c08 	mov.w	ip, #8
			set_data[set_data_len++] = len + 1;
    fef2:	fa5f f882 	uxtb.w	r8, r2
    fef6:	f108 0101 	add.w	r1, r8, #1
    fefa:	f80a 1006 	strb.w	r1, [sl, r6]
    fefe:	1c71      	adds	r1, r6, #1
			set_data[set_data_len++] = type;
    ff00:	b2c9      	uxtb	r1, r1
			set_data_len += len;
    ff02:	f108 0802 	add.w	r8, r8, #2
			set_data[set_data_len++] = type;
    ff06:	f80a c001 	strb.w	ip, [sl, r1]
			memcpy(&set_data[set_data_len], data[j].data, len);
    ff0a:	fa5a f080 	uxtab	r0, sl, r0
    ff0e:	f8d9 1004 	ldr.w	r1, [r9, #4]
    ff12:	9305      	str	r3, [sp, #20]
			set_data_len += len;
    ff14:	4446      	add	r6, r8
			memcpy(&set_data[set_data_len], data[j].data, len);
    ff16:	f7ff fe46 	bl	fba6 <memcpy>
			set_data_len += len;
    ff1a:	b2f6      	uxtb	r6, r6
		for (size_t j = 0; j < ad[i].len; j++) {
    ff1c:	9b05      	ldr	r3, [sp, #20]
    ff1e:	f10b 0b01 	add.w	fp, fp, #1
    ff22:	f109 0908 	add.w	r9, r9, #8
    ff26:	e0b5      	b.n	10094 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x95>
    ff28:	461e      	mov	r6, r3
		for (size_t j = 0; j < ad[i].len; j++) {
    ff2a:	6827      	ldr	r7, [r4, #0]
    ff2c:	f04f 0900 	mov.w	r9, #0
    ff30:	6863      	ldr	r3, [r4, #4]
    ff32:	4599      	cmp	r9, r3
    ff34:	d307      	bcc.n	ff46 <hci_set_ad_ext+0xd8>
	for (size_t i = 0; i < ad_len; i++) {
    ff36:	4546      	cmp	r6, r8
    ff38:	f106 0301 	add.w	r3, r6, #1
    ff3c:	f104 0408 	add.w	r4, r4, #8
    ff40:	d1f2      	bne.n	ff28 <hci_set_ad_ext+0xba>
	return 0;
    ff42:	2000      	movs	r0, #0
    ff44:	e014      	b.n	ff70 <hci_set_ad_ext+0x102>
			uint8_t type = data[j].type;
    ff46:	783b      	ldrb	r3, [r7, #0]
			size_t len = data[j].data_len;
    ff48:	f897 a001 	ldrb.w	sl, [r7, #1]
			uint8_t type = data[j].type;
    ff4c:	9305      	str	r3, [sp, #20]
			size_t offset = 0;
    ff4e:	f04f 0b00 	mov.w	fp, #0
			while (offset < data[j].data_len) {
    ff52:	787b      	ldrb	r3, [r7, #1]
    ff54:	459b      	cmp	fp, r3
    ff56:	d303      	bcc.n	ff60 <hci_set_ad_ext+0xf2>
		for (size_t j = 0; j < ad[i].len; j++) {
    ff58:	f109 0901 	add.w	r9, r9, #1
    ff5c:	3708      	adds	r7, #8
    ff5e:	e7e7      	b.n	ff30 <hci_set_ad_ext+0xc2>
				buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
    ff60:	9802      	ldr	r0, [sp, #8]
    ff62:	21ff      	movs	r1, #255	; 0xff
    ff64:	f7f2 ff6e 	bl	2e44 <bt_hci_cmd_create>
				if (!buf) {
    ff68:	9003      	str	r0, [sp, #12]
    ff6a:	b920      	cbnz	r0, ff76 <hci_set_ad_ext+0x108>
					return -ENOBUFS;
    ff6c:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
    ff70:	b007      	add	sp, #28
    ff72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ff76:	9b03      	ldr	r3, [sp, #12]
    ff78:	21ff      	movs	r1, #255	; 0xff
    ff7a:	f103 0008 	add.w	r0, r3, #8
    ff7e:	f001 ffba 	bl	11ef6 <net_buf_simple_add>
				(void)memset(set_data, 0, sizeof(*set_data));
    ff82:	22ff      	movs	r2, #255	; 0xff
    ff84:	2100      	movs	r1, #0
    ff86:	4605      	mov	r5, r0
    ff88:	f7ff fe18 	bl	fbbc <memset>
				set_data->handle = adv->handle;
    ff8c:	9b01      	ldr	r3, [sp, #4]
    ff8e:	785b      	ldrb	r3, [r3, #1]
    ff90:	702b      	strb	r3, [r5, #0]
				if ((i == 0) && (j == 0) && (offset == 0)) {
    ff92:	ea49 0306 	orr.w	r3, r9, r6
				set_data->frag_pref = BT_HCI_LE_EXT_ADV_FRAG_DISABLED;
    ff96:	f04f 0201 	mov.w	r2, #1
				if ((i == 0) && (j == 0) && (offset == 0)) {
    ff9a:	ea53 030b 	orrs.w	r3, r3, fp
				set_data->frag_pref = BT_HCI_LE_EXT_ADV_FRAG_DISABLED;
    ff9e:	70aa      	strb	r2, [r5, #2]
				if ((i == 0) && (j == 0) && (offset == 0)) {
    ffa0:	d106      	bne.n	ffb0 <hci_set_ad_ext+0x142>
					set_data->op = BT_HCI_LE_EXT_ADV_OP_FIRST_FRAG;
    ffa2:	706a      	strb	r2, [r5, #1]
					set_data->len = MIN(len + 2,
    ffa4:	f10a 0202 	add.w	r2, sl, #2
    ffa8:	2afb      	cmp	r2, #251	; 0xfb
    ffaa:	bf28      	it	cs
    ffac:	22fb      	movcs	r2, #251	; 0xfb
    ffae:	e011      	b.n	ffd4 <hci_set_ad_ext+0x166>
				} else if ((i == ad_len - 1) && (j == ad[i].len - 1)) {
    ffb0:	9b04      	ldr	r3, [sp, #16]
    ffb2:	2b01      	cmp	r3, #1
    ffb4:	bf0c      	ite	eq
    ffb6:	2300      	moveq	r3, #0
    ffb8:	2301      	movne	r3, #1
    ffba:	42b3      	cmp	r3, r6
    ffbc:	d12e      	bne.n	1001c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x1d>
    ffbe:	6863      	ldr	r3, [r4, #4]
    ffc0:	3b01      	subs	r3, #1
    ffc2:	4599      	cmp	r9, r3
    ffc4:	d12a      	bne.n	1001c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x1d>
					if (offset != 0) {
    ffc6:	f1bb 0f00 	cmp.w	fp, #0
    ffca:	d01e      	beq.n	1000a <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0xb>
						set_data->op = BT_HCI_LE_EXT_ADV_OP_LAST_FRAG;
    ffcc:	2302      	movs	r3, #2
    ffce:	706b      	strb	r3, [r5, #1]
					set_data->len = len - offset;
    ffd0:	ebaa 020b 	sub.w	r2, sl, fp
    ffd4:	b2d2      	uxtb	r2, r2
    ffd6:	70ea      	strb	r2, [r5, #3]
				if (offset == 0) {
    ffd8:	f1bb 0f00 	cmp.w	fp, #0
    ffdc:	d125      	bne.n	1002a <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x2b>
					set_data->data[0] = len + 1;
    ffde:	f10a 0301 	add.w	r3, sl, #1
    ffe2:	712b      	strb	r3, [r5, #4]
					set_data->data[1] = type;
    ffe4:	9b05      	ldr	r3, [sp, #20]
    ffe6:	716b      	strb	r3, [r5, #5]
					memcpy(&set_data->data[2], data[j].data, set_data->len - 2);
    ffe8:	6879      	ldr	r1, [r7, #4]
    ffea:	3a02      	subs	r2, #2
    ffec:	1da8      	adds	r0, r5, #6
    ffee:	f7ff fdda 	bl	fba6 <memcpy>
					offset += set_data->len - 2;
    fff2:	f895 b003 	ldrb.w	fp, [r5, #3]
    fff6:	f1ab 0b02 	sub.w	fp, fp, #2
				err = bt_hci_cmd_send_sync(hci_op, buf, NULL);
    fffa:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    fffe:	2200      	movs	r2, #0
   10000:	f7f2 ff5a 	bl	2eb8 <bt_hci_cmd_send_sync>
				if (err) {
   10004:	2800      	cmp	r0, #0
   10006:	d0a4      	beq.n	ff52 <hci_set_ad_ext+0xe4>
   10008:	e7b2      	b.n	ff70 <hci_set_ad_ext+0x102>
					} else if (len + 2 <= BT_HCI_LE_EXT_ADV_FRAG_MAX_LEN) {
   1000a:	f10a 0302 	add.w	r3, sl, #2
   1000e:	2bfb      	cmp	r3, #251	; 0xfb
						set_data->op = BT_HCI_LE_EXT_ADV_OP_LAST_FRAG;
   10010:	bf9a      	itte	ls
   10012:	2302      	movls	r3, #2
   10014:	706b      	strbls	r3, [r5, #1]
						set_data->op = BT_HCI_LE_EXT_ADV_OP_INTERM_FRAG;
   10016:	f885 b001 	strbhi.w	fp, [r5, #1]
   1001a:	e7c3      	b.n	ffa4 <hci_set_ad_ext+0x136>
					set_data->op = BT_HCI_LE_EXT_ADV_OP_INTERM_FRAG;
   1001c:	f04f 0300 	mov.w	r3, #0
   10020:	706b      	strb	r3, [r5, #1]
				if (offset == 0) {
   10022:	f1bb 0f00 	cmp.w	fp, #0
   10026:	d1d3      	bne.n	ffd0 <hci_set_ad_ext+0x162>
   10028:	e7bc      	b.n	ffa4 <hci_set_ad_ext+0x136>
					memcpy(&set_data->data[0], &data[j].data[offset],
   1002a:	6879      	ldr	r1, [r7, #4]
   1002c:	1d28      	adds	r0, r5, #4
   1002e:	4459      	add	r1, fp
   10030:	f7ff fdb9 	bl	fba6 <memcpy>
					offset += set_data->len;
   10034:	78eb      	ldrb	r3, [r5, #3]
   10036:	449b      	add	fp, r3
   10038:	e7df      	b.n	fffa <hci_set_ad_ext+0x18c>
		net_buf_unref(buf);
   1003a:	4638      	mov	r0, r7
   1003c:	f7fc fc0c 	bl	c858 <net_buf_unref>
		return err;
   10040:	f06f 0015 	mvn.w	r0, #21
   10044:	e794      	b.n	ff70 <hci_set_ad_ext+0x102>
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
   10046:	9802      	ldr	r0, [sp, #8]
   10048:	21ff      	movs	r1, #255	; 0xff
   1004a:	f7f2 fefb 	bl	2e44 <bt_hci_cmd_create>
	if (!buf) {
   1004e:	4607      	mov	r7, r0
   10050:	2800      	cmp	r0, #0
   10052:	d08b      	beq.n	ff6c <hci_set_ad_ext+0xfe>
   10054:	21ff      	movs	r1, #255	; 0xff
   10056:	f107 0008 	add.w	r0, r7, #8
   1005a:	f001 ff4c 	bl	11ef6 <net_buf_simple_add>
	(void)memset(set_data, 0, sizeof(*set_data));
   1005e:	22ff      	movs	r2, #255	; 0xff
   10060:	2100      	movs	r1, #0
   10062:	4605      	mov	r5, r0
   10064:	f7ff fdaa 	bl	fbbc <memset>
	if (atomic_test_bit(adv->flags, BT_ADV_EXT_ADV)) {
   10068:	9b01      	ldr	r3, [sp, #4]
   1006a:	210b      	movs	r1, #11
   1006c:	f103 0010 	add.w	r0, r3, #16
   10070:	f7ff fee7 	bl	fe42 <atomic_test_bit>
		max_data_size = BT_GAP_ADV_MAX_ADV_DATA_LEN;
   10074:	2800      	cmp	r0, #0
   10076:	eb04 02c6 	add.w	r2, r4, r6, lsl #3
   1007a:	bf14      	ite	ne
   1007c:	23fb      	movne	r3, #251	; 0xfb
   1007e:	231f      	moveq	r3, #31
	err = set_data_add_complete(set_data->data, max_data_size, ad, ad_len,
   10080:	9203      	str	r2, [sp, #12]
				ssize_t shortened_len = set_data_len_max -
   10082:	1e9a      	subs	r2, r3, #2
	err = set_data_add_complete(set_data->data, max_data_size, ad, ad_len,
   10084:	f105 0a04 	add.w	sl, r5, #4
	uint8_t set_data_len = 0;
   10088:	2600      	movs	r6, #0
				ssize_t shortened_len = set_data_len_max -
   1008a:	9204      	str	r2, [sp, #16]
		for (size_t j = 0; j < ad[i].len; j++) {
   1008c:	f8d4 9000 	ldr.w	r9, [r4]
   10090:	f04f 0b00 	mov.w	fp, #0
   10094:	6862      	ldr	r2, [r4, #4]
   10096:	4593      	cmp	fp, r2
   10098:	f4ff af17 	bcc.w	feca <hci_set_ad_ext+0x5c>
	for (size_t i = 0; i < ad_len; i++) {
   1009c:	9a03      	ldr	r2, [sp, #12]
   1009e:	3408      	adds	r4, #8
   100a0:	42a2      	cmp	r2, r4
   100a2:	d1f3      	bne.n	1008c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x8d>
	set_data->handle = adv->handle;
   100a4:	9b01      	ldr	r3, [sp, #4]
	*data_len = set_data_len;
   100a6:	70ee      	strb	r6, [r5, #3]
	set_data->handle = adv->handle;
   100a8:	785b      	ldrb	r3, [r3, #1]
   100aa:	702b      	strb	r3, [r5, #0]
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   100ac:	9802      	ldr	r0, [sp, #8]
	set_data->op = BT_HCI_LE_EXT_ADV_OP_COMPLETE_DATA;
   100ae:	2303      	movs	r3, #3
   100b0:	706b      	strb	r3, [r5, #1]
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   100b2:	2200      	movs	r2, #0
	set_data->frag_pref = BT_HCI_LE_EXT_ADV_FRAG_DISABLED;
   100b4:	2301      	movs	r3, #1
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   100b6:	4639      	mov	r1, r7
	set_data->frag_pref = BT_HCI_LE_EXT_ADV_FRAG_DISABLED;
   100b8:	70ab      	strb	r3, [r5, #2]
}
   100ba:	b007      	add	sp, #28
   100bc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   100c0:	f7f2 befa 	b.w	2eb8 <bt_hci_cmd_send_sync>

000100c4 <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
   100c4:	2207      	movs	r2, #7
   100c6:	f7ff bd6e 	b.w	fba6 <memcpy>

000100ca <atomic_set_bit_to>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   100ca:	2301      	movs	r3, #1
{
   100cc:	b410      	push	{r4}
	atomic_val_t mask = ATOMIC_MASK(bit);
   100ce:	fa03 f101 	lsl.w	r1, r3, r1
{
   100d2:	4604      	mov	r4, r0
	if (val) {
   100d4:	b162      	cbz	r2, 100f0 <atomic_set_bit_to+0x26>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   100d6:	f3bf 8f5b 	dmb	ish
   100da:	e854 3f00 	ldrex	r3, [r4]
   100de:	430b      	orrs	r3, r1
   100e0:	e844 3200 	strex	r2, r3, [r4]
   100e4:	2a00      	cmp	r2, #0
   100e6:	d1f8      	bne.n	100da <atomic_set_bit_to+0x10>
   100e8:	f3bf 8f5b 	dmb	ish
	}
}
   100ec:	bc10      	pop	{r4}
   100ee:	4770      	bx	lr
   100f0:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   100f2:	43c9      	mvns	r1, r1
   100f4:	f7ff beac 	b.w	fe50 <atomic_and>

000100f8 <le_adv_update>:
{
   100f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   100fc:	b087      	sub	sp, #28
   100fe:	4604      	mov	r4, r0
   10100:	f89d 504c 	ldrb.w	r5, [sp, #76]	; 0x4c
   10104:	f89d b044 	ldrb.w	fp, [sp, #68]	; 0x44
   10108:	f89d 8048 	ldrb.w	r8, [sp, #72]	; 0x48
   1010c:	460f      	mov	r7, r1
   1010e:	4692      	mov	sl, r2
	struct bt_ad d[2] = {};
   10110:	2100      	movs	r1, #0
   10112:	2210      	movs	r2, #16
   10114:	a802      	add	r0, sp, #8
{
   10116:	461e      	mov	r6, r3
	struct bt_ad d[2] = {};
   10118:	f7ff fd50 	bl	fbbc <memset>
	if (name_type != ADV_NAME_TYPE_NONE) {
   1011c:	b175      	cbz	r5, 1013c <le_adv_update+0x44>
		const char *name = bt_get_name();
   1011e:	f7f3 fa63 	bl	35e8 <bt_get_name>
   10122:	4681      	mov	r9, r0
		if ((ad && ad_has_name(ad, ad_len)) ||
   10124:	bb47      	cbnz	r7, 10178 <le_adv_update+0x80>
   10126:	bb9e      	cbnz	r6, 10190 <le_adv_update+0x98>
		data = (struct bt_data)BT_DATA(
   10128:	4648      	mov	r0, r9
   1012a:	f7ff fcf7 	bl	fb1c <strlen>
   1012e:	2209      	movs	r2, #9
   10130:	f88d 2000 	strb.w	r2, [sp]
   10134:	f88d 0001 	strb.w	r0, [sp, #1]
   10138:	f8cd 9004 	str.w	r9, [sp, #4]
	if (!(ext_adv && scannable)) {
   1013c:	f1bb 0f00 	cmp.w	fp, #0
   10140:	d028      	beq.n	10194 <le_adv_update+0x9c>
   10142:	f1b8 0f00 	cmp.w	r8, #0
   10146:	d025      	beq.n	10194 <le_adv_update+0x9c>
		d[0].len = sd_len;
   10148:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1014a:	9303      	str	r3, [sp, #12]
		if (name_type == ADV_NAME_TYPE_SD) {
   1014c:	2d02      	cmp	r5, #2
		d[0].data = sd;
   1014e:	9602      	str	r6, [sp, #8]
		if (name_type == ADV_NAME_TYPE_SD) {
   10150:	f04f 0301 	mov.w	r3, #1
   10154:	d043      	beq.n	101de <le_adv_update+0xe6>
		return hci_set_ad_ext(adv, BT_HCI_OP_LE_SET_EXT_SCAN_RSP_DATA,
   10156:	aa02      	add	r2, sp, #8
   10158:	f242 0138 	movw	r1, #8248	; 0x2038
   1015c:	4620      	mov	r0, r4
   1015e:	f7ff fe86 	bl	fe6e <hci_set_ad_ext>
		if (err) {
   10162:	b358      	cbz	r0, 101bc <le_adv_update+0xc4>
   10164:	e038      	b.n	101d8 <le_adv_update+0xe0>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   10166:	f817 1032 	ldrb.w	r1, [r7, r2, lsl #3]
   1016a:	3908      	subs	r1, #8
   1016c:	2901      	cmp	r1, #1
   1016e:	d93b      	bls.n	101e8 <le_adv_update+0xf0>
	for (i = 0; i < ad_len; i++) {
   10170:	3201      	adds	r2, #1
   10172:	4592      	cmp	sl, r2
   10174:	d1f7      	bne.n	10166 <le_adv_update+0x6e>
   10176:	e7d6      	b.n	10126 <le_adv_update+0x2e>
   10178:	2200      	movs	r2, #0
   1017a:	e7fa      	b.n	10172 <le_adv_update+0x7a>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   1017c:	f816 1032 	ldrb.w	r1, [r6, r2, lsl #3]
   10180:	3908      	subs	r1, #8
   10182:	2901      	cmp	r1, #1
   10184:	d930      	bls.n	101e8 <le_adv_update+0xf0>
	for (i = 0; i < ad_len; i++) {
   10186:	3201      	adds	r2, #1
   10188:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1018a:	4293      	cmp	r3, r2
   1018c:	d1f6      	bne.n	1017c <le_adv_update+0x84>
   1018e:	e7cb      	b.n	10128 <le_adv_update+0x30>
   10190:	2200      	movs	r2, #0
   10192:	e7f9      	b.n	10188 <le_adv_update+0x90>
		if (name_type == ADV_NAME_TYPE_AD) {
   10194:	2d01      	cmp	r5, #1
			d_len = 2;
   10196:	bf0c      	ite	eq
   10198:	2302      	moveq	r3, #2
		d_len = 1;
   1019a:	2301      	movne	r3, #1
		return hci_set_ad_ext(adv, BT_HCI_OP_LE_SET_EXT_ADV_DATA,
   1019c:	aa02      	add	r2, sp, #8
   1019e:	f242 0137 	movw	r1, #8247	; 0x2037
   101a2:	4620      	mov	r0, r4
			d[1].data = &data;
   101a4:	bf04      	itt	eq
   101a6:	f8cd d010 	streq.w	sp, [sp, #16]
			d[1].len = 1;
   101aa:	9505      	streq	r5, [sp, #20]
		d[0].len = ad_len;
   101ac:	e9cd 7a02 	strd	r7, sl, [sp, #8]
		return hci_set_ad_ext(adv, BT_HCI_OP_LE_SET_EXT_ADV_DATA,
   101b0:	f7ff fe5d 	bl	fe6e <hci_set_ad_ext>
		if (err) {
   101b4:	b980      	cbnz	r0, 101d8 <le_adv_update+0xe0>
	if (scannable) {
   101b6:	f1b8 0f00 	cmp.w	r8, #0
   101ba:	d1c5      	bne.n	10148 <le_adv_update+0x50>
   101bc:	3410      	adds	r4, #16
   101be:	f3bf 8f5b 	dmb	ish
   101c2:	e854 3f00 	ldrex	r3, [r4]
   101c6:	f043 0304 	orr.w	r3, r3, #4
   101ca:	e844 3200 	strex	r2, r3, [r4]
   101ce:	2a00      	cmp	r2, #0
   101d0:	d1f7      	bne.n	101c2 <le_adv_update+0xca>
   101d2:	f3bf 8f5b 	dmb	ish
	return 0;
   101d6:	2000      	movs	r0, #0
}
   101d8:	b007      	add	sp, #28
   101da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			d[1].len = 1;
   101de:	9305      	str	r3, [sp, #20]
			d[1].data = &data;
   101e0:	f8cd d010 	str.w	sp, [sp, #16]
			d_len = 2;
   101e4:	462b      	mov	r3, r5
   101e6:	e7b6      	b.n	10156 <le_adv_update+0x5e>
			return -EINVAL;
   101e8:	f06f 0015 	mvn.w	r0, #21
   101ec:	e7f4      	b.n	101d8 <le_adv_update+0xe0>

000101ee <get_adv_name_type>:
	if (atomic_test_bit(adv->flags, BT_ADV_INCLUDE_NAME_SD)) {
   101ee:	f100 0210 	add.w	r2, r0, #16
{
   101f2:	b508      	push	{r3, lr}
	if (atomic_test_bit(adv->flags, BT_ADV_INCLUDE_NAME_SD)) {
   101f4:	2108      	movs	r1, #8
   101f6:	4610      	mov	r0, r2
   101f8:	f7ff fe23 	bl	fe42 <atomic_test_bit>
   101fc:	b928      	cbnz	r0, 1020a <get_adv_name_type+0x1c>
}
   101fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	if (atomic_test_bit(adv->flags, BT_ADV_INCLUDE_NAME_AD)) {
   10202:	2107      	movs	r1, #7
   10204:	4610      	mov	r0, r2
   10206:	f7ff be1c 	b.w	fe42 <atomic_test_bit>
}
   1020a:	2002      	movs	r0, #2
   1020c:	bd08      	pop	{r3, pc}

0001020e <get_adv_name_type_param>:
	if (param->options & BT_LE_ADV_OPT_USE_NAME) {
   1020e:	6843      	ldr	r3, [r0, #4]
   10210:	f013 0008 	ands.w	r0, r3, #8
   10214:	d00a      	beq.n	1022c <get_adv_name_type_param+0x1e>
		if (param->options & BT_LE_ADV_OPT_FORCE_NAME_IN_AD) {
   10216:	035a      	lsls	r2, r3, #13
   10218:	d407      	bmi.n	1022a <get_adv_name_type_param+0x1c>
		if ((param->options & BT_LE_ADV_OPT_EXT_ADV) &&
   1021a:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
		return ADV_NAME_TYPE_SD;
   1021e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   10222:	bf0c      	ite	eq
   10224:	2001      	moveq	r0, #1
   10226:	2002      	movne	r0, #2
   10228:	4770      	bx	lr
			return ADV_NAME_TYPE_AD;
   1022a:	2001      	movs	r0, #1
}
   1022c:	4770      	bx	lr

0001022e <le_ext_adv_param_set>:
{
   1022e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	bool dir_adv = param->peer != NULL, scannable;
   10232:	f8d1 8010 	ldr.w	r8, [r1, #16]
{
   10236:	4607      	mov	r7, r0
	bool dir_adv = param->peer != NULL, scannable;
   10238:	f1b8 0600 	subs.w	r6, r8, #0
{
   1023c:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EXT_ADV_PARAM, sizeof(*cp));
   1023e:	f242 0036 	movw	r0, #8246	; 0x2036
   10242:	f04f 0119 	mov.w	r1, #25
{
   10246:	4693      	mov	fp, r2
	bool dir_adv = param->peer != NULL, scannable;
   10248:	bf18      	it	ne
   1024a:	2601      	movne	r6, #1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EXT_ADV_PARAM, sizeof(*cp));
   1024c:	f7f2 fdfa 	bl	2e44 <bt_hci_cmd_create>
	if (!buf) {
   10250:	4682      	mov	sl, r0
   10252:	2800      	cmp	r0, #0
   10254:	f000 80fc 	beq.w	10450 <le_ext_adv_param_set+0x222>
   10258:	2119      	movs	r1, #25
   1025a:	3008      	adds	r0, #8
   1025c:	f001 fe4b 	bl	11ef6 <net_buf_simple_add>
	(void)memset(cp, 0, sizeof(*cp));
   10260:	2219      	movs	r2, #25
   10262:	4604      	mov	r4, r0
   10264:	2100      	movs	r1, #0
   10266:	f7ff fca9 	bl	fbbc <memset>
	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv,
   1026a:	4632      	mov	r2, r6
   1026c:	6869      	ldr	r1, [r5, #4]
   1026e:	f104 030a 	add.w	r3, r4, #10
   10272:	4638      	mov	r0, r7
   10274:	f7f3 fb2c 	bl	38d0 <bt_id_set_adv_own_addr>
	if (err) {
   10278:	4606      	mov	r6, r0
   1027a:	2800      	cmp	r0, #0
   1027c:	f040 80d6 	bne.w	1042c <le_ext_adv_param_set+0x1fe>
		bt_addr_le_copy(&adv->target_addr, param->peer);
   10280:	f107 0009 	add.w	r0, r7, #9
	if (dir_adv) {
   10284:	f1b8 0f00 	cmp.w	r8, #0
   10288:	f000 80d4 	beq.w	10434 <le_ext_adv_param_set+0x206>
		bt_addr_le_copy(&adv->target_addr, param->peer);
   1028c:	6929      	ldr	r1, [r5, #16]
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
   1028e:	f7ff ff19 	bl	100c4 <bt_addr_le_copy>
	name_type = get_adv_name_type_param(param);
   10292:	4628      	mov	r0, r5
   10294:	f7ff ffbb 	bl	1020e <get_adv_name_type_param>
	cp->handle = adv->handle;
   10298:	787b      	ldrb	r3, [r7, #1]
   1029a:	7023      	strb	r3, [r4, #0]
	sys_put_le24(param->interval_min, cp->prim_min_interval);
   1029c:	68ab      	ldr	r3, [r5, #8]
	dst[0] = val;
   1029e:	70e3      	strb	r3, [r4, #3]
	dst[1] = val >> 8;
   102a0:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[2] = val >> 16;
   102a4:	0c1b      	lsrs	r3, r3, #16
	dst[1] = val >> 8;
   102a6:	7122      	strb	r2, [r4, #4]
	dst[2] = val >> 16;
   102a8:	7163      	strb	r3, [r4, #5]
	sys_put_le24(param->interval_max, cp->prim_max_interval);
   102aa:	68eb      	ldr	r3, [r5, #12]
	dst[0] = val;
   102ac:	71a3      	strb	r3, [r4, #6]
	dst[1] = val >> 8;
   102ae:	f3c3 2207 	ubfx	r2, r3, #8, #8
	dst[2] = val >> 16;
   102b2:	0c1b      	lsrs	r3, r3, #16
	dst[1] = val >> 8;
   102b4:	71e2      	strb	r2, [r4, #7]
	dst[2] = val >> 16;
   102b6:	7223      	strb	r3, [r4, #8]
	cp->prim_channel_map = get_adv_channel_map(param->options);
   102b8:	686e      	ldr	r6, [r5, #4]
	name_type = get_adv_name_type_param(param);
   102ba:	4681      	mov	r9, r0
	cp->prim_channel_map = get_adv_channel_map(param->options);
   102bc:	4630      	mov	r0, r6
   102be:	f7ff fdab 	bl	fe18 <get_adv_channel_map>
	cp->filter_policy = get_filter_policy(param->options);
   102c2:	2300      	movs	r3, #0
   102c4:	74a3      	strb	r3, [r4, #18]
	cp->tx_power = BT_HCI_LE_ADV_TX_POWER_NO_PREF;
   102c6:	237f      	movs	r3, #127	; 0x7f
   102c8:	74e3      	strb	r3, [r4, #19]
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
   102ca:	f416 6280 	ands.w	r2, r6, #1024	; 0x400
	cp->prim_adv_phy = BT_HCI_LE_PHY_1M;
   102ce:	f04f 0301 	mov.w	r3, #1
	cp->prim_channel_map = get_adv_channel_map(param->options);
   102d2:	7260      	strb	r0, [r4, #9]
	cp->prim_adv_phy = BT_HCI_LE_PHY_1M;
   102d4:	7523      	strb	r3, [r4, #20]
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
   102d6:	d003      	beq.n	102e0 <le_ext_adv_param_set+0xb2>
		if (param->options & BT_LE_ADV_OPT_NO_2M) {
   102d8:	0531      	lsls	r1, r6, #20
			cp->sec_adv_phy = BT_HCI_LE_PHY_2M;
   102da:	bf58      	it	pl
   102dc:	2302      	movpl	r3, #2
   102de:	75a3      	strb	r3, [r4, #22]
	if (param->options & BT_LE_ADV_OPT_CODED) {
   102e0:	04f0      	lsls	r0, r6, #19
		cp->prim_adv_phy = BT_HCI_LE_PHY_CODED;
   102e2:	bf42      	ittt	mi
   102e4:	2303      	movmi	r3, #3
   102e6:	7523      	strbmi	r3, [r4, #20]
		cp->sec_adv_phy = BT_HCI_LE_PHY_CODED;
   102e8:	75a3      	strbmi	r3, [r4, #22]
	if (!(param->options & BT_LE_ADV_OPT_EXT_ADV)) {
   102ea:	b92a      	cbnz	r2, 102f8 <le_ext_adv_param_set+0xca>
		cp->props |= BT_HCI_LE_ADV_PROP_LEGACY;
   102ec:	f8b4 3001 	ldrh.w	r3, [r4, #1]
   102f0:	f043 0310 	orr.w	r3, r3, #16
   102f4:	f8a4 3001 	strh.w	r3, [r4, #1]
	if (param->options & BT_LE_ADV_OPT_USE_TX_POWER) {
   102f8:	0471      	lsls	r1, r6, #17
		cp->props |= BT_HCI_LE_ADV_PROP_TX_POWER;
   102fa:	bf42      	ittt	mi
   102fc:	f8b4 3001 	ldrhmi.w	r3, [r4, #1]
   10300:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
   10304:	f8a4 3001 	strhmi.w	r3, [r4, #1]
	if (param->options & BT_LE_ADV_OPT_ANONYMOUS) {
   10308:	04b3      	lsls	r3, r6, #18
		cp->props |= BT_HCI_LE_ADV_PROP_ANON;
   1030a:	bf42      	ittt	mi
   1030c:	f8b4 3001 	ldrhmi.w	r3, [r4, #1]
   10310:	f043 0320 	orrmi.w	r3, r3, #32
   10314:	f8a4 3001 	strhmi.w	r3, [r4, #1]
	if (param->options & BT_LE_ADV_OPT_NOTIFY_SCAN_REQ) {
   10318:	05f0      	lsls	r0, r6, #23
		cp->scan_req_notify_enable = BT_HCI_LE_ADV_SCAN_REQ_ENABLE;
   1031a:	bf44      	itt	mi
   1031c:	2301      	movmi	r3, #1
   1031e:	7623      	strbmi	r3, [r4, #24]
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
   10320:	07f1      	lsls	r1, r6, #31
   10322:	d50d      	bpl.n	10340 <le_ext_adv_param_set+0x112>
		cp->props |= BT_HCI_LE_ADV_PROP_CONN;
   10324:	f8b4 3001 	ldrh.w	r3, [r4, #1]
   10328:	f043 0101 	orr.w	r1, r3, #1
   1032c:	f8a4 1001 	strh.w	r1, [r4, #1]
		if (!dir_adv && !(param->options & BT_LE_ADV_OPT_EXT_ADV)) {
   10330:	f1b8 0f00 	cmp.w	r8, #0
   10334:	d104      	bne.n	10340 <le_ext_adv_param_set+0x112>
   10336:	b91a      	cbnz	r2, 10340 <le_ext_adv_param_set+0x112>
			cp->props |= BT_HCI_LE_ADV_PROP_SCAN;
   10338:	f043 0303 	orr.w	r3, r3, #3
   1033c:	f8a4 3001 	strh.w	r3, [r4, #1]
	if ((param->options & BT_LE_ADV_OPT_SCANNABLE) || has_scan_data ||
   10340:	05b3      	lsls	r3, r6, #22
   10342:	d405      	bmi.n	10350 <le_ext_adv_param_set+0x122>
   10344:	f1bb 0f00 	cmp.w	fp, #0
   10348:	d102      	bne.n	10350 <le_ext_adv_param_set+0x122>
   1034a:	f1b9 0f02 	cmp.w	r9, #2
   1034e:	d105      	bne.n	1035c <le_ext_adv_param_set+0x12e>
		cp->props |= BT_HCI_LE_ADV_PROP_SCAN;
   10350:	f8b4 3001 	ldrh.w	r3, [r4, #1]
   10354:	f043 0302 	orr.w	r3, r3, #2
   10358:	f8a4 3001 	strh.w	r3, [r4, #1]
	scannable = !!(cp->props & BT_HCI_LE_ADV_PROP_SCAN);
   1035c:	f8b4 b001 	ldrh.w	fp, [r4, #1]
	if (dir_adv) {
   10360:	f1b8 0f00 	cmp.w	r8, #0
   10364:	d00c      	beq.n	10380 <le_ext_adv_param_set+0x152>
		if (!(param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY)) {
   10366:	06f6      	lsls	r6, r6, #27
		cp->props |= BT_HCI_LE_ADV_PROP_DIRECT;
   10368:	bf4c      	ite	mi
   1036a:	f04b 0304 	orrmi.w	r3, fp, #4
			cp->props |= BT_HCI_LE_ADV_PROP_HI_DC_CONN;
   1036e:	f04b 030c 	orrpl.w	r3, fp, #12
		bt_addr_le_copy(&cp->peer_addr, param->peer);
   10372:	6929      	ldr	r1, [r5, #16]
			cp->props |= BT_HCI_LE_ADV_PROP_HI_DC_CONN;
   10374:	f8a4 3001 	strh.w	r3, [r4, #1]
		bt_addr_le_copy(&cp->peer_addr, param->peer);
   10378:	f104 000b 	add.w	r0, r4, #11
   1037c:	f7ff fea2 	bl	100c4 <bt_addr_le_copy>
	cp->sid = param->sid;
   10380:	786b      	ldrb	r3, [r5, #1]
   10382:	75e3      	strb	r3, [r4, #23]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EXT_ADV_PARAM, buf, &rsp);
   10384:	466a      	mov	r2, sp
   10386:	4651      	mov	r1, sl
   10388:	f242 0036 	movw	r0, #8246	; 0x2036
   1038c:	f7f2 fd94 	bl	2eb8 <bt_hci_cmd_send_sync>
	if (err) {
   10390:	4606      	mov	r6, r0
   10392:	2800      	cmp	r0, #0
   10394:	d14a      	bne.n	1042c <le_ext_adv_param_set+0x1fe>
	struct bt_hci_rp_le_set_ext_adv_param *rp = (void *)rsp->data;
   10396:	9800      	ldr	r0, [sp, #0]
	adv->tx_power = rp->tx_power;
   10398:	6883      	ldr	r3, [r0, #8]
   1039a:	785b      	ldrb	r3, [r3, #1]
   1039c:	763b      	strb	r3, [r7, #24]
	atomic_set_bit(adv->flags, BT_ADV_PARAMS_SET);
   1039e:	f107 0410 	add.w	r4, r7, #16
	net_buf_unref(rsp);
   103a2:	f7fc fa59 	bl	c858 <net_buf_unref>
   103a6:	f3bf 8f5b 	dmb	ish
   103aa:	e854 3f00 	ldrex	r3, [r4]
   103ae:	f043 0302 	orr.w	r3, r3, #2
   103b2:	e844 3200 	strex	r2, r3, [r4]
   103b6:	2a00      	cmp	r2, #0
   103b8:	d1f7      	bne.n	103aa <le_ext_adv_param_set+0x17c>
   103ba:	f3bf 8f5b 	dmb	ish
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   103be:	f06f 0108 	mvn.w	r1, #8
   103c2:	4620      	mov	r0, r4
   103c4:	f7ff fd44 	bl	fe50 <atomic_and>
	if (atomic_test_and_clear_bit(adv->flags, BT_ADV_RANDOM_ADDR_PENDING)) {
   103c8:	0700      	lsls	r0, r0, #28
   103ca:	d439      	bmi.n	10440 <le_ext_adv_param_set+0x212>
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   103cc:	f46f 5100 	mvn.w	r1, #8192	; 0x2000
   103d0:	4620      	mov	r0, r4
   103d2:	f7ff fd3d 	bl	fe50 <atomic_and>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_AD,
   103d6:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
   103da:	425a      	negs	r2, r3
   103dc:	415a      	adcs	r2, r3
   103de:	2107      	movs	r1, #7
   103e0:	4620      	mov	r0, r4
   103e2:	f7ff fe72 	bl	100ca <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD,
   103e6:	f1a9 0102 	sub.w	r1, r9, #2
   103ea:	424a      	negs	r2, r1
   103ec:	414a      	adcs	r2, r1
   103ee:	4620      	mov	r0, r4
   103f0:	2108      	movs	r1, #8
   103f2:	f7ff fe6a 	bl	100ca <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
   103f6:	686a      	ldr	r2, [r5, #4]
   103f8:	2109      	movs	r1, #9
   103fa:	f002 0201 	and.w	r2, r2, #1
   103fe:	4620      	mov	r0, r4
   10400:	f7ff fe63 	bl	100ca <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_SCANNABLE, scannable);
   10404:	f3cb 0240 	ubfx	r2, fp, #1, #1
   10408:	210a      	movs	r1, #10
   1040a:	4620      	mov	r0, r4
   1040c:	f7ff fe5d 	bl	100ca <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
   10410:	686a      	ldr	r2, [r5, #4]
   10412:	210c      	movs	r1, #12
   10414:	f3c2 0280 	ubfx	r2, r2, #2, #1
   10418:	4620      	mov	r0, r4
   1041a:	f7ff fe56 	bl	100ca <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_EXT_ADV,
   1041e:	686a      	ldr	r2, [r5, #4]
   10420:	210b      	movs	r1, #11
   10422:	f3c2 2280 	ubfx	r2, r2, #10, #1
   10426:	4620      	mov	r0, r4
   10428:	f7ff fe4f 	bl	100ca <atomic_set_bit_to>
}
   1042c:	4630      	mov	r0, r6
   1042e:	b003      	add	sp, #12
   10430:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
   10434:	f8cd 8000 	str.w	r8, [sp]
   10438:	4669      	mov	r1, sp
   1043a:	f8cd 8003 	str.w	r8, [sp, #3]
   1043e:	e726      	b.n	1028e <le_ext_adv_param_set+0x60>
		err = bt_id_set_adv_random_addr(adv, &adv->random_addr.a);
   10440:	1cf9      	adds	r1, r7, #3
   10442:	4638      	mov	r0, r7
   10444:	f7ff fc8b 	bl	fd5e <bt_id_set_adv_random_addr>
		if (err) {
   10448:	2800      	cmp	r0, #0
   1044a:	d0bf      	beq.n	103cc <le_ext_adv_param_set+0x19e>
   1044c:	4606      	mov	r6, r0
   1044e:	e7ed      	b.n	1042c <le_ext_adv_param_set+0x1fe>
		return -ENOBUFS;
   10450:	f06f 0668 	mvn.w	r6, #104	; 0x68
   10454:	e7ea      	b.n	1042c <le_ext_adv_param_set+0x1fe>

00010456 <bt_le_adv_set_enable_ext>:
{
   10456:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1045a:	4680      	mov	r8, r0
   1045c:	b086      	sub	sp, #24
   1045e:	460f      	mov	r7, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EXT_ADV_ENABLE, 6);
   10460:	f242 0039 	movw	r0, #8249	; 0x2039
   10464:	2106      	movs	r1, #6
{
   10466:	4614      	mov	r4, r2
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EXT_ADV_ENABLE, 6);
   10468:	f7f2 fcec 	bl	2e44 <bt_hci_cmd_create>
	if (!buf) {
   1046c:	4605      	mov	r5, r0
   1046e:	b380      	cbz	r0, 104d2 <bt_le_adv_set_enable_ext+0x7c>
	return net_buf_simple_add_u8(&buf->b, val);
   10470:	f100 0608 	add.w	r6, r0, #8
	if (enable) {
   10474:	b33f      	cbz	r7, 104c6 <bt_le_adv_set_enable_ext+0x70>
   10476:	2101      	movs	r1, #1
   10478:	4630      	mov	r0, r6
   1047a:	f001 fd4b 	bl	11f14 <net_buf_simple_add_u8>
   1047e:	2101      	movs	r1, #1
   10480:	4630      	mov	r0, r6
   10482:	f001 fd47 	bl	11f14 <net_buf_simple_add_u8>
   10486:	f898 1001 	ldrb.w	r1, [r8, #1]
   1048a:	4630      	mov	r0, r6
   1048c:	f001 fd42 	bl	11f14 <net_buf_simple_add_u8>
	net_buf_add_le16(buf, param ? sys_cpu_to_le16(param->timeout) : 0);
   10490:	b1dc      	cbz	r4, 104ca <bt_le_adv_set_enable_ext+0x74>
   10492:	8821      	ldrh	r1, [r4, #0]
	net_buf_simple_add_le16(&buf->b, val);
   10494:	4630      	mov	r0, r6
   10496:	f001 fd45 	bl	11f24 <net_buf_simple_add_le16>
	net_buf_add_u8(buf, param ? param->num_events : 0);
   1049a:	b1c4      	cbz	r4, 104ce <bt_le_adv_set_enable_ext+0x78>
   1049c:	78a1      	ldrb	r1, [r4, #2]
	return net_buf_simple_add_u8(&buf->b, val);
   1049e:	4630      	mov	r0, r6
   104a0:	f001 fd38 	bl	11f14 <net_buf_simple_add_u8>
	bt_hci_cmd_state_set_init(buf, &state, adv->flags, BT_ADV_ENABLED, enable);
   104a4:	f108 0210 	add.w	r2, r8, #16
   104a8:	a903      	add	r1, sp, #12
   104aa:	4628      	mov	r0, r5
   104ac:	9700      	str	r7, [sp, #0]
   104ae:	2306      	movs	r3, #6
   104b0:	f7f2 fcb6 	bl	2e20 <bt_hci_cmd_state_set_init>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EXT_ADV_ENABLE, buf, NULL);
   104b4:	2200      	movs	r2, #0
   104b6:	4629      	mov	r1, r5
   104b8:	f242 0039 	movw	r0, #8249	; 0x2039
   104bc:	f7f2 fcfc 	bl	2eb8 <bt_hci_cmd_send_sync>
}
   104c0:	b006      	add	sp, #24
   104c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   104c6:	4639      	mov	r1, r7
   104c8:	e7d6      	b.n	10478 <bt_le_adv_set_enable_ext+0x22>
	net_buf_add_le16(buf, param ? sys_cpu_to_le16(param->timeout) : 0);
   104ca:	4621      	mov	r1, r4
   104cc:	e7e2      	b.n	10494 <bt_le_adv_set_enable_ext+0x3e>
	net_buf_add_u8(buf, param ? param->num_events : 0);
   104ce:	4621      	mov	r1, r4
   104d0:	e7e5      	b.n	1049e <bt_le_adv_set_enable_ext+0x48>
		return -ENOBUFS;
   104d2:	f06f 0068 	mvn.w	r0, #104	; 0x68
   104d6:	e7f3      	b.n	104c0 <bt_le_adv_set_enable_ext+0x6a>

000104d8 <bt_le_lim_adv_cancel_timeout>:
	return k_work_cancel_delayable(&adv->lim_adv_timeout_work);
   104d8:	3020      	adds	r0, #32
   104da:	f002 b978 	b.w	127ce <k_work_cancel_delayable>

000104de <bt_le_ext_adv_set_data>:
{
   104de:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   104e2:	4616      	mov	r6, r2
	ext_adv = atomic_test_bit(adv->flags, BT_ADV_EXT_ADV);
   104e4:	f100 0210 	add.w	r2, r0, #16
{
   104e8:	b085      	sub	sp, #20
   104ea:	4604      	mov	r4, r0
   104ec:	460d      	mov	r5, r1
	ext_adv = atomic_test_bit(adv->flags, BT_ADV_EXT_ADV);
   104ee:	4610      	mov	r0, r2
   104f0:	210b      	movs	r1, #11
{
   104f2:	461f      	mov	r7, r3
	ext_adv = atomic_test_bit(adv->flags, BT_ADV_EXT_ADV);
   104f4:	f7ff fca5 	bl	fe42 <atomic_test_bit>
	scannable = atomic_test_bit(adv->flags, BT_ADV_SCANNABLE);
   104f8:	210a      	movs	r1, #10
	ext_adv = atomic_test_bit(adv->flags, BT_ADV_EXT_ADV);
   104fa:	4680      	mov	r8, r0
	scannable = atomic_test_bit(adv->flags, BT_ADV_SCANNABLE);
   104fc:	4610      	mov	r0, r2
   104fe:	f7ff fca0 	bl	fe42 <atomic_test_bit>
   10502:	4681      	mov	r9, r0
	return le_adv_update(adv, ad, ad_len, sd, sd_len, ext_adv, scannable,
   10504:	4620      	mov	r0, r4
   10506:	f7ff fe72 	bl	101ee <get_adv_name_type>
   1050a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1050c:	9300      	str	r3, [sp, #0]
   1050e:	e9cd 9002 	strd	r9, r0, [sp, #8]
   10512:	f8cd 8004 	str.w	r8, [sp, #4]
   10516:	463b      	mov	r3, r7
   10518:	4632      	mov	r2, r6
   1051a:	4629      	mov	r1, r5
   1051c:	4620      	mov	r0, r4
   1051e:	f7ff fdeb 	bl	100f8 <le_adv_update>
}
   10522:	b005      	add	sp, #20
   10524:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00010528 <bt_le_ext_adv_start>:
{
   10528:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   1052a:	f100 0610 	add.w	r6, r0, #16
{
   1052e:	4604      	mov	r4, r0
   10530:	460d      	mov	r5, r1
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
   10532:	4630      	mov	r0, r6
   10534:	2106      	movs	r1, #6
   10536:	f7ff fc84 	bl	fe42 <atomic_test_bit>
   1053a:	bb98      	cbnz	r0, 105a4 <bt_le_ext_adv_start+0x7c>
	atomic_set_bit_to(adv->flags, BT_ADV_LIMITED, param &&
   1053c:	b375      	cbz	r5, 1059c <bt_le_ext_adv_start+0x74>
   1053e:	882b      	ldrh	r3, [r5, #0]
   10540:	bb73      	cbnz	r3, 105a0 <bt_le_ext_adv_start+0x78>
			  (param->timeout > 0 || param->num_events > 0));
   10542:	78aa      	ldrb	r2, [r5, #2]
   10544:	3a00      	subs	r2, #0
   10546:	bf18      	it	ne
   10548:	2201      	movne	r2, #1
	atomic_set_bit_to(adv->flags, BT_ADV_LIMITED, param &&
   1054a:	2105      	movs	r1, #5
   1054c:	4630      	mov	r0, r6
   1054e:	f7ff fdbc 	bl	100ca <atomic_set_bit_to>
	if (atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
   10552:	2109      	movs	r1, #9
   10554:	4630      	mov	r0, r6
   10556:	f7ff fc74 	bl	fe42 <atomic_test_bit>
   1055a:	b938      	cbnz	r0, 1056c <bt_le_ext_adv_start+0x44>
		if (!atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY)) {
   1055c:	210c      	movs	r1, #12
   1055e:	4630      	mov	r0, r6
   10560:	f7ff fc6f 	bl	fe42 <atomic_test_bit>
   10564:	b910      	cbnz	r0, 1056c <bt_le_ext_adv_start+0x44>
			bt_id_set_adv_private_addr(adv);
   10566:	4620      	mov	r0, r4
   10568:	f7ff fc43 	bl	fdf2 <bt_id_set_adv_private_addr>
	if (get_adv_name_type(adv) != ADV_NAME_TYPE_NONE &&
   1056c:	4620      	mov	r0, r4
   1056e:	f7ff fe3e 	bl	101ee <get_adv_name_type>
   10572:	b158      	cbz	r0, 1058c <bt_le_ext_adv_start+0x64>
	    !atomic_test_bit(adv->flags, BT_ADV_DATA_SET)) {
   10574:	2102      	movs	r1, #2
   10576:	4630      	mov	r0, r6
   10578:	f7ff fc63 	bl	fe42 <atomic_test_bit>
	if (get_adv_name_type(adv) != ADV_NAME_TYPE_NONE &&
   1057c:	4603      	mov	r3, r0
   1057e:	b928      	cbnz	r0, 1058c <bt_le_ext_adv_start+0x64>
		bt_le_ext_adv_set_data(adv, NULL, 0, NULL, 0);
   10580:	9000      	str	r0, [sp, #0]
   10582:	4602      	mov	r2, r0
   10584:	4601      	mov	r1, r0
   10586:	4620      	mov	r0, r4
   10588:	f7ff ffa9 	bl	104de <bt_le_ext_adv_set_data>
	err = bt_le_adv_set_enable_ext(adv, true, param);
   1058c:	462a      	mov	r2, r5
   1058e:	2101      	movs	r1, #1
   10590:	4620      	mov	r0, r4
}
   10592:	b002      	add	sp, #8
   10594:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	err = bt_le_adv_set_enable_ext(adv, true, param);
   10598:	f7ff bf5d 	b.w	10456 <bt_le_adv_set_enable_ext>
	atomic_set_bit_to(adv->flags, BT_ADV_LIMITED, param &&
   1059c:	462a      	mov	r2, r5
   1059e:	e7d4      	b.n	1054a <bt_le_ext_adv_start+0x22>
   105a0:	2201      	movs	r2, #1
   105a2:	e7d2      	b.n	1054a <bt_le_ext_adv_start+0x22>
}
   105a4:	f06f 0077 	mvn.w	r0, #119	; 0x77
   105a8:	b002      	add	sp, #8
   105aa:	bd70      	pop	{r4, r5, r6, pc}

000105ac <atomic_and>:
{
   105ac:	4603      	mov	r3, r0
}
   105ae:	f3bf 8f5b 	dmb	ish
   105b2:	e853 0f00 	ldrex	r0, [r3]
   105b6:	ea00 0201 	and.w	r2, r0, r1
   105ba:	e843 2c00 	strex	ip, r2, [r3]
   105be:	f1bc 0f00 	cmp.w	ip, #0
   105c2:	d1f6      	bne.n	105b2 <atomic_and+0x6>
   105c4:	f3bf 8f5b 	dmb	ish
   105c8:	4770      	bx	lr

000105ca <bt_le_scan_set_enable>:
		return set_le_ext_scan_enable(enable, 0);
   105ca:	2100      	movs	r1, #0
   105cc:	f7f3 bb3a 	b.w	3c44 <set_le_ext_scan_enable>

000105d0 <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, uint16_t mem_size, uint16_t mem_count,
	      void **mem_head)
{
   105d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	*mem_head = mem_pool;
   105d2:	6018      	str	r0, [r3, #0]

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   105d4:	1dc3      	adds	r3, r0, #7
{
   105d6:	4605      	mov	r5, r0
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   105d8:	f023 0303 	bic.w	r3, r3, #3

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   105dc:	1e50      	subs	r0, r2, #1
{
   105de:	460e      	mov	r6, r1
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   105e0:	b280      	uxth	r0, r0
{
   105e2:	4614      	mov	r4, r2
	*((uint16_t *)MROUND((uint8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   105e4:	801a      	strh	r2, [r3, #0]
	(void)memset(((uint8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   105e6:	2100      	movs	r1, #0
   105e8:	2204      	movs	r2, #4
   105ea:	fb06 5000 	mla	r0, r6, r0, r5
   105ee:	f7ff fae5 	bl	fbbc <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
   105f2:	3c02      	subs	r4, #2
   105f4:	b2a4      	uxth	r4, r4
   105f6:	f64f 77ff 	movw	r7, #65535	; 0xffff
   105fa:	42bc      	cmp	r4, r7
   105fc:	d101      	bne.n	10602 <mem_init+0x32>
		next = (uint32_t)((uint8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
		       (void *)&next, sizeof(next));
	}
}
   105fe:	b003      	add	sp, #12
   10600:	bdf0      	pop	{r4, r5, r6, r7, pc}
			       (mem_size * (mem_count + 1)));
   10602:	1c63      	adds	r3, r4, #1
   10604:	b29b      	uxth	r3, r3
   10606:	4373      	muls	r3, r6
		next = (uint32_t)((uint8_t *) mem_pool +
   10608:	18ea      	adds	r2, r5, r3
   1060a:	9201      	str	r2, [sp, #4]
		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
   1060c:	1b98      	subs	r0, r3, r6
   1060e:	2204      	movs	r2, #4
   10610:	eb0d 0102 	add.w	r1, sp, r2
   10614:	4428      	add	r0, r5
   10616:	3c01      	subs	r4, #1
   10618:	f7ff fac5 	bl	fba6 <memcpy>
   1061c:	b2a4      	uxth	r4, r4
   1061e:	e7ec      	b.n	105fa <mem_init+0x2a>

00010620 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
   10620:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (*mem_head) {
   10622:	6804      	ldr	r4, [r0, #0]
{
   10624:	4605      	mov	r5, r0
	if (*mem_head) {
   10626:	b18c      	cbz	r4, 1064c <mem_acquire+0x2c>
		uint16_t free_count;
		void *head;
		void *mem;

		/* Get the free count from the list and decrement it */
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
   10628:	1de3      	adds	r3, r4, #7
   1062a:	f023 0303 	bic.w	r3, r3, #3
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
   1062e:	2204      	movs	r2, #4
   10630:	4621      	mov	r1, r4
   10632:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
   10636:	881e      	ldrh	r6, [r3, #0]
		memcpy(&head, mem, sizeof(head));
   10638:	f7ff fab5 	bl	fba6 <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
   1063c:	9b01      	ldr	r3, [sp, #4]
   1063e:	b123      	cbz	r3, 1064a <mem_acquire+0x2a>
			*((uint16_t *)MROUND((uint8_t *)head + sizeof(head))) =
   10640:	1dda      	adds	r2, r3, #7
   10642:	f022 0203 	bic.w	r2, r2, #3
		free_count--;
   10646:	3e01      	subs	r6, #1
			*((uint16_t *)MROUND((uint8_t *)head + sizeof(head))) =
   10648:	8016      	strh	r6, [r2, #0]
				free_count;
		}

		*mem_head = head;
   1064a:	602b      	str	r3, [r5, #0]
		return mem;
	}

	return NULL;
}
   1064c:	4620      	mov	r0, r4
   1064e:	b002      	add	sp, #8
   10650:	bd70      	pop	{r4, r5, r6, pc}

00010652 <mem_release>:

void mem_release(void *mem, void **mem_head)
{
   10652:	b570      	push	{r4, r5, r6, lr}
	uint16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
   10654:	680c      	ldr	r4, [r1, #0]
{
   10656:	4606      	mov	r6, r0
   10658:	460d      	mov	r5, r1
	if (*mem_head) {
   1065a:	b11c      	cbz	r4, 10664 <mem_release+0x12>
		free_count = *((uint16_t *)MROUND((uint8_t *)*mem_head +
   1065c:	1de3      	adds	r3, r4, #7
   1065e:	f023 0303 	bic.w	r3, r3, #3
   10662:	881c      	ldrh	r4, [r3, #0]
					       sizeof(mem_head)));
	}
	free_count++;

	memcpy(mem, mem_head, sizeof(mem));
   10664:	2204      	movs	r2, #4
   10666:	4629      	mov	r1, r5
   10668:	4630      	mov	r0, r6
   1066a:	f7ff fa9c 	bl	fba6 <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((uint16_t *)MROUND((uint8_t *)mem + sizeof(mem))) = free_count;
   1066e:	1df2      	adds	r2, r6, #7
   10670:	f022 0203 	bic.w	r2, r2, #3
	free_count++;
   10674:	1c63      	adds	r3, r4, #1
	*((uint16_t *)MROUND((uint8_t *)mem + sizeof(mem))) = free_count;
   10676:	8013      	strh	r3, [r2, #0]

	*mem_head = mem;
   10678:	602e      	str	r6, [r5, #0]
}
   1067a:	bd70      	pop	{r4, r5, r6, pc}

0001067c <mem_index_get>:
	return ((void *)((uint8_t *)mem_pool + (mem_size * index)));
}

uint16_t mem_index_get(void *mem, void *mem_pool, uint16_t mem_size)
{
	return ((uint16_t)((uint8_t *)mem - (uint8_t *)mem_pool) / mem_size);
   1067c:	1a40      	subs	r0, r0, r1
   1067e:	b280      	uxth	r0, r0
}
   10680:	fbb0 f0f2 	udiv	r0, r0, r2
   10684:	4770      	bx	lr

00010686 <mem_rcopy>:
/**
 * @brief  Copy bytes in reverse
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(uint8_t *dst, uint8_t const *src, uint16_t len)
{
   10686:	b510      	push	{r4, lr}
	src += len;
   10688:	4411      	add	r1, r2
	while (len--) {
   1068a:	3801      	subs	r0, #1
   1068c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   10690:	3a01      	subs	r2, #1
   10692:	b292      	uxth	r2, r2
   10694:	429a      	cmp	r2, r3
   10696:	d100      	bne.n	1069a <mem_rcopy+0x14>
		*dst++ = *--src;
	}
}
   10698:	bd10      	pop	{r4, pc}
		*dst++ = *--src;
   1069a:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
   1069e:	f800 4f01 	strb.w	r4, [r0, #1]!
   106a2:	e7f5      	b.n	10690 <mem_rcopy+0xa>

000106a4 <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
uint8_t mem_nz(uint8_t *src, uint16_t len)
{
	while (len--) {
   106a4:	4401      	add	r1, r0
   106a6:	4288      	cmp	r0, r1
   106a8:	d101      	bne.n	106ae <mem_nz+0xa>
		if (*src++) {
			return 1;
		}
	}

	return 0;
   106aa:	2000      	movs	r0, #0
   106ac:	4770      	bx	lr
		if (*src++) {
   106ae:	f810 3b01 	ldrb.w	r3, [r0], #1
   106b2:	2b00      	cmp	r3, #0
   106b4:	d0f7      	beq.n	106a6 <mem_nz+0x2>
			return 1;
   106b6:	2001      	movs	r0, #1
}
   106b8:	4770      	bx	lr

000106ba <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
   106ba:	6010      	str	r0, [r2, #0]
   106bc:	6008      	str	r0, [r1, #0]

	return link;
}
   106be:	4770      	bx	lr

000106c0 <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
   106c0:	b510      	push	{r4, lr}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
   106c2:	6814      	ldr	r4, [r2, #0]
   106c4:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
   106c6:	6814      	ldr	r4, [r2, #0]
   106c8:	6061      	str	r1, [r4, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	cpu_dmb(); /* Ensure data accesses are synchronized */
	*tail = link; /* Commit: enqueue of memq node */
   106ca:	6010      	str	r0, [r2, #0]

	return link;
}
   106cc:	bd10      	pop	{r4, pc}

000106ce <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
   106ce:	4288      	cmp	r0, r1
   106d0:	d003      	beq.n	106da <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
   106d2:	b11a      	cbz	r2, 106dc <memq_peek+0xe>
		*mem = head->mem;
   106d4:	6843      	ldr	r3, [r0, #4]
   106d6:	6013      	str	r3, [r2, #0]
   106d8:	4770      	bx	lr
		return NULL;
   106da:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
   106dc:	4770      	bx	lr

000106de <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
   106de:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
   106e0:	4283      	cmp	r3, r0
   106e2:	d009      	beq.n	106f8 <memq_dequeue+0x1a>
	if (mem) {
   106e4:	b122      	cbz	r2, 106f0 <memq_dequeue+0x12>
		*mem = head->mem;
   106e6:	6858      	ldr	r0, [r3, #4]
   106e8:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
   106ea:	681a      	ldr	r2, [r3, #0]
   106ec:	600a      	str	r2, [r1, #0]

	return old_head;
   106ee:	e001      	b.n	106f4 <memq_dequeue+0x16>
	if (old_head == NULL) {
   106f0:	2b00      	cmp	r3, #0
   106f2:	d1fa      	bne.n	106ea <memq_dequeue+0xc>
}
   106f4:	4618      	mov	r0, r3
   106f6:	4770      	bx	lr
		return NULL; /* queue is empty */
   106f8:	2300      	movs	r3, #0
   106fa:	e7fb      	b.n	106f4 <memq_dequeue+0x16>

000106fc <util_ones_count_get>:
 * @param octets_len Must not be bigger than 255/8 = 31 bytes
 *
 * @return popcnt of 'octets'
 */
uint8_t util_ones_count_get(const uint8_t *octets, uint8_t octets_len)
{
   106fc:	b510      	push	{r4, lr}
   106fe:	1e42      	subs	r2, r0, #1
	uint8_t one_count = 0U;
   10700:	2000      	movs	r0, #0

	while (octets_len--) {
   10702:	3901      	subs	r1, #1
   10704:	b2c9      	uxtb	r1, r1
   10706:	29ff      	cmp	r1, #255	; 0xff
   10708:	d100      	bne.n	1070c <util_ones_count_get+0x10>
		}
		octets++;
	}

	return one_count;
}
   1070a:	bd10      	pop	{r4, pc}
		bite = *octets;
   1070c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		while (bite) {
   10710:	2b00      	cmp	r3, #0
   10712:	d0f6      	beq.n	10702 <util_ones_count_get+0x6>
			bite &= (bite - 1);
   10714:	b25b      	sxtb	r3, r3
   10716:	1e5c      	subs	r4, r3, #1
   10718:	4023      	ands	r3, r4
			one_count++;
   1071a:	3001      	adds	r0, #1
			bite &= (bite - 1);
   1071c:	b2db      	uxtb	r3, r3
			one_count++;
   1071e:	b2c0      	uxtb	r0, r0
   10720:	e7f6      	b.n	10710 <util_ones_count_get+0x14>

00010722 <ticker_dequeue>:
{
   10722:	b5f0      	push	{r4, r5, r6, r7, lr}
	previous = instance->ticker_id_head;
   10724:	7f42      	ldrb	r2, [r0, #29]
	node = &instance->nodes[0];
   10726:	6806      	ldr	r6, [r0, #0]
{
   10728:	4605      	mov	r5, r0
   1072a:	468c      	mov	ip, r1
	previous = instance->ticker_id_head;
   1072c:	4613      	mov	r3, r2
	total = 0U;
   1072e:	2000      	movs	r0, #0
	while (current != TICKER_NULL) {
   10730:	2aff      	cmp	r2, #255	; 0xff
   10732:	d101      	bne.n	10738 <ticker_dequeue+0x16>
		return 0;
   10734:	2000      	movs	r0, #0
}
   10736:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ticker_current = &node[current];
   10738:	eb02 0442 	add.w	r4, r2, r2, lsl #1
   1073c:	0127      	lsls	r7, r4, #4
   1073e:	eb06 1404 	add.w	r4, r6, r4, lsl #4
		if (current == id) {
   10742:	4562      	cmp	r2, ip
		total += ticker_current->ticks_to_expire;
   10744:	68a1      	ldr	r1, [r4, #8]
		current = ticker_current->next;
   10746:	5df7      	ldrb	r7, [r6, r7]
		total += ticker_current->ticks_to_expire;
   10748:	4408      	add	r0, r1
		if (current == id) {
   1074a:	d002      	beq.n	10752 <ticker_dequeue+0x30>
   1074c:	4613      	mov	r3, r2
		current = ticker_current->next;
   1074e:	463a      	mov	r2, r7
   10750:	e7ee      	b.n	10730 <ticker_dequeue+0xe>
	if (previous == current) {
   10752:	4293      	cmp	r3, r2
   10754:	d100      	bne.n	10758 <ticker_dequeue+0x36>
		instance->ticker_id_head = ticker_current->next;
   10756:	776f      	strb	r7, [r5, #29]
	node[previous].next = ticker_current->next;
   10758:	b21b      	sxth	r3, r3
   1075a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1075e:	011b      	lsls	r3, r3, #4
   10760:	54f7      	strb	r7, [r6, r3]
	if (ticker_current->next != TICKER_NULL) {
   10762:	7823      	ldrb	r3, [r4, #0]
   10764:	2bff      	cmp	r3, #255	; 0xff
   10766:	d0e6      	beq.n	10736 <ticker_dequeue+0x14>
		node[ticker_current->next].ticks_to_expire += timeout;
   10768:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1076c:	eb06 1303 	add.w	r3, r6, r3, lsl #4
   10770:	689a      	ldr	r2, [r3, #8]
   10772:	440a      	add	r2, r1
   10774:	609a      	str	r2, [r3, #8]
	return (total + timeout);
   10776:	e7de      	b.n	10736 <ticker_dequeue+0x14>

00010778 <ticks_to_expire_prep>:
{
   10778:	b530      	push	{r4, r5, lr}
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   1077a:	1a55      	subs	r5, r2, r1
   1077c:	f415 0f00 	tst.w	r5, #8388608	; 0x800000
	uint32_t ticks_to_expire = ticker->ticks_to_expire;
   10780:	6883      	ldr	r3, [r0, #8]
	uint32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
   10782:	6944      	ldr	r4, [r0, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   10784:	d109      	bne.n	1079a <ticks_to_expire_prep+0x22>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   10786:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
   1078a:	442b      	add	r3, r5
	if (ticks_to_expire > ticks_to_expire_minus) {
   1078c:	42a3      	cmp	r3, r4
   1078e:	d90e      	bls.n	107ae <ticks_to_expire_prep+0x36>
		ticks_to_expire -= ticks_to_expire_minus;
   10790:	1b1b      	subs	r3, r3, r4
		ticks_to_expire_minus = 0U;
   10792:	2400      	movs	r4, #0
	ticker->ticks_to_expire = ticks_to_expire;
   10794:	6083      	str	r3, [r0, #8]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
   10796:	6144      	str	r4, [r0, #20]
}
   10798:	bd30      	pop	{r4, r5, pc}
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1079a:	1a8a      	subs	r2, r1, r2
   1079c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
   107a0:	4293      	cmp	r3, r2
   107a2:	d901      	bls.n	107a8 <ticks_to_expire_prep+0x30>
			ticks_to_expire -= delta_current_start;
   107a4:	1a9b      	subs	r3, r3, r2
   107a6:	e7f1      	b.n	1078c <ticks_to_expire_prep+0x14>
			ticks_to_expire_minus +=
   107a8:	4414      	add	r4, r2
   107aa:	1ae4      	subs	r4, r4, r3
			ticks_to_expire = 0U;
   107ac:	2300      	movs	r3, #0
		ticks_to_expire_minus -= ticks_to_expire;
   107ae:	1ae4      	subs	r4, r4, r3
		ticks_to_expire = 0U;
   107b0:	2300      	movs	r3, #0
   107b2:	e7ef      	b.n	10794 <ticks_to_expire_prep+0x1c>

000107b4 <ticker_job_op_cb>:
{
   107b4:	4603      	mov	r3, r0
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   107b6:	2200      	movs	r2, #0
   107b8:	701a      	strb	r2, [r3, #0]
	if (user_op->fp_op_func) {
   107ba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	user_op->status = status;
   107bc:	6299      	str	r1, [r3, #40]	; 0x28
{
   107be:	4608      	mov	r0, r1
	if (user_op->fp_op_func) {
   107c0:	b10a      	cbz	r2, 107c6 <ticker_job_op_cb+0x12>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   107c2:	6b19      	ldr	r1, [r3, #48]	; 0x30
   107c4:	4710      	bx	r2
}
   107c6:	4770      	bx	lr

000107c8 <ticker_job_list_insert>:
{
   107c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   107cc:	b089      	sub	sp, #36	; 0x24
	node = &instance->nodes[0];
   107ce:	6803      	ldr	r3, [r0, #0]
   107d0:	9303      	str	r3, [sp, #12]
	users = &instance->users[0];
   107d2:	6843      	ldr	r3, [r0, #4]
   107d4:	9305      	str	r3, [sp, #20]
	while (count_user--) {
   107d6:	7a43      	ldrb	r3, [r0, #9]
{
   107d8:	4606      	mov	r6, r0
   107da:	4688      	mov	r8, r1
   107dc:	3b01      	subs	r3, #1
   107de:	fa5f fa83 	uxtb.w	sl, r3
	while (count_user--) {
   107e2:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   107e6:	d102      	bne.n	107ee <ticker_job_list_insert+0x26>
}
   107e8:	b009      	add	sp, #36	; 0x24
   107ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		user = &users[count_user];
   107ee:	9b05      	ldr	r3, [sp, #20]
   107f0:	eb03 0bca 	add.w	fp, r3, sl, lsl #3
		user_ops = (void *)&user->user_op[0];
   107f4:	f8db 3004 	ldr.w	r3, [fp, #4]
		user_ops_first = user->first;
   107f8:	f89b 7001 	ldrb.w	r7, [fp, #1]
		user_ops = (void *)&user->user_op[0];
   107fc:	9304      	str	r3, [sp, #16]
		while ((insert_head != TICKER_NULL) ||
   107fe:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   10802:	d076      	beq.n	108f2 <ticker_job_list_insert+0x12a>
				ticker = &node[id_insert];
   10804:	eb08 0448 	add.w	r4, r8, r8, lsl #1
   10808:	9a03      	ldr	r2, [sp, #12]
   1080a:	f8cd 8008 	str.w	r8, [sp, #8]
   1080e:	0123      	lsls	r3, r4, #4
				user_op = NULL;
   10810:	2500      	movs	r5, #0
				insert_head = ticker->next;
   10812:	f812 8003 	ldrb.w	r8, [r2, r3]
				ticker = &node[id_insert];
   10816:	eb02 1404 	add.w	r4, r2, r4, lsl #4
	ticker->next = TICKER_NULL;
   1081a:	23ff      	movs	r3, #255	; 0xff
   1081c:	7023      	strb	r3, [r4, #0]
	ticker_new = &node[id];
   1081e:	f9bd c008 	ldrsh.w	ip, [sp, #8]
	node = &instance->nodes[0];
   10822:	6830      	ldr	r0, [r6, #0]
	ticker_new = &node[id];
   10824:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   10828:	ea4f 120c 	mov.w	r2, ip, lsl #4
   1082c:	eb00 1c0c 	add.w	ip, r0, ip, lsl #4
   10830:	9206      	str	r2, [sp, #24]
	ticks_to_expire = ticker_new->ticks_to_expire;
   10832:	f8dc 2008 	ldr.w	r2, [ip, #8]
   10836:	9201      	str	r2, [sp, #4]
	current = instance->ticker_id_head;
   10838:	7f72      	ldrb	r2, [r6, #29]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   1083a:	2aff      	cmp	r2, #255	; 0xff
   1083c:	d00c      	beq.n	10858 <ticker_job_list_insert+0x90>
		(ticker_current = &node[current])->ticks_to_expire))) {
   1083e:	eb02 0e42 	add.w	lr, r2, r2, lsl #1
   10842:	ea4f 110e 	mov.w	r1, lr, lsl #4
   10846:	eb00 1e0e 	add.w	lr, r0, lr, lsl #4
   1084a:	9107      	str	r1, [sp, #28]
		(ticks_to_expire_current =
   1084c:	f8de 9008 	ldr.w	r9, [lr, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   10850:	9901      	ldr	r1, [sp, #4]
   10852:	4549      	cmp	r1, r9
   10854:	f080 8085 	bcs.w	10962 <ticker_job_list_insert+0x19a>
	if (previous == TICKER_NULL) {
   10858:	2bff      	cmp	r3, #255	; 0xff
		node[previous].next = id;
   1085a:	bf18      	it	ne
   1085c:	b21b      	sxthne	r3, r3
	ticker_new->ticks_to_expire = ticks_to_expire;
   1085e:	9901      	ldr	r1, [sp, #4]
   10860:	f8cc 1008 	str.w	r1, [ip, #8]
		node[previous].next = id;
   10864:	bf18      	it	ne
   10866:	eb03 0343 	addne.w	r3, r3, r3, lsl #1
	ticker_new->next = current;
   1086a:	9906      	ldr	r1, [sp, #24]
		instance->ticker_id_head = id;
   1086c:	bf08      	it	eq
   1086e:	9b02      	ldreq	r3, [sp, #8]
	ticker_new->next = current;
   10870:	5442      	strb	r2, [r0, r1]
		node[previous].next = id;
   10872:	bf1d      	ittte	ne
   10874:	011b      	lslne	r3, r3, #4
   10876:	9902      	ldrne	r1, [sp, #8]
   10878:	54c1      	strbne	r1, [r0, r3]
		instance->ticker_id_head = id;
   1087a:	7773      	strbeq	r3, [r6, #29]
	if (current != TICKER_NULL) {
   1087c:	2aff      	cmp	r2, #255	; 0xff
   1087e:	d007      	beq.n	10890 <ticker_job_list_insert+0xc8>
		node[current].ticks_to_expire -= ticks_to_expire;
   10880:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   10884:	eb00 1202 	add.w	r2, r0, r2, lsl #4
   10888:	9901      	ldr	r1, [sp, #4]
   1088a:	6893      	ldr	r3, [r2, #8]
   1088c:	1a5b      	subs	r3, r3, r1
   1088e:	6093      	str	r3, [r2, #8]
	ticker->req = ticker->ack + 1;
   10890:	78a3      	ldrb	r3, [r4, #2]
   10892:	3301      	adds	r3, #1
   10894:	7063      	strb	r3, [r4, #1]
			if (user_op) {
   10896:	2d00      	cmp	r5, #0
   10898:	d0b1      	beq.n	107fe <ticker_job_list_insert+0x36>
				ticker_job_op_cb(user_op, status);
   1089a:	2100      	movs	r1, #0
   1089c:	4628      	mov	r0, r5
   1089e:	f7ff ff89 	bl	107b4 <ticker_job_op_cb>
				if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
   108a2:	6863      	ldr	r3, [r4, #4]
   108a4:	2b00      	cmp	r3, #0
   108a6:	d1aa      	bne.n	107fe <ticker_job_list_insert+0x36>
					ticker->fp_op_func =
   108a8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   108aa:	6223      	str	r3, [r4, #32]
					ticker->op_context =
   108ac:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   108ae:	6263      	str	r3, [r4, #36]	; 0x24
   108b0:	e7a5      	b.n	107fe <ticker_job_list_insert+0x36>
				user_op = &user_ops[user_ops_first];
   108b2:	9a04      	ldr	r2, [sp, #16]
   108b4:	2334      	movs	r3, #52	; 0x34
   108b6:	fb17 f303 	smulbb	r3, r7, r3
   108ba:	18d5      	adds	r5, r2, r3
				first = user_ops_first + 1;
   108bc:	3701      	adds	r7, #1
				if (first == user->count_user_op) {
   108be:	f89b 2000 	ldrb.w	r2, [fp]
				first = user_ops_first + 1;
   108c2:	b2ff      	uxtb	r7, r7
					first = 0U;
   108c4:	42ba      	cmp	r2, r7
   108c6:	bf08      	it	eq
   108c8:	2700      	moveq	r7, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
   108ca:	9a04      	ldr	r2, [sp, #16]
   108cc:	5cd3      	ldrb	r3, [r2, r3]
   108ce:	2b04      	cmp	r3, #4
   108d0:	d10f      	bne.n	108f2 <ticker_job_list_insert+0x12a>
				id_insert = user_op->id;
   108d2:	786b      	ldrb	r3, [r5, #1]
   108d4:	9302      	str	r3, [sp, #8]
				ticker = &node[id_insert];
   108d6:	eb03 0443 	add.w	r4, r3, r3, lsl #1
   108da:	9b03      	ldr	r3, [sp, #12]
   108dc:	eb03 1404 	add.w	r4, r3, r4, lsl #4
				if (((ticker->req -
   108e0:	7863      	ldrb	r3, [r4, #1]
				      ticker->ack) & 0xff) != 0U) {
   108e2:	78a2      	ldrb	r2, [r4, #2]
				if (((ticker->req -
   108e4:	1a9b      	subs	r3, r3, r2
				      ticker->ack) & 0xff) != 0U) {
   108e6:	b2db      	uxtb	r3, r3
				if (((ticker->req -
   108e8:	b153      	cbz	r3, 10900 <ticker_job_list_insert+0x138>
					ticker_job_op_cb(user_op,
   108ea:	2101      	movs	r1, #1
   108ec:	4628      	mov	r0, r5
   108ee:	f7ff ff61 	bl	107b4 <ticker_job_op_cb>
		while ((insert_head != TICKER_NULL) ||
   108f2:	f89b 3002 	ldrb.w	r3, [fp, #2]
   108f6:	42bb      	cmp	r3, r7
   108f8:	d1db      	bne.n	108b2 <ticker_job_list_insert+0xea>
   108fa:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
   108fe:	e76e      	b.n	107de <ticker_job_list_insert+0x16>
	if (start->lazy != TICKER_LAZY_MUST_EXPIRE_KEEP) {
   10900:	8aab      	ldrh	r3, [r5, #20]
				ticker_job_op_start(ticker, user_op,
   10902:	6971      	ldr	r1, [r6, #20]
	if (start->lazy != TICKER_LAZY_MUST_EXPIRE_KEEP) {
   10904:	f64f 72fe 	movw	r2, #65534	; 0xfffe
   10908:	4293      	cmp	r3, r2
   1090a:	d006      	beq.n	1091a <ticker_job_list_insert+0x152>
		ticker->must_expire =
   1090c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   10910:	1a98      	subs	r0, r3, r2
   10912:	4242      	negs	r2, r0
   10914:	4142      	adcs	r2, r0
   10916:	f884 202c 	strb.w	r2, [r4, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
   1091a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   1091c:	62a2      	str	r2, [r4, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
   1091e:	68ea      	ldr	r2, [r5, #12]
   10920:	6062      	str	r2, [r4, #4]
	ticker->remainder_periodic = start->remainder_periodic;
   10922:	692a      	ldr	r2, [r5, #16]
   10924:	6222      	str	r2, [r4, #32]
	ticker->lazy_periodic =
   10926:	f64f 72fd 	movw	r2, #65533	; 0xfffd
   1092a:	4293      	cmp	r3, r2
   1092c:	bf88      	it	hi
   1092e:	2300      	movhi	r3, #0
   10930:	83a3      	strh	r3, [r4, #28]
	ticker->ticks_slot = start->ticks_slot;
   10932:	69ab      	ldr	r3, [r5, #24]
   10934:	61a3      	str	r3, [r4, #24]
	ticker->timeout_func = start->fp_timeout_func;
   10936:	69eb      	ldr	r3, [r5, #28]
   10938:	60e3      	str	r3, [r4, #12]
	ticker->context = start->context;
   1093a:	6a2b      	ldr	r3, [r5, #32]
   1093c:	6123      	str	r3, [r4, #16]
	ticker->ticks_to_expire_minus = 0U;
   1093e:	f04f 0900 	mov.w	r9, #0
	ticker->ticks_to_expire = start->ticks_first;
   10942:	68ab      	ldr	r3, [r5, #8]
   10944:	60a3      	str	r3, [r4, #8]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   10946:	686a      	ldr	r2, [r5, #4]
	ticker->ticks_to_expire_minus = 0U;
   10948:	f8c4 9014 	str.w	r9, [r4, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   1094c:	4620      	mov	r0, r4
   1094e:	f7ff ff13 	bl	10778 <ticks_to_expire_prep>
	ticker->force = 1U;
   10952:	f04f 0301 	mov.w	r3, #1
	ticker->remainder_current = 0U;
   10956:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
	ticker->lazy_current = 0U;
   1095a:	f8a4 901e 	strh.w	r9, [r4, #30]
	ticker->force = 1U;
   1095e:	70e3      	strb	r3, [r4, #3]
}
   10960:	e75b      	b.n	1081a <ticker_job_list_insert+0x52>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
   10962:	9901      	ldr	r1, [sp, #4]
   10964:	ebb1 0109 	subs.w	r1, r1, r9
   10968:	9101      	str	r1, [sp, #4]
   1096a:	d105      	bne.n	10978 <ticker_job_list_insert+0x1b0>
   1096c:	f8bc 101e 	ldrh.w	r1, [ip, #30]
   10970:	f8be e01e 	ldrh.w	lr, [lr, #30]
   10974:	4571      	cmp	r1, lr
   10976:	d803      	bhi.n	10980 <ticker_job_list_insert+0x1b8>
		current = ticker_current->next;
   10978:	4613      	mov	r3, r2
   1097a:	9a07      	ldr	r2, [sp, #28]
   1097c:	5c82      	ldrb	r2, [r0, r2]
   1097e:	e75c      	b.n	1083a <ticker_job_list_insert+0x72>
   10980:	f8cd 9004 	str.w	r9, [sp, #4]
   10984:	e768      	b.n	10858 <ticker_job_list_insert+0x90>

00010986 <ticker_worker>:
{
   10986:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
   1098a:	7f86      	ldrb	r6, [r0, #30]
	instance->worker_trigger = 1U;
   1098c:	2301      	movs	r3, #1
{
   1098e:	b08d      	sub	sp, #52	; 0x34
   10990:	4605      	mov	r5, r0
	instance->worker_trigger = 1U;
   10992:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
   10994:	b91e      	cbnz	r6, 1099e <ticker_worker+0x18>
	if (instance->ticker_id_head == TICKER_NULL) {
   10996:	7f43      	ldrb	r3, [r0, #29]
   10998:	2bff      	cmp	r3, #255	; 0xff
   1099a:	d103      	bne.n	109a4 <ticker_worker+0x1e>
		instance->worker_trigger = 0U;
   1099c:	77c6      	strb	r6, [r0, #31]
}
   1099e:	b00d      	add	sp, #52	; 0x34
   109a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
   109a4:	f7fb f9b4 	bl	bd10 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   109a8:	696b      	ldr	r3, [r5, #20]
	ticker_id_head = instance->ticker_id_head;
   109aa:	7f6f      	ldrb	r7, [r5, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   109ac:	1ac0      	subs	r0, r0, r3
	if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
   109ae:	7f2b      	ldrb	r3, [r5, #28]
   109b0:	2bff      	cmp	r3, #255	; 0xff
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   109b2:	f020 4b7f 	bic.w	fp, r0, #4278190080	; 0xff000000
	if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
   109b6:	d004      	beq.n	109c2 <ticker_worker+0x3c>
		if (instance->ticks_slot_previous > ticks_elapsed) {
   109b8:	69ae      	ldr	r6, [r5, #24]
	uint8_t slot_reserved = 0;
   109ba:	455e      	cmp	r6, fp
   109bc:	bf94      	ite	ls
   109be:	2600      	movls	r6, #0
   109c0:	2601      	movhi	r6, #1
	node = &instance->nodes[0];
   109c2:	f8d5 9000 	ldr.w	r9, [r5]
	ticks_expired = 0U;
   109c6:	f04f 0800 	mov.w	r8, #0
	while (ticker_id_head != TICKER_NULL) {
   109ca:	2fff      	cmp	r7, #255	; 0xff
   109cc:	d11a      	bne.n	10a04 <ticker_worker+0x7e>
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
   109ce:	7aea      	ldrb	r2, [r5, #11]
   109d0:	7aab      	ldrb	r3, [r5, #10]
   109d2:	4293      	cmp	r3, r2
   109d4:	d105      	bne.n	109e2 <ticker_worker+0x5c>
	uint8_t idx = *ticks_elapsed_index + 1;
   109d6:	3301      	adds	r3, #1
   109d8:	b2db      	uxtb	r3, r3
		idx = 0U;
   109da:	2b02      	cmp	r3, #2
   109dc:	bf08      	it	eq
   109de:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   109e0:	72eb      	strb	r3, [r5, #11]
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   109e2:	7aeb      	ldrb	r3, [r5, #11]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   109e4:	6a6c      	ldr	r4, [r5, #36]	; 0x24
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   109e6:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   109ea:	2201      	movs	r2, #1
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   109ec:	f8c3 800c 	str.w	r8, [r3, #12]
	instance->worker_trigger = 0U;
   109f0:	2300      	movs	r3, #0
   109f2:	77eb      	strb	r3, [r5, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   109f4:	2104      	movs	r1, #4
   109f6:	462b      	mov	r3, r5
   109f8:	2003      	movs	r0, #3
   109fa:	46a4      	mov	ip, r4
}
   109fc:	b00d      	add	sp, #52	; 0x34
   109fe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   10a02:	4760      	bx	ip
		ticker = &node[ticker_id_head];
   10a04:	eb07 0747 	add.w	r7, r7, r7, lsl #1
   10a08:	eb09 1407 	add.w	r4, r9, r7, lsl #4
   10a0c:	013a      	lsls	r2, r7, #4
		ticks_to_expire = ticker->ticks_to_expire;
   10a0e:	68a3      	ldr	r3, [r4, #8]
		if (ticks_elapsed < ticks_to_expire) {
   10a10:	459b      	cmp	fp, r3
   10a12:	d3dc      	bcc.n	109ce <ticker_worker+0x48>
		ticks_elapsed -= ticks_to_expire;
   10a14:	ebab 0b03 	sub.w	fp, fp, r3
		ticks_expired += ticks_to_expire;
   10a18:	4498      	add	r8, r3
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   10a1a:	78a3      	ldrb	r3, [r4, #2]
   10a1c:	9303      	str	r3, [sp, #12]
		ticker_id_head = ticker->next;
   10a1e:	f819 7002 	ldrb.w	r7, [r9, r2]
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   10a22:	7863      	ldrb	r3, [r4, #1]
   10a24:	9a03      	ldr	r2, [sp, #12]
   10a26:	1a9b      	subs	r3, r3, r2
   10a28:	b2db      	uxtb	r3, r3
   10a2a:	2b01      	cmp	r3, #1
   10a2c:	d1cd      	bne.n	109ca <ticker_worker+0x44>
		if (ticker->ticks_slot != 0U &&
   10a2e:	69a3      	ldr	r3, [r4, #24]
   10a30:	9304      	str	r3, [sp, #16]
   10a32:	2b00      	cmp	r3, #0
   10a34:	d034      	beq.n	10aa0 <ticker_worker+0x11a>
   10a36:	2e00      	cmp	r6, #0
   10a38:	f040 80a8 	bne.w	10b8c <ticker_worker+0x206>
	if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
   10a3c:	f994 302d 	ldrsb.w	r3, [r4, #45]	; 0x2d
   10a40:	9305      	str	r3, [sp, #20]
   10a42:	3380      	adds	r3, #128	; 0x80
   10a44:	d02c      	beq.n	10aa0 <ticker_worker+0x11a>
   10a46:	2fff      	cmp	r7, #255	; 0xff
   10a48:	d02a      	beq.n	10aa0 <ticker_worker+0x11a>
		int32_t lazy_current = ticker->lazy_current;
   10a4a:	8be3      	ldrh	r3, [r4, #30]
		if (lazy_current >= ticker->lazy_periodic) {
   10a4c:	8ba2      	ldrh	r2, [r4, #28]
		uint32_t current_age = ticker->ticks_periodic +
   10a4e:	6861      	ldr	r1, [r4, #4]
		if (lazy_current >= ticker->lazy_periodic) {
   10a50:	4293      	cmp	r3, r2
			lazy_current -= ticker->lazy_periodic;
   10a52:	bf28      	it	cs
   10a54:	1a9b      	subcs	r3, r3, r2
		uint32_t current_age = ticker->ticks_periodic +
   10a56:	fb03 1201 	mla	r2, r3, r1, r1
   10a5a:	9209      	str	r2, [sp, #36]	; 0x24
		uint32_t acc_ticks_to_expire = 0U;
   10a5c:	2200      	movs	r2, #0
   10a5e:	9206      	str	r2, [sp, #24]
				(lazy_current - ticker->priority);
   10a60:	9a05      	ldr	r2, [sp, #20]
   10a62:	1a9b      	subs	r3, r3, r2
		uint32_t current_age = ticker->ticks_periodic +
   10a64:	46ba      	mov	sl, r7
				(lazy_current - ticker->priority);
   10a66:	930b      	str	r3, [sp, #44]	; 0x2c
			struct ticker_node *ticker_next = &nodes[id_head];
   10a68:	fa0f fa8a 	sxth.w	sl, sl
   10a6c:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
   10a70:	ea4f 130a 	mov.w	r3, sl, lsl #4
   10a74:	eb09 1a0a 	add.w	sl, r9, sl, lsl #4
   10a78:	9308      	str	r3, [sp, #32]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   10a7a:	f8da c008 	ldr.w	ip, [sl, #8]
   10a7e:	9b06      	ldr	r3, [sp, #24]
   10a80:	4463      	add	r3, ip
   10a82:	9306      	str	r3, [sp, #24]
			if (acc_ticks_to_expire > ticker->ticks_slot) {
   10a84:	9a06      	ldr	r2, [sp, #24]
   10a86:	9b04      	ldr	r3, [sp, #16]
   10a88:	4293      	cmp	r3, r2
   10a8a:	d309      	bcc.n	10aa0 <ticker_worker+0x11a>
			if (ticker_next->ticks_slot == 0U) {
   10a8c:	f8da 3018 	ldr.w	r3, [sl, #24]
   10a90:	2b00      	cmp	r3, #0
   10a92:	d13a      	bne.n	10b0a <ticker_worker+0x184>
			id_head = ticker_next->next;
   10a94:	9b08      	ldr	r3, [sp, #32]
   10a96:	f819 a003 	ldrb.w	sl, [r9, r3]
		while (id_head != TICKER_NULL) {
   10a9a:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   10a9e:	d1e3      	bne.n	10a68 <ticker_worker+0xe2>
		must_expire_skip = 0U;
   10aa0:	f04f 0a00 	mov.w	sl, #0
		if (ticker->ext_data) {
   10aa4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   10aa6:	2b00      	cmp	r3, #0
   10aa8:	f000 809a 	beq.w	10be0 <ticker_worker+0x25a>
			ticker->ext_data->ticks_drift = 0U;
   10aac:	2200      	movs	r2, #0
			ticks_drift = ticker->ext_data->ticks_drift;
   10aae:	6859      	ldr	r1, [r3, #4]
			ticker->ext_data->reschedule_state =
   10ab0:	721a      	strb	r2, [r3, #8]
			ticker->ext_data->ticks_drift = 0U;
   10ab2:	605a      	str	r2, [r3, #4]
		ticker->ack--;
   10ab4:	9b03      	ldr	r3, [sp, #12]
   10ab6:	3b01      	subs	r3, #1
   10ab8:	70a3      	strb	r3, [r4, #2]
		if (ticker->timeout_func) {
   10aba:	68e3      	ldr	r3, [r4, #12]
   10abc:	469e      	mov	lr, r3
   10abe:	2b00      	cmp	r3, #0
   10ac0:	d083      	beq.n	109ca <ticker_worker+0x44>
					   ticks_expired -
   10ac2:	6960      	ldr	r0, [r4, #20]
   10ac4:	696b      	ldr	r3, [r5, #20]
			ticker->timeout_func(ticks_at_expire,
   10ac6:	6a62      	ldr	r2, [r4, #36]	; 0x24
					   ticks_expired -
   10ac8:	eba8 0000 	sub.w	r0, r8, r0
   10acc:	4418      	add	r0, r3
			ticks_at_expire = (instance->ticks_current +
   10ace:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
   10ad2:	f1ba 0f00 	cmp.w	sl, #0
   10ad6:	f040 8085 	bne.w	10be4 <ticker_worker+0x25e>
   10ada:	8be3      	ldrh	r3, [r4, #30]
   10adc:	f8d4 c010 	ldr.w	ip, [r4, #16]
   10ae0:	f8cd c004 	str.w	ip, [sp, #4]
   10ae4:	f894 c003 	ldrb.w	ip, [r4, #3]
   10ae8:	f8cd c000 	str.w	ip, [sp]
   10aec:	46f4      	mov	ip, lr
   10aee:	47e0      	blx	ip
			if (!IS_ENABLED(CONFIG_BT_TICKER_LOW_LAT) &&
   10af0:	f1ba 0f00 	cmp.w	sl, #0
   10af4:	f47f af69 	bne.w	109ca <ticker_worker+0x44>
				if (ticker->ticks_slot != 0U) {
   10af8:	69a3      	ldr	r3, [r4, #24]
				ticker->lazy_current = 0U;
   10afa:	f8a4 a01e 	strh.w	sl, [r4, #30]
					slot_reserved = 1U;
   10afe:	2b00      	cmp	r3, #0
				ticker->force = 0U;
   10b00:	f884 a003 	strb.w	sl, [r4, #3]
					slot_reserved = 1U;
   10b04:	bf18      	it	ne
   10b06:	2601      	movne	r6, #1
   10b08:	e75f      	b.n	109ca <ticker_worker+0x44>
			int32_t lazy_next = ticker_next->lazy_current;
   10b0a:	f8ba 201e 	ldrh.w	r2, [sl, #30]
				ticker_next->lazy_periodic > lazy_next;
   10b0e:	f8ba 001c 	ldrh.w	r0, [sl, #28]
				ticker_next->priority;
   10b12:	f99a e02d 	ldrsb.w	lr, [sl, #45]	; 0x2d
   10b16:	f8cd e01c 	str.w	lr, [sp, #28]
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
   10b1a:	f8da e004 	ldr.w	lr, [sl, #4]
			if (!lazy_next_periodic_skip) {
   10b1e:	4282      	cmp	r2, r0
			int32_t lazy_next = ticker_next->lazy_current;
   10b20:	4613      	mov	r3, r2
				lazy_next -= ticker_next->lazy_periodic;
   10b22:	bf28      	it	cs
   10b24:	1a13      	subcs	r3, r2, r0
					  0U :
   10b26:	f1be 0f00 	cmp.w	lr, #0
   10b2a:	d04d      	beq.n	10bc8 <ticker_worker+0x242>
   10b2c:	ebae 0c0c 	sub.w	ip, lr, ip
				(ticker->ticks_periodic == 0U) ||
   10b30:	2900      	cmp	r1, #0
   10b32:	d04b      	beq.n	10bcc <ticker_worker+0x246>
			uint32_t next_age = (ticker_next->ticks_periodic == 0U ?
   10b34:	fb0e cc03 	mla	ip, lr, r3, ip
				(ticker->ticks_periodic == 0U) ||
   10b38:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
   10b3c:	45e6      	cmp	lr, ip
   10b3e:	bf8c      	ite	hi
   10b40:	f04f 0e01 	movhi.w	lr, #1
   10b44:	f04f 0e00 	movls.w	lr, #0
					(ticker->ticks_periodic != 0U) &&
   10b48:	bf34      	ite	cc
   10b4a:	f04f 0c01 	movcc.w	ip, #1
   10b4e:	f04f 0c00 	movcs.w	ip, #0
			uint8_t next_force = (ticker_next->force > ticker->force);
   10b52:	f89a a003 	ldrb.w	sl, [sl, #3]
   10b56:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
			if (!lazy_next_periodic_skip &&
   10b5a:	4282      	cmp	r2, r0
			uint8_t next_force = (ticker_next->force > ticker->force);
   10b5c:	f894 a003 	ldrb.w	sl, [r4, #3]
			if (!lazy_next_periodic_skip &&
   10b60:	d398      	bcc.n	10a94 <ticker_worker+0x10e>
   10b62:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   10b64:	4552      	cmp	r2, sl
   10b66:	d811      	bhi.n	10b8c <ticker_worker+0x206>
			    (next_force ||
   10b68:	9a07      	ldr	r2, [sp, #28]
   10b6a:	f112 0f80 	cmn.w	r2, #128	; 0x80
   10b6e:	d00d      	beq.n	10b8c <ticker_worker+0x206>
				(lazy_next - ticker_next->priority) >
   10b70:	1a9b      	subs	r3, r3, r2
			     next_is_critical ||
   10b72:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   10b74:	4293      	cmp	r3, r2
   10b76:	dd02      	ble.n	10b7e <ticker_worker+0x1f8>
			     (next_has_priority && !current_is_older) ||
   10b78:	f1be 0f00 	cmp.w	lr, #0
   10b7c:	d006      	beq.n	10b8c <ticker_worker+0x206>
   10b7e:	9b05      	ldr	r3, [sp, #20]
   10b80:	9a07      	ldr	r2, [sp, #28]
   10b82:	4293      	cmp	r3, r2
   10b84:	d186      	bne.n	10a94 <ticker_worker+0x10e>
			     (equal_priority && next_is_older))) {
   10b86:	f1bc 0f00 	cmp.w	ip, #0
   10b8a:	d083      	beq.n	10a94 <ticker_worker+0x10e>
			struct ticker_ext *ext_data = ticker->ext_data;
   10b8c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		int32_t lazy_current = ticker->lazy_current;
   10b8e:	8be2      	ldrh	r2, [r4, #30]
			if (ext_data &&
   10b90:	b14b      	cbz	r3, 10ba6 <ticker_worker+0x220>
   10b92:	6819      	ldr	r1, [r3, #0]
   10b94:	b1f1      	cbz	r1, 10bd4 <ticker_worker+0x24e>
			    ext_data->ticks_slot_window != 0U &&
   10b96:	7a19      	ldrb	r1, [r3, #8]
   10b98:	b9e1      	cbnz	r1, 10bd4 <ticker_worker+0x24e>
			    TICKER_RESCHEDULE_STATE_NONE &&
   10b9a:	8ba1      	ldrh	r1, [r4, #28]
   10b9c:	4291      	cmp	r1, r2
   10b9e:	d819      	bhi.n	10bd4 <ticker_worker+0x24e>
				ext_data->reschedule_state =
   10ba0:	f04f 0101 	mov.w	r1, #1
				ext_data->reschedule_state =
   10ba4:	7219      	strb	r1, [r3, #8]
			ticker->lazy_current++;
   10ba6:	3201      	adds	r2, #1
			if ((ticker->must_expire == 0U) ||
   10ba8:	f894 102c 	ldrb.w	r1, [r4, #44]	; 0x2c
			ticker->lazy_current++;
   10bac:	b292      	uxth	r2, r2
   10bae:	83e2      	strh	r2, [r4, #30]
			if ((ticker->must_expire == 0U) ||
   10bb0:	b131      	cbz	r1, 10bc0 <ticker_worker+0x23a>
   10bb2:	8ba1      	ldrh	r1, [r4, #28]
   10bb4:	4291      	cmp	r1, r2
   10bb6:	d203      	bcs.n	10bc0 <ticker_worker+0x23a>
			    (ticker->lazy_periodic >= ticker->lazy_current) ||
   10bb8:	b17b      	cbz	r3, 10bda <ticker_worker+0x254>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
   10bba:	7a1b      	ldrb	r3, [r3, #8]
   10bbc:	2b01      	cmp	r3, #1
   10bbe:	d10c      	bne.n	10bda <ticker_worker+0x254>
				ticker->ack--;
   10bc0:	9b03      	ldr	r3, [sp, #12]
   10bc2:	3b01      	subs	r3, #1
   10bc4:	70a3      	strb	r3, [r4, #2]
				continue;
   10bc6:	e700      	b.n	109ca <ticker_worker+0x44>
					  0U :
   10bc8:	46f4      	mov	ip, lr
   10bca:	e7b1      	b.n	10b30 <ticker_worker+0x1aa>
				(ticker->ticks_periodic == 0U) ||
   10bcc:	f04f 0e01 	mov.w	lr, #1
					(ticker->ticks_periodic != 0U) &&
   10bd0:	468c      	mov	ip, r1
   10bd2:	e7be      	b.n	10b52 <ticker_worker+0x1cc>
				ext_data->reschedule_state =
   10bd4:	f04f 0100 	mov.w	r1, #0
   10bd8:	e7e4      	b.n	10ba4 <ticker_worker+0x21e>
			must_expire_skip = 1U;
   10bda:	f04f 0a01 	mov.w	sl, #1
   10bde:	e761      	b.n	10aa4 <ticker_worker+0x11e>
			ticks_drift = 0U;
   10be0:	4619      	mov	r1, r3
   10be2:	e767      	b.n	10ab4 <ticker_worker+0x12e>
			ticker->timeout_func(ticks_at_expire,
   10be4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   10be8:	e778      	b.n	10adc <ticker_worker+0x156>

00010bea <ticker_start>:
{
   10bea:	b510      	push	{r4, lr}
   10bec:	b08a      	sub	sp, #40	; 0x28
	return ticker_start_ext(instance_index, user_id, ticker_id,
   10bee:	2400      	movs	r4, #0
   10bf0:	9409      	str	r4, [sp, #36]	; 0x24
   10bf2:	9c14      	ldr	r4, [sp, #80]	; 0x50
   10bf4:	9408      	str	r4, [sp, #32]
   10bf6:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   10bf8:	9407      	str	r4, [sp, #28]
   10bfa:	9c12      	ldr	r4, [sp, #72]	; 0x48
   10bfc:	9406      	str	r4, [sp, #24]
   10bfe:	9c11      	ldr	r4, [sp, #68]	; 0x44
   10c00:	9405      	str	r4, [sp, #20]
   10c02:	9c10      	ldr	r4, [sp, #64]	; 0x40
   10c04:	9404      	str	r4, [sp, #16]
   10c06:	f8bd 403c 	ldrh.w	r4, [sp, #60]	; 0x3c
   10c0a:	9403      	str	r4, [sp, #12]
   10c0c:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   10c0e:	9402      	str	r4, [sp, #8]
   10c10:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   10c12:	9401      	str	r4, [sp, #4]
   10c14:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   10c16:	9400      	str	r4, [sp, #0]
   10c18:	f7f3 fef0 	bl	49fc <ticker_start_ext>
}
   10c1c:	b00a      	add	sp, #40	; 0x28
   10c1e:	bd10      	pop	{r4, pc}

00010c20 <ticker_update>:
{
   10c20:	b510      	push	{r4, lr}
   10c22:	b088      	sub	sp, #32
	return ticker_update_ext(instance_index, user_id, ticker_id,
   10c24:	2400      	movs	r4, #0
   10c26:	9407      	str	r4, [sp, #28]
   10c28:	9c10      	ldr	r4, [sp, #64]	; 0x40
   10c2a:	9406      	str	r4, [sp, #24]
   10c2c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   10c2e:	9405      	str	r4, [sp, #20]
   10c30:	f89d 4038 	ldrb.w	r4, [sp, #56]	; 0x38
   10c34:	9404      	str	r4, [sp, #16]
   10c36:	f8bd 4034 	ldrh.w	r4, [sp, #52]	; 0x34
   10c3a:	9403      	str	r4, [sp, #12]
   10c3c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   10c3e:	9402      	str	r4, [sp, #8]
   10c40:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   10c42:	9401      	str	r4, [sp, #4]
   10c44:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   10c46:	9400      	str	r4, [sp, #0]
   10c48:	f7f3 ff26 	bl	4a98 <ticker_update_ext>
}
   10c4c:	b008      	add	sp, #32
   10c4e:	bd10      	pop	{r4, pc}

00010c50 <ticker_ticks_now_get>:
	return cntr_cnt_get();
   10c50:	f7fb b85e 	b.w	bd10 <cntr_cnt_get>

00010c54 <ll_addr_read>:

uint8_t *ll_addr_read(uint8_t addr_type, uint8_t *const bdaddr)
{
   10c54:	b538      	push	{r3, r4, r5, lr}
	uint8_t *addr;

	addr = ll_addr_get(addr_type);
   10c56:	f7f4 f855 	bl	4d04 <ll_addr_get>
{
   10c5a:	460d      	mov	r5, r1
	if (addr) {
   10c5c:	4604      	mov	r4, r0
   10c5e:	b120      	cbz	r0, 10c6a <ll_addr_read+0x16>
		memcpy(bdaddr, addr, BDADDR_SIZE);
   10c60:	4601      	mov	r1, r0
   10c62:	2206      	movs	r2, #6
   10c64:	4628      	mov	r0, r5
   10c66:	f7fe ff9e 	bl	fba6 <memcpy>
	}

	return addr;
}
   10c6a:	4620      	mov	r0, r4
   10c6c:	bd38      	pop	{r3, r4, r5, pc}

00010c6e <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
   10c6e:	2300      	movs	r3, #0
   10c70:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
   10c72:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
   10c74:	4770      	bx	lr

00010c76 <dup_ext_adv_adi_store>:
{
   10c76:	b538      	push	{r3, r4, r5, lr}
   10c78:	4604      	mov	r4, r0
	adv_set = &dup_mode->set[dup_mode->set_curr];
   10c7a:	8800      	ldrh	r0, [r0, #0]
   10c7c:	f3c0 1044 	ubfx	r0, r0, #5, #5
	adv_set->data_cmplt = (data_status ==
   10c80:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   10c84:	4423      	add	r3, r4
			      1U : 0U;
   10c86:	fab2 f282 	clz	r2, r2
	adv_set->data_cmplt = (data_status ==
   10c8a:	789d      	ldrb	r5, [r3, #2]
			      1U : 0U;
   10c8c:	0952      	lsrs	r2, r2, #5
		(void)memcpy(&adv_set->adi, adi, sizeof(*adi));
   10c8e:	3001      	adds	r0, #1
	adv_set->data_cmplt = (data_status ==
   10c90:	f362 0500 	bfi	r5, r2, #0, #1
		(void)memcpy(&adv_set->adi, adi, sizeof(*adi));
   10c94:	eb00 0040 	add.w	r0, r0, r0, lsl #1
	adv_set->data_cmplt = (data_status ==
   10c98:	709d      	strb	r5, [r3, #2]
		(void)memcpy(&adv_set->adi, adi, sizeof(*adi));
   10c9a:	4420      	add	r0, r4
   10c9c:	2202      	movs	r2, #2
	if (adi) {
   10c9e:	b1e1      	cbz	r1, 10cda <dup_ext_adv_adi_store+0x64>
		(void)memcpy(&adv_set->adi, adi, sizeof(*adi));
   10ca0:	f7fe ff81 	bl	fba6 <memcpy>
	if (dup_mode->set_count < CONFIG_BT_CTLR_DUP_FILTER_ADV_SET_MAX) {
   10ca4:	7823      	ldrb	r3, [r4, #0]
   10ca6:	06da      	lsls	r2, r3, #27
		dup_mode->set_count++;
   10ca8:	bf05      	ittet	eq
   10caa:	1c5a      	addeq	r2, r3, #1
   10cac:	f002 021f 	andeq.w	r2, r2, #31
		dup_mode->set_curr++;
   10cb0:	8823      	ldrhne	r3, [r4, #0]
		dup_mode->set_count++;
   10cb2:	f362 0304 	bfieq	r3, r2, #0, #5
   10cb6:	bf07      	ittee	eq
   10cb8:	7023      	strbeq	r3, [r4, #0]
		dup_mode->set_curr = dup_mode->set_count;
   10cba:	8823      	ldrheq	r3, [r4, #0]
		dup_mode->set_curr++;
   10cbc:	f3c3 1244 	ubfxne	r2, r3, #5, #5
   10cc0:	3201      	addne	r2, #1
   10cc2:	f362 1349 	bfi	r3, r2, #5, #5
   10cc6:	8023      	strh	r3, [r4, #0]
	if (dup_mode->set_curr == CONFIG_BT_CTLR_DUP_FILTER_ADV_SET_MAX) {
   10cc8:	8823      	ldrh	r3, [r4, #0]
   10cca:	f403 7278 	and.w	r2, r3, #992	; 0x3e0
   10cce:	2a20      	cmp	r2, #32
		dup_mode->set_curr = 0U;
   10cd0:	bf04      	itt	eq
   10cd2:	f36f 1349 	bfceq	r3, #5, #5
   10cd6:	8023      	strheq	r3, [r4, #0]
}
   10cd8:	bd38      	pop	{r3, r4, r5, pc}
		(void)memset(&adv_set->adi, 0U, sizeof(*adi));
   10cda:	f7fe ff6f 	bl	fbbc <memset>
   10cde:	e7e1      	b.n	10ca4 <dup_ext_adv_adi_store+0x2e>

00010ce0 <node_rx_extra_list_release>:
{
   10ce0:	b537      	push	{r0, r1, r2, r4, r5, lr}
		node_rx_curr->hdr.next = NULL;
   10ce2:	2400      	movs	r4, #0
	while (node_rx_extra) {
   10ce4:	b908      	cbnz	r0, 10cea <node_rx_extra_list_release+0xa>
}
   10ce6:	b003      	add	sp, #12
   10ce8:	bd30      	pop	{r4, r5, pc}
		node_rx_extra = node_rx_curr->hdr.rx_ftr.extra;
   10cea:	68c5      	ldr	r5, [r0, #12]
		node_rx_curr = node_rx_extra;
   10cec:	9001      	str	r0, [sp, #4]
		node_rx_curr->hdr.next = NULL;
   10cee:	6004      	str	r4, [r0, #0]
		ll_rx_mem_release((void **)&node_rx_curr);
   10cf0:	a801      	add	r0, sp, #4
   10cf2:	f7f5 fb4f 	bl	6394 <ll_rx_mem_release>
		node_rx_extra = node_rx_curr->hdr.rx_ftr.extra;
   10cf6:	4628      	mov	r0, r5
   10cf8:	e7f4      	b.n	10ce4 <node_rx_extra_list_release+0x4>

00010cfa <meta_evt>:
{
   10cfa:	b570      	push	{r4, r5, r6, lr}
	return net_buf_simple_add(&buf->b, len);
   10cfc:	f100 0408 	add.w	r4, r0, #8
   10d00:	460e      	mov	r6, r1
   10d02:	4620      	mov	r0, r4
   10d04:	2102      	movs	r1, #2
   10d06:	4615      	mov	r5, r2
   10d08:	f001 f8f5 	bl	11ef6 <net_buf_simple_add>
	hdr->evt = evt;
   10d0c:	233e      	movs	r3, #62	; 0x3e
   10d0e:	7003      	strb	r3, [r0, #0]
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   10d10:	1c6b      	adds	r3, r5, #1
	hdr->len = len;
   10d12:	7043      	strb	r3, [r0, #1]
   10d14:	2101      	movs	r1, #1
   10d16:	4620      	mov	r0, r4
   10d18:	f001 f8ed 	bl	11ef6 <net_buf_simple_add>
	me->subevent = subevt;
   10d1c:	7006      	strb	r6, [r0, #0]
   10d1e:	4629      	mov	r1, r5
   10d20:	4620      	mov	r0, r4
}
   10d22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   10d26:	f001 b8e6 	b.w	11ef6 <net_buf_simple_add>

00010d2a <ext_adv_info_fill>:
{
   10d2a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10d2e:	b089      	sub	sp, #36	; 0x24
   10d30:	e9cd 2301 	strd	r2, r3, [sp, #4]
   10d34:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
   10d38:	f89d 7068 	ldrb.w	r7, [sp, #104]	; 0x68
   10d3c:	9303      	str	r3, [sp, #12]
   10d3e:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
   10d42:	9307      	str	r3, [sp, #28]
   10d44:	f99d 3058 	ldrsb.w	r3, [sp, #88]	; 0x58
   10d48:	9304      	str	r3, [sp, #16]
	sep = meta_evt(buf, BT_HCI_EVT_LE_EXT_ADVERTISING_REPORT,
   10d4a:	f107 0219 	add.w	r2, r7, #25
{
   10d4e:	f99d 305c 	ldrsb.w	r3, [sp, #92]	; 0x5c
   10d52:	9305      	str	r3, [sp, #20]
   10d54:	4680      	mov	r8, r0
   10d56:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
	sep = meta_evt(buf, BT_HCI_EVT_LE_EXT_ADVERTISING_REPORT,
   10d5a:	981c      	ldr	r0, [sp, #112]	; 0x70
{
   10d5c:	9306      	str	r3, [sp, #24]
	sep = meta_evt(buf, BT_HCI_EVT_LE_EXT_ADVERTISING_REPORT,
   10d5e:	b2d2      	uxtb	r2, r2
{
   10d60:	460d      	mov	r5, r1
	sep = meta_evt(buf, BT_HCI_EVT_LE_EXT_ADVERTISING_REPORT,
   10d62:	210d      	movs	r1, #13
{
   10d64:	9e12      	ldr	r6, [sp, #72]	; 0x48
   10d66:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
   10d6a:	f8dd 9064 	ldr.w	r9, [sp, #100]	; 0x64
   10d6e:	f8dd a06c 	ldr.w	sl, [sp, #108]	; 0x6c
	sep = meta_evt(buf, BT_HCI_EVT_LE_EXT_ADVERTISING_REPORT,
   10d72:	f7ff ffc2 	bl	10cfa <meta_evt>
	sep->num_reports = 1U;
   10d76:	2201      	movs	r2, #1
   10d78:	7002      	strb	r2, [r0, #0]
	adv_info->evt_type = evt_type;
   10d7a:	f8a0 8001 	strh.w	r8, [r0, #1]
	sep = meta_evt(buf, BT_HCI_EVT_LE_EXT_ADVERTISING_REPORT,
   10d7e:	4604      	mov	r4, r0
	} else if (rl_idx < ll_rl_size_get()) {
   10d80:	f000 fcb9 	bl	116f6 <ll_rl_size_get>
   10d84:	9b07      	ldr	r3, [sp, #28]
   10d86:	4298      	cmp	r0, r3
   10d88:	f104 0004 	add.w	r0, r4, #4
   10d8c:	d936      	bls.n	10dfc <ext_adv_info_fill+0xd2>
		ll_rl_id_addr_get(rl_idx, &adv_info->addr.type,
   10d8e:	4602      	mov	r2, r0
   10d90:	1ce1      	adds	r1, r4, #3
   10d92:	4618      	mov	r0, r3
   10d94:	f7f7 fc42 	bl	861c <ll_rl_id_addr_get>
		adv_info->addr.type += 2U;
   10d98:	78e3      	ldrb	r3, [r4, #3]
   10d9a:	3302      	adds	r3, #2
   10d9c:	70e3      	strb	r3, [r4, #3]
   10d9e:	fa95 f3a5 	rbit	r3, r5
   10da2:	2d00      	cmp	r5, #0
   10da4:	fab3 f383 	clz	r3, r3
   10da8:	bf08      	it	eq
   10daa:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   10dae:	3301      	adds	r3, #1
	adv_info->prim_phy = find_lsb_set(phy);
   10db0:	72a3      	strb	r3, [r4, #10]
	adv_info->sec_phy = sec_phy;
   10db2:	9b01      	ldr	r3, [sp, #4]
   10db4:	72e3      	strb	r3, [r4, #11]
	adv_info->sid = (adi) ? adi->sid : BT_HCI_LE_EXT_ADV_SID_INVALID;
   10db6:	f1b9 0f00 	cmp.w	r9, #0
   10dba:	d02d      	beq.n	10e18 <ext_adv_info_fill+0xee>
   10dbc:	f899 3001 	ldrb.w	r3, [r9, #1]
   10dc0:	091b      	lsrs	r3, r3, #4
   10dc2:	7323      	strb	r3, [r4, #12]
	adv_info->tx_power = tx_pwr;
   10dc4:	9b04      	ldr	r3, [sp, #16]
   10dc6:	7363      	strb	r3, [r4, #13]
	adv_info->rssi = rssi;
   10dc8:	9b05      	ldr	r3, [sp, #20]
   10dca:	73a3      	strb	r3, [r4, #14]
	if (evt_type & BT_HCI_LE_ADV_EVT_TYPE_DIRECT) {
   10dcc:	f018 0104 	ands.w	r1, r8, #4
	adv_info->interval = interval_le16;
   10dd0:	9b06      	ldr	r3, [sp, #24]
   10dd2:	f8a4 300f 	strh.w	r3, [r4, #15]
		(void)memcpy(adv_info->direct_addr.a.val, direct_addr,
   10dd6:	f104 0012 	add.w	r0, r4, #18
	if (evt_type & BT_HCI_LE_ADV_EVT_TYPE_DIRECT) {
   10dda:	d01f      	beq.n	10e1c <ext_adv_info_fill+0xf2>
		adv_info->direct_addr.type = direct_addr_type;
   10ddc:	9b03      	ldr	r3, [sp, #12]
   10dde:	7463      	strb	r3, [r4, #17]
		(void)memcpy(adv_info->direct_addr.a.val, direct_addr,
   10de0:	2206      	movs	r2, #6
   10de2:	4659      	mov	r1, fp
   10de4:	f7fe fedf 	bl	fba6 <memcpy>
	(void)memcpy(adv_info->data, data, data_len);
   10de8:	463a      	mov	r2, r7
   10dea:	4651      	mov	r1, sl
   10dec:	f104 0019 	add.w	r0, r4, #25
	adv_info->length = data_len;
   10df0:	7627      	strb	r7, [r4, #24]
}
   10df2:	b009      	add	sp, #36	; 0x24
   10df4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)memcpy(adv_info->data, data, data_len);
   10df8:	f7fe bed5 	b.w	fba6 <memcpy>
	} else if (adv_addr) {
   10dfc:	b136      	cbz	r6, 10e0c <ext_adv_info_fill+0xe2>
		adv_info->addr.type = adv_addr_type;
   10dfe:	9b02      	ldr	r3, [sp, #8]
   10e00:	70e3      	strb	r3, [r4, #3]
		(void)memcpy(adv_info->addr.a.val, adv_addr, sizeof(bt_addr_t));
   10e02:	2206      	movs	r2, #6
   10e04:	4631      	mov	r1, r6
   10e06:	f7fe fece 	bl	fba6 <memcpy>
   10e0a:	e7c8      	b.n	10d9e <ext_adv_info_fill+0x74>
		adv_info->addr.type = 0U;
   10e0c:	70e6      	strb	r6, [r4, #3]
		(void)memset(adv_info->addr.a.val, 0, sizeof(bt_addr_t));
   10e0e:	2206      	movs	r2, #6
   10e10:	4631      	mov	r1, r6
   10e12:	f7fe fed3 	bl	fbbc <memset>
   10e16:	e7c2      	b.n	10d9e <ext_adv_info_fill+0x74>
	adv_info->sid = (adi) ? adi->sid : BT_HCI_LE_EXT_ADV_SID_INVALID;
   10e18:	23ff      	movs	r3, #255	; 0xff
   10e1a:	e7d2      	b.n	10dc2 <ext_adv_info_fill+0x98>
		adv_info->direct_addr.type = 0U;
   10e1c:	7461      	strb	r1, [r4, #17]
		(void)memset(adv_info->direct_addr.a.val, 0, sizeof(bt_addr_t));
   10e1e:	2206      	movs	r2, #6
   10e20:	f7fe fecc 	bl	fbbc <memset>
   10e24:	e7e0      	b.n	10de8 <ext_adv_info_fill+0xbe>

00010e26 <ext_adv_data_frag.constprop.0>:
static void ext_adv_data_frag(const struct node_rx_pdu *node_rx_data,
   10e26:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10e2a:	b095      	sub	sp, #84	; 0x54
   10e2c:	4698      	mov	r8, r3
   10e2e:	f89d 3078 	ldrb.w	r3, [sp, #120]	; 0x78
   10e32:	930e      	str	r3, [sp, #56]	; 0x38
   10e34:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
   10e38:	930f      	str	r3, [sp, #60]	; 0x3c
   10e3a:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
   10e3e:	9310      	str	r3, [sp, #64]	; 0x40
   10e40:	f99d 308c 	ldrsb.w	r3, [sp, #140]	; 0x8c
   10e44:	9311      	str	r3, [sp, #68]	; 0x44
   10e46:	e9dd 5928 	ldrd	r5, r9, [sp, #160]	; 0xa0
   10e4a:	f99d 3090 	ldrsb.w	r3, [sp, #144]	; 0x90
   10e4e:	9312      	str	r3, [sp, #72]	; 0x48
   10e50:	f89d 709c 	ldrb.w	r7, [sp, #156]	; 0x9c
   10e54:	f8bd 3094 	ldrh.w	r3, [sp, #148]	; 0x94
   10e58:	920d      	str	r2, [sp, #52]	; 0x34
   10e5a:	4604      	mov	r4, r0
   10e5c:	9313      	str	r3, [sp, #76]	; 0x4c
	evt_type |= (BT_HCI_LE_ADV_EVT_TYPE_DATA_STATUS_PARTIAL << 5);
   10e5e:	f041 0a20 	orr.w	sl, r1, #32
	const uint8_t data_len_frag = MIN(*data_len, data_len_max);
   10e62:	782e      	ldrb	r6, [r5, #0]
		ext_adv_pdu_frag(evt_type, phy, *sec_phy, adv_addr_type,
   10e64:	f898 b000 	ldrb.w	fp, [r8]
	const uint8_t data_len_frag = MIN(*data_len, data_len_max);
   10e68:	2ee5      	cmp	r6, #229	; 0xe5
   10e6a:	bf28      	it	cs
   10e6c:	26e5      	movcs	r6, #229	; 0xe5
		ext_adv_info_fill(evt_type, phy, sec_phy, adv_addr_type,
   10e6e:	9b2b      	ldr	r3, [sp, #172]	; 0xac
   10e70:	990d      	ldr	r1, [sp, #52]	; 0x34
   10e72:	681b      	ldr	r3, [r3, #0]
   10e74:	930a      	str	r3, [sp, #40]	; 0x28
   10e76:	f8d9 3000 	ldr.w	r3, [r9]
   10e7a:	e9cd 6308 	strd	r6, r3, [sp, #32]
   10e7e:	9b26      	ldr	r3, [sp, #152]	; 0x98
   10e80:	9307      	str	r3, [sp, #28]
   10e82:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   10e84:	9306      	str	r3, [sp, #24]
   10e86:	9b12      	ldr	r3, [sp, #72]	; 0x48
   10e88:	9305      	str	r3, [sp, #20]
   10e8a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   10e8c:	9304      	str	r3, [sp, #16]
   10e8e:	9b10      	ldr	r3, [sp, #64]	; 0x40
   10e90:	9303      	str	r3, [sp, #12]
   10e92:	9b21      	ldr	r3, [sp, #132]	; 0x84
   10e94:	9302      	str	r3, [sp, #8]
   10e96:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   10e98:	9301      	str	r3, [sp, #4]
   10e9a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   10e9c:	9300      	str	r3, [sp, #0]
   10e9e:	465a      	mov	r2, fp
   10ea0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   10ea2:	4650      	mov	r0, sl
   10ea4:	f7ff ff41 	bl	10d2a <ext_adv_info_fill>
		*data += data_len_frag;
   10ea8:	f8d9 3000 	ldr.w	r3, [r9]
   10eac:	4433      	add	r3, r6
   10eae:	f8c9 3000 	str.w	r3, [r9]
		*data_len -= data_len_frag;
   10eb2:	782b      	ldrb	r3, [r5, #0]
   10eb4:	1b9b      	subs	r3, r3, r6
   10eb6:	702b      	strb	r3, [r5, #0]
		*evt_buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   10eb8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   10ebc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   10ec0:	2001      	movs	r0, #1
   10ec2:	f7f1 feb5 	bl	2c30 <bt_buf_get_rx>
   10ec6:	9b2b      	ldr	r3, [sp, #172]	; 0xac
   10ec8:	4601      	mov	r1, r0
   10eca:	6018      	str	r0, [r3, #0]
		net_buf_frag_add(buf, *evt_buf);
   10ecc:	982a      	ldr	r0, [sp, #168]	; 0xa8
   10ece:	f000 fff5 	bl	11ebc <net_buf_frag_add>
	} while (*data_len > data_len_max);
   10ed2:	782b      	ldrb	r3, [r5, #0]
		*data_len_total -= data_len_frag;
   10ed4:	1bbf      	subs	r7, r7, r6
	} while (*data_len > data_len_max);
   10ed6:	2be5      	cmp	r3, #229	; 0xe5
		*data_len_total -= data_len_frag;
   10ed8:	b2ff      	uxtb	r7, r7
	} while (*data_len > data_len_max);
   10eda:	d8c8      	bhi.n	10e6e <ext_adv_data_frag.constprop.0+0x48>
		node_rx_data = node_rx_data->hdr.rx_ftr.extra;
   10edc:	68e4      	ldr	r4, [r4, #12]
		if (node_rx_data) {
   10ede:	b174      	cbz	r4, 10efe <ext_adv_data_frag.constprop.0+0xd8>
	if (!p->ext_hdr_len) {
   10ee0:	7fa3      	ldrb	r3, [r4, #30]
   10ee2:	069e      	lsls	r6, r3, #26
   10ee4:	d113      	bne.n	10f0e <ext_adv_data_frag.constprop.0+0xe8>
	h = (void *)p->ext_hdr_adv_data;
   10ee6:	f104 031f 	add.w	r3, r4, #31
		hdr_len = PDU_AC_EXT_HEADER_SIZE_MIN;
   10eea:	2201      	movs	r2, #1
	if (hdr_len < adv->len) {
   10eec:	7f61      	ldrb	r1, [r4, #29]
   10eee:	4291      	cmp	r1, r2
		return adv->len - hdr_len;
   10ef0:	bf85      	ittet	hi
   10ef2:	1a8a      	subhi	r2, r1, r2
   10ef4:	b2d2      	uxtbhi	r2, r2
	return 0;
   10ef6:	2200      	movls	r2, #0
		*data = ptr;
   10ef8:	f8c9 3000 	strhi.w	r3, [r9]
			*data_len = ext_adv_data_get(node_rx_data, sec_phy,
   10efc:	702a      	strb	r2, [r5, #0]
	} while ((*data_len < data_len_total) || (*data_len > data_len_max));
   10efe:	782b      	ldrb	r3, [r5, #0]
   10f00:	42bb      	cmp	r3, r7
   10f02:	d3ae      	bcc.n	10e62 <ext_adv_data_frag.constprop.0+0x3c>
   10f04:	2be5      	cmp	r3, #229	; 0xe5
   10f06:	d8ac      	bhi.n	10e62 <ext_adv_data_frag.constprop.0+0x3c>
}
   10f08:	b015      	add	sp, #84	; 0x54
   10f0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (h->adv_addr) {
   10f0e:	7fe2      	ldrb	r2, [r4, #31]
   10f10:	07d0      	lsls	r0, r2, #31
		ptr += BDADDR_SIZE;
   10f12:	bf4c      	ite	mi
   10f14:	f104 0326 	addmi.w	r3, r4, #38	; 0x26
	ptr = h->data;
   10f18:	f104 0320 	addpl.w	r3, r4, #32
	if (h->tgt_addr) {
   10f1c:	0791      	lsls	r1, r2, #30
		ptr += BDADDR_SIZE;
   10f1e:	bf48      	it	mi
   10f20:	3306      	addmi	r3, #6
	if (h->adi) {
   10f22:	0716      	lsls	r6, r2, #28
		ptr += sizeof(struct pdu_adv_adi);
   10f24:	bf48      	it	mi
   10f26:	3302      	addmi	r3, #2
	if (h->aux_ptr) {
   10f28:	06d0      	lsls	r0, r2, #27
   10f2a:	d506      	bpl.n	10f3a <ext_adv_data_frag.constprop.0+0x114>
		*sec_phy = HCI_AUX_PHY_TO_HCI_PHY(aux_ptr->phy);
   10f2c:	789a      	ldrb	r2, [r3, #2]
   10f2e:	f3c2 1242 	ubfx	r2, r2, #5, #3
   10f32:	3201      	adds	r2, #1
   10f34:	f888 2000 	strb.w	r2, [r8]
		ptr += sizeof(*aux_ptr);
   10f38:	3303      	adds	r3, #3
	if (h->sync_info) {
   10f3a:	7fe2      	ldrb	r2, [r4, #31]
   10f3c:	0691      	lsls	r1, r2, #26
	hdr_buf_len = PDU_AC_EXT_HEADER_SIZE_MIN + p->ext_hdr_len;
   10f3e:	7fa1      	ldrb	r1, [r4, #30]
		ptr += sizeof(struct pdu_adv_sync_info);
   10f40:	bf48      	it	mi
   10f42:	3312      	addmi	r3, #18
	if (h->tx_pwr) {
   10f44:	0652      	lsls	r2, r2, #25
		ptr++;
   10f46:	bf48      	it	mi
   10f48:	3301      	addmi	r3, #1
	p = (void *)&adv->adv_ext_ind;
   10f4a:	f104 021e 	add.w	r2, r4, #30
	hdr_buf_len = PDU_AC_EXT_HEADER_SIZE_MIN + p->ext_hdr_len;
   10f4e:	f3c1 0105 	ubfx	r1, r1, #0, #6
	hdr_len = ptr - (uint8_t *)p;
   10f52:	1a9a      	subs	r2, r3, r2
	hdr_buf_len = PDU_AC_EXT_HEADER_SIZE_MIN + p->ext_hdr_len;
   10f54:	3101      	adds	r1, #1
	hdr_len = ptr - (uint8_t *)p;
   10f56:	b2d2      	uxtb	r2, r2
	hdr_buf_len = PDU_AC_EXT_HEADER_SIZE_MIN + p->ext_hdr_len;
   10f58:	b2c9      	uxtb	r1, r1
	if (hdr_len < hdr_buf_len) {
   10f5a:	428a      	cmp	r2, r1
		uint8_t acad_len = hdr_buf_len - hdr_len;
   10f5c:	bf3e      	ittt	cc
   10f5e:	1a8a      	subcc	r2, r1, r2
		ptr += acad_len;
   10f60:	fa53 f382 	uxtabcc	r3, r3, r2
   10f64:	460a      	movcc	r2, r1
   10f66:	e7c1      	b.n	10eec <ext_adv_data_frag.constprop.0+0xc6>

00010f68 <sys_get_le64>:
{
   10f68:	4603      	mov	r3, r0
}
   10f6a:	6800      	ldr	r0, [r0, #0]
   10f6c:	6859      	ldr	r1, [r3, #4]
   10f6e:	4770      	bx	lr

00010f70 <hci_get_class>:
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   10f70:	7900      	ldrb	r0, [r0, #4]
   10f72:	2803      	cmp	r0, #3
   10f74:	d013      	beq.n	10f9e <hci_get_class+0x2e>
		switch (node_rx->hdr.type) {
   10f76:	2812      	cmp	r0, #18
   10f78:	d013      	beq.n	10fa2 <hci_get_class+0x32>
   10f7a:	d80b      	bhi.n	10f94 <hci_get_class+0x24>
   10f7c:	2808      	cmp	r0, #8
   10f7e:	d804      	bhi.n	10f8a <hci_get_class+0x1a>
			return HCI_CLASS_EVT_DISCARDABLE;
   10f80:	2805      	cmp	r0, #5
   10f82:	bf34      	ite	cc
   10f84:	2000      	movcc	r0, #0
   10f86:	2002      	movcs	r0, #2
   10f88:	4770      	bx	lr
		return HCI_CLASS_NONE;
   10f8a:	f1a0 030b 	sub.w	r3, r0, #11
   10f8e:	4258      	negs	r0, r3
   10f90:	4158      	adcs	r0, r3
   10f92:	4770      	bx	lr
			return HCI_CLASS_EVT_DISCARDABLE;
   10f94:	2815      	cmp	r0, #21
   10f96:	bf14      	ite	ne
   10f98:	2000      	movne	r0, #0
   10f9a:	2002      	moveq	r0, #2
   10f9c:	4770      	bx	lr
		return HCI_CLASS_NONE;
   10f9e:	2000      	movs	r0, #0
   10fa0:	4770      	bx	lr
		switch (node_rx->hdr.type) {
   10fa2:	2001      	movs	r0, #1
}
   10fa4:	4770      	bx	lr

00010fa6 <bt_rand>:
#include "hal/ecb.h"
#include "lll.h"

int bt_rand(void *buf, size_t len)
{
	return lll_csrand_get(buf, len);
   10fa6:	f7f8 bb31 	b.w	960c <lll_csrand_get>

00010faa <bt_encrypt_le>:
}

int bt_encrypt_le(const uint8_t key[16], const uint8_t plaintext[16],
		  uint8_t enc_data[16])
{
   10faa:	b508      	push	{r3, lr}
	BT_DBG("key %s", bt_hex(key, 16));
	BT_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt(key, plaintext, enc_data, NULL);
   10fac:	2300      	movs	r3, #0
   10fae:	f000 fe4c 	bl	11c4a <ecb_encrypt>

	BT_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
   10fb2:	2000      	movs	r0, #0
   10fb4:	bd08      	pop	{r3, pc}

00010fb6 <ll_feat_get>:

#else /* !CONFIG_BT_CTLR_SET_HOST_FEATURE */
uint64_t ll_feat_get(void)
{
	return LL_FEAT;
}
   10fb6:	f245 10c0 	movw	r0, #20928	; 0x51c0
   10fba:	2100      	movs	r1, #0
   10fbc:	4770      	bx	lr

00010fbe <disabled_cb>:
	z_impl_k_sem_give(sem);
   10fbe:	f7fd bb5d 	b.w	e67c <z_impl_k_sem_give>

00010fc2 <ull_done_extra_type_set>:
{
   10fc2:	b510      	push	{r4, lr}
   10fc4:	4604      	mov	r4, r0
	extra = ull_event_done_extra_get();
   10fc6:	f7f5 fc61 	bl	688c <ull_event_done_extra_get>
	if (!extra) {
   10fca:	b100      	cbz	r0, 10fce <ull_done_extra_type_set+0xc>
	extra->type = type;
   10fcc:	7004      	strb	r4, [r0, #0]
}
   10fce:	bd10      	pop	{r4, pc}

00010fd0 <ull_rxfifo_alloc>:
 * @details This function allocates up to 'max' number of MFIFO elements by
 *          enqueuing pointers to memory elements with associated memq links.
 */
void ull_rxfifo_alloc(uint8_t s, uint8_t n, uint8_t f, uint8_t *l, uint8_t *m,
		      void *mem_free, void *link_free, uint8_t max)
{
   10fd0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10fd4:	e9dd a60d 	ldrd	sl, r6, [sp, #52]	; 0x34
   10fd8:	469b      	mov	fp, r3
   10fda:	f89d 703c 	ldrb.w	r7, [sp, #60]	; 0x3c
   10fde:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   10fe0:	9100      	str	r1, [sp, #0]
   10fe2:	4681      	mov	r9, r0
   10fe4:	4690      	mov	r8, r2
   10fe6:	9301      	str	r3, [sp, #4]
	uint8_t idx;

	while ((max--) && mfifo_enqueue_idx_get(n, f, *l, &idx)) {
   10fe8:	b177      	cbz	r7, 11008 <ull_rxfifo_alloc+0x38>
	last = last + 1;
   10fea:	f89b 4000 	ldrb.w	r4, [fp]
		last = 0U;
   10fee:	9b00      	ldr	r3, [sp, #0]
	last = last + 1;
   10ff0:	3401      	adds	r4, #1
   10ff2:	b2e4      	uxtb	r4, r4
		last = 0U;
   10ff4:	42a3      	cmp	r3, r4
   10ff6:	bf08      	it	eq
   10ff8:	2400      	moveq	r4, #0
	if (last == first) {
   10ffa:	45a0      	cmp	r8, r4
   10ffc:	d004      	beq.n	11008 <ull_rxfifo_alloc+0x38>
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(link_free);
   10ffe:	4630      	mov	r0, r6
   11000:	f7ff fb0e 	bl	10620 <mem_acquire>
		if (!link) {
   11004:	4605      	mov	r5, r0
   11006:	b910      	cbnz	r0, 1100e <ull_rxfifo_alloc+0x3e>
		link->mem = NULL;
		rx->link = link;

		mfifo_by_idx_enqueue(m, s, idx, rx, l);
	}
}
   11008:	b003      	add	sp, #12
   1100a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rx = mem_acquire(mem_free);
   1100e:	4650      	mov	r0, sl
   11010:	f7ff fb06 	bl	10620 <mem_acquire>
		if (!rx) {
   11014:	b930      	cbnz	r0, 11024 <ull_rxfifo_alloc+0x54>
			mem_release(link, link_free);
   11016:	4631      	mov	r1, r6
   11018:	4628      	mov	r0, r5
}
   1101a:	b003      	add	sp, #12
   1101c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			mem_release(link, link_free);
   11020:	f7ff bb17 	b.w	10652 <mem_release>
		link->mem = NULL;
   11024:	2300      	movs	r3, #0
   11026:	606b      	str	r3, [r5, #4]
		rx->link = link;
   11028:	6005      	str	r5, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1102a:	f89b 5000 	ldrb.w	r5, [fp]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1102e:	9b01      	ldr	r3, [sp, #4]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   11030:	fb15 f509 	smulbb	r5, r5, r9
	while ((max--) && mfifo_enqueue_idx_get(n, f, *l, &idx)) {
   11034:	1e7a      	subs	r2, r7, #1
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   11036:	5158      	str	r0, [r3, r5]
   11038:	b2d7      	uxtb	r7, r2
	*last = idx; /* Commit: Update write index */
   1103a:	f88b 4000 	strb.w	r4, [fp]
}
   1103e:	e7d3      	b.n	10fe8 <ull_rxfifo_alloc+0x18>

00011040 <ull_rxfifo_release>:
 * @brief   Support function for RXFIFO_RELEASE macro
 * @details This function releases a node by returning it to the FIFO.
 */
void *ull_rxfifo_release(uint8_t s, uint8_t n, uint8_t f, uint8_t *l, uint8_t *m,
			 memq_link_t *link, struct node_rx_hdr *rx)
{
   11040:	b530      	push	{r4, r5, lr}
	last = last + 1;
   11042:	781c      	ldrb	r4, [r3, #0]
   11044:	3401      	adds	r4, #1
   11046:	b2e4      	uxtb	r4, r4
		last = 0U;
   11048:	42a1      	cmp	r1, r4
   1104a:	bf08      	it	eq
   1104c:	2400      	moveq	r4, #0
	if (last == first) {
   1104e:	42a2      	cmp	r2, r4
   11050:	4605      	mov	r5, r0
   11052:	9805      	ldr	r0, [sp, #20]
   11054:	d008      	beq.n	11068 <ull_rxfifo_release+0x28>

	if (!mfifo_enqueue_idx_get(n, f, *l, &idx)) {
		return NULL;
	}

	rx->link = link;
   11056:	9a04      	ldr	r2, [sp, #16]
   11058:	6002      	str	r2, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1105a:	781a      	ldrb	r2, [r3, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1105c:	9903      	ldr	r1, [sp, #12]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1105e:	fb12 f205 	smulbb	r2, r2, r5
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   11062:	5088      	str	r0, [r1, r2]
	*last = idx; /* Commit: Update write index */
   11064:	701c      	strb	r4, [r3, #0]

	mfifo_by_idx_enqueue(m, s, idx, rx, l);

	return rx;
}
   11066:	bd30      	pop	{r4, r5, pc}
		return NULL;
   11068:	2000      	movs	r0, #0
   1106a:	e7fc      	b.n	11066 <ull_rxfifo_release+0x26>

0001106c <lll_prepare>:
{
   1106c:	b507      	push	{r0, r1, r2, lr}
	return lll_prepare_resolve(is_abort_cb, abort_cb, prepare_cb,
   1106e:	2300      	movs	r3, #0
   11070:	e9cd 3300 	strd	r3, r3, [sp]
   11074:	9b04      	ldr	r3, [sp, #16]
   11076:	f7f8 fc29 	bl	98cc <lll_prepare_resolve>
}
   1107a:	b003      	add	sp, #12
   1107c:	f85d fb04 	ldr.w	pc, [sp], #4

00011080 <ext_disabled_cb>:
	struct node_rx_hdr *rx_hdr = (void *)lll->node_rx_adv_term;
   11080:	6a01      	ldr	r1, [r0, #32]
{
   11082:	b508      	push	{r3, lr}
	if (!rx_hdr) {
   11084:	b131      	cbz	r1, 11094 <ext_disabled_cb+0x14>
	ll_rx_put(rx_hdr->link, rx_hdr);
   11086:	6808      	ldr	r0, [r1, #0]
   11088:	f7f5 f9e8 	bl	645c <ll_rx_put>
}
   1108c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	ll_rx_sched();
   11090:	f7f5 b9ea 	b.w	6468 <ll_rx_sched>
}
   11094:	bd08      	pop	{r3, pc}

00011096 <adv_time_get.constprop.0>:
static uint16_t adv_time_get(struct pdu_adv *pdu, struct pdu_adv *pdu_scan,
   11096:	b570      	push	{r4, r5, r6, lr}
	if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
   11098:	7806      	ldrb	r6, [r0, #0]
   1109a:	f006 060f 	and.w	r6, r6, #15
		time_us += PDU_AC_US(pdu->len, phy, phy_flags) * adv_chn_cnt +
   1109e:	1e54      	subs	r4, r2, #1
	if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
   110a0:	2e07      	cmp	r6, #7
static uint16_t adv_time_get(struct pdu_adv *pdu, struct pdu_adv *pdu_scan,
   110a2:	4605      	mov	r5, r0
		time_us += PDU_AC_US(pdu->len, phy, phy_flags) * adv_chn_cnt +
   110a4:	b2a4      	uxth	r4, r4
	if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
   110a6:	d115      	bne.n	110d4 <adv_time_get.constprop.0+0x3e>
		time_us += PDU_AC_US(pdu->len, phy, phy_flags) * adv_chn_cnt +
   110a8:	7840      	ldrb	r0, [r0, #1]
   110aa:	f003 0103 	and.w	r1, r3, #3
   110ae:	3109      	adds	r1, #9
   110b0:	4401      	add	r1, r0
   110b2:	00c9      	lsls	r1, r1, #3
   110b4:	f3c3 0040 	ubfx	r0, r3, #1, #1
   110b8:	fa21 f000 	lsr.w	r0, r1, r0
   110bc:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   110c0:	fb10 f002 	smulbb	r0, r0, r2
   110c4:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
   110c8:	eb00 0043 	add.w	r0, r0, r3, lsl #1
   110cc:	f500 70c8 	add.w	r0, r0, #400	; 0x190
			time_us += (BYTES2US(adv_size, PHY_1M) +
   110d0:	b280      	uxth	r0, r0
}
   110d2:	bd70      	pop	{r4, r5, r6, pc}
		if (pdu->type == PDU_ADV_TYPE_NONCONN_IND) {
   110d4:	2e02      	cmp	r6, #2
   110d6:	d10c      	bne.n	110f2 <adv_time_get.constprop.0+0x5c>
			adv_size += pdu->len;
   110d8:	7840      	ldrb	r0, [r0, #1]
			time_us += BYTES2US(adv_size, PHY_1M) * adv_chn_cnt +
   110da:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   110de:	3010      	adds	r0, #16
   110e0:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
   110e4:	00c1      	lsls	r1, r0, #3
   110e6:	0058      	lsls	r0, r3, #1
   110e8:	f500 70c8 	add.w	r0, r0, #400	; 0x190
   110ec:	fb01 0002 	mla	r0, r1, r2, r0
   110f0:	e7ee      	b.n	110d0 <adv_time_get.constprop.0+0x3a>
			if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   110f2:	2e01      	cmp	r6, #1
   110f4:	d017      	beq.n	11126 <adv_time_get.constprop.0+0x90>
			BYTES2US((PDU_OVERHEAD_SIZE(PHY_1M) +
   110f6:	784b      	ldrb	r3, [r1, #1]
   110f8:	3310      	adds	r3, #16
		const uint16_t scan_rsp_us =
   110fa:	00db      	lsls	r3, r3, #3
			} else if (pdu->type == PDU_ADV_TYPE_ADV_IND) {
   110fc:	b96e      	cbnz	r6, 1111a <adv_time_get.constprop.0+0x84>
				adv_size += pdu->len;
   110fe:	7868      	ldrb	r0, [r5, #1]
				time_us += scan_req_us + EVENT_IFS_MAX_US +
   11100:	f503 7336 	add.w	r3, r3, #728	; 0x2d8
				adv_size += pdu->len;
   11104:	3010      	adds	r0, #16
				   BYTES2US(adv_size, PHY_1M) + EVENT_IFS_MAX_US;
   11106:	00c2      	lsls	r2, r0, #3
   11108:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
				    EVENT_IFS_MAX_US + rx_to_us +
   1110c:	f502 73b3 	add.w	r3, r2, #358	; 0x166
   11110:	3098      	adds	r0, #152	; 0x98
				    rxtx_turn_us) * (adv_chn_cnt - 1) +
   11112:	fb13 f304 	smulbb	r3, r3, r4
			time_us += (BYTES2US(adv_size, PHY_1M) +
   11116:	4418      	add	r0, r3
   11118:	e7da      	b.n	110d0 <adv_time_get.constprop.0+0x3a>
			} else if (pdu->type == PDU_ADV_TYPE_SCAN_IND) {
   1111a:	2e06      	cmp	r6, #6
   1111c:	d0ef      	beq.n	110fe <adv_time_get.constprop.0+0x68>
		uint16_t adv_size =
   1111e:	2010      	movs	r0, #16
	uint16_t time_us = EVENT_OVERHEAD_START_US + EVENT_OVERHEAD_END_US;
   11120:	f44f 73c8 	mov.w	r3, #400	; 0x190
   11124:	e7ef      	b.n	11106 <adv_time_get.constprop.0+0x70>
				adv_size += TARGETA_SIZE;
   11126:	2016      	movs	r0, #22
				time_us += conn_ind_us;
   11128:	f44f 733c 	mov.w	r3, #752	; 0x2f0
   1112c:	e7eb      	b.n	11106 <adv_time_get.constprop.0+0x70>

0001112e <ull_adv_init>:
{
   1112e:	b508      	push	{r3, lr}
		err = ull_adv_aux_init();
   11130:	f7f6 face 	bl	76d0 <ull_adv_aux_init>
		if (err) {
   11134:	b918      	cbnz	r0, 1113e <ull_adv_init+0x10>
}
   11136:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	err = init_reset();
   1113a:	f7f5 bf25 	b.w	6f88 <init_reset>
}
   1113e:	bd08      	pop	{r3, pc}

00011140 <ull_adv_reset>:
{
   11140:	b508      	push	{r3, lr}
		(void)disable(handle);
   11142:	2000      	movs	r0, #0
   11144:	f7f6 f9e4 	bl	7510 <disable>
}
   11148:	2000      	movs	r0, #0
   1114a:	bd08      	pop	{r3, pc}

0001114c <ull_adv_is_enabled>:
{
   1114c:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   1114e:	f7f6 f9d1 	bl	74f4 <ull_adv_is_enabled_get>
}
   11152:	3800      	subs	r0, #0
   11154:	bf18      	it	ne
   11156:	2001      	movne	r0, #1
   11158:	bd08      	pop	{r3, pc}

0001115a <ull_adv_filter_pol_get>:
{
   1115a:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   1115c:	f7f6 f9ca 	bl	74f4 <ull_adv_is_enabled_get>
	if (!adv) {
   11160:	b110      	cbz	r0, 11168 <ull_adv_filter_pol_get+0xe>
	return adv->lll.filter_policy;
   11162:	f890 0020 	ldrb.w	r0, [r0, #32]
   11166:	0980      	lsrs	r0, r0, #6
}
   11168:	bd08      	pop	{r3, pc}

0001116a <ull_adv_pdu_update_addrs>:
{
   1116a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (com_hdr->ext_hdr_len) {
   1116e:	788e      	ldrb	r6, [r1, #2]
{
   11170:	4607      	mov	r7, r0
	if (com_hdr->ext_hdr_len) {
   11172:	f016 063f 	ands.w	r6, r6, #63	; 0x3f
	const uint8_t *rpa = ull_filter_adva_get(adv->lll.rl_idx);
   11176:	f890 0022 	ldrb.w	r0, [r0, #34]	; 0x22
		hdr_flags = *hdr;
   1117a:	bf18      	it	ne
   1117c:	78ce      	ldrbne	r6, [r1, #3]
{
   1117e:	460c      	mov	r4, r1
	const uint8_t *rpa = ull_filter_adva_get(adv->lll.rl_idx);
   11180:	f7f7 fc3a 	bl	89f8 <ull_filter_adva_get>
	if (!rpa || IS_ENABLED(CONFIG_BT_CTLR_CHECK_SAME_PEER_CONN)) {
   11184:	4605      	mov	r5, r0
   11186:	bb80      	cbnz	r0, 111ea <ull_adv_pdu_update_addrs+0x80>
		} else if (ll_adv_cmds_is_ext() && pdu->tx_addr) {
   11188:	7820      	ldrb	r0, [r4, #0]
   1118a:	0642      	lsls	r2, r0, #25
   1118c:	d527      	bpl.n	111de <ull_adv_pdu_update_addrs+0x74>
			own_id_addr = adv->rnd_addr;
   1118e:	f107 0568 	add.w	r5, r7, #104	; 0x68
	adv_addr = adv_pdu_adva_get(pdu);
   11192:	4620      	mov	r0, r4
   11194:	f7f5 fdd6 	bl	6d44 <adv_pdu_adva_get>
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
   11198:	2206      	movs	r2, #6
   1119a:	4629      	mov	r1, r5
	adv_addr = adv_pdu_adva_get(pdu);
   1119c:	4680      	mov	r8, r0
	memcpy(adv_addr, tx_addr, BDADDR_SIZE);
   1119e:	f7fe fd02 	bl	fba6 <memcpy>
	if ((pdu->type == PDU_ADV_TYPE_DIRECT_IND) ||
   111a2:	7823      	ldrb	r3, [r4, #0]
   111a4:	f003 030f 	and.w	r3, r3, #15
   111a8:	2b01      	cmp	r3, #1
   111aa:	d003      	beq.n	111b4 <ull_adv_pdu_update_addrs+0x4a>
	    ((pdu->type == PDU_ADV_TYPE_EXT_IND) && hdr_flags.tgt_addr) ||
   111ac:	2b07      	cmp	r3, #7
   111ae:	d113      	bne.n	111d8 <ull_adv_pdu_update_addrs+0x6e>
   111b0:	07b3      	lsls	r3, r6, #30
   111b2:	d511      	bpl.n	111d8 <ull_adv_pdu_update_addrs+0x6e>
	rx_addr = ull_filter_tgta_get(adv->lll.rl_idx);
   111b4:	f897 0022 	ldrb.w	r0, [r7, #34]	; 0x22
   111b8:	f7f7 fc48 	bl	8a4c <ull_filter_tgta_get>
	if (rx_addr) {
   111bc:	4605      	mov	r5, r0
   111be:	b158      	cbz	r0, 111d8 <ull_adv_pdu_update_addrs+0x6e>
		pdu->rx_addr = 1;
   111c0:	7823      	ldrb	r3, [r4, #0]
   111c2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   111c6:	7023      	strb	r3, [r4, #0]
		tgt_addr = adv_pdu_adva_get(pdu) + BDADDR_SIZE;
   111c8:	4620      	mov	r0, r4
   111ca:	f7f5 fdbb 	bl	6d44 <adv_pdu_adva_get>
		memcpy(tgt_addr, rx_addr, BDADDR_SIZE);
   111ce:	2206      	movs	r2, #6
   111d0:	4629      	mov	r1, r5
   111d2:	4410      	add	r0, r2
   111d4:	f7fe fce7 	bl	fba6 <memcpy>
}
   111d8:	4640      	mov	r0, r8
   111da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			own_id_addr = ll_addr_get(pdu->tx_addr);
   111de:	f3c0 1080 	ubfx	r0, r0, #6, #1
   111e2:	f7f3 fd8f 	bl	4d04 <ll_addr_get>
   111e6:	4605      	mov	r5, r0
   111e8:	e7d3      	b.n	11192 <ull_adv_pdu_update_addrs+0x28>
		pdu->tx_addr = 1;
   111ea:	7823      	ldrb	r3, [r4, #0]
   111ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   111f0:	7023      	strb	r3, [r4, #0]
		tx_addr = rpa;
   111f2:	e7ce      	b.n	11192 <ull_adv_pdu_update_addrs+0x28>

000111f4 <adv_scan_pdu_addr_update>:
{
   111f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	} else if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
   111f6:	780b      	ldrb	r3, [r1, #0]
   111f8:	f003 030f 	and.w	r3, r3, #15
   111fc:	2b07      	cmp	r3, #7
{
   111fe:	4605      	mov	r5, r0
   11200:	460c      	mov	r4, r1
   11202:	4617      	mov	r7, r2
	} else if (pdu->type == PDU_ADV_TYPE_EXT_IND) {
   11204:	d13a      	bne.n	1127c <adv_scan_pdu_addr_update+0x88>
		if (pri_com_hdr->ext_hdr_len) {
   11206:	788a      	ldrb	r2, [r1, #2]
   11208:	f012 033f 	ands.w	r3, r2, #63	; 0x3f
			pri_hdr_flags = *pri_hdr;
   1120c:	bf18      	it	ne
   1120e:	78cb      	ldrbne	r3, [r1, #3]
		if (pri_com_hdr->adv_mode & BT_HCI_LE_ADV_PROP_SCAN) {
   11210:	09d2      	lsrs	r2, r2, #7
   11212:	d006      	beq.n	11222 <adv_scan_pdu_addr_update+0x2e>
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   11214:	f890 2031 	ldrb.w	r2, [r0, #49]	; 0x31
   11218:	eb00 0282 	add.w	r2, r0, r2, lsl #2
			if (!sr->len) {
   1121c:	6b52      	ldr	r2, [r2, #52]	; 0x34
   1121e:	7852      	ldrb	r2, [r2, #1]
   11220:	b342      	cbz	r2, 11274 <adv_scan_pdu_addr_update+0x80>
		if (pri_hdr_flags.adv_addr) {
   11222:	07de      	lsls	r6, r3, #31
   11224:	d42a      	bmi.n	1127c <adv_scan_pdu_addr_update+0x88>
		} else if (pri_hdr_flags.aux_ptr) {
   11226:	06d8      	lsls	r0, r3, #27
   11228:	d401      	bmi.n	1122e <adv_scan_pdu_addr_update+0x3a>
	return 0;
   1122a:	2000      	movs	r0, #0
}
   1122c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			sec_pdu = lll_adv_aux_data_peek(lll->aux);
   1122e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
	return (void *)lll->data.pdu[lll->data.last];
   11230:	7c5a      	ldrb	r2, [r3, #17]
   11232:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   11236:	695e      	ldr	r6, [r3, #20]
			if (sec_com_hdr->ext_hdr_len) {
   11238:	78b3      	ldrb	r3, [r6, #2]
   1123a:	0699      	lsls	r1, r3, #26
   1123c:	d0f5      	beq.n	1122a <adv_scan_pdu_addr_update+0x36>
			if (sec_hdr_flags.adv_addr) {
   1123e:	78f3      	ldrb	r3, [r6, #3]
   11240:	07da      	lsls	r2, r3, #31
   11242:	d5f2      	bpl.n	1122a <adv_scan_pdu_addr_update+0x36>
		adv_addr = ull_adv_pdu_update_addrs(adv, pdu_adv_to_update);
   11244:	4631      	mov	r1, r6
   11246:	4628      	mov	r0, r5
   11248:	f7ff ff8f 	bl	1116a <ull_adv_pdu_update_addrs>
		if (pdu_adv_to_update->tx_addr &&
   1124c:	7833      	ldrb	r3, [r6, #0]
   1124e:	065b      	lsls	r3, r3, #25
   11250:	d503      	bpl.n	1125a <adv_scan_pdu_addr_update+0x66>
		    !mem_nz((void *)adv_addr, BDADDR_SIZE)) {
   11252:	2106      	movs	r1, #6
   11254:	f7ff fa26 	bl	106a4 <mem_nz>
		if (pdu_adv_to_update->tx_addr &&
   11258:	b170      	cbz	r0, 11278 <adv_scan_pdu_addr_update+0x84>
		if ((pdu->type != PDU_ADV_TYPE_EXT_IND) ||
   1125a:	7823      	ldrb	r3, [r4, #0]
   1125c:	f003 030f 	and.w	r3, r3, #15
   11260:	2b07      	cmp	r3, #7
   11262:	d102      	bne.n	1126a <adv_scan_pdu_addr_update+0x76>
		    (pdu->adv_ext_ind.adv_mode & BT_HCI_LE_ADV_PROP_SCAN)) {
   11264:	78a3      	ldrb	r3, [r4, #2]
		if ((pdu->type != PDU_ADV_TYPE_EXT_IND) ||
   11266:	09db      	lsrs	r3, r3, #7
   11268:	d0df      	beq.n	1122a <adv_scan_pdu_addr_update+0x36>
			ull_adv_pdu_update_addrs(adv, pdu_scan);
   1126a:	4639      	mov	r1, r7
   1126c:	4628      	mov	r0, r5
   1126e:	f7ff ff7c 	bl	1116a <ull_adv_pdu_update_addrs>
   11272:	e7da      	b.n	1122a <adv_scan_pdu_addr_update+0x36>
				return BT_HCI_ERR_CMD_DISALLOWED;
   11274:	200c      	movs	r0, #12
   11276:	e7d9      	b.n	1122c <adv_scan_pdu_addr_update+0x38>
			return BT_HCI_ERR_INVALID_PARAM;
   11278:	2012      	movs	r0, #18
   1127a:	e7d7      	b.n	1122c <adv_scan_pdu_addr_update+0x38>
   1127c:	4626      	mov	r6, r4
   1127e:	e7e1      	b.n	11244 <adv_scan_pdu_addr_update+0x50>

00011280 <ull_adv_data_set>:
	if (len > PDU_AC_DATA_SIZE_MAX) {
   11280:	291f      	cmp	r1, #31
{
   11282:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   11286:	4604      	mov	r4, r0
   11288:	460d      	mov	r5, r1
   1128a:	4617      	mov	r7, r2
	if (len > PDU_AC_DATA_SIZE_MAX) {
   1128c:	d852      	bhi.n	11334 <ull_adv_data_set+0xb4>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   1128e:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
   11292:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   11296:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
   1129a:	f898 3000 	ldrb.w	r3, [r8]
   1129e:	f003 030f 	and.w	r3, r3, #15
   112a2:	2b01      	cmp	r3, #1
   112a4:	d001      	beq.n	112aa <ull_adv_data_set+0x2a>
   112a6:	2b07      	cmp	r3, #7
   112a8:	d10b      	bne.n	112c2 <ull_adv_data_set+0x42>
		adv->ad_data_backup.len = len;
   112aa:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
		memcpy(adv->ad_data_backup.data, data, adv->ad_data_backup.len);
   112ae:	462a      	mov	r2, r5
   112b0:	4639      	mov	r1, r7
   112b2:	f104 0045 	add.w	r0, r4, #69	; 0x45
   112b6:	f7fe fc76 	bl	fba6 <memcpy>
	return 0;
   112ba:	2000      	movs	r0, #0
}
   112bc:	b002      	add	sp, #8
   112be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
   112c2:	f10d 0107 	add.w	r1, sp, #7
   112c6:	3024      	adds	r0, #36	; 0x24
   112c8:	f000 fada 	bl	11880 <lll_adv_pdu_alloc>
		pdu->chan_sel = prev->chan_sel;
   112cc:	4641      	mov	r1, r8
   112ce:	4606      	mov	r6, r0
   112d0:	f811 2b02 	ldrb.w	r2, [r1], #2
   112d4:	f3c2 1040 	ubfx	r0, r2, #5, #1
	pdu->type = prev->type;
   112d8:	f3c2 0303 	ubfx	r3, r2, #0, #4
   112dc:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
	pdu->tx_addr = prev->tx_addr;
   112e0:	f3c2 1080 	ubfx	r0, r2, #6, #1
	pdu->type = prev->type;
   112e4:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
   112e8:	f002 0280 	and.w	r2, r2, #128	; 0x80
   112ec:	4630      	mov	r0, r6
   112ee:	4313      	orrs	r3, r2
   112f0:	f800 3b02 	strb.w	r3, [r0], #2
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
   112f4:	2206      	movs	r2, #6
   112f6:	f7fe fc56 	bl	fba6 <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
   112fa:	462a      	mov	r2, r5
   112fc:	4639      	mov	r1, r7
   112fe:	f106 0008 	add.w	r0, r6, #8
	pdu->len = BDADDR_SIZE + len;
   11302:	3506      	adds	r5, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
   11304:	f7fe fc4f 	bl	fba6 <memcpy>
	pdu->len = BDADDR_SIZE + len;
   11308:	7075      	strb	r5, [r6, #1]
	if (adv->is_enabled) {
   1130a:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   1130e:	07db      	lsls	r3, r3, #31
   11310:	d404      	bmi.n	1131c <ull_adv_data_set+0x9c>
	pdu->last = idx;
   11312:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11316:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
   1131a:	e7ce      	b.n	112ba <ull_adv_data_set+0x3a>
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   1131c:	f894 3031 	ldrb.w	r3, [r4, #49]	; 0x31
   11320:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		err = ull_adv_time_update(adv, pdu, pdu_scan);
   11324:	4631      	mov	r1, r6
   11326:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   11328:	4620      	mov	r0, r4
   1132a:	f7ef fac9 	bl	8c0 <ull_adv_time_update>
		if (err) {
   1132e:	2800      	cmp	r0, #0
   11330:	d0ef      	beq.n	11312 <ull_adv_data_set+0x92>
   11332:	e7c3      	b.n	112bc <ull_adv_data_set+0x3c>
		return BT_HCI_ERR_INVALID_PARAM;
   11334:	2012      	movs	r0, #18
   11336:	e7c1      	b.n	112bc <ull_adv_data_set+0x3c>

00011338 <ull_scan_rsp_set>:
	if (len > PDU_AC_DATA_SIZE_MAX) {
   11338:	291f      	cmp	r1, #31
{
   1133a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1133e:	4604      	mov	r4, r0
   11340:	460e      	mov	r6, r1
   11342:	4617      	mov	r7, r2
	if (len > PDU_AC_DATA_SIZE_MAX) {
   11344:	d83e      	bhi.n	113c4 <ull_scan_rsp_set+0x8c>
   11346:	f890 3031 	ldrb.w	r3, [r0, #49]	; 0x31
   1134a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	return lll_adv_pdu_alloc(&lll->scan_rsp, idx);
   1134e:	f10d 0107 	add.w	r1, sp, #7
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   11352:	f8d3 8034 	ldr.w	r8, [r3, #52]	; 0x34
	return lll_adv_pdu_alloc(&lll->scan_rsp, idx);
   11356:	3030      	adds	r0, #48	; 0x30
   11358:	f000 fa92 	bl	11880 <lll_adv_pdu_alloc>
	pdu->tx_addr = prev->tx_addr;
   1135c:	4641      	mov	r1, r8
   1135e:	4605      	mov	r5, r0
   11360:	f811 3b02 	ldrb.w	r3, [r1], #2
   11364:	f3c3 1380 	ubfx	r3, r3, #6, #1
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   11368:	019b      	lsls	r3, r3, #6
   1136a:	f043 0304 	orr.w	r3, r3, #4
   1136e:	7003      	strb	r3, [r0, #0]
	pdu->len = BDADDR_SIZE + len;
   11370:	1db3      	adds	r3, r6, #6
   11372:	7043      	strb	r3, [r0, #1]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
   11374:	2206      	movs	r2, #6
   11376:	3002      	adds	r0, #2
   11378:	f7fe fc15 	bl	fba6 <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
   1137c:	4632      	mov	r2, r6
   1137e:	4639      	mov	r1, r7
   11380:	f105 0008 	add.w	r0, r5, #8
   11384:	f7fe fc0f 	bl	fba6 <memcpy>
	if (adv->is_enabled) {
   11388:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   1138c:	07db      	lsls	r3, r3, #31
   1138e:	d407      	bmi.n	113a0 <ull_scan_rsp_set+0x68>
	pdu->last = idx;
   11390:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11394:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
	return 0;
   11398:	2000      	movs	r0, #0
}
   1139a:	b002      	add	sp, #8
   1139c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   113a0:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
   113a4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   113a8:	6a99      	ldr	r1, [r3, #40]	; 0x28
		if ((pdu_adv_scan->type == PDU_ADV_TYPE_ADV_IND) ||
   113aa:	780b      	ldrb	r3, [r1, #0]
   113ac:	f013 030f 	ands.w	r3, r3, #15
   113b0:	d001      	beq.n	113b6 <ull_scan_rsp_set+0x7e>
   113b2:	2b06      	cmp	r3, #6
   113b4:	d1ec      	bne.n	11390 <ull_scan_rsp_set+0x58>
			err = ull_adv_time_update(adv, pdu_adv_scan, pdu);
   113b6:	462a      	mov	r2, r5
   113b8:	4620      	mov	r0, r4
   113ba:	f7ef fa81 	bl	8c0 <ull_adv_time_update>
			if (err) {
   113be:	2800      	cmp	r0, #0
   113c0:	d0e6      	beq.n	11390 <ull_scan_rsp_set+0x58>
   113c2:	e7ea      	b.n	1139a <ull_scan_rsp_set+0x62>
		return BT_HCI_ERR_INVALID_PARAM;
   113c4:	2012      	movs	r0, #18
   113c6:	e7e8      	b.n	1139a <ull_scan_rsp_set+0x62>

000113c8 <aux_time_get>:
{
   113c8:	b570      	push	{r4, r5, r6, lr}
	time_us = PDU_AC_US(pdu->len, lll->phy_s, lll->phy_flags) +
   113ca:	6a03      	ldr	r3, [r0, #32]
   113cc:	7958      	ldrb	r0, [r3, #5]
	if ((pdu->adv_ext_ind.adv_mode & BT_HCI_LE_ADV_PROP_CONN) ==
   113ce:	788b      	ldrb	r3, [r1, #2]
   113d0:	f3c0 04c1 	ubfx	r4, r0, #3, #2
	time_us = PDU_AC_US(pdu->len, lll->phy_s, lll->phy_flags) +
   113d4:	f3c0 1600 	ubfx	r6, r0, #4, #1
   113d8:	7848      	ldrb	r0, [r1, #1]
   113da:	3009      	adds	r0, #9
   113dc:	4420      	add	r0, r4
   113de:	00c0      	lsls	r0, r0, #3
   113e0:	fa20 f506 	lsr.w	r5, r0, r6
	if ((pdu->adv_ext_ind.adv_mode & BT_HCI_LE_ADV_PROP_CONN) ==
   113e4:	0658      	lsls	r0, r3, #25
   113e6:	ea4f 1193 	mov.w	r1, r3, lsr #6
   113ea:	d50c      	bpl.n	11406 <aux_time_get+0x3e>
			PDU_AC_MAX_US((INITA_SIZE + ADVA_SIZE + LLDATA_SIZE),
   113ec:	f104 032b 	add.w	r3, r4, #43	; 0x2b
   113f0:	00db      	lsls	r3, r3, #3
   113f2:	40f3      	lsrs	r3, r6
			PDU_AC_US((PDU_AC_EXT_HEADER_SIZE_MIN + ADVA_SIZE +
   113f4:	f104 0016 	add.w	r0, r4, #22
			PDU_AC_MAX_US((SCANA_SIZE + ADVA_SIZE), lll->phy_s);
   113f8:	00c0      	lsls	r0, r0, #3
   113fa:	40f0      	lsrs	r0, r6
		time_us += EVENT_IFS_MAX_US * 2 + scan_req_us + scan_rsp_us;
   113fc:	4403      	add	r3, r0
   113fe:	f505 7030 	add.w	r0, r5, #704	; 0x2c0
   11402:	4418      	add	r0, r3
	return time_us;
   11404:	e003      	b.n	1140e <aux_time_get+0x46>
	} else if ((pdu->adv_ext_ind.adv_mode & BT_HCI_LE_ADV_PROP_SCAN) ==
   11406:	078b      	lsls	r3, r1, #30
   11408:	d402      	bmi.n	11410 <aux_time_get+0x48>
	time_us = PDU_AC_US(pdu->len, lll->phy_s, lll->phy_flags) +
   1140a:	f505 70c8 	add.w	r0, r5, #400	; 0x190
}
   1140e:	bd70      	pop	{r4, r5, r6, pc}
			PDU_AC_US(pdu_scan->len, lll->phy_s, lll->phy_flags);
   11410:	7853      	ldrb	r3, [r2, #1]
   11412:	3309      	adds	r3, #9
   11414:	4423      	add	r3, r4
   11416:	00db      	lsls	r3, r3, #3
   11418:	40f3      	lsrs	r3, r6
			PDU_AC_MAX_US((SCANA_SIZE + ADVA_SIZE), lll->phy_s);
   1141a:	f104 0015 	add.w	r0, r4, #21
   1141e:	e7eb      	b.n	113f8 <aux_time_get+0x30>

00011420 <ticker_op_cb>:

static void ticker_op_cb(uint32_t status, void *param)
{
	*((uint32_t volatile *)param) = status;
   11420:	6008      	str	r0, [r1, #0]
}
   11422:	4770      	bx	lr

00011424 <ll_adv_aux_random_addr_set>:
{
   11424:	b510      	push	{r4, lr}
   11426:	460c      	mov	r4, r1
	adv = ull_adv_is_created_get(handle);
   11428:	f7f6 f900 	bl	762c <ull_adv_is_created_get>
	if (!adv) {
   1142c:	b130      	cbz	r0, 1143c <ll_adv_aux_random_addr_set+0x18>
	(void)memcpy(adv->rnd_addr, addr, BDADDR_SIZE);
   1142e:	2206      	movs	r2, #6
   11430:	4621      	mov	r1, r4
   11432:	3068      	adds	r0, #104	; 0x68
   11434:	f7fe fbb7 	bl	fba6 <memcpy>
	return 0;
   11438:	2000      	movs	r0, #0
}
   1143a:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_UNKNOWN_ADV_IDENTIFIER;
   1143c:	2042      	movs	r0, #66	; 0x42
   1143e:	e7fc      	b.n	1143a <ll_adv_aux_random_addr_set+0x16>

00011440 <ll_adv_aux_max_data_length_get>:
}
   11440:	201f      	movs	r0, #31
   11442:	4770      	bx	lr

00011444 <ll_adv_aux_set_count_get>:
}
   11444:	2001      	movs	r0, #1
   11446:	4770      	bx	lr

00011448 <ull_adv_aux_ptr_fill>:
	aux_ptr->chan_idx = 0U;
   11448:	7803      	ldrb	r3, [r0, #0]
   1144a:	f36f 0305 	bfc	r3, #0, #6
{
   1144e:	b570      	push	{r4, r5, r6, lr}
	aux_ptr->chan_idx = 0U;
   11450:	7003      	strb	r3, [r0, #0]
{
   11452:	4604      	mov	r4, r0
   11454:	460e      	mov	r6, r1
   11456:	4615      	mov	r5, r2
	aux_ptr->ca = (lll_clock_ppm_local_get() <= SCA_50_PPM) ?
   11458:	f000 f9ea 	bl	11830 <lll_clock_ppm_local_get>
   1145c:	7822      	ldrb	r2, [r4, #0]
   1145e:	78a3      	ldrb	r3, [r4, #2]
		      SCA_VALUE_50_PPM : SCA_VALUE_500_PPM;
   11460:	2832      	cmp	r0, #50	; 0x32
   11462:	bf8c      	ite	hi
   11464:	2000      	movhi	r0, #0
   11466:	2001      	movls	r0, #1
	aux_ptr->ca = (lll_clock_ppm_local_get() <= SCA_50_PPM) ?
   11468:	f360 1286 	bfi	r2, r0, #6, #1
	offs = offs_us / OFFS_UNIT_30_US;
   1146c:	201e      	movs	r0, #30
   1146e:	fbb6 f0f0 	udiv	r0, r6, r0
	if (!!(offs >> OFFS_UNIT_BITS)) {
   11472:	0b41      	lsrs	r1, r0, #13
	aux_ptr->ca = (lll_clock_ppm_local_get() <= SCA_50_PPM) ?
   11474:	7022      	strb	r2, [r4, #0]
	if (!!(offs >> OFFS_UNIT_BITS)) {
   11476:	b2d2      	uxtb	r2, r2
   11478:	d01a      	beq.n	114b0 <ull_adv_aux_ptr_fill+0x68>
		aux_ptr->offs = offs / (OFFS_UNIT_300_US / OFFS_UNIT_30_US);
   1147a:	f44f 7196 	mov.w	r1, #300	; 0x12c
   1147e:	f023 031f 	bic.w	r3, r3, #31
   11482:	fbb6 f1f1 	udiv	r1, r6, r1
   11486:	7061      	strb	r1, [r4, #1]
   11488:	f3c1 2104 	ubfx	r1, r1, #8, #5
   1148c:	430b      	orrs	r3, r1
		aux_ptr->offs_units = OFFS_UNIT_VALUE_300_US;
   1148e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
		aux_ptr->offs = offs / (OFFS_UNIT_300_US / OFFS_UNIT_30_US);
   11492:	70a3      	strb	r3, [r4, #2]
		aux_ptr->offs_units = OFFS_UNIT_VALUE_300_US;
   11494:	7022      	strb	r2, [r4, #0]
	aux_ptr->phy = find_lsb_set(phy_s) - 1;
   11496:	78a2      	ldrb	r2, [r4, #2]
   11498:	fa95 f3a5 	rbit	r3, r5
   1149c:	2d00      	cmp	r5, #0
   1149e:	fab3 f383 	clz	r3, r3
   114a2:	bf08      	it	eq
   114a4:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   114a8:	f363 1247 	bfi	r2, r3, #5, #3
   114ac:	70a2      	strb	r2, [r4, #2]
}
   114ae:	bd70      	pop	{r4, r5, r6, pc}
		aux_ptr->offs = offs;
   114b0:	7060      	strb	r0, [r4, #1]
   114b2:	f023 031f 	bic.w	r3, r3, #31
   114b6:	f3c0 2004 	ubfx	r0, r0, #8, #5
   114ba:	4303      	orrs	r3, r0
   114bc:	70a3      	strb	r3, [r4, #2]
		aux_ptr->offs_units = OFFS_UNIT_VALUE_30_US;
   114be:	4613      	mov	r3, r2
   114c0:	f361 13c7 	bfi	r3, r1, #7, #1
   114c4:	7023      	strb	r3, [r4, #0]
   114c6:	e7e6      	b.n	11496 <ull_adv_aux_ptr_fill+0x4e>

000114c8 <ull_adv_aux_lll_handle_get>:
	return ull_adv_aux_handle_get((void *)lll->hdr.parent);
   114c8:	6800      	ldr	r0, [r0, #0]
   114ca:	f7f6 b931 	b.w	7730 <ull_adv_aux_handle_get>

000114ce <ll_adv_aux_ad_data_set>:
{
   114ce:	b5f0      	push	{r4, r5, r6, r7, lr}
	if ((op != BT_HCI_LE_EXT_ADV_OP_COMPLETE_DATA) &&
   114d0:	3903      	subs	r1, #3
   114d2:	2901      	cmp	r1, #1
{
   114d4:	b087      	sub	sp, #28
   114d6:	461d      	mov	r5, r3
	if ((op != BT_HCI_LE_EXT_ADV_OP_COMPLETE_DATA) &&
   114d8:	d850      	bhi.n	1157c <ll_adv_aux_ad_data_set+0xae>
	adv = ull_adv_is_created_get(handle);
   114da:	f7f6 f8a7 	bl	762c <ull_adv_is_created_get>
	if (!adv) {
   114de:	4604      	mov	r4, r0
   114e0:	2800      	cmp	r0, #0
   114e2:	d04d      	beq.n	11580 <ll_adv_aux_ad_data_set+0xb2>
	(void)memcpy(val_ptr, &data, sizeof(data));
   114e4:	2204      	movs	r2, #4
   114e6:	a90c      	add	r1, sp, #48	; 0x30
   114e8:	f10d 0011 	add.w	r0, sp, #17
	*val_ptr++ = len;
   114ec:	f88d 5010 	strb.w	r5, [sp, #16]
	(void)memcpy(val_ptr, &data, sizeof(data));
   114f0:	f7fe fb59 	bl	fba6 <memcpy>
	err = ull_adv_aux_hdr_set_clear(adv, ULL_ADV_PDU_HDR_FIELD_AD_DATA,
   114f4:	f10d 030e 	add.w	r3, sp, #14
   114f8:	2200      	movs	r2, #0
   114fa:	9301      	str	r3, [sp, #4]
   114fc:	9200      	str	r2, [sp, #0]
   114fe:	ab04      	add	r3, sp, #16
   11500:	f44f 7100 	mov.w	r1, #512	; 0x200
   11504:	4620      	mov	r0, r4
   11506:	f7ef fa9f 	bl	a48 <ull_adv_aux_hdr_set_clear>
	if (err) {
   1150a:	4605      	mov	r5, r0
   1150c:	bb60      	cbnz	r0, 11568 <ll_adv_aux_ad_data_set+0x9a>
	if (!adv->lll.aux) {
   1150e:	6c23      	ldr	r3, [r4, #64]	; 0x40
   11510:	b353      	cbz	r3, 11568 <ll_adv_aux_ad_data_set+0x9a>
	if (adv->is_enabled) {
   11512:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
   11516:	07d2      	lsls	r2, r2, #31
   11518:	d52b      	bpl.n	11572 <ll_adv_aux_ad_data_set+0xa4>
		aux = HDR_LLL2ULL(adv->lll.aux);
   1151a:	681e      	ldr	r6, [r3, #0]
		if (!aux->is_started) {
   1151c:	f896 304a 	ldrb.w	r3, [r6, #74]	; 0x4a
   11520:	07db      	lsls	r3, r3, #31
   11522:	d414      	bmi.n	1154e <ll_adv_aux_ad_data_set+0x80>
			aux->interval =	adv->interval +
   11524:	6e63      	ldr	r3, [r4, #100]	; 0x64
   11526:	330f      	adds	r3, #15
   11528:	8733      	strh	r3, [r6, #56]	; 0x38
			ticks_anchor = ticker_ticks_now_get();
   1152a:	f7ff fb91 	bl	10c50 <ticker_ticks_now_get>
   1152e:	4607      	mov	r7, r0
			ticks_slot_overhead = ull_adv_aux_evt_init(aux);
   11530:	4630      	mov	r0, r6
   11532:	f7ef fa1d 	bl	970 <ull_adv_aux_evt_init>
			ret = ull_adv_aux_start(aux, ticks_anchor,
   11536:	4639      	mov	r1, r7
			ticks_slot_overhead = ull_adv_aux_evt_init(aux);
   11538:	4602      	mov	r2, r0
			ret = ull_adv_aux_start(aux, ticks_anchor,
   1153a:	4630      	mov	r0, r6
   1153c:	f7ef fa40 	bl	9c0 <ull_adv_aux_start>
			if (ret) {
   11540:	b9a8      	cbnz	r0, 1156e <ll_adv_aux_ad_data_set+0xa0>
			aux->is_started = 1;
   11542:	f896 304a 	ldrb.w	r3, [r6, #74]	; 0x4a
   11546:	f043 0301 	orr.w	r3, r3, #1
   1154a:	f886 304a 	strb.w	r3, [r6, #74]	; 0x4a
	return lll_adv_pdu_alloc(&lll->adv_data, idx);
   1154e:	f10d 010f 	add.w	r1, sp, #15
   11552:	f104 0024 	add.w	r0, r4, #36	; 0x24
   11556:	f000 f993 	bl	11880 <lll_adv_pdu_alloc>
		err = ull_adv_time_update(adv, pdu, NULL);
   1155a:	2200      	movs	r2, #0
   1155c:	4601      	mov	r1, r0
   1155e:	4620      	mov	r0, r4
   11560:	f7ef f9ae 	bl	8c0 <ull_adv_time_update>
		if (err) {
   11564:	b128      	cbz	r0, 11572 <ll_adv_aux_ad_data_set+0xa4>
				return BT_HCI_ERR_INSUFFICIENT_RESOURCES;
   11566:	4605      	mov	r5, r0
}
   11568:	4628      	mov	r0, r5
   1156a:	b007      	add	sp, #28
   1156c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				return BT_HCI_ERR_INSUFFICIENT_RESOURCES;
   1156e:	200d      	movs	r0, #13
   11570:	e7f9      	b.n	11566 <ll_adv_aux_ad_data_set+0x98>
	pdu->last = idx;
   11572:	f89d 300e 	ldrb.w	r3, [sp, #14]
   11576:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
	return 0;
   1157a:	e7f5      	b.n	11568 <ll_adv_aux_ad_data_set+0x9a>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1157c:	250c      	movs	r5, #12
   1157e:	e7f3      	b.n	11568 <ll_adv_aux_ad_data_set+0x9a>
		return BT_HCI_ERR_UNKNOWN_ADV_IDENTIFIER;
   11580:	2542      	movs	r5, #66	; 0x42
   11582:	e7f1      	b.n	11568 <ll_adv_aux_ad_data_set+0x9a>

00011584 <ll_adv_aux_set_remove>:
{
   11584:	b538      	push	{r3, r4, r5, lr}
	adv = ull_adv_is_created_get(handle);
   11586:	f7f6 f851 	bl	762c <ull_adv_is_created_get>
	if (!adv) {
   1158a:	4604      	mov	r4, r0
   1158c:	b1d0      	cbz	r0, 115c4 <ll_adv_aux_set_remove+0x40>
	if (adv->is_enabled) {
   1158e:	f890 5078 	ldrb.w	r5, [r0, #120]	; 0x78
   11592:	f015 0501 	ands.w	r5, r5, #1
   11596:	d117      	bne.n	115c8 <ll_adv_aux_set_remove+0x44>
	if (lll->aux) {
   11598:	6c03      	ldr	r3, [r0, #64]	; 0x40
   1159a:	b11b      	cbz	r3, 115a4 <ll_adv_aux_set_remove+0x20>
		aux = HDR_LLL2ULL(lll->aux);
   1159c:	6818      	ldr	r0, [r3, #0]
		lll->aux = NULL;
   1159e:	6425      	str	r5, [r4, #64]	; 0x40
		ull_adv_aux_release(aux);
   115a0:	f7f6 f9e6 	bl	7970 <ull_adv_aux_release>
	(void)lll_adv_data_dequeue(&adv->lll.adv_data);
   115a4:	f104 0024 	add.w	r0, r4, #36	; 0x24
   115a8:	f7f8 fb3a 	bl	9c20 <lll_adv_data_dequeue>
	(void)lll_adv_data_dequeue(&adv->lll.scan_rsp);
   115ac:	f104 0030 	add.w	r0, r4, #48	; 0x30
   115b0:	f7f8 fb36 	bl	9c20 <lll_adv_data_dequeue>
	adv->is_created = 0;
   115b4:	f894 306e 	ldrb.w	r3, [r4, #110]	; 0x6e
   115b8:	f36f 1304 	bfc	r3, #4, #1
   115bc:	f884 306e 	strb.w	r3, [r4, #110]	; 0x6e
}
   115c0:	4628      	mov	r0, r5
   115c2:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_ADV_IDENTIFIER;
   115c4:	2542      	movs	r5, #66	; 0x42
   115c6:	e7fb      	b.n	115c0 <ll_adv_aux_set_remove+0x3c>
		return BT_HCI_ERR_CMD_DISALLOWED;
   115c8:	250c      	movs	r5, #12
   115ca:	e7f9      	b.n	115c0 <ll_adv_aux_set_remove+0x3c>

000115cc <ll_adv_aux_set_clear>:
{
   115cc:	b508      	push	{r3, lr}
		err = ll_adv_aux_set_remove(handle);
   115ce:	2000      	movs	r0, #0
   115d0:	f7ff ffd8 	bl	11584 <ll_adv_aux_set_remove>
	uint8_t retval = BT_HCI_ERR_SUCCESS;
   115d4:	280c      	cmp	r0, #12
}
   115d6:	bf18      	it	ne
   115d8:	2000      	movne	r0, #0
   115da:	bd08      	pop	{r3, pc}

000115dc <ull_adv_aux_done>:
	adv = HDR_LLL2ULL(lll_aux->adv);
   115dc:	69c2      	ldr	r2, [r0, #28]
   115de:	6a12      	ldr	r2, [r2, #32]
	done->param = &adv->ull;
   115e0:	6812      	ldr	r2, [r2, #0]
   115e2:	61c2      	str	r2, [r0, #28]
	ull_adv_done(done);
   115e4:	f7ee bfa8 	b.w	538 <ull_adv_done>

000115e8 <ext_disabled_cb>:

static void ext_disabled_cb(void *param)
{
   115e8:	b508      	push	{r3, lr}
	/* Under race condition, if a connection has been established then
	 * node_rx is already utilized to send terminate event on connection
	 */
	lll = (void *)param;
	scan = HDR_LLL2ULL(lll);
	rx_hdr = (void *)scan->node_rx_scan_term;
   115ea:	6803      	ldr	r3, [r0, #0]
   115ec:	6c19      	ldr	r1, [r3, #64]	; 0x40
	if (!rx_hdr) {
   115ee:	b131      	cbz	r1, 115fe <ext_disabled_cb+0x16>
	}

	/* NOTE: parameters are already populated on disable,
	 * just enqueue here
	 */
	ll_rx_put(rx_hdr->link, rx_hdr);
   115f0:	6808      	ldr	r0, [r1, #0]
   115f2:	f7f4 ff33 	bl	645c <ll_rx_put>
	ll_rx_sched();
}
   115f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	ll_rx_sched();
   115fa:	f7f4 bf35 	b.w	6468 <ll_rx_sched>
}
   115fe:	bd08      	pop	{r3, pc}

00011600 <ull_scan_init>:
		err = ull_scan_aux_init();
   11600:	f7f6 bdb0 	b.w	8164 <ull_scan_aux_init>

00011604 <disable.constprop.0>:
#endif /* CONFIG_BT_CTLR_ADV_EXT */

static uint8_t disable(uint8_t handle)
   11604:	b570      	push	{r4, r5, r6, lr}
{
	struct ll_scan_set *scan;
	uint8_t ret;

	scan = ull_scan_is_enabled_get(handle);
   11606:	2000      	movs	r0, #0
   11608:	f7f6 fc68 	bl	7edc <ull_scan_is_enabled_get>
	if (!scan) {
   1160c:	4604      	mov	r4, r0
   1160e:	b1e0      	cbz	r0, 1164a <disable.constprop.0+0x46>
	if (scan->lll.conn) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif

	ret = ull_scan_disable(handle, scan);
   11610:	4601      	mov	r1, r0
   11612:	2000      	movs	r0, #0
   11614:	f7f6 fbb2 	bl	7d7c <ull_scan_disable>
	if (ret) {
   11618:	4605      	mov	r5, r0
   1161a:	b9a0      	cbnz	r0, 11646 <disable.constprop.0+0x42>
		return ret;
	}

	scan->is_enabled = 0U;
   1161c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44

#if defined(CONFIG_BT_CTLR_ADV_EXT)
	if (scan->node_rx_scan_term) {
   11620:	6c26      	ldr	r6, [r4, #64]	; 0x40
	scan->is_enabled = 0U;
   11622:	f360 0300 	bfi	r3, r0, #0, #1
   11626:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	if (scan->node_rx_scan_term) {
   1162a:	b136      	cbz	r6, 1163a <disable.constprop.0+0x36>
		struct node_rx_pdu *node_rx_scan_term =
			(void *)scan->node_rx_scan_term;

		scan->node_rx_scan_term = NULL;
   1162c:	6420      	str	r0, [r4, #64]	; 0x40

		ll_rx_link_release(node_rx_scan_term->hdr.link);
   1162e:	6830      	ldr	r0, [r6, #0]
   11630:	f7f4 ff02 	bl	6438 <ll_rx_link_release>
		ll_rx_release(node_rx_scan_term);
   11634:	4630      	mov	r0, r6
   11636:	f7f4 ff0b 	bl	6450 <ll_rx_release>
	}
#endif /* CONFIG_BT_CTLR_ADV_EXT */

#if defined(CONFIG_BT_CTLR_PRIVACY)
#if defined(CONFIG_BT_BROADCASTER)
	if (!ull_adv_is_enabled_get(0))
   1163a:	2000      	movs	r0, #0
   1163c:	f7f5 ff5a 	bl	74f4 <ull_adv_is_enabled_get>
   11640:	b908      	cbnz	r0, 11646 <disable.constprop.0+0x42>
#endif
	{
		ull_filter_adv_scan_state_cb(0);
   11642:	f7f7 f881 	bl	8748 <ull_filter_adv_scan_state_cb>
	}
#endif

	return 0;
}
   11646:	4628      	mov	r0, r5
   11648:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   1164a:	250c      	movs	r5, #12
   1164c:	e7fb      	b.n	11646 <disable.constprop.0+0x42>

0001164e <ull_scan_reset>:
{
   1164e:	b508      	push	{r3, lr}
		(void)disable(handle);
   11650:	f7ff ffd8 	bl	11604 <disable.constprop.0>
}
   11654:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		err = ull_scan_aux_reset();
   11658:	f000 b81c 	b.w	11694 <ull_scan_aux_reset>

0001165c <ull_scan_is_enabled>:
{
   1165c:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
   1165e:	f7f6 fc3d 	bl	7edc <ull_scan_is_enabled_get>
	if (!scan) {
   11662:	b148      	cbz	r0, 11678 <ull_scan_is_enabled+0x1c>
	return (((uint32_t)scan->is_enabled << scan->lll.type) |
   11664:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
   11668:	f890 0020 	ldrb.w	r0, [r0, #32]
   1166c:	f003 0301 	and.w	r3, r3, #1
   11670:	f3c0 1040 	ubfx	r0, r0, #5, #1
   11674:	fa03 f000 	lsl.w	r0, r3, r0
}
   11678:	bd08      	pop	{r3, pc}

0001167a <ull_scan_filter_pol_get>:
{
   1167a:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
   1167c:	f7f6 fc2e 	bl	7edc <ull_scan_is_enabled_get>
	if (!scan) {
   11680:	b118      	cbz	r0, 1168a <ull_scan_filter_pol_get+0x10>
	return scan->lll.filter_policy;
   11682:	f890 0020 	ldrb.w	r0, [r0, #32]
   11686:	f3c0 00c1 	ubfx	r0, r0, #3, #2
}
   1168a:	bd08      	pop	{r3, pc}

0001168c <last_disabled_cb>:
	flush(param);
   1168c:	f7f6 bd34 	b.w	80f8 <flush>

00011690 <ticker_op_aux_failure>:
   11690:	f7f6 bd32 	b.w	80f8 <flush>

00011694 <ull_scan_aux_reset>:
   11694:	f7f6 bd66 	b.w	8164 <ull_scan_aux_init>

00011698 <ull_scan_aux_lll_parent_get>:
{
   11698:	b538      	push	{r3, r4, r5, lr}
	aux_set = HDR_LLL2ULL(lll);
   1169a:	6805      	ldr	r5, [r0, #0]
	if (is_lll_scan) {
   1169c:	460c      	mov	r4, r1
   1169e:	b139      	cbz	r1, 116b0 <ull_scan_aux_lll_parent_get+0x18>
	scan_set = HDR_LLL2ULL(aux_set->parent);
   116a0:	6aab      	ldr	r3, [r5, #40]	; 0x28
		*is_lll_scan = !!ull_scan_is_valid_get(scan_set);
   116a2:	6818      	ldr	r0, [r3, #0]
   116a4:	f7f6 fc12 	bl	7ecc <ull_scan_is_valid_get>
   116a8:	3800      	subs	r0, #0
   116aa:	bf18      	it	ne
   116ac:	2001      	movne	r0, #1
   116ae:	7020      	strb	r0, [r4, #0]
}
   116b0:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   116b2:	bd38      	pop	{r3, r4, r5, pc}

000116b4 <rl_access_check.constprop.0>:
static int rl_access_check(bool check_ar)
   116b4:	b508      	push	{r3, lr}
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   116b6:	2000      	movs	r0, #0
   116b8:	f7ff fd48 	bl	1114c <ull_adv_is_enabled>
		? 0 : 1;
   116bc:	b938      	cbnz	r0, 116ce <rl_access_check.constprop.0+0x1a>
		 (ull_scan_is_enabled(0) & ~ULL_SCAN_IS_PASSIVE)))
   116be:	f7ff ffcd 	bl	1165c <ull_scan_is_enabled>
		? 0 : 1;
   116c2:	f030 0301 	bics.w	r3, r0, #1
   116c6:	bf0c      	ite	eq
   116c8:	2001      	moveq	r0, #1
   116ca:	2000      	movne	r0, #0
}
   116cc:	bd08      	pop	{r3, pc}
		? 0 : 1;
   116ce:	2000      	movs	r0, #0
   116d0:	e7fc      	b.n	116cc <rl_access_check.constprop.0+0x18>

000116d2 <ll_fal_size_get>:
}
   116d2:	2008      	movs	r0, #8
   116d4:	4770      	bx	lr

000116d6 <ll_fal_clear>:
{
   116d6:	b510      	push	{r4, lr}
	if (ull_adv_filter_pol_get(0)) {
   116d8:	2000      	movs	r0, #0
   116da:	f7ff fd3e 	bl	1115a <ull_adv_filter_pol_get>
   116de:	b108      	cbz	r0, 116e4 <ll_fal_clear+0xe>
		return BT_HCI_ERR_CMD_DISALLOWED;
   116e0:	200c      	movs	r0, #12
}
   116e2:	bd10      	pop	{r4, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
   116e4:	f7ff ffc9 	bl	1167a <ull_scan_filter_pol_get>
   116e8:	f010 0401 	ands.w	r4, r0, #1
   116ec:	d1f8      	bne.n	116e0 <ll_fal_clear+0xa>
	fal_clear();
   116ee:	f7f6 fe67 	bl	83c0 <fal_clear>
	return 0;
   116f2:	4620      	mov	r0, r4
   116f4:	e7f5      	b.n	116e2 <ll_fal_clear+0xc>

000116f6 <ll_rl_size_get>:
   116f6:	2008      	movs	r0, #8
   116f8:	4770      	bx	lr

000116fa <ll_rl_clear>:
{
   116fa:	b508      	push	{r3, lr}
	if (!rl_access_check(false)) {
   116fc:	f7ff ffda 	bl	116b4 <rl_access_check.constprop.0>
   11700:	b118      	cbz	r0, 1170a <ll_rl_clear+0x10>
	rl_clear();
   11702:	f7f6 fe7b 	bl	83fc <rl_clear>
	return 0;
   11706:	2000      	movs	r0, #0
}
   11708:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   1170a:	200c      	movs	r0, #12
   1170c:	e7fc      	b.n	11708 <ll_rl_clear+0xe>

0001170e <ull_filter_lll_fal_match>:
{
   1170e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11712:	461f      	mov	r7, r3
	if (!filter->enable_bitmask) {
   11714:	7803      	ldrb	r3, [r0, #0]
{
   11716:	4605      	mov	r5, r0
   11718:	4689      	mov	r9, r1
   1171a:	4692      	mov	sl, r2
	if (!filter->enable_bitmask) {
   1171c:	b123      	cbz	r3, 11728 <ull_filter_lll_fal_match+0x1a>
   1171e:	f100 082c 	add.w	r8, r0, #44	; 0x2c
	index = FAL_SIZE;
   11722:	2408      	movs	r4, #8
	while (index--) {
   11724:	3c01      	subs	r4, #1
   11726:	d207      	bcs.n	11738 <ull_filter_lll_fal_match+0x2a>
		return FILTER_IDX_NONE;
   11728:	26ff      	movs	r6, #255	; 0xff
	*devmatch_id = filter_find(filter, addr_type, addr);
   1172a:	b2f0      	uxtb	r0, r6
   1172c:	7038      	strb	r0, [r7, #0]
}
   1172e:	38ff      	subs	r0, #255	; 0xff
   11730:	bf18      	it	ne
   11732:	2001      	movne	r0, #1
   11734:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if ((filter->enable_bitmask & BIT(index)) &&
   11738:	782b      	ldrb	r3, [r5, #0]
   1173a:	40e3      	lsrs	r3, r4
   1173c:	07da      	lsls	r2, r3, #31
   1173e:	d402      	bmi.n	11746 <ull_filter_lll_fal_match+0x38>
   11740:	f1a8 0806 	sub.w	r8, r8, #6
   11744:	e7ee      	b.n	11724 <ull_filter_lll_fal_match+0x16>
		    (((filter->addr_type_bitmask >> index) & 0x01) ==
   11746:	7868      	ldrb	r0, [r5, #1]
   11748:	4120      	asrs	r0, r4
   1174a:	ea80 0009 	eor.w	r0, r0, r9
		if ((filter->enable_bitmask & BIT(index)) &&
   1174e:	07c3      	lsls	r3, r0, #31
   11750:	d4f6      	bmi.n	11740 <ull_filter_lll_fal_match+0x32>
		    !memcmp(filter->bdaddr[index], bdaddr, BDADDR_SIZE)) {
   11752:	2206      	movs	r2, #6
   11754:	4651      	mov	r1, sl
   11756:	4640      	mov	r0, r8
   11758:	4626      	mov	r6, r4
   1175a:	f7fe f9fb 	bl	fb54 <memcmp>
		     (addr_type & 0x01)) &&
   1175e:	2800      	cmp	r0, #0
   11760:	d1ee      	bne.n	11740 <ull_filter_lll_fal_match+0x32>
   11762:	e7e2      	b.n	1172a <ull_filter_lll_fal_match+0x1c>

00011764 <swi_lll_nrf5_isr>:
	mayfly_run(TICKER_USER_ID_LLL);
   11764:	2000      	movs	r0, #0
   11766:	f7f2 bc79 	b.w	405c <mayfly_run>

0001176a <isr_race>:
	radio_status_reset();
   1176a:	f7fa bc01 	b.w	bf70 <radio_status_reset>

0001176e <radio_nrf5_isr>:
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   1176e:	4668      	mov	r0, sp
   11770:	f020 0107 	bic.w	r1, r0, #7
   11774:	468d      	mov	sp, r1
   11776:	b501      	push	{r0, lr}
	isr_radio();
   11778:	f7fa fb10 	bl	bd9c <isr_radio>
	ISR_DIRECT_PM();
   1177c:	f7f0 feee 	bl	255c <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
   11780:	f7f0 ffde 	bl	2740 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   11784:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   11788:	4685      	mov	sp, r0
   1178a:	4770      	bx	lr

0001178c <lll_rand_get>:
   1178c:	f7f7 bf3e 	b.w	960c <lll_csrand_get>

00011790 <lll_rand_isr_get>:
   11790:	f7f7 bf4a 	b.w	9628 <lll_csrand_isr_get>

00011794 <lll_reset>:
}
   11794:	2000      	movs	r0, #0
   11796:	4770      	bx	lr

00011798 <lll_prepare_done>:
}
   11798:	2000      	movs	r0, #0
   1179a:	4770      	bx	lr

0001179c <lll_is_abort_cb>:
}
   1179c:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   117a0:	4770      	bx	lr

000117a2 <lll_event_offset_get>:
{
   117a2:	4603      	mov	r3, r0
		return MAX(ull->ticks_active_to_start,
   117a4:	e9d0 0201 	ldrd	r0, r2, [r0, #4]
	} else if (ull->ticks_prepare_to_start & XON_BITMASK) {
   117a8:	2a00      	cmp	r2, #0
   117aa:	da04      	bge.n	117b6 <lll_event_offset_get+0x14>
		return MAX(ull->ticks_active_to_start,
   117ac:	68db      	ldr	r3, [r3, #12]
   117ae:	4298      	cmp	r0, r3
   117b0:	bf38      	it	cc
   117b2:	4618      	movcc	r0, r3
   117b4:	4770      	bx	lr
		return MAX(ull->ticks_active_to_start,
   117b6:	4290      	cmp	r0, r2
   117b8:	bf38      	it	cc
   117ba:	4610      	movcc	r0, r2
}
   117bc:	4770      	bx	lr

000117be <lll_preempt_calc>:
{
   117be:	b510      	push	{r4, lr}
   117c0:	4614      	mov	r4, r2
	ticks_now = ticker_ticks_now_get();
   117c2:	f7ff fa45 	bl	10c50 <ticker_ticks_now_get>
	diff = ticks_now - ticks_at_event;
   117c6:	1b00      	subs	r0, r0, r4
	if (diff & BIT(HAL_TICKER_CNTR_MSBIT)) {
   117c8:	0203      	lsls	r3, r0, #8
   117ca:	d405      	bmi.n	117d8 <lll_preempt_calc+0x1a>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
   117cc:	3003      	adds	r0, #3
	if (diff > HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) {
   117ce:	2809      	cmp	r0, #9
   117d0:	bf94      	ite	ls
   117d2:	2000      	movls	r0, #0
   117d4:	2001      	movhi	r0, #1
}
   117d6:	bd10      	pop	{r4, pc}
		return 0;
   117d8:	2000      	movs	r0, #0
   117da:	e7fc      	b.n	117d6 <lll_preempt_calc+0x18>

000117dc <lll_radio_rx_ready_delay_get>:
	return radio_rx_ready_delay_get(phy, flags);
   117dc:	f000 ba7a 	b.w	11cd4 <radio_rx_ready_delay_get>

000117e0 <lll_isr_tx_status_reset>:
{
   117e0:	b508      	push	{r3, lr}
	radio_status_reset();
   117e2:	f7fa fbc5 	bl	bf70 <radio_status_reset>
}
   117e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_status_reset();
   117ea:	f7fa bd11 	b.w	c210 <radio_tmr_status_reset>

000117ee <lll_isr_rx_status_reset>:
{
   117ee:	b508      	push	{r3, lr}
	radio_status_reset();
   117f0:	f7fa fbbe 	bl	bf70 <radio_status_reset>
	radio_tmr_status_reset();
   117f4:	f7fa fd0c 	bl	c210 <radio_tmr_status_reset>
}
   117f8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_rssi_status_reset();
   117fc:	f7fa bcac 	b.w	c158 <radio_rssi_status_reset>

00011800 <lll_isr_status_reset>:
{
   11800:	b508      	push	{r3, lr}
	radio_status_reset();
   11802:	f7fa fbb5 	bl	bf70 <radio_status_reset>
	radio_tmr_status_reset();
   11806:	f7fa fd03 	bl	c210 <radio_tmr_status_reset>
	radio_filter_status_reset();
   1180a:	f7fa fcdd 	bl	c1c8 <radio_filter_status_reset>
	radio_ar_status_reset();
   1180e:	f7fa fe19 	bl	c444 <radio_ar_status_reset>
}
   11812:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_rssi_status_reset();
   11816:	f7fa bc9f 	b.w	c158 <radio_rssi_status_reset>

0001181a <lll_isr_abort>:
{
   1181a:	b510      	push	{r4, lr}
   1181c:	4604      	mov	r4, r0
	lll_isr_status_reset();
   1181e:	f7ff ffef 	bl	11800 <lll_isr_status_reset>
	lll_isr_cleanup(param);
   11822:	4620      	mov	r0, r4
}
   11824:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
   11828:	f7f7 bffe 	b.w	9828 <lll_isr_cleanup>

0001182c <lll_isr_done>:
	lll_isr_abort(param);
   1182c:	f7ff bff5 	b.w	1181a <lll_isr_abort>

00011830 <lll_clock_ppm_local_get>:
}

uint32_t lll_clock_ppm_local_get(void)
{
	return sca_ppm_lut[CLOCK_CONTROL_NRF_K32SRC_ACCURACY];
}
   11830:	2032      	movs	r0, #50	; 0x32
   11832:	4770      	bx	lr

00011834 <is_abort_cb>:
}
   11834:	f06f 008b 	mvn.w	r0, #139	; 0x8b
   11838:	4770      	bx	lr

0001183a <isr_abort>:
{
   1183a:	b510      	push	{r4, lr}
   1183c:	4604      	mov	r4, r0
	lll_isr_status_reset();
   1183e:	f7ff ffdf 	bl	11800 <lll_isr_status_reset>
	radio_filter_disable();
   11842:	f7fa fcb7 	bl	c1b4 <radio_filter_disable>
	lll_isr_cleanup(param);
   11846:	4620      	mov	r0, r4
}
   11848:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_isr_cleanup(param);
   1184c:	f7f7 bfec 	b.w	9828 <lll_isr_cleanup>

00011850 <lll_adv_init>:
{
   11850:	b508      	push	{r3, lr}
	err = lll_adv_aux_init();
   11852:	f000 f886 	bl	11962 <lll_adv_aux_init>
	if (err) {
   11856:	b918      	cbnz	r0, 11860 <lll_adv_init+0x10>
}
   11858:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	err = init_reset();
   1185c:	f7f8 b9b8 	b.w	9bd0 <init_reset>
}
   11860:	bd08      	pop	{r3, pc}

00011862 <lll_adv_reset>:
{
   11862:	b508      	push	{r3, lr}
	err = lll_adv_aux_reset();
   11864:	f000 f87f 	bl	11966 <lll_adv_aux_reset>
	if (err) {
   11868:	b918      	cbnz	r0, 11872 <lll_adv_reset+0x10>
}
   1186a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	err = init_reset();
   1186e:	f7f8 b9af 	b.w	9bd0 <init_reset>
}
   11872:	bd08      	pop	{r3, pc}

00011874 <lll_adv_data_reset>:
{
   11874:	4603      	mov	r3, r0
	pdu->first = 0U;
   11876:	2000      	movs	r0, #0
   11878:	7018      	strb	r0, [r3, #0]
	pdu->last = 0U;
   1187a:	7058      	strb	r0, [r3, #1]
	pdu->pdu[1] = NULL;
   1187c:	6098      	str	r0, [r3, #8]
}
   1187e:	4770      	bx	lr

00011880 <lll_adv_pdu_alloc>:
{
   11880:	b510      	push	{r4, lr}
	first = pdu->first;
   11882:	7804      	ldrb	r4, [r0, #0]
	last = pdu->last;
   11884:	7843      	ldrb	r3, [r0, #1]
	if (first == last) {
   11886:	429c      	cmp	r4, r3
	first = pdu->first;
   11888:	b2e2      	uxtb	r2, r4
	if (first == last) {
   1188a:	d10d      	bne.n	118a8 <lll_adv_pdu_alloc+0x28>
		last++;
   1188c:	3301      	adds	r3, #1
   1188e:	b2db      	uxtb	r3, r3
		if (last == DOUBLE_BUFFER_SIZE) {
   11890:	2b02      	cmp	r3, #2
   11892:	d100      	bne.n	11896 <lll_adv_pdu_alloc+0x16>
			last = 0U;
   11894:	2300      	movs	r3, #0
	*idx = last;
   11896:	eb00 0483 	add.w	r4, r0, r3, lsl #2
   1189a:	700b      	strb	r3, [r1, #0]
	p = (void *)pdu->pdu[last];
   1189c:	6860      	ldr	r0, [r4, #4]
	if (p) {
   1189e:	b910      	cbnz	r0, 118a6 <lll_adv_pdu_alloc+0x26>
	p = lll_adv_pdu_alloc_pdu_adv();
   118a0:	f7f8 f9f6 	bl	9c90 <lll_adv_pdu_alloc_pdu_adv>
	pdu->pdu[last] = (void *)p;
   118a4:	6060      	str	r0, [r4, #4]
}
   118a6:	bd10      	pop	{r4, pc}
		pdu->last = first;
   118a8:	7042      	strb	r2, [r0, #1]
		first_latest = pdu->first;
   118aa:	7804      	ldrb	r4, [r0, #0]
		if (first_latest != first) {
   118ac:	42a2      	cmp	r2, r4
   118ae:	d0f2      	beq.n	11896 <lll_adv_pdu_alloc+0x16>
			pdu->last = last;
   118b0:	7043      	strb	r3, [r0, #1]
			last++;
   118b2:	e7eb      	b.n	1188c <lll_adv_pdu_alloc+0xc>

000118b4 <lll_adv_scan_req_check>:
{
   118b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   118b8:	461e      	mov	r6, r3
	return ((((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) == 0) &&
   118ba:	7903      	ldrb	r3, [r0, #4]
{
   118bc:	f89d 9020 	ldrb.w	r9, [sp, #32]
   118c0:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
   118c4:	4617      	mov	r7, r2
		 (devmatch_ok || ull_filter_lll_irk_in_fal(*rl_idx)))) &&
   118c6:	065a      	lsls	r2, r3, #25
{
   118c8:	4605      	mov	r5, r0
   118ca:	460c      	mov	r4, r1
		 (devmatch_ok || ull_filter_lll_irk_in_fal(*rl_idx)))) &&
   118cc:	d508      	bpl.n	118e0 <lll_adv_scan_req_check+0x2c>
		(((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) != 0) &&
   118ce:	f1b9 0f00 	cmp.w	r9, #0
   118d2:	d10d      	bne.n	118f0 <lll_adv_scan_req_check+0x3c>
		 (devmatch_ok || ull_filter_lll_irk_in_fal(*rl_idx)))) &&
   118d4:	f898 0000 	ldrb.w	r0, [r8]
   118d8:	f7f7 fbba 	bl	9050 <ull_filter_lll_irk_in_fal>
   118dc:	b940      	cbnz	r0, 118f0 <lll_adv_scan_req_check+0x3c>
   118de:	e00b      	b.n	118f8 <lll_adv_scan_req_check+0x44>
		 ull_filter_lll_rl_addr_allowed(sr->tx_addr,
   118e0:	f811 0b02 	ldrb.w	r0, [r1], #2
   118e4:	4642      	mov	r2, r8
   118e6:	f3c0 1080 	ubfx	r0, r0, #6, #1
   118ea:	f7f7 fc09 	bl	9100 <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) == 0) &&
   118ee:	b130      	cbz	r0, 118fe <lll_adv_scan_req_check+0x4a>
}

static bool isr_rx_sr_adva_check(uint8_t tx_addr, uint8_t *addr,
				 struct pdu_adv *sr)
{
	return (tx_addr == sr->rx_addr) &&
   118f0:	7823      	ldrb	r3, [r4, #0]
   118f2:	ebb7 1fd3 	cmp.w	r7, r3, lsr #7
   118f6:	d006      	beq.n	11906 <lll_adv_scan_req_check+0x52>
		 (devmatch_ok || ull_filter_lll_irk_in_fal(*rl_idx)))) &&
   118f8:	2000      	movs	r0, #0
}
   118fa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		(((lll->filter_policy & BT_LE_ADV_FP_FILTER_SCAN_REQ) != 0) &&
   118fe:	792b      	ldrb	r3, [r5, #4]
						rl_idx)) ||
   11900:	065b      	lsls	r3, r3, #25
   11902:	d4e4      	bmi.n	118ce <lll_adv_scan_req_check+0x1a>
   11904:	e7f8      	b.n	118f8 <lll_adv_scan_req_check+0x44>
		!memcmp(addr, sr->scan_req.adv_addr, BDADDR_SIZE);
   11906:	2206      	movs	r2, #6
   11908:	f104 0108 	add.w	r1, r4, #8
   1190c:	4630      	mov	r0, r6
   1190e:	f7fe f921 	bl	fb54 <memcmp>
	return (tx_addr == sr->rx_addr) &&
   11912:	fab0 f080 	clz	r0, r0
   11916:	0940      	lsrs	r0, r0, #5
   11918:	e7ef      	b.n	118fa <lll_adv_scan_req_check+0x46>

0001191a <lll_adv_scan_req_report>:
{
   1191a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1191c:	4607      	mov	r7, r0
	node_rx = ull_pdu_rx_alloc_peek(3);
   1191e:	2003      	movs	r0, #3
{
   11920:	4615      	mov	r5, r2
   11922:	461e      	mov	r6, r3
	node_rx = ull_pdu_rx_alloc_peek(3);
   11924:	f7f4 fec6 	bl	66b4 <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
   11928:	4604      	mov	r4, r0
   1192a:	b1b8      	cbz	r0, 1195c <lll_adv_scan_req_report+0x42>
	ull_pdu_rx_alloc();
   1192c:	f7f4 feda 	bl	66e4 <ull_pdu_rx_alloc>
	node_rx->hdr.type = NODE_RX_TYPE_SCAN_REQ;
   11930:	2315      	movs	r3, #21
   11932:	7123      	strb	r3, [r4, #4]
	node_rx->hdr.handle = ull_adv_lll_handle_get(lll);
   11934:	4638      	mov	r0, r7
   11936:	f7f5 fdd5 	bl	74e4 <ull_adv_lll_handle_get>
   1193a:	80e0      	strh	r0, [r4, #6]
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   1193c:	b166      	cbz	r6, 11958 <lll_adv_scan_req_report+0x3e>
   1193e:	f7fa fc05 	bl	c14c <radio_rssi_get>
   11942:	b2c0      	uxtb	r0, r0
   11944:	7620      	strb	r0, [r4, #24]
	ull_rx_put(node_rx->hdr.link, node_rx);
   11946:	4621      	mov	r1, r4
   11948:	6820      	ldr	r0, [r4, #0]
	node_rx->hdr.rx_ftr.rl_idx = rl_idx;
   1194a:	7665      	strb	r5, [r4, #25]
	ull_rx_put(node_rx->hdr.link, node_rx);
   1194c:	f7f4 fee0 	bl	6710 <ull_rx_put>
	ull_rx_sched();
   11950:	f7f4 fee4 	bl	671c <ull_rx_sched>
	return 0;
   11954:	2000      	movs	r0, #0
}
   11956:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? radio_rssi_get() :
   11958:	207f      	movs	r0, #127	; 0x7f
   1195a:	e7f3      	b.n	11944 <lll_adv_scan_req_report+0x2a>
		return -ENOBUFS;
   1195c:	f06f 0068 	mvn.w	r0, #104	; 0x68
   11960:	e7f9      	b.n	11956 <lll_adv_scan_req_report+0x3c>

00011962 <lll_adv_aux_init>:
}
   11962:	2000      	movs	r0, #0
   11964:	4770      	bx	lr

00011966 <lll_adv_aux_reset>:
   11966:	2000      	movs	r0, #0
   11968:	4770      	bx	lr

0001196a <prepare_cb>:
	return common_prepare_cb(p, false);
   1196a:	2100      	movs	r1, #0
   1196c:	f7f8 befc 	b.w	a768 <common_prepare_cb>

00011970 <isr_done>:
{
   11970:	b508      	push	{r3, lr}
	isr_common_done(param);
   11972:	f7f8 ffef 	bl	a954 <isr_common_done>
	radio_rx_enable();
   11976:	f7fa fae3 	bl	bf40 <radio_rx_enable>
}
   1197a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
   1197e:	f7fa bd0d 	b.w	c39c <radio_tmr_end_capture>

00011982 <isr_window>:
{
   11982:	b510      	push	{r4, lr}
   11984:	4604      	mov	r4, r0
	isr_common_done(param);
   11986:	f7f8 ffe5 	bl	a954 <isr_common_done>
	if (++lll->chan == ADV_CHAN_MAX) {
   1198a:	7923      	ldrb	r3, [r4, #4]
   1198c:	f3c3 0241 	ubfx	r2, r3, #1, #2
   11990:	3201      	adds	r2, #1
   11992:	f002 0203 	and.w	r2, r2, #3
   11996:	2a03      	cmp	r2, #3
   11998:	bf14      	ite	ne
   1199a:	f362 0342 	bfine	r3, r2, #1, #2
		lll->chan = 0U;
   1199e:	f36f 0342 	bfceq	r3, #1, #2
   119a2:	7123      	strb	r3, [r4, #4]
	lll_chan_set(37 + lll->chan);
   119a4:	7920      	ldrb	r0, [r4, #4]
   119a6:	f3c0 0041 	ubfx	r0, r0, #1, #2
   119aa:	3025      	adds	r0, #37	; 0x25
   119ac:	f7f7 ff0a 	bl	97c4 <lll_chan_set>
	remainder_us = radio_tmr_start_now(0);
   119b0:	2000      	movs	r0, #0
   119b2:	f7fa fcbf 	bl	c334 <radio_tmr_start_now>
}
   119b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_tmr_end_capture();
   119ba:	f7fa bcef 	b.w	c39c <radio_tmr_end_capture>

000119be <resume_prepare_cb>:
	ull = HDR_LLL2ULL(p->param);
   119be:	68c3      	ldr	r3, [r0, #12]
{
   119c0:	b570      	push	{r4, r5, r6, lr}
   119c2:	4604      	mov	r4, r0
	ull = HDR_LLL2ULL(p->param);
   119c4:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
   119c6:	f7ff f943 	bl	10c50 <ticker_ticks_now_get>
   119ca:	4605      	mov	r5, r0
   119cc:	4630      	mov	r0, r6
   119ce:	f7ff fee8 	bl	117a2 <lll_event_offset_get>
	p->remainder = 0;
   119d2:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_event_offset_get(ull);
   119d4:	1a2d      	subs	r5, r5, r0
   119d6:	6025      	str	r5, [r4, #0]
	p->remainder = 0;
   119d8:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
   119da:	8123      	strh	r3, [r4, #8]
	return common_prepare_cb(p, true);
   119dc:	4620      	mov	r0, r4
   119de:	2101      	movs	r1, #1
}
   119e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return common_prepare_cb(p, true);
   119e4:	f7f8 bec0 	b.w	a768 <common_prepare_cb>

000119e8 <isr_cleanup>:
{
   119e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   119ea:	4605      	mov	r5, r0
	lll_isr_status_reset();
   119ec:	f7ff ff08 	bl	11800 <lll_isr_status_reset>
	if (lll_is_done(param)) {
   119f0:	4628      	mov	r0, r5
   119f2:	f7f7 feb7 	bl	9764 <lll_is_done>
   119f6:	4604      	mov	r4, r0
   119f8:	b990      	cbnz	r0, 11a20 <isr_cleanup+0x38>
	radio_filter_disable();
   119fa:	f7fa fbdb 	bl	c1b4 <radio_filter_disable>
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   119fe:	4623      	mov	r3, r4
   11a00:	9400      	str	r4, [sp, #0]
   11a02:	2204      	movs	r2, #4
   11a04:	4621      	mov	r1, r4
   11a06:	4620      	mov	r0, r4
   11a08:	f7f3 f8ce 	bl	4ba8 <ticker_stop>
	lll->is_aux_sched = 0U;
   11a0c:	7aab      	ldrb	r3, [r5, #10]
	lll_isr_cleanup(param);
   11a0e:	4628      	mov	r0, r5
	lll->is_aux_sched = 0U;
   11a10:	f364 1304 	bfi	r3, r4, #4, #1
   11a14:	72ab      	strb	r3, [r5, #10]
}
   11a16:	b003      	add	sp, #12
   11a18:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	lll_isr_cleanup(param);
   11a1c:	f7f7 bf04 	b.w	9828 <lll_isr_cleanup>
}
   11a20:	b003      	add	sp, #12
   11a22:	bd30      	pop	{r4, r5, pc}

00011a24 <isr_scan_tgta_check>:
{
   11a24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11a28:	f89d a020 	ldrb.w	sl, [sp, #32]
   11a2c:	9e09      	ldr	r6, [sp, #36]	; 0x24
   11a2e:	4615      	mov	r5, r2
   11a30:	4607      	mov	r7, r0
   11a32:	4689      	mov	r9, r1
	if (ull_filter_lll_rl_addr_resolve(addr_type, addr, rl_idx)) {
   11a34:	4652      	mov	r2, sl
   11a36:	4619      	mov	r1, r3
   11a38:	4628      	mov	r0, r5
{
   11a3a:	4698      	mov	r8, r3
	if (ull_filter_lll_rl_addr_resolve(addr_type, addr, rl_idx)) {
   11a3c:	f7f7 fb96 	bl	916c <ull_filter_lll_rl_addr_resolve>
   11a40:	4604      	mov	r4, r0
   11a42:	b9c0      	cbnz	r0, 11a76 <isr_scan_tgta_check+0x52>
	} else if (init && lll->rpa_gen && ull_filter_lll_lrpa_get(rl_idx)) {
   11a44:	f1b9 0f00 	cmp.w	r9, #0
   11a48:	d10d      	bne.n	11a66 <isr_scan_tgta_check+0x42>
	return (((lll->init_addr_type == addr_type) &&
   11a4a:	793b      	ldrb	r3, [r7, #4]
   11a4c:	f3c3 1380 	ubfx	r3, r3, #6, #1
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   11a50:	42ab      	cmp	r3, r5
   11a52:	d113      	bne.n	11a7c <isr_scan_tgta_check+0x58>
   11a54:	2206      	movs	r2, #6
   11a56:	4641      	mov	r1, r8
   11a58:	f107 0012 	add.w	r0, r7, #18
   11a5c:	f7fe f87a 	bl	fb54 <memcmp>
	return (((lll->init_addr_type == addr_type) &&
   11a60:	b960      	cbnz	r0, 11a7c <isr_scan_tgta_check+0x58>
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   11a62:	2001      	movs	r0, #1
   11a64:	e010      	b.n	11a88 <isr_scan_tgta_check+0x64>
	} else if (init && lll->rpa_gen && ull_filter_lll_lrpa_get(rl_idx)) {
   11a66:	7c3b      	ldrb	r3, [r7, #16]
   11a68:	07db      	lsls	r3, r3, #31
   11a6a:	d5ee      	bpl.n	11a4a <isr_scan_tgta_check+0x26>
   11a6c:	4650      	mov	r0, sl
   11a6e:	f7f7 fa29 	bl	8ec4 <ull_filter_lll_lrpa_get>
   11a72:	2800      	cmp	r0, #0
   11a74:	d0e9      	beq.n	11a4a <isr_scan_tgta_check+0x26>
}
   11a76:	4620      	mov	r0, r4
   11a78:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (((lll->filter_policy & SCAN_FP_EXT) != 0U) && (addr_type != 0U) &&
   11a7c:	7938      	ldrb	r0, [r7, #4]
   11a7e:	f3c0 00c1 	ubfx	r0, r0, #3, #2
   11a82:	f010 0002 	ands.w	r0, r0, #2
   11a86:	d101      	bne.n	11a8c <isr_scan_tgta_check+0x68>
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   11a88:	4604      	mov	r4, r0
   11a8a:	e7f4      	b.n	11a76 <isr_scan_tgta_check+0x52>
	if (((lll->filter_policy & SCAN_FP_EXT) != 0U) && (addr_type != 0U) &&
   11a8c:	b155      	cbz	r5, 11aa4 <isr_scan_tgta_check+0x80>
   11a8e:	f898 3005 	ldrb.w	r3, [r8, #5]
   11a92:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   11a96:	2b40      	cmp	r3, #64	; 0x40
   11a98:	d104      	bne.n	11aa4 <isr_scan_tgta_check+0x80>
		if (dir_report) {
   11a9a:	2e00      	cmp	r6, #0
   11a9c:	d0e1      	beq.n	11a62 <isr_scan_tgta_check+0x3e>
			*dir_report = true;
   11a9e:	2001      	movs	r0, #1
   11aa0:	7030      	strb	r0, [r6, #0]
   11aa2:	e7f1      	b.n	11a88 <isr_scan_tgta_check+0x64>
		 !memcmp(lll->init_addr, addr, BDADDR_SIZE))) ||
   11aa4:	2000      	movs	r0, #0
   11aa6:	e7ef      	b.n	11a88 <isr_scan_tgta_check+0x64>

00011aa8 <lll_scan_init>:
}
   11aa8:	2000      	movs	r0, #0
   11aaa:	4770      	bx	lr

00011aac <lll_scan_reset>:
   11aac:	2000      	movs	r0, #0
   11aae:	4770      	bx	lr

00011ab0 <lll_scan_isr_rx_check>:
{
   11ab0:	b510      	push	{r4, lr}
   11ab2:	4604      	mov	r4, r0
   11ab4:	4608      	mov	r0, r1
   11ab6:	4619      	mov	r1, r3
	return (((lll->filter_policy & SCAN_FP_FILTER) == 0U) &&
   11ab8:	7923      	ldrb	r3, [r4, #4]
							       rl_idx))) ||
   11aba:	071b      	lsls	r3, r3, #28
   11abc:	d504      	bpl.n	11ac8 <lll_scan_isr_rx_check+0x18>
	       (((lll->filter_policy & SCAN_FP_FILTER) != 0U) &&
   11abe:	b922      	cbnz	r2, 11aca <lll_scan_isr_rx_check+0x1a>
		(devmatch_ok || ull_filter_lll_irk_in_fal(rl_idx)));
   11ac0:	4608      	mov	r0, r1
   11ac2:	f7f7 fac5 	bl	9050 <ull_filter_lll_irk_in_fal>
   11ac6:	e001      	b.n	11acc <lll_scan_isr_rx_check+0x1c>
	return (((lll->filter_policy & SCAN_FP_FILTER) == 0U) &&
   11ac8:	b91a      	cbnz	r2, 11ad2 <lll_scan_isr_rx_check+0x22>
							       rl_idx))) ||
   11aca:	2001      	movs	r0, #1
}
   11acc:	f000 0001 	and.w	r0, r0, #1
   11ad0:	bd10      	pop	{r4, pc}
		(!devmatch_ok || ull_filter_lll_rl_idx_allowed(irkmatch_ok,
   11ad2:	f7f7 fae5 	bl	90a0 <ull_filter_lll_rl_idx_allowed>
   11ad6:	2800      	cmp	r0, #0
   11ad8:	d1f7      	bne.n	11aca <lll_scan_isr_rx_check+0x1a>
	       (((lll->filter_policy & SCAN_FP_FILTER) != 0U) &&
   11ada:	7923      	ldrb	r3, [r4, #4]
							       rl_idx))) ||
   11adc:	f3c3 00c0 	ubfx	r0, r3, #3, #1
   11ae0:	071b      	lsls	r3, r3, #28
   11ae2:	d4f2      	bmi.n	11aca <lll_scan_isr_rx_check+0x1a>
   11ae4:	e7f2      	b.n	11acc <lll_scan_isr_rx_check+0x1c>

00011ae6 <lll_scan_adva_check>:
{
   11ae6:	b513      	push	{r0, r1, r4, lr}
	if (rl_idx != FILTER_IDX_NONE) {
   11ae8:	2bff      	cmp	r3, #255	; 0xff
{
   11aea:	4604      	mov	r4, r0
   11aec:	f88d 3007 	strb.w	r3, [sp, #7]
   11af0:	4608      	mov	r0, r1
   11af2:	4611      	mov	r1, r2
	if (rl_idx != FILTER_IDX_NONE) {
   11af4:	d005      	beq.n	11b02 <lll_scan_adva_check+0x1c>
		return (rl_idx == lll->rl_idx);
   11af6:	7c60      	ldrb	r0, [r4, #17]
   11af8:	1ac3      	subs	r3, r0, r3
   11afa:	4258      	negs	r0, r3
   11afc:	4158      	adcs	r0, r3
}
   11afe:	b002      	add	sp, #8
   11b00:	bd10      	pop	{r4, pc}
	} else if (!ull_filter_lll_rl_addr_allowed(addr_type, addr, &rl_idx)) {
   11b02:	f10d 0207 	add.w	r2, sp, #7
   11b06:	f7f7 fafb 	bl	9100 <ull_filter_lll_rl_addr_allowed>
	return false;
   11b0a:	2000      	movs	r0, #0
   11b0c:	e7f7      	b.n	11afe <lll_scan_adva_check+0x18>

00011b0e <lll_scan_ext_tgta_check>:
{
   11b0e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   11b12:	4605      	mov	r5, r0
   11b14:	f89d 7028 	ldrb.w	r7, [sp, #40]	; 0x28
   11b18:	4616      	mov	r6, r2
   11b1a:	461c      	mov	r4, r3
	if (pri && !pdu->adv_ext_ind.ext_hdr.adv_addr) {
   11b1c:	4608      	mov	r0, r1
   11b1e:	b111      	cbz	r1, 11b26 <lll_scan_ext_tgta_check+0x18>
   11b20:	78db      	ldrb	r3, [r3, #3]
   11b22:	07d9      	lsls	r1, r3, #31
   11b24:	d529      	bpl.n	11b7a <lll_scan_ext_tgta_check+0x6c>
	if (pdu->len <
   11b26:	7863      	ldrb	r3, [r4, #1]
   11b28:	2b07      	cmp	r3, #7
   11b2a:	d92b      	bls.n	11b84 <lll_scan_ext_tgta_check+0x76>
	is_directed = pdu->adv_ext_ind.ext_hdr.tgt_addr;
   11b2c:	78e2      	ldrb	r2, [r4, #3]
   11b2e:	f3c2 0940 	ubfx	r9, r2, #1, #1
	if (is_directed && (pdu->len < PDU_AC_EXT_HEADER_SIZE_MIN +
   11b32:	0792      	lsls	r2, r2, #30
   11b34:	d501      	bpl.n	11b3a <lll_scan_ext_tgta_check+0x2c>
   11b36:	2b0d      	cmp	r3, #13
   11b38:	d924      	bls.n	11b84 <lll_scan_ext_tgta_check+0x76>
	rx_addr = pdu->rx_addr;
   11b3a:	7821      	ldrb	r1, [r4, #0]
   11b3c:	ea4f 18d1 	mov.w	r8, r1, lsr #7
		 lll_scan_adva_check(lll, tx_addr, adva, rl_idx)) &&
   11b40:	b96e      	cbnz	r6, 11b5e <lll_scan_ext_tgta_check+0x50>
   11b42:	f1b9 0f00 	cmp.w	r9, #0
   11b46:	d01b      	beq.n	11b80 <lll_scan_ext_tgta_check+0x72>
		  isr_scan_tgta_check(lll, is_init, rx_addr, tgta, rl_idx,
   11b48:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   11b4a:	4642      	mov	r2, r8
   11b4c:	e9cd 7300 	strd	r7, r3, [sp]
   11b50:	4631      	mov	r1, r6
   11b52:	f104 030a 	add.w	r3, r4, #10
   11b56:	4628      	mov	r0, r5
   11b58:	f7ff ff64 	bl	11a24 <isr_scan_tgta_check>
   11b5c:	e00b      	b.n	11b76 <lll_scan_ext_tgta_check+0x68>
		 ((lll->filter_policy & SCAN_FP_FILTER) != 0U) ||
   11b5e:	792b      	ldrb	r3, [r5, #4]
	return ((!is_init ||
   11b60:	071b      	lsls	r3, r3, #28
   11b62:	d4ee      	bmi.n	11b42 <lll_scan_ext_tgta_check+0x34>
		 lll_scan_adva_check(lll, tx_addr, adva, rl_idx)) &&
   11b64:	463b      	mov	r3, r7
   11b66:	1d22      	adds	r2, r4, #4
   11b68:	f3c1 1180 	ubfx	r1, r1, #6, #1
   11b6c:	4628      	mov	r0, r5
   11b6e:	f7ff ffba 	bl	11ae6 <lll_scan_adva_check>
		 ((lll->filter_policy & SCAN_FP_FILTER) != 0U) ||
   11b72:	2800      	cmp	r0, #0
   11b74:	d1e5      	bne.n	11b42 <lll_scan_ext_tgta_check+0x34>
		 lll_scan_adva_check(lll, tx_addr, adva, rl_idx)) &&
   11b76:	f000 0001 	and.w	r0, r0, #1
}
   11b7a:	b003      	add	sp, #12
   11b7c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		 lll_scan_adva_check(lll, tx_addr, adva, rl_idx)) &&
   11b80:	2001      	movs	r0, #1
   11b82:	e7f8      	b.n	11b76 <lll_scan_ext_tgta_check+0x68>
		return false;
   11b84:	2000      	movs	r0, #0
   11b86:	e7f8      	b.n	11b7a <lll_scan_ext_tgta_check+0x6c>

00011b88 <lll_scan_aux_addr_match_get>:
{
   11b88:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	if (!ext_hdr->adv_addr) {
   11b8c:	78cc      	ldrb	r4, [r1, #3]
   11b8e:	f014 0401 	ands.w	r4, r4, #1
{
   11b92:	4680      	mov	r8, r0
   11b94:	460d      	mov	r5, r1
   11b96:	4616      	mov	r6, r2
   11b98:	461f      	mov	r7, r3
	if (!ext_hdr->adv_addr) {
   11b9a:	d02b      	beq.n	11bf4 <lll_scan_aux_addr_match_get+0x6c>
	if (IS_ENABLED(CONFIG_BT_CTLR_PRIVACY) && ull_filter_lll_rl_enabled()) {
   11b9c:	f7f7 fb06 	bl	91ac <ull_filter_lll_rl_enabled>
   11ba0:	4604      	mov	r4, r0
   11ba2:	f898 0004 	ldrb.w	r0, [r8, #4]
   11ba6:	b34c      	cbz	r4, 11bfc <lll_scan_aux_addr_match_get+0x74>
		const uint8_t *adva = &ext_hdr->data[ADVA_OFFSET];
   11ba8:	46a8      	mov	r8, r5
			ull_filter_lll_get((lll->filter_policy &
   11baa:	f3c0 00c0 	ubfx	r0, r0, #3, #1
   11bae:	f7f6 fdbf 	bl	8730 <ull_filter_lll_get>
		*devmatch_ok = ull_filter_lll_fal_match(fal, pdu->tx_addr, adva,
   11bb2:	f818 1b04 	ldrb.w	r1, [r8], #4
   11bb6:	463b      	mov	r3, r7
   11bb8:	4642      	mov	r2, r8
   11bba:	f3c1 1180 	ubfx	r1, r1, #6, #1
   11bbe:	f7ff fda6 	bl	1170e <ull_filter_lll_fal_match>
   11bc2:	7030      	strb	r0, [r6, #0]
		if (!*devmatch_ok && pdu->tx_addr) {
   11bc4:	b108      	cbz	r0, 11bca <lll_scan_aux_addr_match_get+0x42>
		*devmatch_ok = ull_filter_lll_fal_match(fal, pdu->tx_addr, adva,
   11bc6:	2401      	movs	r4, #1
   11bc8:	e014      	b.n	11bf4 <lll_scan_aux_addr_match_get+0x6c>
		if (!*devmatch_ok && pdu->tx_addr) {
   11bca:	782b      	ldrb	r3, [r5, #0]
   11bcc:	065b      	lsls	r3, r3, #25
   11bce:	d5fa      	bpl.n	11bc6 <lll_scan_aux_addr_match_get+0x3e>
			(void)ull_filter_lll_irks_get(&count);
   11bd0:	f10d 0007 	add.w	r0, sp, #7
   11bd4:	f7f7 f98c 	bl	8ef0 <ull_filter_lll_irks_get>
			if (count) {
   11bd8:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11bdc:	b153      	cbz	r3, 11bf4 <lll_scan_aux_addr_match_get+0x6c>
				radio_ar_resolve(adva);
   11bde:	4640      	mov	r0, r8
   11be0:	f7fa fc56 	bl	c490 <radio_ar_resolve>
				*irkmatch_ok = radio_ar_has_match();
   11be4:	f7fa fc40 	bl	c468 <radio_ar_has_match>
   11be8:	9b08      	ldr	r3, [sp, #32]
   11bea:	7018      	strb	r0, [r3, #0]
				*irkmatch_id = radio_ar_match_get();
   11bec:	f7fa fc24 	bl	c438 <radio_ar_match_get>
   11bf0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   11bf2:	7018      	strb	r0, [r3, #0]
}
   11bf4:	4620      	mov	r0, r4
   11bf6:	b002      	add	sp, #8
   11bf8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (IS_ENABLED(CONFIG_BT_CTLR_FILTER_ACCEPT_LIST) &&
   11bfc:	f010 0f18 	tst.w	r0, #24
   11c00:	d0e1      	beq.n	11bc6 <lll_scan_aux_addr_match_get+0x3e>
		const struct lll_filter *fal = ull_filter_lll_get(true);
   11c02:	2001      	movs	r0, #1
   11c04:	f7f6 fd94 	bl	8730 <ull_filter_lll_get>
		const uint8_t *adva = &ext_hdr->data[ADVA_OFFSET];
   11c08:	462a      	mov	r2, r5
		*devmatch_ok = ull_filter_lll_fal_match(fal, pdu->tx_addr, adva,
   11c0a:	463b      	mov	r3, r7
   11c0c:	f812 1b04 	ldrb.w	r1, [r2], #4
   11c10:	f3c1 1180 	ubfx	r1, r1, #6, #1
   11c14:	f7ff fd7b 	bl	1170e <ull_filter_lll_fal_match>
   11c18:	7030      	strb	r0, [r6, #0]
   11c1a:	e7d4      	b.n	11bc6 <lll_scan_aux_addr_match_get+0x3e>

00011c1c <isr_rx_ull_schedule>:
{
   11c1c:	b510      	push	{r4, lr}
   11c1e:	4604      	mov	r4, r0
	lll = ull_scan_aux_lll_parent_get(lll_aux, NULL);
   11c20:	2100      	movs	r1, #0
   11c22:	f7ff fd39 	bl	11698 <ull_scan_aux_lll_parent_get>
	isr_rx(lll, lll_aux, lll_aux->phy);
   11c26:	7962      	ldrb	r2, [r4, #5]
   11c28:	4621      	mov	r1, r4
   11c2a:	f002 0207 	and.w	r2, r2, #7
}
   11c2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_rx(lll, lll_aux, lll_aux->phy);
   11c32:	f7f9 be1d 	b.w	b870 <isr_rx>

00011c36 <isr_rx_lll_schedule>:
{
   11c36:	4603      	mov	r3, r0
	lll = node_rx->hdr.rx_ftr.param;
   11c38:	6880      	ldr	r0, [r0, #8]
	phy_aux = node_rx->hdr.rx_ftr.aux_phy; /* PHY remembered in node rx */
   11c3a:	7b1a      	ldrb	r2, [r3, #12]
	if (lll->is_aux_sched) {
   11c3c:	7a83      	ldrb	r3, [r0, #10]
   11c3e:	06db      	lsls	r3, r3, #27
		isr_rx(lll, lll->lll_aux, phy_aux);
   11c40:	bf54      	ite	pl
   11c42:	68c1      	ldrpl	r1, [r0, #12]
		isr_rx(lll, NULL, phy_aux);
   11c44:	2100      	movmi	r1, #0
		isr_rx(lll, lll->lll_aux, phy_aux);
   11c46:	f7f9 be13 	b.w	b870 <isr_rx>

00011c4a <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(uint8_t const *const key_le, uint8_t const *const clear_text_le,
		 uint8_t * const cipher_text_le, uint8_t * const cipher_text_be)
{
   11c4a:	b570      	push	{r4, r5, r6, lr}
   11c4c:	b08c      	sub	sp, #48	; 0x30
   11c4e:	460e      	mov	r6, r1
   11c50:	4615      	mov	r5, r2
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   11c52:	4601      	mov	r1, r0
   11c54:	2210      	movs	r2, #16
   11c56:	4668      	mov	r0, sp
{
   11c58:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   11c5a:	f7fe fd14 	bl	10686 <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
   11c5e:	2210      	movs	r2, #16
   11c60:	eb0d 0002 	add.w	r0, sp, r2
   11c64:	4631      	mov	r1, r6
   11c66:	f7fe fd0e 	bl	10686 <mem_rcopy>

	do_ecb(&ecb);
   11c6a:	4668      	mov	r0, sp
   11c6c:	f7fa f85e 	bl	bd2c <do_ecb>

	if (cipher_text_le) {
   11c70:	b125      	cbz	r5, 11c7c <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
   11c72:	2210      	movs	r2, #16
   11c74:	a908      	add	r1, sp, #32
   11c76:	4628      	mov	r0, r5
   11c78:	f7fe fd05 	bl	10686 <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
   11c7c:	b124      	cbz	r4, 11c88 <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
   11c7e:	2210      	movs	r2, #16
   11c80:	a908      	add	r1, sp, #32
   11c82:	4620      	mov	r0, r4
   11c84:	f7fd ff8f 	bl	fba6 <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
   11c88:	b00c      	add	sp, #48	; 0x30
   11c8a:	bd70      	pop	{r4, r5, r6, pc}

00011c8c <radio_setup>:
	NRF_AMLI->RAMPRI.CPU0    = 0xFFFFFFFFUL;
   11c8c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   11c90:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	NRF_AMLI->RAMPRI.RADIO   = 0x00000000UL;
   11c94:	2100      	movs	r1, #0
	NRF_AMLI->RAMPRI.CPU0    = 0xFFFFFFFFUL;
   11c96:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
	NRF_AMLI->RAMPRI.SPIS1   = 0xFFFFFFFFUL;
   11c9a:	f8c3 2e04 	str.w	r2, [r3, #3588]	; 0xe04
	NRF_AMLI->RAMPRI.RADIO   = 0x00000000UL;
   11c9e:	f8c3 1e08 	str.w	r1, [r3, #3592]	; 0xe08
	NRF_AMLI->RAMPRI.ECB     = 0xFFFFFFFFUL;
   11ca2:	f8c3 2e0c 	str.w	r2, [r3, #3596]	; 0xe0c
	NRF_AMLI->RAMPRI.CCM     = 0x00000000UL;
   11ca6:	f8c3 1e10 	str.w	r1, [r3, #3600]	; 0xe10
	NRF_AMLI->RAMPRI.AAR     = 0xFFFFFFFFUL;
   11caa:	f8c3 2e14 	str.w	r2, [r3, #3604]	; 0xe14
	NRF_AMLI->RAMPRI.SAADC   = 0xFFFFFFFFUL;
   11cae:	f8c3 2e18 	str.w	r2, [r3, #3608]	; 0xe18
	NRF_AMLI->RAMPRI.UARTE   = 0xFFFFFFFFUL;
   11cb2:	f8c3 2e1c 	str.w	r2, [r3, #3612]	; 0xe1c
	NRF_AMLI->RAMPRI.SERIAL0 = 0xFFFFFFFFUL;
   11cb6:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
	NRF_AMLI->RAMPRI.SERIAL2 = 0xFFFFFFFFUL;
   11cba:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
	NRF_AMLI->RAMPRI.NFCT    = 0xFFFFFFFFUL;
   11cbe:	f8c3 2e28 	str.w	r2, [r3, #3624]	; 0xe28
	NRF_AMLI->RAMPRI.I2S     = 0xFFFFFFFFUL;
   11cc2:	f8c3 2e2c 	str.w	r2, [r3, #3628]	; 0xe2c
	NRF_AMLI->RAMPRI.PDM     = 0xFFFFFFFFUL;
   11cc6:	f8c3 2e30 	str.w	r2, [r3, #3632]	; 0xe30
	NRF_AMLI->RAMPRI.PWM     = 0xFFFFFFFFUL;
   11cca:	f8c3 2e34 	str.w	r2, [r3, #3636]	; 0xe34
}
   11cce:	4770      	bx	lr

00011cd0 <radio_tx_chain_delay_get>:
}
   11cd0:	2001      	movs	r0, #1
   11cd2:	4770      	bx	lr

00011cd4 <radio_rx_ready_delay_get>:
}
   11cd4:	2029      	movs	r0, #41	; 0x29
   11cd6:	4770      	bx	lr

00011cd8 <radio_rx_chain_delay_get>:
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_2M_US;
   11cd8:	2802      	cmp	r0, #2
}
   11cda:	bf14      	ite	ne
   11cdc:	200a      	movne	r0, #10
   11cde:	2005      	moveq	r0, #5
   11ce0:	4770      	bx	lr

00011ce2 <radio_phy_flags_rx_get>:
}
   11ce2:	2000      	movs	r0, #0
   11ce4:	4770      	bx	lr

00011ce6 <mayfly_prio_is_equal>:
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   11ce6:	4288      	cmp	r0, r1
   11ce8:	d00a      	beq.n	11d00 <mayfly_prio_is_equal+0x1a>
	return (caller_id == callee_id) ||
   11cea:	2801      	cmp	r0, #1
   11cec:	d104      	bne.n	11cf8 <mayfly_prio_is_equal+0x12>
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
   11cee:	2902      	cmp	r1, #2
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   11cf0:	bf14      	ite	ne
   11cf2:	2000      	movne	r0, #0
   11cf4:	2001      	moveq	r0, #1
   11cf6:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   11cf8:	2802      	cmp	r0, #2
   11cfa:	d103      	bne.n	11d04 <mayfly_prio_is_equal+0x1e>
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   11cfc:	2901      	cmp	r1, #1
   11cfe:	e7f7      	b.n	11cf0 <mayfly_prio_is_equal+0xa>
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   11d00:	2001      	movs	r0, #1
   11d02:	4770      	bx	lr
   11d04:	2000      	movs	r0, #0
}
   11d06:	4770      	bx	lr

00011d08 <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(uint32_t value)
{
   11d08:	4601      	mov	r1, r0
	cntr_cmp_set(0, value);
   11d0a:	2000      	movs	r0, #0
   11d0c:	f7fa b806 	b.w	bd1c <cntr_cmp_set>

00011d10 <sys_put_le32>:
	dst[1] = val >> 8;
   11d10:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   11d14:	7008      	strb	r0, [r1, #0]
	sys_put_le16(val >> 16, &dst[2]);
   11d16:	0c00      	lsrs	r0, r0, #16
	dst[0] = val;
   11d18:	7088      	strb	r0, [r1, #2]
	dst[1] = val >> 8;
   11d1a:	0a00      	lsrs	r0, r0, #8
   11d1c:	704b      	strb	r3, [r1, #1]
   11d1e:	70c8      	strb	r0, [r1, #3]
}
   11d20:	4770      	bx	lr

00011d22 <hci_vendor_read_static_addr>:
				 uint8_t size)
{
	/* only one supported */
	ARG_UNUSED(size);

	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   11d22:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
{
   11d26:	b510      	push	{r4, lr}
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   11d28:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
   11d2c:	3201      	adds	r2, #1
{
   11d2e:	4604      	mov	r4, r0
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   11d30:	d106      	bne.n	11d40 <hci_vendor_read_static_addr+0x1e>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   11d32:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   11d36:	f64f 72ff 	movw	r2, #65535	; 0xffff
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   11d3a:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   11d3c:	4293      	cmp	r3, r2
   11d3e:	d044      	beq.n	11dca <hci_vendor_read_static_addr+0xa8>
	     (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
   11d40:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   11d44:	f8d2 00a0 	ldr.w	r0, [r2, #160]	; 0xa0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   11d48:	f010 0001 	ands.w	r0, r0, #1
   11d4c:	d036      	beq.n	11dbc <hci_vendor_read_static_addr+0x9a>
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addrs[0].bdaddr.val[0]);
   11d4e:	4621      	mov	r1, r4
   11d50:	f8d2 00a4 	ldr.w	r0, [r2, #164]	; 0xa4
   11d54:	f7ff ffdc 	bl	11d10 <sys_put_le32>
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addrs[0].bdaddr.val[4]);
   11d58:	f8d2 30a8 	ldr.w	r3, [r2, #168]	; 0xa8
	dst[0] = val;
   11d5c:	7123      	strb	r3, [r4, #4]
	dst[1] = val >> 8;
   11d5e:	f3c3 2307 	ubfx	r3, r3, #8, #8

		/* The FICR value is a just a random number, with no knowledge
		 * of the Bluetooth Specification requirements for random
		 * static addresses.
		 */
		BT_ADDR_SET_STATIC(&addrs[0].bdaddr);
   11d62:	f063 033f 	orn	r3, r3, #63	; 0x3f
   11d66:	7163      	strb	r3, [r4, #5]

		/* If no public address is provided and a static address is
		 * available, then it is recommended to return an identity root
		 * key (if available) from this command.
		 */
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   11d68:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
   11d6c:	3101      	adds	r1, #1
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
   11d6e:	f104 0306 	add.w	r3, r4, #6
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   11d72:	d024      	beq.n	11dbe <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   11d74:	f8d2 1094 	ldr.w	r1, [r2, #148]	; 0x94
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   11d78:	3101      	adds	r1, #1
   11d7a:	d020      	beq.n	11dbe <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   11d7c:	f8d2 1098 	ldr.w	r1, [r2, #152]	; 0x98
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
   11d80:	3101      	adds	r1, #1
   11d82:	d01c      	beq.n	11dbe <hci_vendor_read_static_addr+0x9c>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
   11d84:	f8d2 109c 	ldr.w	r1, [r2, #156]	; 0x9c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
   11d88:	3101      	adds	r1, #1
   11d8a:	d018      	beq.n	11dbe <hci_vendor_read_static_addr+0x9c>
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
   11d8c:	4619      	mov	r1, r3
   11d8e:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
   11d92:	f7ff ffbd 	bl	11d10 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[1], &addrs[0].ir[4]);
   11d96:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
   11d9a:	f104 010a 	add.w	r1, r4, #10
   11d9e:	f7ff ffb7 	bl	11d10 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[2], &addrs[0].ir[8]);
   11da2:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
   11da6:	f104 010e 	add.w	r1, r4, #14
   11daa:	f7ff ffb1 	bl	11d10 <sys_put_le32>
			sys_put_le32(NRF_FICR->IR[3], &addrs[0].ir[12]);
   11dae:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
   11db2:	f104 0112 	add.w	r1, r4, #18
   11db6:	f7ff ffab 	bl	11d10 <sys_put_le32>
		} else {
			/* Mark IR as invalid */
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
		}

		return 1;
   11dba:	2001      	movs	r0, #1
	}

	return 0;
}
   11dbc:	bd10      	pop	{r4, pc}
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
   11dbe:	2210      	movs	r2, #16
   11dc0:	2100      	movs	r1, #0
   11dc2:	4618      	mov	r0, r3
   11dc4:	f7fd fefa 	bl	fbbc <memset>
   11dc8:	e7f7      	b.n	11dba <hci_vendor_read_static_addr+0x98>
	return 0;
   11dca:	2000      	movs	r0, #0
   11dcc:	e7f6      	b.n	11dbc <hci_vendor_read_static_addr+0x9a>

00011dce <hci_vendor_read_key_hierarchy_roots>:

void hci_vendor_read_key_hierarchy_roots(uint8_t ir[16], uint8_t er[16])
{
   11dce:	b510      	push	{r4, lr}
	/* Mark IR as invalid.
	 * No public address is available, and static address IR should be read
	 * using Read Static Addresses command.
	 */
	(void)memset(ir, 0x00, 16);
   11dd0:	2210      	movs	r2, #16
{
   11dd2:	460c      	mov	r4, r1
	(void)memset(ir, 0x00, 16);
   11dd4:	2100      	movs	r1, #0
   11dd6:	f7fd fef1 	bl	fbbc <memset>

	/* Fill in ER if present */
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   11dda:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   11dde:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
   11de2:	3301      	adds	r3, #1
   11de4:	d023      	beq.n	11e2e <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   11de6:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   11dea:	3301      	adds	r3, #1
   11dec:	d01f      	beq.n	11e2e <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   11dee:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   11df2:	3301      	adds	r3, #1
   11df4:	d01b      	beq.n	11e2e <hci_vendor_read_key_hierarchy_roots+0x60>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
   11df6:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   11dfa:	3301      	adds	r3, #1
   11dfc:	d017      	beq.n	11e2e <hci_vendor_read_key_hierarchy_roots+0x60>
		sys_put_le32(NRF_FICR->ER[0], &er[0]);
   11dfe:	4621      	mov	r1, r4
   11e00:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
   11e04:	f7ff ff84 	bl	11d10 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[1], &er[4]);
   11e08:	1d21      	adds	r1, r4, #4
   11e0a:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
   11e0e:	f7ff ff7f 	bl	11d10 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[2], &er[8]);
   11e12:	f104 0108 	add.w	r1, r4, #8
   11e16:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
   11e1a:	f7ff ff79 	bl	11d10 <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
   11e1e:	f104 010c 	add.w	r1, r4, #12
   11e22:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
	} else {
		/* Mark ER as invalid */
		(void)memset(er, 0x00, 16);
	}
}
   11e26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
   11e2a:	f7ff bf71 	b.w	11d10 <sys_put_le32>
		(void)memset(er, 0x00, 16);
   11e2e:	4620      	mov	r0, r4
   11e30:	2210      	movs	r2, #16
}
   11e32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		(void)memset(er, 0x00, 16);
   11e36:	2100      	movs	r1, #0
   11e38:	f7fd bec0 	b.w	fbbc <memset>

00011e3c <fixed_data_unref>:
}
   11e3c:	4770      	bx	lr

00011e3e <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   11e3e:	6a41      	ldr	r1, [r0, #36]	; 0x24
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   11e40:	6849      	ldr	r1, [r1, #4]
   11e42:	6809      	ldr	r1, [r1, #0]
   11e44:	f7fa bc74 	b.w	c730 <net_buf_alloc_len>

00011e48 <net_buf_get>:
{
   11e48:	b570      	push	{r4, r5, r6, lr}
   11e4a:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
   11e4c:	f7fc fbe2 	bl	e614 <z_impl_k_queue_get>
	if (!buf) {
   11e50:	4605      	mov	r5, r0
   11e52:	b128      	cbz	r0, 11e60 <net_buf_get+0x18>
   11e54:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   11e56:	7963      	ldrb	r3, [r4, #5]
   11e58:	f013 0301 	ands.w	r3, r3, #1
   11e5c:	d102      	bne.n	11e64 <net_buf_get+0x1c>
	frag->frags = NULL;
   11e5e:	6023      	str	r3, [r4, #0]
}
   11e60:	4628      	mov	r0, r5
   11e62:	bd70      	pop	{r4, r5, r6, pc}
   11e64:	2300      	movs	r3, #0
   11e66:	2200      	movs	r2, #0
   11e68:	4630      	mov	r0, r6
   11e6a:	f7fc fbd3 	bl	e614 <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
   11e6e:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   11e70:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
   11e72:	f023 0301 	bic.w	r3, r3, #1
   11e76:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   11e78:	4604      	mov	r4, r0
   11e7a:	e7ec      	b.n	11e56 <net_buf_get+0xe>

00011e7c <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
   11e7c:	6883      	ldr	r3, [r0, #8]
   11e7e:	440b      	add	r3, r1
   11e80:	6003      	str	r3, [r0, #0]
}
   11e82:	4770      	bx	lr

00011e84 <net_buf_put>:
{
   11e84:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
   11e86:	460a      	mov	r2, r1
   11e88:	6814      	ldr	r4, [r2, #0]
   11e8a:	b914      	cbnz	r4, 11e92 <net_buf_put+0xe>
}
   11e8c:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
   11e8e:	f000 bbb9 	b.w	12604 <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
   11e92:	7953      	ldrb	r3, [r2, #5]
   11e94:	f043 0301 	orr.w	r3, r3, #1
   11e98:	7153      	strb	r3, [r2, #5]
   11e9a:	4622      	mov	r2, r4
   11e9c:	e7f4      	b.n	11e88 <net_buf_put+0x4>

00011e9e <net_buf_ref>:
{
	__ASSERT_NO_MSG(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   11e9e:	7902      	ldrb	r2, [r0, #4]
   11ea0:	3201      	adds	r2, #1
   11ea2:	7102      	strb	r2, [r0, #4]
	return buf;
}
   11ea4:	4770      	bx	lr

00011ea6 <net_buf_frag_insert>:
void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
	__ASSERT_NO_MSG(parent);
	__ASSERT_NO_MSG(frag);

	if (parent->frags) {
   11ea6:	6802      	ldr	r2, [r0, #0]
{
   11ea8:	b510      	push	{r4, lr}
	if (parent->frags) {
   11eaa:	b12a      	cbz	r2, 11eb8 <net_buf_frag_insert+0x12>
   11eac:	460b      	mov	r3, r1
	while (buf->frags) {
   11eae:	461c      	mov	r4, r3
   11eb0:	681b      	ldr	r3, [r3, #0]
   11eb2:	2b00      	cmp	r3, #0
   11eb4:	d1fb      	bne.n	11eae <net_buf_frag_insert+0x8>
		net_buf_frag_last(frag)->frags = parent->frags;
   11eb6:	6022      	str	r2, [r4, #0]
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
   11eb8:	6001      	str	r1, [r0, #0]
}
   11eba:	bd10      	pop	{r4, pc}

00011ebc <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
   11ebc:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(frag);

	if (!head) {
   11ebe:	4604      	mov	r4, r0
   11ec0:	b920      	cbnz	r0, 11ecc <net_buf_frag_add+0x10>
	buf->ref++;
   11ec2:	790b      	ldrb	r3, [r1, #4]
   11ec4:	3301      	adds	r3, #1
   11ec6:	710b      	strb	r3, [r1, #4]
		return net_buf_ref(frag);
   11ec8:	4608      	mov	r0, r1
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);

	return head;
}
   11eca:	bd10      	pop	{r4, pc}
   11ecc:	4603      	mov	r3, r0
	while (buf->frags) {
   11ece:	4618      	mov	r0, r3
   11ed0:	681b      	ldr	r3, [r3, #0]
   11ed2:	2b00      	cmp	r3, #0
   11ed4:	d1fb      	bne.n	11ece <net_buf_frag_add+0x12>
	net_buf_frag_insert(net_buf_frag_last(head), frag);
   11ed6:	f7ff ffe6 	bl	11ea6 <net_buf_frag_insert>
   11eda:	4620      	mov	r0, r4
   11edc:	e7f5      	b.n	11eca <net_buf_frag_add+0xe>

00011ede <net_buf_frag_del>:
				       struct net_buf *frag,
				       const char *func, int line)
#else
struct net_buf *net_buf_frag_del(struct net_buf *parent, struct net_buf *frag)
#endif
{
   11ede:	b510      	push	{r4, lr}
	struct net_buf *next_frag;

	__ASSERT_NO_MSG(frag);

	if (parent) {
   11ee0:	b108      	cbz	r0, 11ee6 <net_buf_frag_del+0x8>
		__ASSERT_NO_MSG(parent->frags);
		__ASSERT_NO_MSG(parent->frags == frag);
		parent->frags = frag->frags;
   11ee2:	680b      	ldr	r3, [r1, #0]
   11ee4:	6003      	str	r3, [r0, #0]
	}

	next_frag = frag->frags;
   11ee6:	680c      	ldr	r4, [r1, #0]

	frag->frags = NULL;
   11ee8:	2300      	movs	r3, #0

#if defined(CONFIG_NET_BUF_LOG)
	net_buf_unref_debug(frag, func, line);
#else
	net_buf_unref(frag);
   11eea:	4608      	mov	r0, r1
	frag->frags = NULL;
   11eec:	600b      	str	r3, [r1, #0]
	net_buf_unref(frag);
   11eee:	f7fa fcb3 	bl	c858 <net_buf_unref>
#endif

	return next_frag;
}
   11ef2:	4620      	mov	r0, r4
   11ef4:	bd10      	pop	{r4, pc}

00011ef6 <net_buf_simple_add>:
	return buf->data + buf->len;
   11ef6:	8883      	ldrh	r3, [r0, #4]
   11ef8:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   11efa:	4419      	add	r1, r3
   11efc:	8081      	strh	r1, [r0, #4]
	return tail;
}
   11efe:	18d0      	adds	r0, r2, r3
   11f00:	4770      	bx	lr

00011f02 <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
   11f02:	b430      	push	{r4, r5}
   11f04:	8884      	ldrh	r4, [r0, #4]
   11f06:	6805      	ldr	r5, [r0, #0]
	buf->len += len;
   11f08:	18a3      	adds	r3, r4, r2
   11f0a:	8083      	strh	r3, [r0, #4]
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
   11f0c:	1928      	adds	r0, r5, r4
}
   11f0e:	bc30      	pop	{r4, r5}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
   11f10:	f7fd be49 	b.w	fba6 <memcpy>

00011f14 <net_buf_simple_add_u8>:
   11f14:	8883      	ldrh	r3, [r0, #4]
   11f16:	6802      	ldr	r2, [r0, #0]

uint8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, uint8_t val)
{
   11f18:	b510      	push	{r4, lr}
	buf->len += len;
   11f1a:	1c5c      	adds	r4, r3, #1
   11f1c:	8084      	strh	r4, [r0, #4]
	uint8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
   11f1e:	54d1      	strb	r1, [r2, r3]

	return u8;
}
   11f20:	18d0      	adds	r0, r2, r3
   11f22:	bd10      	pop	{r4, pc}

00011f24 <net_buf_simple_add_le16>:
   11f24:	8883      	ldrh	r3, [r0, #4]
   11f26:	6802      	ldr	r2, [r0, #0]

void net_buf_simple_add_le16(struct net_buf_simple *buf, uint16_t val)
{
   11f28:	b530      	push	{r4, r5, lr}
   11f2a:	18d4      	adds	r4, r2, r3
	buf->len += len;
   11f2c:	1c9d      	adds	r5, r3, #2
   11f2e:	8085      	strh	r5, [r0, #4]
	dst[0] = val;
   11f30:	54d1      	strb	r1, [r2, r3]
	dst[1] = val >> 8;
   11f32:	0a09      	lsrs	r1, r1, #8
   11f34:	7061      	strb	r1, [r4, #1]
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
}
   11f36:	bd30      	pop	{r4, r5, pc}

00011f38 <net_buf_simple_pull>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   11f38:	8882      	ldrh	r2, [r0, #4]
   11f3a:	1a52      	subs	r2, r2, r1
{
   11f3c:	4603      	mov	r3, r0
	buf->len -= len;
   11f3e:	8082      	strh	r2, [r0, #4]
	return buf->data += len;
   11f40:	6800      	ldr	r0, [r0, #0]
   11f42:	4408      	add	r0, r1
   11f44:	6018      	str	r0, [r3, #0]
}
   11f46:	4770      	bx	lr

00011f48 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
   11f48:	4603      	mov	r3, r0
	void *data = buf->data;
   11f4a:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   11f4c:	889a      	ldrh	r2, [r3, #4]
   11f4e:	1a52      	subs	r2, r2, r1
	buf->data += len;
   11f50:	4401      	add	r1, r0
	buf->len -= len;
   11f52:	809a      	strh	r2, [r3, #4]
	buf->data += len;
   11f54:	6019      	str	r1, [r3, #0]

	return data;
}
   11f56:	4770      	bx	lr

00011f58 <net_buf_simple_pull_u8>:

uint8_t net_buf_simple_pull_u8(struct net_buf_simple *buf)
{
   11f58:	b510      	push	{r4, lr}
	uint8_t val;

	val = buf->data[0];
   11f5a:	6803      	ldr	r3, [r0, #0]
   11f5c:	781c      	ldrb	r4, [r3, #0]
	net_buf_simple_pull(buf, 1);
   11f5e:	2101      	movs	r1, #1
   11f60:	f7ff ffea 	bl	11f38 <net_buf_simple_pull>

	return val;
}
   11f64:	4620      	mov	r0, r4
   11f66:	bd10      	pop	{r4, pc}

00011f68 <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   11f68:	6802      	ldr	r2, [r0, #0]
   11f6a:	6880      	ldr	r0, [r0, #8]
}
   11f6c:	1a10      	subs	r0, r2, r0
   11f6e:	4770      	bx	lr

00011f70 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   11f70:	6903      	ldr	r3, [r0, #16]
   11f72:	b2c9      	uxtb	r1, r1
   11f74:	220c      	movs	r2, #12
   11f76:	fb01 3302 	mla	r3, r1, r2, r3
   11f7a:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
   11f7c:	f000 0007 	and.w	r0, r0, #7
   11f80:	4770      	bx	lr

00011f82 <set_on_state>:
	__asm__ volatile(
   11f82:	f04f 0320 	mov.w	r3, #32
   11f86:	f3ef 8211 	mrs	r2, BASEPRI
   11f8a:	f383 8812 	msr	BASEPRI_MAX, r3
   11f8e:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   11f92:	6803      	ldr	r3, [r0, #0]
   11f94:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   11f98:	f043 0302 	orr.w	r3, r3, #2
   11f9c:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   11f9e:	f382 8811 	msr	BASEPRI, r2
   11fa2:	f3bf 8f6f 	isb	sy
}
   11fa6:	4770      	bx	lr

00011fa8 <stop>:
{
   11fa8:	4603      	mov	r3, r0
   11faa:	b570      	push	{r4, r5, r6, lr}
	struct nrf_clock_control_data *data = dev->data;
   11fac:	6900      	ldr	r0, [r0, #16]
	return &data->subsys[type];
   11fae:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
   11fb0:	f04f 0420 	mov.w	r4, #32
   11fb4:	f3ef 8611 	mrs	r6, BASEPRI
   11fb8:	f384 8812 	msr	BASEPRI_MAX, r4
   11fbc:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   11fc0:	250c      	movs	r5, #12
   11fc2:	fb05 0401 	mla	r4, r5, r1, r0
   11fc6:	6c24      	ldr	r4, [r4, #64]	; 0x40
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   11fc8:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
   11fcc:	d001      	beq.n	11fd2 <stop+0x2a>
   11fce:	42a2      	cmp	r2, r4
   11fd0:	d110      	bne.n	11ff4 <stop+0x4c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   11fd2:	fb05 0001 	mla	r0, r5, r1, r0
   11fd6:	2201      	movs	r2, #1
   11fd8:	6402      	str	r2, [r0, #64]	; 0x40
	int err = 0;
   11fda:	2000      	movs	r0, #0
	__asm__ volatile(
   11fdc:	f386 8811 	msr	BASEPRI, r6
   11fe0:	f3bf 8f6f 	isb	sy
	if (err < 0) {
   11fe4:	b928      	cbnz	r0, 11ff2 <stop+0x4a>
	get_sub_config(dev, type)->stop();
   11fe6:	685b      	ldr	r3, [r3, #4]
   11fe8:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   11fec:	684b      	ldr	r3, [r1, #4]
   11fee:	4798      	blx	r3
	return 0;
   11ff0:	2000      	movs	r0, #0
}
   11ff2:	bd70      	pop	{r4, r5, r6, pc}
		err = -EPERM;
   11ff4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   11ff8:	e7f0      	b.n	11fdc <stop+0x34>

00011ffa <api_stop>:
	return stop(dev, subsys, CTX_API);
   11ffa:	2280      	movs	r2, #128	; 0x80
   11ffc:	f7ff bfd4 	b.w	11fa8 <stop>

00012000 <async_start>:
{
   12000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12002:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
   12004:	6904      	ldr	r4, [r0, #16]
{
   12006:	4605      	mov	r5, r0
   12008:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
   1200a:	f04f 0020 	mov.w	r0, #32
   1200e:	f3ef 8c11 	mrs	ip, BASEPRI
   12012:	f380 8812 	msr	BASEPRI_MAX, r0
   12016:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   1201a:	260c      	movs	r6, #12
   1201c:	fb06 4601 	mla	r6, r6, r1, r4
   12020:	6c30      	ldr	r0, [r6, #64]	; 0x40
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   12022:	f000 0e07 	and.w	lr, r0, #7
   12026:	f1be 0f01 	cmp.w	lr, #1
   1202a:	d111      	bne.n	12050 <async_start+0x50>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   1202c:	6437      	str	r7, [r6, #64]	; 0x40
	int err = 0;
   1202e:	2600      	movs	r6, #0
	__asm__ volatile(
   12030:	f38c 8811 	msr	BASEPRI, ip
   12034:	f3bf 8f6f 	isb	sy
	if (err < 0) {
   12038:	b946      	cbnz	r6, 1204c <async_start+0x4c>
	subdata->cb = cb;
   1203a:	200c      	movs	r0, #12
   1203c:	fb00 4401 	mla	r4, r0, r1, r4
	subdata->user_data = user_data;
   12040:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   12044:	686b      	ldr	r3, [r5, #4]
   12046:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
   1204a:	4798      	blx	r3
}
   1204c:	4630      	mov	r0, r6
   1204e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   12050:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
		err = -EALREADY;
   12054:	4287      	cmp	r7, r0
   12056:	bf14      	ite	ne
   12058:	f04f 36ff 	movne.w	r6, #4294967295	; 0xffffffff
   1205c:	f06f 0677 	mvneq.w	r6, #119	; 0x77
   12060:	e7e6      	b.n	12030 <async_start+0x30>

00012062 <api_start>:
{
   12062:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
   12064:	2480      	movs	r4, #128	; 0x80
   12066:	9400      	str	r4, [sp, #0]
   12068:	f7ff ffca 	bl	12000 <async_start>
}
   1206c:	b002      	add	sp, #8
   1206e:	bd10      	pop	{r4, pc}

00012070 <onoff_started_callback>:
	return &data->mgr[type];
   12070:	6900      	ldr	r0, [r0, #16]
{
   12072:	b410      	push	{r4}
	return &data->mgr[type];
   12074:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   12076:	241c      	movs	r4, #28
   12078:	fb03 0004 	mla	r0, r3, r4, r0
   1207c:	2100      	movs	r1, #0
}
   1207e:	bc10      	pop	{r4}
	notify(mgr, 0);
   12080:	4710      	bx	r2

00012082 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   12082:	2000      	movs	r0, #0
   12084:	f000 b906 	b.w	12294 <nrfx_clock_start>

00012088 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   12088:	2000      	movs	r0, #0
   1208a:	f7fb bcc9 	b.w	da20 <nrfx_clock_stop>

0001208e <blocking_start_callback>:
{
   1208e:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   12090:	f7fc baf4 	b.w	e67c <z_impl_k_sem_give>

00012094 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   12094:	6843      	ldr	r3, [r0, #4]
   12096:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   12098:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
   1209c:	600b      	str	r3, [r1, #0]
}
   1209e:	2000      	movs	r0, #0
   120a0:	4770      	bx	lr

000120a2 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   120a2:	6843      	ldr	r3, [r0, #4]
   120a4:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   120a6:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   120aa:	4042      	eors	r2, r0
   120ac:	400a      	ands	r2, r1
   120ae:	4042      	eors	r2, r0
    p_reg->OUT = value;
   120b0:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
   120b4:	2000      	movs	r0, #0
   120b6:	4770      	bx	lr

000120b8 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   120b8:	6843      	ldr	r3, [r0, #4]
   120ba:	685b      	ldr	r3, [r3, #4]
}
   120bc:	2000      	movs	r0, #0
    p_reg->OUTSET = set_mask;
   120be:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
   120c2:	4770      	bx	lr

000120c4 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   120c4:	6843      	ldr	r3, [r0, #4]
   120c6:	685b      	ldr	r3, [r3, #4]
}
   120c8:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   120ca:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
   120ce:	4770      	bx	lr

000120d0 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   120d0:	6843      	ldr	r3, [r0, #4]
   120d2:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   120d4:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value ^ mask);
   120d8:	404b      	eors	r3, r1
    p_reg->OUT = value;
   120da:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
   120de:	2000      	movs	r0, #0
   120e0:	4770      	bx	lr

000120e2 <gpio_nrfx_manage_callback>:
	return port->data;
   120e2:	6903      	ldr	r3, [r0, #16]
	return list->head;
   120e4:	6858      	ldr	r0, [r3, #4]
{
   120e6:	b530      	push	{r4, r5, lr}
	if (!sys_slist_is_empty(callbacks)) {
   120e8:	b158      	cbz	r0, 12102 <gpio_nrfx_manage_callback+0x20>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   120ea:	2400      	movs	r4, #0
   120ec:	4281      	cmp	r1, r0
   120ee:	d112      	bne.n	12116 <gpio_nrfx_manage_callback+0x34>
	return node->next;
   120f0:	6808      	ldr	r0, [r1, #0]
	return list->tail;
   120f2:	689d      	ldr	r5, [r3, #8]
Z_GENLIST_REMOVE(slist, snode)
   120f4:	b954      	cbnz	r4, 1210c <gpio_nrfx_manage_callback+0x2a>
   120f6:	428d      	cmp	r5, r1
	list->head = node;
   120f8:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   120fa:	d100      	bne.n	120fe <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   120fc:	6098      	str	r0, [r3, #8]
	parent->next = child;
   120fe:	2000      	movs	r0, #0
   12100:	6008      	str	r0, [r1, #0]
	if (set) {
   12102:	b96a      	cbnz	r2, 12120 <gpio_nrfx_manage_callback+0x3e>
	return 0;
   12104:	2000      	movs	r0, #0
}
   12106:	bd30      	pop	{r4, r5, pc}
   12108:	4628      	mov	r0, r5
   1210a:	e7ef      	b.n	120ec <gpio_nrfx_manage_callback+0xa>
Z_GENLIST_REMOVE(slist, snode)
   1210c:	428d      	cmp	r5, r1
	parent->next = child;
   1210e:	6020      	str	r0, [r4, #0]
	list->tail = node;
   12110:	bf08      	it	eq
   12112:	609c      	streq	r4, [r3, #8]
}
   12114:	e7f3      	b.n	120fe <gpio_nrfx_manage_callback+0x1c>
	return node->next;
   12116:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   12118:	4604      	mov	r4, r0
   1211a:	2d00      	cmp	r5, #0
   1211c:	d1f4      	bne.n	12108 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   1211e:	b13a      	cbz	r2, 12130 <gpio_nrfx_manage_callback+0x4e>
Z_GENLIST_PREPEND(slist, snode)
   12120:	6898      	ldr	r0, [r3, #8]
	parent->next = child;
   12122:	685a      	ldr	r2, [r3, #4]
   12124:	600a      	str	r2, [r1, #0]
	list->head = node;
   12126:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   12128:	2800      	cmp	r0, #0
   1212a:	d1eb      	bne.n	12104 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   1212c:	6099      	str	r1, [r3, #8]
}
   1212e:	e7ea      	b.n	12106 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   12130:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   12134:	e7e7      	b.n	12106 <gpio_nrfx_manage_callback+0x24>

00012136 <uarte_nrfx_config_get>:
	*cfg = get_dev_data(dev)->uart_config;
   12136:	6902      	ldr	r2, [r0, #16]
{
   12138:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   1213a:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
   1213e:	e883 0003 	stmia.w	r3, {r0, r1}
}
   12142:	2000      	movs	r0, #0
   12144:	4770      	bx	lr

00012146 <uarte_nrfx_err_check>:
	return config->uarte_regs;
   12146:	6843      	ldr	r3, [r0, #4]
   12148:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   1214a:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   1214e:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   12152:	4770      	bx	lr

00012154 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   12154:	6843      	ldr	r3, [r0, #4]
	return dev->data;
   12156:	6902      	ldr	r2, [r0, #16]
	return config->uarte_regs;
   12158:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1215a:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   1215e:	b148      	cbz	r0, 12174 <uarte_nrfx_poll_in+0x20>
	*c = data->rx_data;
   12160:	7c52      	ldrb	r2, [r2, #17]
   12162:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12164:	2000      	movs	r0, #0
   12166:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   1216a:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1216e:	2201      	movs	r2, #1
   12170:	601a      	str	r2, [r3, #0]
	return 0;
   12172:	4770      	bx	lr
		return -1;
   12174:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   12178:	4770      	bx	lr

0001217a <nrf_gpio_cfg_input>:
{
   1217a:	b507      	push	{r0, r1, r2, lr}
   1217c:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1217e:	a801      	add	r0, sp, #4
   12180:	f7fa fed4 	bl	cf2c <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
   12184:	9b01      	ldr	r3, [sp, #4]
   12186:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   1218a:	0089      	lsls	r1, r1, #2
    reg->PIN_CNF[pin_number] = cnf;
   1218c:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
}
   12190:	b003      	add	sp, #12
   12192:	f85d fb04 	ldr.w	pc, [sp], #4

00012196 <is_tx_ready.isra.0>:
	return config->uarte_regs;
   12196:	6802      	ldr	r2, [r0, #0]
static bool is_tx_ready(const struct device *dev)
   12198:	4603      	mov	r3, r0
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1219a:	f8d2 0158 	ldr.w	r0, [r2, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   1219e:	b940      	cbnz	r0, 121b2 <is_tx_ready.isra.0+0x1c>
	bool ppi_endtx = get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   121a0:	685b      	ldr	r3, [r3, #4]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   121a2:	079b      	lsls	r3, r3, #30
   121a4:	d406      	bmi.n	121b4 <is_tx_ready.isra.0+0x1e>
   121a6:	f8d2 0120 	ldr.w	r0, [r2, #288]	; 0x120
   121aa:	3800      	subs	r0, #0
   121ac:	bf18      	it	ne
   121ae:	2001      	movne	r0, #1
   121b0:	4770      	bx	lr
   121b2:	2001      	movs	r0, #1
}
   121b4:	4770      	bx	lr

000121b6 <uarte_nrfx_isr_int>:
	return config->uarte_regs;
   121b6:	6843      	ldr	r3, [r0, #4]
   121b8:	681b      	ldr	r3, [r3, #0]
    return p_reg->INTENSET & mask;
   121ba:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   121be:	05d1      	lsls	r1, r2, #23
   121c0:	d518      	bpl.n	121f4 <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   121c2:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   121c6:	b1aa      	cbz	r2, 121f4 <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
   121c8:	f04f 0120 	mov.w	r1, #32
   121cc:	f3ef 8211 	mrs	r2, BASEPRI
   121d0:	f381 8812 	msr	BASEPRI_MAX, r1
   121d4:	f3bf 8f6f 	isb	sy
   121d8:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   121dc:	b131      	cbz	r1, 121ec <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   121de:	2100      	movs	r1, #0
   121e0:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   121e4:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   121e8:	2101      	movs	r1, #1
   121ea:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   121ec:	f382 8811 	msr	BASEPRI, r2
   121f0:	f3bf 8f6f 	isb	sy
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   121f4:	6842      	ldr	r2, [r0, #4]
   121f6:	6852      	ldr	r2, [r2, #4]
   121f8:	06d2      	lsls	r2, r2, #27
   121fa:	d515      	bpl.n	12228 <uarte_nrfx_isr_int+0x72>
	__asm__ volatile(
   121fc:	f04f 0120 	mov.w	r1, #32
   12200:	f3ef 8211 	mrs	r2, BASEPRI
   12204:	f381 8812 	msr	BASEPRI_MAX, r1
   12208:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1220c:	f8d3 1158 	ldr.w	r1, [r3, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   12210:	b111      	cbz	r1, 12218 <uarte_nrfx_isr_int+0x62>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   12212:	2100      	movs	r1, #0
   12214:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_reg->INTENCLR = mask;
   12218:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   1221c:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
	__asm__ volatile(
   12220:	f382 8811 	msr	BASEPRI, r2
   12224:	f3bf 8f6f 	isb	sy
}
   12228:	4770      	bx	lr

0001222a <uarte_1_init>:
#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
#endif

#ifdef CONFIG_UART_1_NRF_UARTE
UART_NRF_UARTE_DEVICE(1);
   1222a:	b510      	push	{r4, lr}
   1222c:	2200      	movs	r2, #0
   1222e:	4604      	mov	r4, r0
   12230:	2101      	movs	r1, #1
   12232:	2028      	movs	r0, #40	; 0x28
   12234:	f7f0 f97a 	bl	252c <z_arm_irq_priority_set>
   12238:	2028      	movs	r0, #40	; 0x28
   1223a:	f7f0 f945 	bl	24c8 <arch_irq_enable>
   1223e:	4620      	mov	r0, r4
   12240:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   12244:	f7fa bf94 	b.w	d170 <uarte_instance_init.constprop.0>

00012248 <uarte_0_init>:
UART_NRF_UARTE_DEVICE(0);
   12248:	b510      	push	{r4, lr}
   1224a:	2200      	movs	r2, #0
   1224c:	4604      	mov	r4, r0
   1224e:	2101      	movs	r1, #1
   12250:	2002      	movs	r0, #2
   12252:	f7f0 f96b 	bl	252c <z_arm_irq_priority_set>
   12256:	2002      	movs	r0, #2
   12258:	f7f0 f936 	bl	24c8 <arch_irq_enable>
   1225c:	4620      	mov	r0, r4
   1225e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   12262:	f7fa bf85 	b.w	d170 <uarte_instance_init.constprop.0>

00012266 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   12266:	4770      	bx	lr

00012268 <nrf52_errata_136>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
   12268:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
   1226c:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
}
   12270:	f1a0 0308 	sub.w	r3, r0, #8
   12274:	4258      	negs	r0, r3
   12276:	4158      	adcs	r0, r3
   12278:	4770      	bx	lr

0001227a <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   1227a:	4700      	bx	r0

0001227c <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   1227c:	f000 bbed 	b.w	12a5a <z_impl_k_busy_wait>

00012280 <nrfx_clock_enable>:
{
   12280:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   12282:	2000      	movs	r0, #0
   12284:	f7f0 f944 	bl	2510 <arch_irq_is_enabled>
   12288:	b918      	cbnz	r0, 12292 <nrfx_clock_enable+0x12>
}
   1228a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   1228e:	f7f0 b91b 	b.w	24c8 <arch_irq_enable>
   12292:	bd08      	pop	{r3, pc}

00012294 <nrfx_clock_start>:
    switch (domain)
   12294:	b110      	cbz	r0, 1229c <nrfx_clock_start+0x8>
   12296:	2801      	cmp	r0, #1
   12298:	d01d      	beq.n	122d6 <nrfx_clock_start+0x42>
   1229a:	4770      	bx	lr
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   1229c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   122a0:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   122a4:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
   122a8:	03c9      	lsls	r1, r1, #15
   122aa:	d512      	bpl.n	122d2 <nrfx_clock_start+0x3e>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
   122ac:	f002 0203 	and.w	r2, r2, #3
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
   122b0:	2a01      	cmp	r2, #1
   122b2:	d10e      	bne.n	122d2 <nrfx_clock_start+0x3e>
    p_reg->LFCLKSRC = (uint32_t)(source);
   122b4:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   122b8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   122bc:	2200      	movs	r2, #0
   122be:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   122c2:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    p_reg->INTENSET = mask;
   122c6:	2202      	movs	r2, #2
   122c8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   122cc:	2201      	movs	r2, #1
   122ce:	609a      	str	r2, [r3, #8]
}
   122d0:	4770      	bx	lr
    p_reg->LFCLKSRC = (uint32_t)(source);
   122d2:	2200      	movs	r2, #0
   122d4:	e7ee      	b.n	122b4 <nrfx_clock_start+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   122d6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   122da:	2200      	movs	r2, #0
   122dc:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   122e0:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
   122e4:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   122e8:	6018      	str	r0, [r3, #0]
}
   122ea:	4770      	bx	lr

000122ec <nrf_gpio_reconfigure>:
{
   122ec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   122ee:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   122f0:	a801      	add	r0, sp, #4
{
   122f2:	e9dd 4608 	ldrd	r4, r6, [sp, #32]
   122f6:	4617      	mov	r7, r2
   122f8:	461d      	mov	r5, r3
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   122fa:	f7fb fc01 	bl	db00 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   122fe:	9b01      	ldr	r3, [sp, #4]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   12300:	2f00      	cmp	r7, #0
   12302:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   12306:	bf14      	ite	ne
   12308:	2302      	movne	r3, #2
   1230a:	2300      	moveq	r3, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   1230c:	2900      	cmp	r1, #0
   1230e:	bf18      	it	ne
   12310:	f043 0301 	orrne.w	r3, r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   12314:	2d00      	cmp	r5, #0
   12316:	bf14      	ite	ne
   12318:	f04f 0c0c 	movne.w	ip, #12
   1231c:	f04f 0c00 	moveq.w	ip, #0
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   12320:	2c00      	cmp	r4, #0
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   12322:	ea43 030c 	orr.w	r3, r3, ip
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   12326:	bf14      	ite	ne
   12328:	f44f 6ce0 	movne.w	ip, #1792	; 0x700
   1232c:	f04f 0c00 	moveq.w	ip, #0
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
   12330:	2e00      	cmp	r6, #0
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   12332:	ea43 030c 	orr.w	r3, r3, ip
    uint32_t cnf = reg->PIN_CNF[pin_number];
   12336:	f8d0 2700 	ldr.w	r2, [r0, #1792]	; 0x700
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
   1233a:	bf14      	ite	ne
   1233c:	f44f 3c40 	movne.w	ip, #196608	; 0x30000
   12340:	f04f 0c00 	moveq.w	ip, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   12344:	ea43 030c 	orr.w	r3, r3, ip
    cnf &= ~to_update;
   12348:	ea22 0303 	bic.w	r3, r2, r3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   1234c:	b101      	cbz	r1, 12350 <nrf_gpio_reconfigure+0x64>
   1234e:	7809      	ldrb	r1, [r1, #0]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   12350:	b10f      	cbz	r7, 12356 <nrf_gpio_reconfigure+0x6a>
   12352:	783f      	ldrb	r7, [r7, #0]
   12354:	007f      	lsls	r7, r7, #1
   12356:	4319      	orrs	r1, r3
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   12358:	b10d      	cbz	r5, 1235e <nrf_gpio_reconfigure+0x72>
   1235a:	782d      	ldrb	r5, [r5, #0]
   1235c:	00ad      	lsls	r5, r5, #2
   1235e:	4339      	orrs	r1, r7
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   12360:	b10c      	cbz	r4, 12366 <nrf_gpio_reconfigure+0x7a>
   12362:	7822      	ldrb	r2, [r4, #0]
   12364:	0214      	lsls	r4, r2, #8
   12366:	430d      	orrs	r5, r1
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
   12368:	b10e      	cbz	r6, 1236e <nrf_gpio_reconfigure+0x82>
   1236a:	7836      	ldrb	r6, [r6, #0]
   1236c:	0436      	lsls	r6, r6, #16
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   1236e:	432c      	orrs	r4, r5
   12370:	4334      	orrs	r4, r6
    reg->PIN_CNF[pin_number] = cnf;
   12372:	f8c0 4700 	str.w	r4, [r0, #1792]	; 0x700
}
   12376:	b003      	add	sp, #12
   12378:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001237a <nrf_gpio_cfg_sense_set>:
{
   1237a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
   1237c:	f10d 030f 	add.w	r3, sp, #15
   12380:	9301      	str	r3, [sp, #4]
   12382:	2300      	movs	r3, #0
{
   12384:	f88d 100f 	strb.w	r1, [sp, #15]
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
   12388:	9300      	str	r3, [sp, #0]
   1238a:	461a      	mov	r2, r3
   1238c:	4619      	mov	r1, r3
   1238e:	f7ff ffad 	bl	122ec <nrf_gpio_reconfigure>
}
   12392:	b005      	add	sp, #20
   12394:	f85d fb04 	ldr.w	pc, [sp], #4

00012398 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   12398:	f7fb bf18 	b.w	e1cc <_DoInit>

0001239c <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
   1239c:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   1239e:	f7ff fffb 	bl	12398 <SEGGER_RTT_Init>

	return 0;
}
   123a2:	2000      	movs	r0, #0
   123a4:	bd08      	pop	{r3, pc}

000123a6 <z_device_state_init>:
}
   123a6:	4770      	bx	lr

000123a8 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   123a8:	b138      	cbz	r0, 123ba <z_device_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   123aa:	68c3      	ldr	r3, [r0, #12]
   123ac:	8818      	ldrh	r0, [r3, #0]
   123ae:	f3c0 0008 	ubfx	r0, r0, #0, #9
   123b2:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
   123b6:	4258      	negs	r0, r3
   123b8:	4158      	adcs	r0, r3
}
   123ba:	4770      	bx	lr

000123bc <arch_system_halt>:
	__asm__ volatile(
   123bc:	f04f 0220 	mov.w	r2, #32
   123c0:	f3ef 8311 	mrs	r3, BASEPRI
   123c4:	f382 8812 	msr	BASEPRI_MAX, r2
   123c8:	f3bf 8f6f 	isb	sy
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
   123cc:	e7fe      	b.n	123cc <arch_system_halt+0x10>

000123ce <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
   123ce:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
   123d0:	f7ff fff4 	bl	123bc <arch_system_halt>

000123d4 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   123d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   123d6:	4605      	mov	r5, r0
   123d8:	460e      	mov	r6, r1
   123da:	f04f 0320 	mov.w	r3, #32
   123de:	f3ef 8711 	mrs	r7, BASEPRI
   123e2:	f383 8812 	msr	BASEPRI_MAX, r3
   123e6:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   123ea:	f7fc fd91 	bl	ef10 <z_impl_z_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
   123ee:	4631      	mov	r1, r6
   123f0:	4604      	mov	r4, r0
   123f2:	4628      	mov	r0, r5
   123f4:	f7ff ffeb 	bl	123ce <k_sys_fatal_error_handler>
	__asm__ volatile(
   123f8:	f387 8811 	msr	BASEPRI, r7
   123fc:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   12400:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   12402:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   12406:	f7f0 bac7 	b.w	2998 <z_impl_k_thread_abort>

0001240a <k_heap_init>:
{
   1240a:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   1240c:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   12410:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   12414:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   12416:	f7fd bab2 	b.w	f97e <sys_heap_init>

0001241a <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   1241a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1241e:	b085      	sub	sp, #20
   12420:	4606      	mov	r6, r0
   12422:	4688      	mov	r8, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   12424:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
{
   12428:	4691      	mov	r9, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   1242a:	f000 fb1a 	bl	12a62 <sys_clock_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   1242e:	f106 0a14 	add.w	sl, r6, #20
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   12432:	4605      	mov	r5, r0
   12434:	460f      	mov	r7, r1
	__asm__ volatile(
   12436:	f04f 0320 	mov.w	r3, #32
   1243a:	f3ef 8411 	mrs	r4, BASEPRI
   1243e:	f383 8812 	msr	BASEPRI_MAX, r3
   12442:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   12446:	f106 0b0c 	add.w	fp, r6, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   1244a:	464a      	mov	r2, r9
   1244c:	4641      	mov	r1, r8
   1244e:	4630      	mov	r0, r6
   12450:	f7fd fa2d 	bl	f8ae <sys_heap_aligned_alloc>
   12454:	9003      	str	r0, [sp, #12]
		now = sys_clock_tick_get();
   12456:	f7fc ff11 	bl	f27c <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   1245a:	9b03      	ldr	r3, [sp, #12]
   1245c:	b13b      	cbz	r3, 1246e <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
   1245e:	f384 8811 	msr	BASEPRI, r4
   12462:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   12466:	4618      	mov	r0, r3
   12468:	b005      	add	sp, #20
   1246a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   1246e:	1a28      	subs	r0, r5, r0
   12470:	eb67 0101 	sbc.w	r1, r7, r1
   12474:	2801      	cmp	r0, #1
   12476:	f171 0200 	sbcs.w	r2, r1, #0
   1247a:	dbf0      	blt.n	1245e <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   1247c:	e9cd 0100 	strd	r0, r1, [sp]
   12480:	465a      	mov	r2, fp
   12482:	4621      	mov	r1, r4
   12484:	4650      	mov	r0, sl
   12486:	f7fc fc33 	bl	ecf0 <z_pend_curr>
	__asm__ volatile(
   1248a:	f04f 0320 	mov.w	r3, #32
   1248e:	f3ef 8411 	mrs	r4, BASEPRI
   12492:	f383 8812 	msr	BASEPRI_MAX, r3
   12496:	f3bf 8f6f 	isb	sy
   1249a:	e7d6      	b.n	1244a <k_heap_aligned_alloc+0x30>

0001249c <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
   1249c:	b538      	push	{r3, r4, r5, lr}
   1249e:	4604      	mov	r4, r0
   124a0:	f04f 0320 	mov.w	r3, #32
   124a4:	f3ef 8511 	mrs	r5, BASEPRI
   124a8:	f383 8812 	msr	BASEPRI_MAX, r3
   124ac:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   124b0:	f7fd f9c5 	bl	f83e <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   124b4:	f104 000c 	add.w	r0, r4, #12
   124b8:	f000 fa5c 	bl	12974 <z_unpend_all>
   124bc:	b130      	cbz	r0, 124cc <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   124be:	4629      	mov	r1, r5
   124c0:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   124c4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   124c8:	f7fc bac0 	b.w	ea4c <z_reschedule>
	__asm__ volatile(
   124cc:	f385 8811 	msr	BASEPRI, r5
   124d0:	f3bf 8f6f 	isb	sy
}
   124d4:	bd38      	pop	{r3, r4, r5, pc}

000124d6 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   124d6:	f3ef 8005 	mrs	r0, IPSR
}
   124da:	3800      	subs	r0, #0
   124dc:	bf18      	it	ne
   124de:	2001      	movne	r0, #1
   124e0:	4770      	bx	lr

000124e2 <z_impl_k_thread_name_set>:
}
   124e2:	f06f 0057 	mvn.w	r0, #87	; 0x57
   124e6:	4770      	bx	lr

000124e8 <z_impl_k_thread_start>:
	z_sched_start(thread);
   124e8:	f7fc bba6 	b.w	ec38 <z_sched_start>

000124ec <z_pm_save_idle_exit>:
{
   124ec:	b508      	push	{r3, lr}
	pm_system_resume();
   124ee:	f7ef ff09 	bl	2304 <pm_system_resume>
}
   124f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   124f6:	f7ff beb6 	b.w	12266 <sys_clock_idle_exit>

000124fa <queue_insert>:
{
   124fa:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   124fe:	4699      	mov	r9, r3
   12500:	4604      	mov	r4, r0
   12502:	f89d 3020 	ldrb.w	r3, [sp, #32]
   12506:	460d      	mov	r5, r1
   12508:	4690      	mov	r8, r2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   1250a:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
   1250e:	f04f 0220 	mov.w	r2, #32
   12512:	f3ef 8711 	mrs	r7, BASEPRI
   12516:	f382 8812 	msr	BASEPRI_MAX, r2
   1251a:	f3bf 8f6f 	isb	sy
	if (is_append) {
   1251e:	b103      	cbz	r3, 12522 <queue_insert+0x28>
	return list->tail;
   12520:	6845      	ldr	r5, [r0, #4]
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   12522:	4630      	mov	r0, r6
   12524:	f000 fa0e 	bl	12944 <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   12528:	b158      	cbz	r0, 12542 <queue_insert+0x48>
   1252a:	2400      	movs	r4, #0
   1252c:	67c4      	str	r4, [r0, #124]	; 0x7c
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   1252e:	f8c0 8014 	str.w	r8, [r0, #20]
	z_ready_thread(thread);
   12532:	f000 f9ab 	bl	1288c <z_ready_thread>
	z_reschedule(&queue->lock, key);
   12536:	4630      	mov	r0, r6
   12538:	4639      	mov	r1, r7
   1253a:	f7fc fa87 	bl	ea4c <z_reschedule>
	return 0;
   1253e:	2000      	movs	r0, #0
   12540:	e00c      	b.n	1255c <queue_insert+0x62>
	if (alloc) {
   12542:	f1b9 0f00 	cmp.w	r9, #0
   12546:	d01b      	beq.n	12580 <queue_insert+0x86>
	return z_thread_aligned_alloc(0, size);
   12548:	2108      	movs	r1, #8
   1254a:	f7fc ff33 	bl	f3b4 <z_thread_aligned_alloc>
		if (anode == NULL) {
   1254e:	b938      	cbnz	r0, 12560 <queue_insert+0x66>
	__asm__ volatile(
   12550:	f387 8811 	msr	BASEPRI, r7
   12554:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   12558:	f06f 000b 	mvn.w	r0, #11
}
   1255c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   12560:	2301      	movs	r3, #1
		anode->data = data;
   12562:	f8c0 8004 	str.w	r8, [r0, #4]
   12566:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   12568:	6803      	ldr	r3, [r0, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1256a:	f003 0203 	and.w	r2, r3, #3
Z_GENLIST_INSERT(sflist, sfnode)
   1256e:	b95d      	cbnz	r5, 12588 <queue_insert+0x8e>
	parent->next_and_flags = cur_flags | (unative_t)child;
   12570:	6823      	ldr	r3, [r4, #0]
   12572:	4313      	orrs	r3, r2
   12574:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   12576:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   12578:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   1257a:	b973      	cbnz	r3, 1259a <queue_insert+0xa0>
	list->tail = node;
   1257c:	6060      	str	r0, [r4, #4]
}
   1257e:	e00c      	b.n	1259a <queue_insert+0xa0>
	node->next_and_flags = flags;
   12580:	f8c8 9000 	str.w	r9, [r8]
}
   12584:	4640      	mov	r0, r8
   12586:	e7ef      	b.n	12568 <queue_insert+0x6e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   12588:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   1258a:	f033 0303 	bics.w	r3, r3, #3
   1258e:	d110      	bne.n	125b2 <queue_insert+0xb8>
	parent->next_and_flags = cur_flags | (unative_t)child;
   12590:	6002      	str	r2, [r0, #0]
	return list->tail;
   12592:	6862      	ldr	r2, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
   12594:	b93a      	cbnz	r2, 125a6 <queue_insert+0xac>
	list->head = node;
   12596:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   1259a:	2104      	movs	r1, #4
   1259c:	f104 0010 	add.w	r0, r4, #16
   125a0:	f000 fbbc 	bl	12d1c <z_handle_obj_poll_events>
   125a4:	e7c7      	b.n	12536 <queue_insert+0x3c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   125a6:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   125a8:	f003 0303 	and.w	r3, r3, #3
   125ac:	4303      	orrs	r3, r0
   125ae:	6013      	str	r3, [r2, #0]
   125b0:	e7e4      	b.n	1257c <queue_insert+0x82>
   125b2:	4313      	orrs	r3, r2
   125b4:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   125b6:	682b      	ldr	r3, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   125b8:	f003 0303 	and.w	r3, r3, #3
   125bc:	4303      	orrs	r3, r0
   125be:	602b      	str	r3, [r5, #0]
}
   125c0:	e7eb      	b.n	1259a <queue_insert+0xa0>

000125c2 <z_queue_node_peek>:
{
   125c2:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
   125c4:	4604      	mov	r4, r0
   125c6:	b130      	cbz	r0, 125d6 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   125c8:	6802      	ldr	r2, [r0, #0]
   125ca:	0793      	lsls	r3, r2, #30
   125cc:	d003      	beq.n	125d6 <z_queue_node_peek+0x14>
		ret = anode->data;
   125ce:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   125d0:	b109      	cbz	r1, 125d6 <z_queue_node_peek+0x14>
			k_free(anode);
   125d2:	f000 fbb1 	bl	12d38 <k_free>
}
   125d6:	4620      	mov	r0, r4
   125d8:	bd10      	pop	{r4, pc}

000125da <k_queue_append>:
{
   125da:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, true);
   125dc:	2301      	movs	r3, #1
   125de:	9300      	str	r3, [sp, #0]
   125e0:	2300      	movs	r3, #0
{
   125e2:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
   125e4:	4619      	mov	r1, r3
   125e6:	f7ff ff88 	bl	124fa <queue_insert>
}
   125ea:	b003      	add	sp, #12
   125ec:	f85d fb04 	ldr.w	pc, [sp], #4

000125f0 <k_queue_prepend>:
{
   125f0:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, false);
   125f2:	2300      	movs	r3, #0
{
   125f4:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, false);
   125f6:	9300      	str	r3, [sp, #0]
   125f8:	4619      	mov	r1, r3
   125fa:	f7ff ff7e 	bl	124fa <queue_insert>
}
   125fe:	b003      	add	sp, #12
   12600:	f85d fb04 	ldr.w	pc, [sp], #4

00012604 <k_queue_append_list>:
{
   12604:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   12608:	4605      	mov	r5, r0
   1260a:	4616      	mov	r6, r2
	CHECKIF(head == NULL || tail == NULL) {
   1260c:	460c      	mov	r4, r1
   1260e:	b391      	cbz	r1, 12676 <k_queue_append_list+0x72>
   12610:	b38a      	cbz	r2, 12676 <k_queue_append_list+0x72>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   12612:	f100 0708 	add.w	r7, r0, #8
	__asm__ volatile(
   12616:	f04f 0320 	mov.w	r3, #32
   1261a:	f3ef 8811 	mrs	r8, BASEPRI
   1261e:	f383 8812 	msr	BASEPRI_MAX, r3
   12622:	f3bf 8f6f 	isb	sy
		thread = z_unpend_first_thread(&queue->wait_q);
   12626:	4638      	mov	r0, r7
   12628:	f000 f98c 	bl	12944 <z_unpend_first_thread>
   1262c:	f04f 0900 	mov.w	r9, #0
	while ((head != NULL) && (thread != NULL)) {
   12630:	b920      	cbnz	r0, 1263c <k_queue_append_list+0x38>
	return list->tail;
   12632:	686a      	ldr	r2, [r5, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   12634:	b9ca      	cbnz	r2, 1266a <k_queue_append_list+0x66>
	list->head = node;
   12636:	602c      	str	r4, [r5, #0]
	list->tail = node;
   12638:	606e      	str	r6, [r5, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   1263a:	e00a      	b.n	12652 <k_queue_append_list+0x4e>
	thread->base.swap_data = data;
   1263c:	6144      	str	r4, [r0, #20]
   1263e:	f8c0 907c 	str.w	r9, [r0, #124]	; 0x7c
	z_ready_thread(thread);
   12642:	f000 f923 	bl	1288c <z_ready_thread>
		head = *(void **)head;
   12646:	6824      	ldr	r4, [r4, #0]
		thread = z_unpend_first_thread(&queue->wait_q);
   12648:	4638      	mov	r0, r7
   1264a:	f000 f97b 	bl	12944 <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
   1264e:	2c00      	cmp	r4, #0
   12650:	d1ee      	bne.n	12630 <k_queue_append_list+0x2c>
	z_handle_obj_poll_events(&queue->poll_events, state);
   12652:	2104      	movs	r1, #4
   12654:	f105 0010 	add.w	r0, r5, #16
   12658:	f000 fb60 	bl	12d1c <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   1265c:	4638      	mov	r0, r7
   1265e:	4641      	mov	r1, r8
   12660:	f7fc f9f4 	bl	ea4c <z_reschedule>
	return 0;
   12664:	2000      	movs	r0, #0
}
   12666:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1266a:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1266c:	f003 0303 	and.w	r3, r3, #3
   12670:	431c      	orrs	r4, r3
   12672:	6014      	str	r4, [r2, #0]
}
   12674:	e7e0      	b.n	12638 <k_queue_append_list+0x34>
		return -EINVAL;
   12676:	f06f 0015 	mvn.w	r0, #21
   1267a:	e7f4      	b.n	12666 <k_queue_append_list+0x62>

0001267c <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   1267c:	b15a      	cbz	r2, 12696 <z_impl_k_sem_init+0x1a>
   1267e:	428a      	cmp	r2, r1
   12680:	d309      	bcc.n	12696 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   12682:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   12686:	e9c0 1202 	strd	r1, r2, [r0, #8]
   1268a:	e9c0 0000 	strd	r0, r0, [r0]
   1268e:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   12692:	2000      	movs	r0, #0
   12694:	4770      	bx	lr
		return -EINVAL;
   12696:	f06f 0015 	mvn.w	r0, #21
}
   1269a:	4770      	bx	lr

0001269c <flag_test_and_clear>:
	return (*flagp & BIT(bit)) != 0U;
   1269c:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
   1269e:	2301      	movs	r3, #1
   126a0:	408b      	lsls	r3, r1
   126a2:	ea22 0303 	bic.w	r3, r2, r3
   126a6:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
   126a8:	fa22 f001 	lsr.w	r0, r2, r1
}
   126ac:	f000 0001 	and.w	r0, r0, #1
   126b0:	4770      	bx	lr

000126b2 <unschedule_locked>:
{
   126b2:	b538      	push	{r3, r4, r5, lr}
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
   126b4:	2103      	movs	r1, #3
{
   126b6:	4605      	mov	r5, r0
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
   126b8:	300c      	adds	r0, #12
   126ba:	f7ff ffef 	bl	1269c <flag_test_and_clear>
   126be:	4604      	mov	r4, r0
   126c0:	b118      	cbz	r0, 126ca <unschedule_locked+0x18>
		z_abort_timeout(&dwork->timeout);
   126c2:	f105 0010 	add.w	r0, r5, #16
   126c6:	f000 f982 	bl	129ce <z_abort_timeout>
}
   126ca:	4620      	mov	r0, r4
   126cc:	bd38      	pop	{r3, r4, r5, pc}

000126ce <notify_queue_locked.isra.0>:
	if (queue != NULL) {
   126ce:	b120      	cbz	r0, 126da <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
   126d0:	2200      	movs	r2, #0
   126d2:	4611      	mov	r1, r2
   126d4:	3088      	adds	r0, #136	; 0x88
   126d6:	f000 b95d 	b.w	12994 <z_sched_wake>
}
   126da:	4770      	bx	lr

000126dc <cancel_async_locked>:
	return (*flagp & BIT(bit)) != 0U;
   126dc:	68c3      	ldr	r3, [r0, #12]
{
   126de:	b570      	push	{r4, r5, r6, lr}
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   126e0:	f3c3 0540 	ubfx	r5, r3, #1, #1
   126e4:	079b      	lsls	r3, r3, #30
{
   126e6:	4604      	mov	r4, r0
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   126e8:	d416      	bmi.n	12718 <cancel_async_locked+0x3c>
		queue_remove_locked(work->queue, work);
   126ea:	6886      	ldr	r6, [r0, #8]
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
   126ec:	2102      	movs	r1, #2
   126ee:	300c      	adds	r0, #12
   126f0:	f7ff ffd4 	bl	1269c <flag_test_and_clear>
   126f4:	b180      	cbz	r0, 12718 <cancel_async_locked+0x3c>
	return list->head;
   126f6:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   126fa:	b16a      	cbz	r2, 12718 <cancel_async_locked+0x3c>
   126fc:	4294      	cmp	r4, r2
   126fe:	d11b      	bne.n	12738 <cancel_async_locked+0x5c>
	return node->next;
   12700:	6822      	ldr	r2, [r4, #0]
	return list->tail;
   12702:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
Z_GENLIST_REMOVE(slist, snode)
   12706:	b98d      	cbnz	r5, 1272c <cancel_async_locked+0x50>
   12708:	428c      	cmp	r4, r1
	list->head = node;
   1270a:	f8c6 2080 	str.w	r2, [r6, #128]	; 0x80
Z_GENLIST_REMOVE(slist, snode)
   1270e:	d101      	bne.n	12714 <cancel_async_locked+0x38>
	list->tail = node;
   12710:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
	parent->next = child;
   12714:	2300      	movs	r3, #0
   12716:	6023      	str	r3, [r4, #0]
	return *flagp;
   12718:	68e3      	ldr	r3, [r4, #12]
	if (ret != 0) {
   1271a:	f013 000f 	ands.w	r0, r3, #15
	*flagp |= BIT(bit);
   1271e:	bf1e      	ittt	ne
   12720:	f043 0302 	orrne.w	r3, r3, #2
   12724:	60e3      	strne	r3, [r4, #12]
	return flags_get(&work->flags) & K_WORK_MASK;
   12726:	f003 000f 	andne.w	r0, r3, #15
}
   1272a:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_REMOVE(slist, snode)
   1272c:	428c      	cmp	r4, r1
	parent->next = child;
   1272e:	602a      	str	r2, [r5, #0]
	list->tail = node;
   12730:	bf08      	it	eq
   12732:	f8c6 5084 	streq.w	r5, [r6, #132]	; 0x84
}
   12736:	e7ed      	b.n	12714 <cancel_async_locked+0x38>
	return node->next;
   12738:	4615      	mov	r5, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1273a:	6812      	ldr	r2, [r2, #0]
   1273c:	e7dd      	b.n	126fa <cancel_async_locked+0x1e>

0001273e <work_timeout>:
{
   1273e:	b573      	push	{r0, r1, r4, r5, r6, lr}
   12740:	4604      	mov	r4, r0
   12742:	f04f 0320 	mov.w	r3, #32
   12746:	f3ef 8511 	mrs	r5, BASEPRI
   1274a:	f383 8812 	msr	BASEPRI_MAX, r3
   1274e:	f3bf 8f6f 	isb	sy
	struct k_work_q *queue = NULL;
   12752:	2300      	movs	r3, #0
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   12754:	f1a0 0610 	sub.w	r6, r0, #16
   12758:	2103      	movs	r1, #3
   1275a:	3804      	subs	r0, #4
	struct k_work_q *queue = NULL;
   1275c:	9301      	str	r3, [sp, #4]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   1275e:	f7ff ff9d 	bl	1269c <flag_test_and_clear>
   12762:	b128      	cbz	r0, 12770 <work_timeout+0x32>
		queue = dw->queue;
   12764:	69a3      	ldr	r3, [r4, #24]
   12766:	9301      	str	r3, [sp, #4]
		(void)submit_to_queue_locked(wp, &queue);
   12768:	a901      	add	r1, sp, #4
   1276a:	4630      	mov	r0, r6
   1276c:	f7fc f86a 	bl	e844 <submit_to_queue_locked>
	__asm__ volatile(
   12770:	f385 8811 	msr	BASEPRI, r5
   12774:	f3bf 8f6f 	isb	sy
}
   12778:	b002      	add	sp, #8
   1277a:	bd70      	pop	{r4, r5, r6, pc}

0001277c <k_work_submit_to_queue>:
{
   1277c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1277e:	9001      	str	r0, [sp, #4]
   12780:	4608      	mov	r0, r1
	__asm__ volatile(
   12782:	f04f 0320 	mov.w	r3, #32
   12786:	f3ef 8511 	mrs	r5, BASEPRI
   1278a:	f383 8812 	msr	BASEPRI_MAX, r3
   1278e:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
   12792:	a901      	add	r1, sp, #4
   12794:	f7fc f856 	bl	e844 <submit_to_queue_locked>
   12798:	4604      	mov	r4, r0
	__asm__ volatile(
   1279a:	f385 8811 	msr	BASEPRI, r5
   1279e:	f3bf 8f6f 	isb	sy
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
   127a2:	2800      	cmp	r0, #0
   127a4:	dd04      	ble.n	127b0 <k_work_submit_to_queue+0x34>
	return z_impl_k_is_preempt_thread();
   127a6:	f7fc fbb9 	bl	ef1c <z_impl_k_is_preempt_thread>
   127aa:	b108      	cbz	r0, 127b0 <k_work_submit_to_queue+0x34>
	z_impl_k_yield();
   127ac:	f7fc fb0e 	bl	edcc <z_impl_k_yield>
}
   127b0:	4620      	mov	r0, r4
   127b2:	b003      	add	sp, #12
   127b4:	bd30      	pop	{r4, r5, pc}

000127b6 <k_work_init_delayable>:
{
   127b6:	b538      	push	{r3, r4, r5, lr}
	*dwork = (struct k_work_delayable){
   127b8:	2230      	movs	r2, #48	; 0x30
{
   127ba:	4604      	mov	r4, r0
   127bc:	460d      	mov	r5, r1
	*dwork = (struct k_work_delayable){
   127be:	2100      	movs	r1, #0
   127c0:	f7fd f9fc 	bl	fbbc <memset>
   127c4:	f44f 7380 	mov.w	r3, #256	; 0x100
   127c8:	6065      	str	r5, [r4, #4]
   127ca:	60e3      	str	r3, [r4, #12]
}
   127cc:	bd38      	pop	{r3, r4, r5, pc}

000127ce <k_work_cancel_delayable>:

	return ret;
}

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
   127ce:	b538      	push	{r3, r4, r5, lr}
   127d0:	4604      	mov	r4, r0
	__asm__ volatile(
   127d2:	f04f 0320 	mov.w	r3, #32
   127d6:	f3ef 8511 	mrs	r5, BASEPRI
   127da:	f383 8812 	msr	BASEPRI_MAX, r3
   127de:	f3bf 8f6f 	isb	sy
	(void)unschedule_locked(dwork);
   127e2:	f7ff ff66 	bl	126b2 <unschedule_locked>
	return cancel_async_locked(&dwork->work);
   127e6:	4620      	mov	r0, r4
   127e8:	f7ff ff78 	bl	126dc <cancel_async_locked>
	__asm__ volatile(
   127ec:	f385 8811 	msr	BASEPRI, r5
   127f0:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
   127f4:	bd38      	pop	{r3, r4, r5, pc}

000127f6 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   127f6:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   127fa:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   127fc:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   127fe:	2300      	movs	r3, #0
	node->prev = NULL;
   12800:	e9c0 3300 	strd	r3, r3, [r0]
}
   12804:	4770      	bx	lr

00012806 <unpend_thread_no_timeout>:
{
   12806:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   12808:	f7ff fff5 	bl	127f6 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1280c:	7b43      	ldrb	r3, [r0, #13]
   1280e:	f023 0302 	bic.w	r3, r3, #2
   12812:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   12814:	2300      	movs	r3, #0
   12816:	6083      	str	r3, [r0, #8]
}
   12818:	bd08      	pop	{r3, pc}

0001281a <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
   1281a:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   1281e:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
   12822:	4283      	cmp	r3, r0
		return b2 - b1;
   12824:	bf14      	ite	ne
   12826:	1ac0      	subne	r0, r0, r3
	return 0;
   12828:	2000      	moveq	r0, #0
}
   1282a:	4770      	bx	lr

0001282c <z_unpend_thread>:
{
   1282c:	b510      	push	{r4, lr}
	__asm__ volatile(
   1282e:	f04f 0320 	mov.w	r3, #32
   12832:	f3ef 8411 	mrs	r4, BASEPRI
   12836:	f383 8812 	msr	BASEPRI_MAX, r3
   1283a:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   1283e:	f7ff ffe2 	bl	12806 <unpend_thread_no_timeout>
	__asm__ volatile(
   12842:	f384 8811 	msr	BASEPRI, r4
   12846:	f3bf 8f6f 	isb	sy
}
   1284a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1284e:	3018      	adds	r0, #24
   12850:	f000 b8bd 	b.w	129ce <z_abort_timeout>

00012854 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   12854:	4603      	mov	r3, r0
   12856:	b920      	cbnz	r0, 12862 <z_reschedule_irqlock+0xe>
   12858:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
   1285c:	b90a      	cbnz	r2, 12862 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   1285e:	f7ef beb3 	b.w	25c8 <arch_swap>
   12862:	f383 8811 	msr	BASEPRI, r3
   12866:	f3bf 8f6f 	isb	sy
}
   1286a:	4770      	bx	lr

0001286c <z_reschedule_unlocked>:
	__asm__ volatile(
   1286c:	f04f 0320 	mov.w	r3, #32
   12870:	f3ef 8011 	mrs	r0, BASEPRI
   12874:	f383 8812 	msr	BASEPRI_MAX, r3
   12878:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   1287c:	f7ff bfea 	b.w	12854 <z_reschedule_irqlock>

00012880 <z_priq_dumb_best>:
{
   12880:	4603      	mov	r3, r0
	return list->head == list;
   12882:	6800      	ldr	r0, [r0, #0]
}
   12884:	4283      	cmp	r3, r0
   12886:	bf08      	it	eq
   12888:	2000      	moveq	r0, #0
   1288a:	4770      	bx	lr

0001288c <z_ready_thread>:
{
   1288c:	b510      	push	{r4, lr}
   1288e:	f04f 0320 	mov.w	r3, #32
   12892:	f3ef 8411 	mrs	r4, BASEPRI
   12896:	f383 8812 	msr	BASEPRI_MAX, r3
   1289a:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   1289e:	f7fc f995 	bl	ebcc <ready_thread>
	__asm__ volatile(
   128a2:	f384 8811 	msr	BASEPRI, r4
   128a6:	f3bf 8f6f 	isb	sy
}
   128aa:	bd10      	pop	{r4, pc}

000128ac <z_thread_timeout>:
{
   128ac:	b510      	push	{r4, lr}
   128ae:	4601      	mov	r1, r0
	__asm__ volatile(
   128b0:	f04f 0320 	mov.w	r3, #32
   128b4:	f3ef 8411 	mrs	r4, BASEPRI
   128b8:	f383 8812 	msr	BASEPRI_MAX, r3
   128bc:	f3bf 8f6f 	isb	sy
		if (!killed) {
   128c0:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
   128c4:	f013 0f28 	tst.w	r3, #40	; 0x28
   128c8:	d10d      	bne.n	128e6 <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
   128ca:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
   128ce:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
   128d0:	b10b      	cbz	r3, 128d6 <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
   128d2:	f7ff ff98 	bl	12806 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   128d6:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
   128da:	f023 0314 	bic.w	r3, r3, #20
   128de:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
   128e2:	f7fc f973 	bl	ebcc <ready_thread>
	__asm__ volatile(
   128e6:	f384 8811 	msr	BASEPRI, r4
   128ea:	f3bf 8f6f 	isb	sy
}
   128ee:	bd10      	pop	{r4, pc}

000128f0 <add_to_waitq_locked>:
{
   128f0:	b538      	push	{r3, r4, r5, lr}
   128f2:	4604      	mov	r4, r0
   128f4:	460d      	mov	r5, r1
	unready_thread(thread);
   128f6:	f7fc f9bd 	bl	ec74 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   128fa:	7b63      	ldrb	r3, [r4, #13]
   128fc:	f043 0302 	orr.w	r3, r3, #2
   12900:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   12902:	b195      	cbz	r5, 1292a <add_to_waitq_locked+0x3a>
   12904:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   12906:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   12908:	429d      	cmp	r5, r3
   1290a:	d015      	beq.n	12938 <add_to_waitq_locked+0x48>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1290c:	b1a3      	cbz	r3, 12938 <add_to_waitq_locked+0x48>
	int32_t b1 = thread_1->base.prio;
   1290e:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   12912:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
   12916:	4291      	cmp	r1, r2
   12918:	d008      	beq.n	1292c <add_to_waitq_locked+0x3c>
		return b2 - b1;
   1291a:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   1291c:	2a00      	cmp	r2, #0
   1291e:	dd05      	ble.n	1292c <add_to_waitq_locked+0x3c>
	sys_dnode_t *const prev = successor->prev;
   12920:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   12922:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   12926:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   12928:	605c      	str	r4, [r3, #4]
}
   1292a:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
   1292c:	686a      	ldr	r2, [r5, #4]
   1292e:	4293      	cmp	r3, r2
   12930:	d002      	beq.n	12938 <add_to_waitq_locked+0x48>
   12932:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   12934:	2b00      	cmp	r3, #0
   12936:	d1ec      	bne.n	12912 <add_to_waitq_locked+0x22>
	sys_dnode_t *const tail = list->tail;
   12938:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   1293a:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   1293e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   12940:	606c      	str	r4, [r5, #4]
}
   12942:	e7f2      	b.n	1292a <add_to_waitq_locked+0x3a>

00012944 <z_unpend_first_thread>:
{
   12944:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   12946:	f04f 0320 	mov.w	r3, #32
   1294a:	f3ef 8511 	mrs	r5, BASEPRI
   1294e:	f383 8812 	msr	BASEPRI_MAX, r3
   12952:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   12956:	f7ff ff93 	bl	12880 <z_priq_dumb_best>
		if (thread != NULL) {
   1295a:	4604      	mov	r4, r0
   1295c:	b120      	cbz	r0, 12968 <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
   1295e:	f7ff ff52 	bl	12806 <unpend_thread_no_timeout>
   12962:	3018      	adds	r0, #24
   12964:	f000 f833 	bl	129ce <z_abort_timeout>
	__asm__ volatile(
   12968:	f385 8811 	msr	BASEPRI, r5
   1296c:	f3bf 8f6f 	isb	sy
}
   12970:	4620      	mov	r0, r4
   12972:	bd38      	pop	{r3, r4, r5, pc}

00012974 <z_unpend_all>:
{
   12974:	b538      	push	{r3, r4, r5, lr}
   12976:	4605      	mov	r5, r0
	int need_sched = 0;
   12978:	2000      	movs	r0, #0
	return list->head == list;
   1297a:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1297c:	42a5      	cmp	r5, r4
   1297e:	d000      	beq.n	12982 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   12980:	b904      	cbnz	r4, 12984 <z_unpend_all+0x10>
}
   12982:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   12984:	4620      	mov	r0, r4
   12986:	f7ff ff51 	bl	1282c <z_unpend_thread>
		z_ready_thread(thread);
   1298a:	4620      	mov	r0, r4
   1298c:	f7ff ff7e 	bl	1288c <z_ready_thread>
		need_sched = 1;
   12990:	2001      	movs	r0, #1
   12992:	e7f2      	b.n	1297a <z_unpend_all+0x6>

00012994 <z_sched_wake>:
{
   12994:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   12996:	f04f 0320 	mov.w	r3, #32
   1299a:	f3ef 8511 	mrs	r5, BASEPRI
   1299e:	f383 8812 	msr	BASEPRI_MAX, r3
   129a2:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   129a6:	f7ff ff6b 	bl	12880 <z_priq_dumb_best>
		if (thread != NULL) {
   129aa:	4604      	mov	r4, r0
   129ac:	b150      	cbz	r0, 129c4 <z_sched_wake+0x30>
   129ae:	67c1      	str	r1, [r0, #124]	; 0x7c
   129b0:	6142      	str	r2, [r0, #20]
			unpend_thread_no_timeout(thread);
   129b2:	f7ff ff28 	bl	12806 <unpend_thread_no_timeout>
   129b6:	3018      	adds	r0, #24
   129b8:	f000 f809 	bl	129ce <z_abort_timeout>
			ready_thread(thread);
   129bc:	4620      	mov	r0, r4
   129be:	f7fc f905 	bl	ebcc <ready_thread>
			ret = true;
   129c2:	2001      	movs	r0, #1
	__asm__ volatile(
   129c4:	f385 8811 	msr	BASEPRI, r5
   129c8:	f3bf 8f6f 	isb	sy
}
   129cc:	bd38      	pop	{r3, r4, r5, pc}

000129ce <z_abort_timeout>:
{
   129ce:	b510      	push	{r4, lr}
	__asm__ volatile(
   129d0:	f04f 0220 	mov.w	r2, #32
   129d4:	f3ef 8411 	mrs	r4, BASEPRI
   129d8:	f382 8812 	msr	BASEPRI_MAX, r2
   129dc:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   129e0:	6803      	ldr	r3, [r0, #0]
   129e2:	b13b      	cbz	r3, 129f4 <z_abort_timeout+0x26>
			remove_timeout(to);
   129e4:	f7fc fb5a 	bl	f09c <remove_timeout>
			ret = 0;
   129e8:	2000      	movs	r0, #0
	__asm__ volatile(
   129ea:	f384 8811 	msr	BASEPRI, r4
   129ee:	f3bf 8f6f 	isb	sy
}
   129f2:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   129f4:	f06f 0015 	mvn.w	r0, #21
   129f8:	e7f7      	b.n	129ea <z_abort_timeout+0x1c>

000129fa <z_get_next_timeout_expiry>:
{
   129fa:	b510      	push	{r4, lr}
	__asm__ volatile(
   129fc:	f04f 0320 	mov.w	r3, #32
   12a00:	f3ef 8411 	mrs	r4, BASEPRI
   12a04:	f383 8812 	msr	BASEPRI_MAX, r3
   12a08:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   12a0c:	f7fc fb1e 	bl	f04c <next_timeout>
	__asm__ volatile(
   12a10:	f384 8811 	msr	BASEPRI, r4
   12a14:	f3bf 8f6f 	isb	sy
}
   12a18:	bd10      	pop	{r4, pc}

00012a1a <z_set_timeout_expiry>:
{
   12a1a:	b570      	push	{r4, r5, r6, lr}
   12a1c:	4604      	mov	r4, r0
   12a1e:	460d      	mov	r5, r1
	__asm__ volatile(
   12a20:	f04f 0320 	mov.w	r3, #32
   12a24:	f3ef 8611 	mrs	r6, BASEPRI
   12a28:	f383 8812 	msr	BASEPRI_MAX, r3
   12a2c:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   12a30:	f7fc fb0c 	bl	f04c <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   12a34:	2801      	cmp	r0, #1
   12a36:	dd05      	ble.n	12a44 <z_set_timeout_expiry+0x2a>
   12a38:	42a0      	cmp	r0, r4
   12a3a:	db03      	blt.n	12a44 <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   12a3c:	4629      	mov	r1, r5
   12a3e:	4620      	mov	r0, r4
   12a40:	f7fa fe4c 	bl	d6dc <sys_clock_set_timeout>
	__asm__ volatile(
   12a44:	f386 8811 	msr	BASEPRI, r6
   12a48:	f3bf 8f6f 	isb	sy
}
   12a4c:	bd70      	pop	{r4, r5, r6, pc}

00012a4e <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   12a4e:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   12a50:	f7fc fc14 	bl	f27c <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   12a54:	bd08      	pop	{r3, pc}

00012a56 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   12a56:	f7fc bc11 	b.w	f27c <sys_clock_tick_get>

00012a5a <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   12a5a:	b108      	cbz	r0, 12a60 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   12a5c:	f7f0 b8de 	b.w	2c1c <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   12a60:	4770      	bx	lr

00012a62 <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   12a62:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   12a66:	bf08      	it	eq
   12a68:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   12a6c:	b538      	push	{r3, r4, r5, lr}
   12a6e:	4605      	mov	r5, r0
   12a70:	460c      	mov	r4, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   12a72:	d01d      	beq.n	12ab0 <sys_clock_timeout_end_calc+0x4e>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   12a74:	ea51 0300 	orrs.w	r3, r1, r0
   12a78:	d103      	bne.n	12a82 <sys_clock_timeout_end_calc+0x20>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   12a7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   12a7e:	f7fc bbfd 	b.w	f27c <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   12a82:	f06f 0301 	mvn.w	r3, #1
   12a86:	1a18      	subs	r0, r3, r0
   12a88:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12a8c:	eb63 0101 	sbc.w	r1, r3, r1
   12a90:	2900      	cmp	r1, #0
   12a92:	da0c      	bge.n	12aae <sys_clock_timeout_end_calc+0x4c>
		return sys_clock_tick_get() + MAX(1, dt);
   12a94:	f7fc fbf2 	bl	f27c <sys_clock_tick_get>
   12a98:	2d01      	cmp	r5, #1
   12a9a:	4622      	mov	r2, r4
   12a9c:	f174 0400 	sbcs.w	r4, r4, #0
   12aa0:	462b      	mov	r3, r5
   12aa2:	bfbc      	itt	lt
   12aa4:	2301      	movlt	r3, #1
   12aa6:	2200      	movlt	r2, #0
   12aa8:	1818      	adds	r0, r3, r0
   12aaa:	eb41 0102 	adc.w	r1, r1, r2
}
   12aae:	bd38      	pop	{r3, r4, r5, pc}
		return UINT64_MAX;
   12ab0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   12ab4:	4601      	mov	r1, r0
   12ab6:	e7fa      	b.n	12aae <sys_clock_timeout_end_calc+0x4c>

00012ab8 <add_event>:
{
   12ab8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12aba:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   12abc:	e9d0 2300 	ldrd	r2, r3, [r0]
   12ac0:	4290      	cmp	r0, r2
   12ac2:	4604      	mov	r4, r0
   12ac4:	460d      	mov	r5, r1
   12ac6:	d105      	bne.n	12ad4 <add_event+0x1c>
	sys_dnode_t *const tail = list->tail;
   12ac8:	6863      	ldr	r3, [r4, #4]
	node->prev = tail;
   12aca:	e9c5 4300 	strd	r4, r3, [r5]
	tail->next = node;
   12ace:	601d      	str	r5, [r3, #0]
	list->tail = node;
   12ad0:	6065      	str	r5, [r4, #4]
}
   12ad2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   12ad4:	2b00      	cmp	r3, #0
   12ad6:	d0f7      	beq.n	12ac8 <add_event+0x10>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   12ad8:	6898      	ldr	r0, [r3, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   12ada:	b100      	cbz	r0, 12ade <add_event+0x26>
   12adc:	3860      	subs	r0, #96	; 0x60
   12ade:	b107      	cbz	r7, 12ae2 <add_event+0x2a>
   12ae0:	3f60      	subs	r7, #96	; 0x60
		(z_sched_prio_cmp(poller_thread(pending->poller),
   12ae2:	4639      	mov	r1, r7
   12ae4:	f7ff fe99 	bl	1281a <z_sched_prio_cmp>
	if ((pending == NULL) ||
   12ae8:	2800      	cmp	r0, #0
   12aea:	dced      	bgt.n	12ac8 <add_event+0x10>
	return list->head == list;
   12aec:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   12aee:	42b4      	cmp	r4, r6
   12af0:	d0ea      	beq.n	12ac8 <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   12af2:	2e00      	cmp	r6, #0
   12af4:	d0e8      	beq.n	12ac8 <add_event+0x10>
		if (z_sched_prio_cmp(poller_thread(poller),
   12af6:	68b1      	ldr	r1, [r6, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   12af8:	b101      	cbz	r1, 12afc <add_event+0x44>
   12afa:	3960      	subs	r1, #96	; 0x60
		if (z_sched_prio_cmp(poller_thread(poller),
   12afc:	4638      	mov	r0, r7
   12afe:	f7ff fe8c 	bl	1281a <z_sched_prio_cmp>
   12b02:	2800      	cmp	r0, #0
   12b04:	dd05      	ble.n	12b12 <add_event+0x5a>
	sys_dnode_t *const prev = successor->prev;
   12b06:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   12b08:	e9c5 6300 	strd	r6, r3, [r5]
	prev->next = node;
   12b0c:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   12b0e:	6075      	str	r5, [r6, #4]
			return;
   12b10:	e7df      	b.n	12ad2 <add_event+0x1a>
	return (node == list->tail) ? NULL : node->next;
   12b12:	6863      	ldr	r3, [r4, #4]
   12b14:	42b3      	cmp	r3, r6
   12b16:	d0d7      	beq.n	12ac8 <add_event+0x10>
   12b18:	6836      	ldr	r6, [r6, #0]
   12b1a:	e7ea      	b.n	12af2 <add_event+0x3a>

00012b1c <register_events>:
{
   12b1c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   12b20:	2500      	movs	r5, #0
{
   12b22:	468b      	mov	fp, r1
   12b24:	4614      	mov	r4, r2
   12b26:	461f      	mov	r7, r3
   12b28:	4682      	mov	sl, r0
	int events_registered = 0;
   12b2a:	462e      	mov	r6, r5
	event->poller = NULL;
   12b2c:	46a8      	mov	r8, r5
	for (int ii = 0; ii < num_events; ii++) {
   12b2e:	455d      	cmp	r5, fp
   12b30:	db02      	blt.n	12b38 <register_events+0x1c>
}
   12b32:	4630      	mov	r0, r6
   12b34:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__asm__ volatile(
   12b38:	f04f 0320 	mov.w	r3, #32
   12b3c:	f3ef 8911 	mrs	r9, BASEPRI
   12b40:	f383 8812 	msr	BASEPRI_MAX, r3
   12b44:	f3bf 8f6f 	isb	sy
	switch (event->type) {
   12b48:	f89a 300d 	ldrb.w	r3, [sl, #13]
   12b4c:	f003 031f 	and.w	r3, r3, #31
   12b50:	3b01      	subs	r3, #1
   12b52:	2b07      	cmp	r3, #7
   12b54:	d80f      	bhi.n	12b76 <register_events+0x5a>
   12b56:	e8df f003 	tbb	[pc, r3]
   12b5a:	041e      	.short	0x041e
   12b5c:	0e0e0a0e 	.word	0x0e0e0a0e
   12b60:	250e      	.short	0x250e
		if (k_sem_count_get(event->sem) > 0U) {
   12b62:	f8da 3010 	ldr.w	r3, [sl, #16]
   12b66:	689b      	ldr	r3, [r3, #8]
   12b68:	b12b      	cbz	r3, 12b76 <register_events+0x5a>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   12b6a:	2302      	movs	r3, #2
   12b6c:	e020      	b.n	12bb0 <register_events+0x94>
		if (!k_queue_is_empty(event->queue)) {
   12b6e:	f8da 3010 	ldr.w	r3, [sl, #16]
   12b72:	681b      	ldr	r3, [r3, #0]
   12b74:	bb8b      	cbnz	r3, 12bda <register_events+0xbe>
		} else if (!just_check && poller->is_polling) {
   12b76:	bb47      	cbnz	r7, 12bca <register_events+0xae>
   12b78:	7823      	ldrb	r3, [r4, #0]
   12b7a:	b333      	cbz	r3, 12bca <register_events+0xae>
	switch (event->type) {
   12b7c:	f89a 300d 	ldrb.w	r3, [sl, #13]
   12b80:	f003 031f 	and.w	r3, r3, #31
   12b84:	3b01      	subs	r3, #1
   12b86:	2b07      	cmp	r3, #7
   12b88:	d830      	bhi.n	12bec <register_events+0xd0>
   12b8a:	e8df f003 	tbb	[pc, r3]
   12b8e:	2833      	.short	0x2833
   12b90:	2f2f282f 	.word	0x2f2f282f
   12b94:	382f      	.short	0x382f
		if (event->signal->signaled != 0U) {
   12b96:	f8da 3010 	ldr.w	r3, [sl, #16]
   12b9a:	689b      	ldr	r3, [r3, #8]
   12b9c:	2b00      	cmp	r3, #0
   12b9e:	d0ea      	beq.n	12b76 <register_events+0x5a>
			*state = K_POLL_STATE_SIGNALED;
   12ba0:	2301      	movs	r3, #1
   12ba2:	e005      	b.n	12bb0 <register_events+0x94>
		if (event->msgq->used_msgs > 0) {
   12ba4:	f8da 3010 	ldr.w	r3, [sl, #16]
   12ba8:	6a1b      	ldr	r3, [r3, #32]
   12baa:	2b00      	cmp	r3, #0
   12bac:	d0e3      	beq.n	12b76 <register_events+0x5a>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
   12bae:	2310      	movs	r3, #16
	event->state |= state;
   12bb0:	f8da 200c 	ldr.w	r2, [sl, #12]
	event->poller = NULL;
   12bb4:	f8ca 8008 	str.w	r8, [sl, #8]
	event->state |= state;
   12bb8:	f3c2 3145 	ubfx	r1, r2, #13, #6
   12bbc:	430b      	orrs	r3, r1
   12bbe:	f363 3252 	bfi	r2, r3, #13, #6
   12bc2:	f8ca 200c 	str.w	r2, [sl, #12]
			poller->is_polling = false;
   12bc6:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
   12bca:	f389 8811 	msr	BASEPRI, r9
   12bce:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   12bd2:	3501      	adds	r5, #1
   12bd4:	f10a 0a14 	add.w	sl, sl, #20
   12bd8:	e7a9      	b.n	12b2e <register_events+0x12>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   12bda:	2304      	movs	r3, #4
   12bdc:	e7e8      	b.n	12bb0 <register_events+0x94>
		add_event(&event->queue->poll_events, event, poller);
   12bde:	f8da 0010 	ldr.w	r0, [sl, #16]
   12be2:	4622      	mov	r2, r4
   12be4:	4651      	mov	r1, sl
   12be6:	3010      	adds	r0, #16
		add_event(&event->msgq->poll_events, event, poller);
   12be8:	f7ff ff66 	bl	12ab8 <add_event>
	event->poller = poller;
   12bec:	f8ca 4008 	str.w	r4, [sl, #8]
			events_registered += 1;
   12bf0:	3601      	adds	r6, #1
   12bf2:	e7ea      	b.n	12bca <register_events+0xae>
		add_event(&event->signal->poll_events, event, poller);
   12bf4:	f8da 0010 	ldr.w	r0, [sl, #16]
   12bf8:	4622      	mov	r2, r4
   12bfa:	4651      	mov	r1, sl
   12bfc:	e7f4      	b.n	12be8 <register_events+0xcc>
		add_event(&event->msgq->poll_events, event, poller);
   12bfe:	f8da 0010 	ldr.w	r0, [sl, #16]
   12c02:	4622      	mov	r2, r4
   12c04:	4651      	mov	r1, sl
   12c06:	3024      	adds	r0, #36	; 0x24
   12c08:	e7ee      	b.n	12be8 <register_events+0xcc>

00012c0a <signal_poll_event>:
{
   12c0a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct z_poller *poller = event->poller;
   12c0e:	6884      	ldr	r4, [r0, #8]
{
   12c10:	4605      	mov	r5, r0
   12c12:	460e      	mov	r6, r1
	if (poller != NULL) {
   12c14:	b144      	cbz	r4, 12c28 <signal_poll_event+0x1e>
		if (poller->mode == MODE_POLL) {
   12c16:	7863      	ldrb	r3, [r4, #1]
   12c18:	2b01      	cmp	r3, #1
   12c1a:	d136      	bne.n	12c8a <signal_poll_event+0x80>
	if (!z_is_thread_pending(thread)) {
   12c1c:	f814 3c53 	ldrb.w	r3, [r4, #-83]
   12c20:	f013 0302 	ands.w	r3, r3, #2
   12c24:	d10a      	bne.n	12c3c <signal_poll_event+0x32>
		poller->is_polling = false;
   12c26:	7023      	strb	r3, [r4, #0]
	event->state |= state;
   12c28:	68eb      	ldr	r3, [r5, #12]
   12c2a:	f3c3 3145 	ubfx	r1, r3, #13, #6
   12c2e:	430e      	orrs	r6, r1
	event->poller = NULL;
   12c30:	2000      	movs	r0, #0
	event->state |= state;
   12c32:	f366 3352 	bfi	r3, r6, #13, #6
	event->poller = NULL;
   12c36:	60a8      	str	r0, [r5, #8]
	event->state |= state;
   12c38:	60eb      	str	r3, [r5, #12]
	return retcode;
   12c3a:	e00b      	b.n	12c54 <signal_poll_event+0x4a>
	if (z_is_thread_timeout_expired(thread)) {
   12c3c:	e954 230e 	ldrd	r2, r3, [r4, #-56]	; 0x38
   12c40:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   12c44:	bf08      	it	eq
   12c46:	f112 0f02 	cmneq.w	r2, #2
   12c4a:	d105      	bne.n	12c58 <signal_poll_event+0x4e>
		poller->is_polling = false;
   12c4c:	2300      	movs	r3, #0
   12c4e:	7023      	strb	r3, [r4, #0]
		return -EAGAIN;
   12c50:	f06f 000a 	mvn.w	r0, #10
}
   12c54:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   12c58:	f1a4 0860 	sub.w	r8, r4, #96	; 0x60
	z_unpend_thread(thread);
   12c5c:	4640      	mov	r0, r8
   12c5e:	f7ff fde5 	bl	1282c <z_unpend_thread>
	arch_thread_return_value_set(thread,
   12c62:	2e08      	cmp	r6, #8
   12c64:	bf0c      	ite	eq
   12c66:	f06f 0303 	mvneq.w	r3, #3
   12c6a:	2300      	movne	r3, #0
   12c6c:	61e3      	str	r3, [r4, #28]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   12c6e:	f814 3c53 	ldrb.w	r3, [r4, #-83]
   12c72:	06db      	lsls	r3, r3, #27
   12c74:	d102      	bne.n	12c7c <signal_poll_event+0x72>
	if (!z_is_thread_ready(thread)) {
   12c76:	f854 7c48 	ldr.w	r7, [r4, #-72]
   12c7a:	b10f      	cbz	r7, 12c80 <signal_poll_event+0x76>
		poller->is_polling = false;
   12c7c:	2300      	movs	r3, #0
   12c7e:	e7d2      	b.n	12c26 <signal_poll_event+0x1c>
	z_ready_thread(thread);
   12c80:	4640      	mov	r0, r8
   12c82:	f7ff fe03 	bl	1288c <z_ready_thread>
		poller->is_polling = false;
   12c86:	7027      	strb	r7, [r4, #0]
		if (retcode < 0) {
   12c88:	e7ce      	b.n	12c28 <signal_poll_event+0x1e>
		} else if (poller->mode == MODE_TRIGGERED) {
   12c8a:	2b02      	cmp	r3, #2
   12c8c:	d1f6      	bne.n	12c7c <signal_poll_event+0x72>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
   12c8e:	7823      	ldrb	r3, [r4, #0]
   12c90:	2b00      	cmp	r3, #0
   12c92:	d0c9      	beq.n	12c28 <signal_poll_event+0x1e>
   12c94:	f854 7c04 	ldr.w	r7, [r4, #-4]
   12c98:	2f00      	cmp	r7, #0
   12c9a:	d0f4      	beq.n	12c86 <signal_poll_event+0x7c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
		twork->poll_result = 0;
   12c9c:	f04f 0800 	mov.w	r8, #0
		z_abort_timeout(&twork->timeout);
   12ca0:	f1a4 0914 	sub.w	r9, r4, #20
   12ca4:	f104 0014 	add.w	r0, r4, #20
   12ca8:	f7ff fe91 	bl	129ce <z_abort_timeout>
		twork->poll_result = 0;
   12cac:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
		k_work_submit_to_queue(work_q, &twork->work);
   12cb0:	4649      	mov	r1, r9
   12cb2:	4638      	mov	r0, r7
   12cb4:	f7ff fd62 	bl	1277c <k_work_submit_to_queue>
		poller->is_polling = false;
   12cb8:	f884 8000 	strb.w	r8, [r4]
		if (retcode < 0) {
   12cbc:	e7b4      	b.n	12c28 <signal_poll_event+0x1e>

00012cbe <clear_event_registrations>:
	while (num_events--) {
   12cbe:	2314      	movs	r3, #20
{
   12cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
   12cc2:	fb03 0001 	mla	r0, r3, r1, r0
	event->poller = NULL;
   12cc6:	2400      	movs	r4, #0
   12cc8:	2601      	movs	r6, #1
	while (num_events--) {
   12cca:	b901      	cbnz	r1, 12cce <clear_event_registrations+0x10>
}
   12ccc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (event->type) {
   12cce:	f810 3c07 	ldrb.w	r3, [r0, #-7]
	event->poller = NULL;
   12cd2:	f840 4c0c 	str.w	r4, [r0, #-12]
	switch (event->type) {
   12cd6:	f003 031f 	and.w	r3, r3, #31
   12cda:	2b08      	cmp	r3, #8
   12cdc:	f1a0 0714 	sub.w	r7, r0, #20
   12ce0:	d80d      	bhi.n	12cfe <clear_event_registrations+0x40>
   12ce2:	fa06 f303 	lsl.w	r3, r6, r3
   12ce6:	f413 7f8b 	tst.w	r3, #278	; 0x116
   12cea:	d008      	beq.n	12cfe <clear_event_registrations+0x40>
	return node->next != NULL;
   12cec:	f850 3c14 	ldr.w	r3, [r0, #-20]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
   12cf0:	b12b      	cbz	r3, 12cfe <clear_event_registrations+0x40>
	sys_dnode_t *const prev = node->prev;
   12cf2:	f850 5c10 	ldr.w	r5, [r0, #-16]
	prev->next = next;
   12cf6:	602b      	str	r3, [r5, #0]
	next->prev = prev;
   12cf8:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
   12cfa:	e940 4405 	strd	r4, r4, [r0, #-20]
   12cfe:	f382 8811 	msr	BASEPRI, r2
   12d02:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   12d06:	f04f 0320 	mov.w	r3, #32
   12d0a:	f3ef 8211 	mrs	r2, BASEPRI
   12d0e:	f383 8812 	msr	BASEPRI_MAX, r3
   12d12:	f3bf 8f6f 	isb	sy
   12d16:	3901      	subs	r1, #1
   12d18:	4638      	mov	r0, r7
   12d1a:	e7d6      	b.n	12cca <clear_event_registrations+0xc>

00012d1c <z_handle_obj_poll_events>:
{
   12d1c:	4603      	mov	r3, r0
	return list->head == list;
   12d1e:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   12d20:	4283      	cmp	r3, r0
   12d22:	d008      	beq.n	12d36 <z_handle_obj_poll_events+0x1a>
	sys_dnode_t *const next = node->next;
   12d24:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   12d28:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   12d2a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   12d2c:	2300      	movs	r3, #0
	node->prev = NULL;
   12d2e:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
   12d32:	f7ff bf6a 	b.w	12c0a <signal_poll_event>
}
   12d36:	4770      	bx	lr

00012d38 <k_free>:
	if (ptr != NULL) {
   12d38:	b120      	cbz	r0, 12d44 <k_free+0xc>
		k_heap_free(*heap_ref, ptr);
   12d3a:	1f01      	subs	r1, r0, #4
   12d3c:	f850 0c04 	ldr.w	r0, [r0, #-4]
   12d40:	f7ff bbac 	b.w	1249c <k_heap_free>
}
   12d44:	4770      	bx	lr
	...

00012d48 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   12d48:	f7fa bd2a 	b.w	d7a0 <SystemInit>
